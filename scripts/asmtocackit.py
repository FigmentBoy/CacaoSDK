import os
import re

funcs = {}
with open("../template/Cacao/symadd.asm", "r") as f:
	data = f.read()
	for m in re.finditer(r"; (?:cocos2d::)?(?:extension::)?([^(?:non)].+?)::(.+?)\((.+)\)\ndefit.+?, (0x[0-9a-f]+)", data):
		cl, fun, param, add = m.group(1), m.group(2), m.group(3), m.group(4)
		if cl not in funcs:
			funcs[cl] = []

		if "~" == fun[0]:
			if len(funcs[cl]) == 0 or (len(funcs[cl]) > 0 and funcs[cl][-1][0] != "dtor()"):
				funcs[cl].append([fun, param, add])
			funcs[cl][-1][2] = hex(max(int(add, 16), int(funcs[cl][-1][2], 16)))
		elif fun == f"{cl}()":
			if len(funcs[cl]) == 0 or (len(funcs[cl]) > 0 and funcs[cl][-1][0] != "ctor()"):
				funcs[cl].append([fun, param, add])
			funcs[cl][-1][2] = hex(max(int(add, 16), int(funcs[cl][-1][2], 16)))
		else:
			funcs[cl].append([fun, param, add])

			

with open("../template/Cacao/include/CacKit", "w") as f:
	f.write('''//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif
#define CAC_HOOKS void __cacinj() __attribute__((constructor)); void __cacinj() {
#define END_CAC_HOOKS \\
    for(auto& i : __cackit::glob) {i->apply_hooks();};m->enable();}

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};


class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}
''')
	for cl in funcs:
		if cl == "fmt" or cl == "FMOD":
			continue
		f.write(f"""

class ${cl} : public $CacBase {{
 public:
    ${cl}() {{
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }}
    typedef ${cl}* __thistype;
""")
		hooks = ""
		i = 0
		for fun, param, add in funcs[cl]: # todo change void
			params = []

			param = param.replace("void (cocos2d::CCObject::*)(cocos2d::CCObject*)", "Cacao::CC_SEL").replace("void (cocos2d::CCObject::*)(float)", "Cacao::CC_SCHED")
			
			p = param
			m = re.match(r"(.+?(?:<.*?>)?[&*]*), (.+)?", p)
			while m is not None:
				params.append(m.group(1))
				p = m.group(2)
				m = re.match(r"(.+?(?:<.*>)?), (.+)?", p)
			params.append(p)

			#fuck it hardcoding
			if param == "std::map<std::string, std::string, std::less<std::string>, std::allocator<std::pair<std::string const, std::string> > >&":
				params = [param]

			if p == "..." or p == "std::__va_list":
				continue

			param1 = ", ".join([p + f" p{i}" for i, p in enumerate(params)])
			param2 = ", " + ", ".join(params)
			param3 = ", " + ", ".join([f"p{i}" for i in range(len(params))])
			f.write(f"""
    virtual void {fun}({param1}) {{
        return reinterpret_cast<void(*)(decltype(this){param2})>(m->getOriginal(getBase()+{add}))(this{param3});
    }}
""")

			hooks += f"""
        m->registerHook(getBase()+{add}, extract_virtual(this, (void(${cl}::*)({param})){{&${cl}::{fun}}}));
"""
			i += 1
		f.write("\nvoid apply_hooks() override {" + hooks + "    }\n};\n")



