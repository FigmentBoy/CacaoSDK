//Copyright camila314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
using namespace cocos2d::extension;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

void __apply_hooks();
#define APPLY_HOOKS() static int const __cachook = (inject(), __apply_hooks(), 0)
#define $apply() APPLY_HOOKS()

#define CONCAT_(x, y) x##y
#define CONCAT(x, y) CONCAT_(x, y)
#define REDIRECT_(base, counter) CONCAT($hook, counter): public base<CONCAT($hook, counter)>
#define $redirect(base) REDIRECT_($##base, __COUNTER__)

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

// REVIVAL!!!
template <class T>
inline long extract_virtual(T instance) {
    return (*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+8));
};


template <typename F>
inline typename GetReturnType<F>::type (*extract(F func))() {
    return reinterpret_cast<typename GetReturnType<F>::type(*)()>(*reinterpret_cast<long*>(&func));
};

class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}

void __apply_hooks() {
    for(auto& i : __cackit::glob) i->apply_hooks();
    if (__cackit::glob.size() > 0) m->enable();
}


template<class D>
class $AnimatedGameObject : public AnimatedGameObject, public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AnimatedGameObject() {}
    typedef AnimatedGameObject* __thistype;

    void playAnimation(in p0) {
        if ((void($AnimatedGameObject::*)(in)){&$AnimatedGameObject::playAnimation} != (void(D::*)(in)){&D::playAnimation})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
        else return AnimatedGameObject::playAnimation(p0);
    }

    void updateChildSpriteColor(cocos2d::_ccColor3 p0) {
        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3)){&D::updateChildSpriteColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0xc8450))(this, p0);
        else return AnimatedGameObject::updateChildSpriteColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($AnimatedGameObject::*)(in)){&$AnimatedGameObject::playAnimation} != (void(D::*)(in)){&D::playAnimation})
            m->registerHook(getBase()+0xc93d0, extract((void(D::*)(in)){&D::playAnimation}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3)){&D::updateChildSpriteColor})
            m->registerHook(getBase()+0xc8450, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateChildSpriteColor}));
    }
};


template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
 public:
    $AppDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AppDelegate() {}
    typedef AppDelegate* __thistype;

    void bgScale() {
        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aaab0))(this);
        else return AppDelegate::bgScale();
    }

    static AppDelegate* get() {
        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            return reinterpret_cast<AppDelegate*(*)()>(m->getOriginal(getBase()+0x3aab10))();
        else return AppDelegate::get();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            m->registerHook(getBase()+0x3aaab0, extract((void(D::*)()){&D::bgScale}));

        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            m->registerHook(getBase()+0x3aab10, (AppDelegate*(*)()){&D::get});
    }
};


template<class D>
class $AudioEffectsLayer : public AudioEffectsLayer, public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AudioEffectsLayer() {}
    typedef AudioEffectsLayer* __thistype;

    void audioStep(floa p0) {
        if ((void($AudioEffectsLayer::*)(floa)){&$AudioEffectsLayer::audioStep} != (void(D::*)(floa)){&D::audioStep})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x271f40))(this, p0);
        else return AudioEffectsLayer::audioStep(p0);
    }

    static AudioEffectsLayer* create(std::strin p0) {
        if ((AudioEffectsLayer*(*)(std::strin)){&$AudioEffectsLayer::create} != (AudioEffectsLayer*(*)(std::strin)){&D::create})
            return reinterpret_cast<AudioEffectsLayer*(*)(std::strin)>(m->getOriginal(getBase()+0x271a00))(p0);
        else return AudioEffectsLayer::create(p0);
    }

    void resetAudioVars() {
        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars} != (void(D::*)()){&D::resetAudioVars})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x271ee0))(this);
        else return AudioEffectsLayer::resetAudioVars();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($AudioEffectsLayer::*)(floa)){&$AudioEffectsLayer::audioStep} != (void(D::*)(floa)){&D::audioStep})
            m->registerHook(getBase()+0x271f40, extract((void(D::*)(floa)){&D::audioStep}));

        if ((AudioEffectsLayer*(*)(std::strin)){&$AudioEffectsLayer::create} != (AudioEffectsLayer*(*)(std::strin)){&D::create})
            m->registerHook(getBase()+0x271a00, (AudioEffectsLayer*(*)(std::strin)){&D::create});

        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars} != (void(D::*)()){&D::resetAudioVars})
            m->registerHook(getBase()+0x271ee0, extract((void(D::*)()){&D::resetAudioVars}));
    }
};


template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ButtonSprite() {}
    typedef ButtonSprite* __thistype;

    static ButtonSprite* create(char const p0) {
        if ((ButtonSprite*(*)(char const)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const)>(m->getOriginal(getBase()+0x4fa10))(p0);
        else return ButtonSprite::create(p0);
    }

    static ButtonSprite* create(char const p0, in p1, in p2, floa p3, boo p4) {
        if ((ButtonSprite*(*)(char const, in, in, floa, boo)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const, in, in, floa, boo)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const, in, in, floa, boo)>(m->getOriginal(getBase()+0x4fa40))(p0, p1, p2, p3, p4);
        else return ButtonSprite::create(p0, p1, p2, p3, p4);
    }

    void updateBGImage(char const p0) {
        if ((void($ButtonSprite::*)(char const)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const)){&D::updateBGImage})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x502d0))(this, p0);
        else return ButtonSprite::updateBGImage(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((ButtonSprite*(*)(char const)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const)){&D::create})
            m->registerHook(getBase()+0x4fa10, (ButtonSprite*(*)(char const)){&D::create});

        if ((ButtonSprite*(*)(char const, in, in, floa, boo)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const, in, in, floa, boo)){&D::create})
            m->registerHook(getBase()+0x4fa40, (ButtonSprite*(*)(char const, in, in, floa, boo)){&D::create});

        if ((void($ButtonSprite::*)(char const)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const)){&D::updateBGImage})
            m->registerHook(getBase()+0x502d0, extract((void(D::*)(char const)){&D::updateBGImage}));
    }
};


template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCAnimatedSprite() {}
    typedef CCAnimatedSprite* __thistype;

    void runAnimation(std::strin p0) {
        if ((void($CCAnimatedSprite::*)(std::strin)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(std::strin)){&D::runAnimation})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
        else return CCAnimatedSprite::runAnimation(p0);
    }

    void tweenToAnimation(std::strin p0, floa p1) {
        if ((void($CCAnimatedSprite::*)(std::strin, floa)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(std::strin, floa)){&D::tweenToAnimation})
            return reinterpret_cast<void(*)(decltype(this), std::strin, floa)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
        else return CCAnimatedSprite::tweenToAnimation(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($CCAnimatedSprite::*)(std::strin)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(std::strin)){&D::runAnimation})
            m->registerHook(getBase()+0x1a6430, extract((void(D::*)(std::strin)){&D::runAnimation}));

        if ((void($CCAnimatedSprite::*)(std::strin, floa)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(std::strin, floa)){&D::tweenToAnimation})
            m->registerHook(getBase()+0x1a65b0, extract((void(D::*)(std::strin, floa)){&D::tweenToAnimation}));
    }
};


template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCCircleWave() {}
    typedef CCCircleWave* __thistype;

    static CCCircleWave* create(floa p0, floa p1, floa p2, boo p3) {
        if ((CCCircleWave*(*)(floa, floa, floa, boo)){&$CCCircleWave::create} != (CCCircleWave*(*)(floa, floa, floa, boo)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(floa, floa, floa, boo)>(m->getOriginal(getBase()+0xbd270))(p0, p1, p2, p3);
        else return CCCircleWave::create(p0, p1, p2, p3);
    }

    static CCCircleWave* create(floa p0, floa p1, floa p2, boo p3, boo p4) {
        if ((CCCircleWave*(*)(floa, floa, floa, boo, boo)){&$CCCircleWave::create} != (CCCircleWave*(*)(floa, floa, floa, boo, boo)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(floa, floa, floa, boo, boo)>(m->getOriginal(getBase()+0xbd290))(p0, p1, p2, p3, p4);
        else return CCCircleWave::create(p0, p1, p2, p3, p4);
    }

    void followObject(cocos2d::CCNode p0, boo p1) {
        if ((void($CCCircleWave::*)(cocos2d::CCNode, boo)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode, boo)){&D::followObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode, boo)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
        else return CCCircleWave::followObject(p0, p1);
    }

    void updatePosition(floa p0) {
        if ((void($CCCircleWave::*)(floa)){&$CCCircleWave::updatePosition} != (void(D::*)(floa)){&D::updatePosition})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xbd630))(this, p0);
        else return CCCircleWave::updatePosition(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCCircleWave*(*)(floa, floa, floa, boo)){&$CCCircleWave::create} != (CCCircleWave*(*)(floa, floa, floa, boo)){&D::create})
            m->registerHook(getBase()+0xbd270, (CCCircleWave*(*)(floa, floa, floa, boo)){&D::create});

        if ((CCCircleWave*(*)(floa, floa, floa, boo, boo)){&$CCCircleWave::create} != (CCCircleWave*(*)(floa, floa, floa, boo, boo)){&D::create})
            m->registerHook(getBase()+0xbd290, (CCCircleWave*(*)(floa, floa, floa, boo, boo)){&D::create});

        if ((void($CCCircleWave::*)(cocos2d::CCNode, boo)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode, boo)){&D::followObject})
            m->registerHook(getBase()+0xbd670, extract((void(D::*)(cocos2d::CCNode, boo)){&D::followObject}));

        if ((void($CCCircleWave::*)(floa)){&$CCCircleWave::updatePosition} != (void(D::*)(floa)){&D::updatePosition})
            m->registerHook(getBase()+0xbd630, extract((void(D::*)(floa)){&D::updatePosition}));
    }
};


template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCLightFlash() {}
    typedef CCLightFlash* __thistype;

    static CCLightFlash* create() {
        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            return reinterpret_cast<CCLightFlash*(*)()>(m->getOriginal(getBase()+0x295870))();
        else return CCLightFlash::create();
    }

    void playEffect(cocos2d::CCPoin p0, cocos2d::_ccColor3 p1, floa p2, floa p3, floa p4, floa p5, floa p6, floa p7, floa p8, floa p9, floa p10, floa p11, floa p12, floa p13, floa p14, floa p15, in p16, boo p17, boo p18, floa p19) {
        if ((void($CCLightFlash::*)(cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)){&D::playEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
        else return CCLightFlash::playEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            m->registerHook(getBase()+0x295870, (CCLightFlash*(*)()){&D::create});

        if ((void($CCLightFlash::*)(cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)){&D::playEffect})
            m->registerHook(getBase()+0x295900, extract((void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, floa, in, boo, boo, floa)){&D::playEffect}));
    }
};


template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMenuItemSpriteExtra() {}
    typedef CCMenuItemSpriteExtra* __thistype;

    static CCMenuItemSpriteExtra* create(cocos2d::CCNode p0, cocos2d::CCNode p1, cocos2d::CCObject p2, cocos2d::SEL_CallFunc p3) {
        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)>(m->getOriginal(getBase()+0x1253c0))(p0, p1, p2, p3);
        else return CCMenuItemSpriteExtra::create(p0, p1, p2, p3);
    }

    void setSizeMult(floa p0) {
        if ((void($CCMenuItemSpriteExtra::*)(floa)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(floa)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
        else return CCMenuItemSpriteExtra::setSizeMult(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create})
            m->registerHook(getBase()+0x1253c0, (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create});

        if ((void($CCMenuItemSpriteExtra::*)(floa)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(floa)){&D::setSizeMult})
            m->registerHook(getBase()+0x1255e0, extract((void(D::*)(floa)){&D::setSizeMult}));
    }
};


template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMenuItemToggler() {}
    typedef CCMenuItemToggler* __thistype;

    static CCMenuItemToggler* create(cocos2d::CCNode p0, cocos2d::CCNode p1, cocos2d::CCObject p2, cocos2d::SEL_CallFunc p3) {
        if ((CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create})
            return reinterpret_cast<CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)>(m->getOriginal(getBase()+0x38400))(p0, p1, p2, p3);
        else return CCMenuItemToggler::create(p0, p1, p2, p3);
    }

    void setSizeMult(floa p0) {
        if ((void($CCMenuItemToggler::*)(floa)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(floa)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x38a40))(this, p0);
        else return CCMenuItemToggler::setSizeMult(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create})
            m->registerHook(getBase()+0x38400, (CCMenuItemToggler*(*)(cocos2d::CCNode, cocos2d::CCNode, cocos2d::CCObject, cocos2d::SEL_CallFunc)){&D::create});

        if ((void($CCMenuItemToggler::*)(floa)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(floa)){&D::setSizeMult})
            m->registerHook(getBase()+0x38a40, extract((void(D::*)(floa)){&D::setSizeMult}));
    }
};


template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
 public:
    $CCMoveCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMoveCNode() {}
    typedef CCMoveCNode* __thistype;

    static CCMoveCNode* create() {
        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            return reinterpret_cast<CCMoveCNode*(*)()>(m->getOriginal(getBase()+0x1842a0))();
        else return CCMoveCNode::create();
    }

    bool init() {
        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x18b3d0))(this);
        else return CCMoveCNode::init();
    }

     ~CCMoveCNode() {
        if ((($CCMoveCNode::*)()){&$CCMoveCNode::~CCMoveCNode} != ((D::*)()){&D::~CCMoveCNode})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x18b2c0))(this);
        else return CCMoveCNode::~CCMoveCNode();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            m->registerHook(getBase()+0x1842a0, (CCMoveCNode*(*)()){&D::create});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x18b3d0, extract((bool(D::*)()){&D::init}));

        if ((($CCMoveCNode::*)()){&$CCMoveCNode::~CCMoveCNode} != ((D::*)()){&D::~CCMoveCNode})
            m->registerHook(getBase()+0x18b2c0, extract(((D::*)()){&D::~CCMoveCNode}));
    }
};


template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
 public:
    $CCNodeContainer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCNodeContainer() {}
    typedef CCNodeContainer* __thistype;

    static CCNodeContainer* create() {
        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            return reinterpret_cast<CCNodeContainer*(*)()>(m->getOriginal(getBase()+0xb1090))();
        else return CCNodeContainer::create();
    }

    bool init() {
        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xba950))(this);
        else return CCNodeContainer::init();
    }

    void visit() {
        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xba960))(this);
        else return CCNodeContainer::visit();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            m->registerHook(getBase()+0xb1090, (CCNodeContainer*(*)()){&D::create});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xba950, extract((bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0xba960, extract((void(D::*)()){&D::visit}));
    }
};


template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCSpritePlus() {}
    typedef CCSpritePlus* __thistype;

    bool initWithSpriteFrameName(char const p0) {
        if ((bool($CCSpritePlus::*)(char const)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const)){&D::initWithSpriteFrameName})
            return reinterpret_cast<bool(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x248670))(this, p0);
        else return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((bool($CCSpritePlus::*)(char const)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const)){&D::initWithSpriteFrameName})
            m->registerHook(getBase()+0x248670, extract((bool(D::*)(char const)){&D::initWithSpriteFrameName}));
    }
};


template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCTextInputNode() {}
    typedef CCTextInputNode* __thistype;

    static CCTextInputNode* create(floa p0, floa p1, char const p2, char const p3, in p4, char const p5) {
        if ((CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)){&D::create})
            return reinterpret_cast<CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)>(m->getOriginal(getBase()+0x5cfb0))(p0, p1, p2, p3, p4, p5);
        else return CCTextInputNode::create(p0, p1, p2, p3, p4, p5);
    }

    std::string getString() {
        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
        else return CCTextInputNode::getString();
    }

    void refreshLabel() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d730))(this);
        else return CCTextInputNode::refreshLabel();
    }

    void setAllowedChars(std::strin p0) {
        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::strin)){&D::setAllowedChars})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x5d360))(this, p0);
        else return CCTextInputNode::setAllowedChars(p0);
    }

    void setLabelPlaceholderColor(cocos2d::_ccColor3 p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3)){&D::setLabelPlaceholderColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x5da90))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderColor(p0);
    }

    void setLabelPlaceholderScale(floa p0) {
        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(floa)){&D::setLabelPlaceholderScale})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x5da70))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderScale(p0);
    }

    void setMaxLabelScale(floa p0) {
        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(floa)){&D::setMaxLabelScale})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x5da30))(this, p0);
        else return CCTextInputNode::setMaxLabelScale(p0);
    }

    void setMaxLabelWidth(floa p0) {
        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(floa)){&D::setMaxLabelWidth})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x5da50))(this, p0);
        else return CCTextInputNode::setMaxLabelWidth(p0);
    }

    void setString(std::strin p0) {
        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::setString} != (void(D::*)(std::strin)){&D::setString})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
        else return CCTextInputNode::setString(p0);
    }

    void updateLabel(std::strin p0) {
        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::strin)){&D::updateLabel})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x5d4a0))(this, p0);
        else return CCTextInputNode::updateLabel(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)){&D::create})
            m->registerHook(getBase()+0x5cfb0, (CCTextInputNode*(*)(floa, floa, char const, char const, in, char const)){&D::create});

        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            m->registerHook(getBase()+0x5d6f0, extract((std::string(D::*)()){&D::getString}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            m->registerHook(getBase()+0x5d730, extract((void(D::*)()){&D::refreshLabel}));

        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::strin)){&D::setAllowedChars})
            m->registerHook(getBase()+0x5d360, extract((void(D::*)(std::strin)){&D::setAllowedChars}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3)){&D::setLabelPlaceholderColor})
            m->registerHook(getBase()+0x5da90, extract((void(D::*)(cocos2d::_ccColor3)){&D::setLabelPlaceholderColor}));

        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(floa)){&D::setLabelPlaceholderScale})
            m->registerHook(getBase()+0x5da70, extract((void(D::*)(floa)){&D::setLabelPlaceholderScale}));

        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(floa)){&D::setMaxLabelScale})
            m->registerHook(getBase()+0x5da30, extract((void(D::*)(floa)){&D::setMaxLabelScale}));

        if ((void($CCTextInputNode::*)(floa)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(floa)){&D::setMaxLabelWidth})
            m->registerHook(getBase()+0x5da50, extract((void(D::*)(floa)){&D::setMaxLabelWidth}));

        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::setString} != (void(D::*)(std::strin)){&D::setString})
            m->registerHook(getBase()+0x5d3e0, extract((void(D::*)(std::strin)){&D::setString}));

        if ((void($CCTextInputNode::*)(std::strin)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::strin)){&D::updateLabel})
            m->registerHook(getBase()+0x5d4a0, extract((void(D::*)(std::strin)){&D::updateLabel}));
    }
};


template<class D>
class $CheckpointObject : public CheckpointObject, public $CacBase {
 public:
    $CheckpointObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CheckpointObject() {}
    typedef CheckpointObject* __thistype;

    static CheckpointObject* create() {
        if ((CheckpointObject*(*)()){&$CheckpointObject::create} != (CheckpointObject*(*)()){&D::create})
            return reinterpret_cast<CheckpointObject*(*)()>(m->getOriginal(getBase()+0x7e7d0))();
        else return CheckpointObject::create();
    }

    void getObject() {
        if ((void($CheckpointObject::*)()){&$CheckpointObject::getObject} != (void(D::*)()){&D::getObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef50))(this);
        else return CheckpointObject::getObject();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CheckpointObject*(*)()){&$CheckpointObject::create} != (CheckpointObject*(*)()){&D::create})
            m->registerHook(getBase()+0x7e7d0, (CheckpointObject*(*)()){&D::create});

        if ((void($CheckpointObject::*)()){&$CheckpointObject::getObject} != (void(D::*)()){&D::getObject})
            m->registerHook(getBase()+0x7ef50, extract((void(D::*)()){&D::getObject}));
    }
};


template<class D>
class $CollisionBlockPopup : public CollisionBlockPopup, public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CollisionBlockPopup() {}
    typedef CollisionBlockPopup* __thistype;

    static CollisionBlockPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$CollisionBlockPopup::create} != (CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x130010))(p0, p1);
        else return CollisionBlockPopup::create(p0, p1);
    }

    void onNextItemID(cocos2d::CCObject p0) {
        if ((void($CollisionBlockPopup::*)(cocos2d::CCObject)){&$CollisionBlockPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject)){&D::onNextItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x130e60))(this, p0);
        else return CollisionBlockPopup::onNextItemID(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$CollisionBlockPopup::create} != (CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x130010, (CollisionBlockPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($CollisionBlockPopup::*)(cocos2d::CCObject)){&$CollisionBlockPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject)){&D::onNextItemID})
            m->registerHook(getBase()+0x130e60, extract((void(D::*)(cocos2d::CCObject)){&D::onNextItemID}));
    }
};


template<class D>
class $CollisionTriggerAction : public CollisionTriggerAction, public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CollisionTriggerAction() {}
    typedef CollisionTriggerAction* __thistype;

    static CollisionTriggerAction* createFromString(std::strin p0) {
        if ((CollisionTriggerAction*(*)(std::strin)){&$CollisionTriggerAction::createFromString} != (CollisionTriggerAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<CollisionTriggerAction*(*)(std::strin)>(m->getOriginal(getBase()+0x176ee0))(p0);
        else return CollisionTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CollisionTriggerAction*(*)(std::strin)){&$CollisionTriggerAction::createFromString} != (CollisionTriggerAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x176ee0, (CollisionTriggerAction*(*)(std::strin)){&D::createFromString});
    }
};


template<class D>
class $ColorAction : public ColorAction, public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorAction() {}
    typedef ColorAction* __thistype;

    void getSaveString() {
        if ((void($ColorAction::*)()){&$ColorAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17d080))(this);
        else return ColorAction::getSaveString();
    }

    void setupFromDict(cocos2d::CCDictionary p0) {
        if ((void($ColorAction::*)(cocos2d::CCDictionary)){&$ColorAction::setupFromDict} != (void(D::*)(cocos2d::CCDictionary)){&D::setupFromDict})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary)>(m->getOriginal(getBase()+0x17f310))(this, p0);
        else return ColorAction::setupFromDict(p0);
    }

    void setupFromString(std::strin p0) {
        if ((void($ColorAction::*)(std::strin)){&$ColorAction::setupFromString} != (void(D::*)(std::strin)){&D::setupFromString})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x17f270))(this, p0);
        else return ColorAction::setupFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($ColorAction::*)()){&$ColorAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17d080, extract((void(D::*)()){&D::getSaveString}));

        if ((void($ColorAction::*)(cocos2d::CCDictionary)){&$ColorAction::setupFromDict} != (void(D::*)(cocos2d::CCDictionary)){&D::setupFromDict})
            m->registerHook(getBase()+0x17f310, extract((void(D::*)(cocos2d::CCDictionary)){&D::setupFromDict}));

        if ((void($ColorAction::*)(std::strin)){&$ColorAction::setupFromString} != (void(D::*)(std::strin)){&D::setupFromString})
            m->registerHook(getBase()+0x17f270, extract((void(D::*)(std::strin)){&D::setupFromString}));
    }
};


template<class D>
class $ColorChannelSprite : public ColorChannelSprite, public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorChannelSprite() {}
    typedef ColorChannelSprite* __thistype;

    void updateBlending(boo p0) {
        if ((void($ColorChannelSprite::*)(boo)){&$ColorChannelSprite::updateBlending} != (void(D::*)(boo)){&D::updateBlending})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x16e1d0))(this, p0);
        else return ColorChannelSprite::updateBlending(p0);
    }

    void updateCopyLabel(in p0, boo p1) {
        if ((void($ColorChannelSprite::*)(in, boo)){&$ColorChannelSprite::updateCopyLabel} != (void(D::*)(in, boo)){&D::updateCopyLabel})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x16ded0))(this, p0, p1);
        else return ColorChannelSprite::updateCopyLabel(p0, p1);
    }

    void updateOpacity(floa p0) {
        if ((void($ColorChannelSprite::*)(floa)){&$ColorChannelSprite::updateOpacity} != (void(D::*)(floa)){&D::updateOpacity})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x16e080))(this, p0);
        else return ColorChannelSprite::updateOpacity(p0);
    }

    void updateValues(ColorAction p0) {
        if ((void($ColorChannelSprite::*)(ColorAction)){&$ColorChannelSprite::updateValues} != (void(D::*)(ColorAction)){&D::updateValues})
            return reinterpret_cast<void(*)(decltype(this), ColorAction)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
        else return ColorChannelSprite::updateValues(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($ColorChannelSprite::*)(boo)){&$ColorChannelSprite::updateBlending} != (void(D::*)(boo)){&D::updateBlending})
            m->registerHook(getBase()+0x16e1d0, extract((void(D::*)(boo)){&D::updateBlending}));

        if ((void($ColorChannelSprite::*)(in, boo)){&$ColorChannelSprite::updateCopyLabel} != (void(D::*)(in, boo)){&D::updateCopyLabel})
            m->registerHook(getBase()+0x16ded0, extract((void(D::*)(in, boo)){&D::updateCopyLabel}));

        if ((void($ColorChannelSprite::*)(floa)){&$ColorChannelSprite::updateOpacity} != (void(D::*)(floa)){&D::updateOpacity})
            m->registerHook(getBase()+0x16e080, extract((void(D::*)(floa)){&D::updateOpacity}));

        if ((void($ColorChannelSprite::*)(ColorAction)){&$ColorChannelSprite::updateValues} != (void(D::*)(ColorAction)){&D::updateValues})
            m->registerHook(getBase()+0x16e2e0, extract((void(D::*)(ColorAction)){&D::updateValues}));
    }
};


template<class D>
class $ColorSelectLiveOverlay : public ColorSelectLiveOverlay, public $CacBase {
 public:
    $ColorSelectLiveOverlay() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorSelectLiveOverlay() {}
    typedef ColorSelectLiveOverlay* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});
    }
};


template<class D>
class $ColorSelectPopup : public ColorSelectPopup, public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorSelectPopup() {}
    typedef ColorSelectPopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3 p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x423320))(this, p0);
        else return ColorSelectPopup::colorValueChanged(p0);
    }

    static ColorSelectPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$ColorSelectPopup::create} != (ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x41eb70))(p0, p1);
        else return ColorSelectPopup::create(p0, p1);
    }

    bool init(EffectGameObject p0, cocos2d::CCArray p1, ColorAction p2) {
        if ((bool($ColorSelectPopup::*)(EffectGameObject, cocos2d::CCArray, ColorAction)){&$ColorSelectPopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray, ColorAction)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject, cocos2d::CCArray, ColorAction)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
        else return ColorSelectPopup::init(p0, p1, p2);
    }

    void onDefault(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onDefault} != (void(D::*)(cocos2d::CCObject)){&D::onDefault})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
        else return ColorSelectPopup::onDefault(p0);
    }

    void onMultiTrigger(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onMultiTrigger} != (void(D::*)(cocos2d::CCObject)){&D::onMultiTrigger})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x422680))(this, p0);
        else return ColorSelectPopup::onMultiTrigger(p0);
    }

    void onPlayerColor1(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onPlayerColor1} != (void(D::*)(cocos2d::CCObject)){&D::onPlayerColor1})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x422500))(this, p0);
        else return ColorSelectPopup::onPlayerColor1(p0);
    }

    void onPlayerColor2(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onPlayerColor2} != (void(D::*)(cocos2d::CCObject)){&D::onPlayerColor2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
        else return ColorSelectPopup::onPlayerColor2(p0);
    }

    void onSpawnedByTrigger(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onSpawnedByTrigger} != (void(D::*)(cocos2d::CCObject)){&D::onSpawnedByTrigger})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
        else return ColorSelectPopup::onSpawnedByTrigger(p0);
    }

    void onToggleHSVMode(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onToggleHSVMode} != (void(D::*)(cocos2d::CCObject)){&D::onToggleHSVMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
        else return ColorSelectPopup::onToggleHSVMode(p0);
    }

    void onTouchTriggered(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onTouchTriggered} != (void(D::*)(cocos2d::CCObject)){&D::onTouchTriggered})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
        else return ColorSelectPopup::onTouchTriggered(p0);
    }

    void show() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423570))(this);
        else return ColorSelectPopup::show();
    }

    void sliderChanged(cocos2d::CCObject p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::sliderChanged} != (void(D::*)(cocos2d::CCObject)){&D::sliderChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
        else return ColorSelectPopup::sliderChanged(p0);
    }

    void updateCopyColor() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor} != (void(D::*)()){&D::updateCopyColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423b70))(this);
        else return ColorSelectPopup::updateCopyColor();
    }

    void updateCopyColorTextInputLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422ed0))(this);
        else return ColorSelectPopup::updateCopyColorTextInputLabel();
    }

    void updateDurLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel} != (void(D::*)()){&D::updateDurLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x421eb0))(this);
        else return ColorSelectPopup::updateDurLabel();
    }

    void updateHSVMode() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode} != (void(D::*)()){&D::updateHSVMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422e00))(this);
        else return ColorSelectPopup::updateHSVMode();
    }

    void updateOpacityLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel} != (void(D::*)()){&D::updateOpacityLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422000))(this);
        else return ColorSelectPopup::updateOpacityLabel();
    }

    void updateTouchTriggered() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered} != (void(D::*)()){&D::updateTouchTriggered})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423020))(this);
        else return ColorSelectPopup::updateTouchTriggered();
    }

     ~ColorSelectPopup() {
        if ((($ColorSelectPopup::*)()){&$ColorSelectPopup::~ColorSelectPopup} != ((D::*)()){&D::~ColorSelectPopup})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x41e960))(this);
        else return ColorSelectPopup::~ColorSelectPopup();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged})
            m->registerHook(getBase()+0x423320, extract((void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged}));

        if ((ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$ColorSelectPopup::create} != (ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x41eb70, (ColorSelectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((bool($ColorSelectPopup::*)(EffectGameObject, cocos2d::CCArray, ColorAction)){&$ColorSelectPopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray, ColorAction)){&D::init})
            m->registerHook(getBase()+0x41ee70, extract((bool(D::*)(EffectGameObject, cocos2d::CCArray, ColorAction)){&D::init}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onDefault} != (void(D::*)(cocos2d::CCObject)){&D::onDefault})
            m->registerHook(getBase()+0x4220e0, extract((void(D::*)(cocos2d::CCObject)){&D::onDefault}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onMultiTrigger} != (void(D::*)(cocos2d::CCObject)){&D::onMultiTrigger})
            m->registerHook(getBase()+0x422680, extract((void(D::*)(cocos2d::CCObject)){&D::onMultiTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onPlayerColor1} != (void(D::*)(cocos2d::CCObject)){&D::onPlayerColor1})
            m->registerHook(getBase()+0x422500, extract((void(D::*)(cocos2d::CCObject)){&D::onPlayerColor1}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onPlayerColor2} != (void(D::*)(cocos2d::CCObject)){&D::onPlayerColor2})
            m->registerHook(getBase()+0x4225c0, extract((void(D::*)(cocos2d::CCObject)){&D::onPlayerColor2}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onSpawnedByTrigger} != (void(D::*)(cocos2d::CCObject)){&D::onSpawnedByTrigger})
            m->registerHook(getBase()+0x4227f0, extract((void(D::*)(cocos2d::CCObject)){&D::onSpawnedByTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onToggleHSVMode} != (void(D::*)(cocos2d::CCObject)){&D::onToggleHSVMode})
            m->registerHook(getBase()+0x4227b0, extract((void(D::*)(cocos2d::CCObject)){&D::onToggleHSVMode}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::onTouchTriggered} != (void(D::*)(cocos2d::CCObject)){&D::onTouchTriggered})
            m->registerHook(getBase()+0x4228b0, extract((void(D::*)(cocos2d::CCObject)){&D::onTouchTriggered}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x423570, extract((void(D::*)()){&D::show}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject)){&$ColorSelectPopup::sliderChanged} != (void(D::*)(cocos2d::CCObject)){&D::sliderChanged})
            m->registerHook(getBase()+0x421ca0, extract((void(D::*)(cocos2d::CCObject)){&D::sliderChanged}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor} != (void(D::*)()){&D::updateCopyColor})
            m->registerHook(getBase()+0x423b70, extract((void(D::*)()){&D::updateCopyColor}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x422ed0, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel} != (void(D::*)()){&D::updateDurLabel})
            m->registerHook(getBase()+0x421eb0, extract((void(D::*)()){&D::updateDurLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode} != (void(D::*)()){&D::updateHSVMode})
            m->registerHook(getBase()+0x422e00, extract((void(D::*)()){&D::updateHSVMode}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel} != (void(D::*)()){&D::updateOpacityLabel})
            m->registerHook(getBase()+0x422000, extract((void(D::*)()){&D::updateOpacityLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered} != (void(D::*)()){&D::updateTouchTriggered})
            m->registerHook(getBase()+0x423020, extract((void(D::*)()){&D::updateTouchTriggered}));

        if ((($ColorSelectPopup::*)()){&$ColorSelectPopup::~ColorSelectPopup} != ((D::*)()){&D::~ColorSelectPopup})
            m->registerHook(getBase()+0x41e960, extract(((D::*)()){&D::~ColorSelectPopup}));
    }
};


template<class D>
class $CountTriggerAction : public CountTriggerAction, public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CountTriggerAction() {}
    typedef CountTriggerAction* __thistype;

    static CountTriggerAction* createFromString(std::strin p0) {
        if ((CountTriggerAction*(*)(std::strin)){&$CountTriggerAction::createFromString} != (CountTriggerAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<CountTriggerAction*(*)(std::strin)>(m->getOriginal(getBase()+0x1754f0))(p0);
        else return CountTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((CountTriggerAction*(*)(std::strin)){&$CountTriggerAction::createFromString} != (CountTriggerAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x1754f0, (CountTriggerAction*(*)(std::strin)){&D::createFromString});
    }
};


template<class D>
class $CreateMenuItem : public CreateMenuItem, public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CreateMenuItem() {}
    typedef CreateMenuItem* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});
    }
};


template<class D>
class $CreatorLayer : public CreatorLayer, public $CacBase {
 public:
    $CreatorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CreatorLayer() {}
    typedef CreatorLayer* __thistype;

    void onMyLevels(cocos2d::CCObject p0) {
        if ((void($CreatorLayer::*)(cocos2d::CCObject)){&$CreatorLayer::onMyLevels} != (void(D::*)(cocos2d::CCObject)){&D::onMyLevels})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x142b70))(this, p0);
        else return CreatorLayer::onMyLevels(p0);
    }

    void onSavedLevels(cocos2d::CCObject p0) {
        if ((void($CreatorLayer::*)(cocos2d::CCObject)){&$CreatorLayer::onSavedLevels} != (void(D::*)(cocos2d::CCObject)){&D::onSavedLevels})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x142860))(this, p0);
        else return CreatorLayer::onSavedLevels(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($CreatorLayer::*)(cocos2d::CCObject)){&$CreatorLayer::onMyLevels} != (void(D::*)(cocos2d::CCObject)){&D::onMyLevels})
            m->registerHook(getBase()+0x142b70, extract((void(D::*)(cocos2d::CCObject)){&D::onMyLevels}));

        if ((void($CreatorLayer::*)(cocos2d::CCObject)){&$CreatorLayer::onSavedLevels} != (void(D::*)(cocos2d::CCObject)){&D::onSavedLevels})
            m->registerHook(getBase()+0x142860, extract((void(D::*)(cocos2d::CCObject)){&D::onSavedLevels}));
    }
};


template<class D>
class $CustomizeObjectLayer : public CustomizeObjectLayer, public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CustomizeObjectLayer() {}
    typedef CustomizeObjectLayer* __thistype;

    void colorSelectClosed(cocos2d::CCNode p0) {
        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode)>(m->getOriginal(getBase()+0xe1050))(this, p0);
        else return CustomizeObjectLayer::colorSelectClosed(p0);
    }

    static CustomizeObjectLayer* create(GameObject p0, cocos2d::CCArray p1) {
        if ((CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)){&$CustomizeObjectLayer::create} != (CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0xdd340))(p0, p1);
        else return CustomizeObjectLayer::create(p0, p1);
    }

    bool init(GameObject p0, cocos2d::CCArray p1) {
        if ((bool($CustomizeObjectLayer::*)(GameObject, cocos2d::CCArray)){&$CustomizeObjectLayer::init} != (bool(D::*)(GameObject, cocos2d::CCArray)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
        else return CustomizeObjectLayer::init(p0, p1);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0xe1470))(this, p0);
        else return CustomizeObjectLayer::textChanged(p0);
    }

    void textInputClosed(CCTextInputNode p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0xe1430))(this, p0);
        else return CustomizeObjectLayer::textInputClosed(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode)){&D::colorSelectClosed})
            m->registerHook(getBase()+0xe1050, extract((void(D::*)(cocos2d::CCNode)){&D::colorSelectClosed}));

        if ((CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)){&$CustomizeObjectLayer::create} != (CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0xdd340, (CustomizeObjectLayer*(*)(GameObject, cocos2d::CCArray)){&D::create});

        if ((bool($CustomizeObjectLayer::*)(GameObject, cocos2d::CCArray)){&$CustomizeObjectLayer::init} != (bool(D::*)(GameObject, cocos2d::CCArray)){&D::init})
            m->registerHook(getBase()+0xdd560, extract((bool(D::*)(GameObject, cocos2d::CCArray)){&D::init}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0xe1470, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode)){&D::textInputClosed})
            m->registerHook(getBase()+0xe1430, extract((void(D::*)(CCTextInputNode)){&D::textInputClosed}));
    }
};


template<class D>
class $DelayedSpawnNode : public DelayedSpawnNode, public $CacBase {
 public:
    $DelayedSpawnNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DelayedSpawnNode() {}
    typedef DelayedSpawnNode* __thistype;

    static DelayedSpawnNode* create() {
        if ((DelayedSpawnNode*(*)()){&$DelayedSpawnNode::create} != (DelayedSpawnNode*(*)()){&D::create})
            return reinterpret_cast<DelayedSpawnNode*(*)()>(m->getOriginal(getBase()+0x9b360))();
        else return DelayedSpawnNode::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((DelayedSpawnNode*(*)()){&$DelayedSpawnNode::create} != (DelayedSpawnNode*(*)()){&D::create})
            m->registerHook(getBase()+0x9b360, (DelayedSpawnNode*(*)()){&D::create});
    }
};


template<class D>
class $DialogLayer : public DialogLayer, public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DialogLayer() {}
    typedef DialogLayer* __thistype;

    static DialogLayer* create(DialogObject p0, in p1) {
        if ((DialogLayer*(*)(DialogObject, in)){&$DialogLayer::create} != (DialogLayer*(*)(DialogObject, in)){&D::create})
            return reinterpret_cast<DialogLayer*(*)(DialogObject, in)>(m->getOriginal(getBase()+0x2047c0))(p0, p1);
        else return DialogLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((DialogLayer*(*)(DialogObject, in)){&$DialogLayer::create} != (DialogLayer*(*)(DialogObject, in)){&D::create})
            m->registerHook(getBase()+0x2047c0, (DialogLayer*(*)(DialogObject, in)){&D::create});
    }
};


template<class D>
class $DialogObject : public DialogObject, public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DialogObject() {}
    typedef DialogObject* __thistype;

    static DialogObject* create(std::strin p0, std::strin p1, in p2, floa p3, boo p4, cocos2d::_ccColor3 p5) {
        if ((DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)){&$DialogObject::create} != (DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)){&D::create})
            return reinterpret_cast<DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x204410))(p0, p1, p2, p3, p4, p5);
        else return DialogObject::create(p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)){&$DialogObject::create} != (DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)){&D::create})
            m->registerHook(getBase()+0x204410, (DialogObject*(*)(std::strin, std::strin, in, floa, boo, cocos2d::_ccColor3)){&D::create});
    }
};


template<class D>
class $DrawGridLayer : public DrawGridLayer, public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DrawGridLayer() {}
    typedef DrawGridLayer* __thistype;

    void addPlayer2Point(cocos2d::CCPoin p0, boo p1) {
        if ((void($DrawGridLayer::*)(cocos2d::CCPoin, boo)){&$DrawGridLayer::addPlayer2Point} != (void(D::*)(cocos2d::CCPoin, boo)){&D::addPlayer2Point})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, boo)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
        else return DrawGridLayer::addPlayer2Point(p0, p1);
    }

    void addPlayerPoint(cocos2d::CCPoin p0) {
        if ((void($DrawGridLayer::*)(cocos2d::CCPoin)){&$DrawGridLayer::addPlayerPoint} != (void(D::*)(cocos2d::CCPoin)){&D::addPlayerPoint})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
        else return DrawGridLayer::addPlayerPoint(p0);
    }

    void addToSpeedObjects(GameObject p0) {
        if ((void($DrawGridLayer::*)(GameObject)){&$DrawGridLayer::addToSpeedObjects} != (void(D::*)(GameObject)){&D::addToSpeedObjects})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x99900))(this, p0);
        else return DrawGridLayer::addToSpeedObjects(p0);
    }

    static DrawGridLayer* create(cocos2d::CCNode p0, LevelEditorLayer p1) {
        if ((DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)){&$DrawGridLayer::create} != (DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)){&D::create})
            return reinterpret_cast<DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)>(m->getOriginal(getBase()+0x920c0))(p0, p1);
        else return DrawGridLayer::create(p0, p1);
    }

    bool init(cocos2d::CCNode p0, LevelEditorLayer p1) {
        if ((bool($DrawGridLayer::*)(cocos2d::CCNode, LevelEditorLayer)){&$DrawGridLayer::init} != (bool(D::*)(cocos2d::CCNode, LevelEditorLayer)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCNode, LevelEditorLayer)>(m->getOriginal(getBase()+0xa36e0))(this, p0, p1);
        else return DrawGridLayer::init(p0, p1);
    }

    void timeForXPos(floa p0) {
        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x9b330))(this, p0);
        else return DrawGridLayer::timeForXPos(p0);
    }

    void update(floa p0) {
        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::update} != (void(D::*)(floa)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xa3b30))(this, p0);
        else return DrawGridLayer::update(p0);
    }

    void updateTimeMarkers() {
        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers} != (void(D::*)()){&D::updateTimeMarkers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92950))(this);
        else return DrawGridLayer::updateTimeMarkers();
    }

    void xPosForTime(floa p0) {
        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x9c830))(this, p0);
        else return DrawGridLayer::xPosForTime(p0);
    }

     ~DrawGridLayer() {
        if ((($DrawGridLayer::*)()){&$DrawGridLayer::~DrawGridLayer} != ((D::*)()){&D::~DrawGridLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0xa3480))(this);
        else return DrawGridLayer::~DrawGridLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($DrawGridLayer::*)(cocos2d::CCPoin, boo)){&$DrawGridLayer::addPlayer2Point} != (void(D::*)(cocos2d::CCPoin, boo)){&D::addPlayer2Point})
            m->registerHook(getBase()+0xa25b0, extract((void(D::*)(cocos2d::CCPoin, boo)){&D::addPlayer2Point}));

        if ((void($DrawGridLayer::*)(cocos2d::CCPoin)){&$DrawGridLayer::addPlayerPoint} != (void(D::*)(cocos2d::CCPoin)){&D::addPlayerPoint})
            m->registerHook(getBase()+0xa39c0, extract((void(D::*)(cocos2d::CCPoin)){&D::addPlayerPoint}));

        if ((void($DrawGridLayer::*)(GameObject)){&$DrawGridLayer::addToSpeedObjects} != (void(D::*)(GameObject)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x99900, extract((void(D::*)(GameObject)){&D::addToSpeedObjects}));

        if ((DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)){&$DrawGridLayer::create} != (DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)){&D::create})
            m->registerHook(getBase()+0x920c0, (DrawGridLayer*(*)(cocos2d::CCNode, LevelEditorLayer)){&D::create});

        if ((bool($DrawGridLayer::*)(cocos2d::CCNode, LevelEditorLayer)){&$DrawGridLayer::init} != (bool(D::*)(cocos2d::CCNode, LevelEditorLayer)){&D::init})
            m->registerHook(getBase()+0xa36e0, extract((bool(D::*)(cocos2d::CCNode, LevelEditorLayer)){&D::init}));

        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            m->registerHook(getBase()+0x9b330, extract((void(D::*)(floa)){&D::timeForXPos}));

        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::update} != (void(D::*)(floa)){&D::update})
            m->registerHook(getBase()+0xa3b30, extract((void(D::*)(floa)){&D::update}));

        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers} != (void(D::*)()){&D::updateTimeMarkers})
            m->registerHook(getBase()+0x92950, extract((void(D::*)()){&D::updateTimeMarkers}));

        if ((void($DrawGridLayer::*)(floa)){&$DrawGridLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c830, extract((void(D::*)(floa)){&D::xPosForTime}));

        if ((($DrawGridLayer::*)()){&$DrawGridLayer::~DrawGridLayer} != ((D::*)()){&D::~DrawGridLayer})
            m->registerHook(getBase()+0xa3480, extract(((D::*)()){&D::~DrawGridLayer}));
    }
};


template<class D>
class $EditButtonBar : public EditButtonBar, public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditButtonBar() {}
    typedef EditButtonBar* __thistype;

    void loadFromItems(cocos2d::CCArray p0, in p1, in p2, boo p3) {
        if ((void($EditButtonBar::*)(cocos2d::CCArray, in, in, boo)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray, in, in, boo)){&D::loadFromItems})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray, in, in, boo)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
        else return EditButtonBar::loadFromItems(p0, p1, p2, p3);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($EditButtonBar::*)(cocos2d::CCArray, in, in, boo)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray, in, in, boo)){&D::loadFromItems})
            m->registerHook(getBase()+0x351010, extract((void(D::*)(cocos2d::CCArray, in, in, boo)){&D::loadFromItems}));
    }
};


template<class D>
class $EditorOptionsLayer : public EditorOptionsLayer, public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorOptionsLayer() {}
    typedef EditorOptionsLayer* __thistype;

    void onButtonsPerRow(cocos2d::CCObject p0) {
        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject)){&$EditorOptionsLayer::onButtonsPerRow} != (void(D::*)(cocos2d::CCObject)){&D::onButtonsPerRow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x147b30))(this, p0);
        else return EditorOptionsLayer::onButtonsPerRow(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject)){&$EditorOptionsLayer::onButtonsPerRow} != (void(D::*)(cocos2d::CCObject)){&D::onButtonsPerRow})
            m->registerHook(getBase()+0x147b30, extract((void(D::*)(cocos2d::CCObject)){&D::onButtonsPerRow}));
    }
};


template<class D>
class $EditorPauseLayer : public EditorPauseLayer, public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorPauseLayer() {}
    typedef EditorPauseLayer* __thistype;

    static EditorPauseLayer* create(LevelEditorLayer p0) {
        if ((EditorPauseLayer*(*)(LevelEditorLayer)){&$EditorPauseLayer::create} != (EditorPauseLayer*(*)(LevelEditorLayer)){&D::create})
            return reinterpret_cast<EditorPauseLayer*(*)(LevelEditorLayer)>(m->getOriginal(getBase()+0x13c680))(p0);
        else return EditorPauseLayer::create(p0);
    }

    void saveLevel() {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel} != (void(D::*)()){&D::saveLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
        else return EditorPauseLayer::saveLevel();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((EditorPauseLayer*(*)(LevelEditorLayer)){&$EditorPauseLayer::create} != (EditorPauseLayer*(*)(LevelEditorLayer)){&D::create})
            m->registerHook(getBase()+0x13c680, (EditorPauseLayer*(*)(LevelEditorLayer)){&D::create});

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel} != (void(D::*)()){&D::saveLevel})
            m->registerHook(getBase()+0x13ebd0, extract((void(D::*)()){&D::saveLevel}));
    }
};


template<class D>
class $EditorUI : public EditorUI, public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorUI() {}
    typedef EditorUI* __thistype;

    void constrainGameLayerPosition() {
        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c6d0))(this);
        else return EditorUI::constrainGameLayerPosition();
    }

    void create(LevelEditorLayer p0) {
        if ((void($EditorUI::*)(LevelEditorLayer)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer)){&D::create})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer)>(m->getOriginal(getBase()+0x8a80))(this, p0);
        else return EditorUI::create(p0);
    }

    void deselectAll() {
        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
        else return EditorUI::deselectAll();
    }

    void onDeselectAll(CCObject p0) {
        if ((void($EditorUI::*)(CCObject)){&$EditorUI::onDeselectAll} != (void(D::*)(CCObject)){&D::onDeselectAll})
            return reinterpret_cast<void(*)(decltype(this), CCObject)>(m->getOriginal(getBase()+0x19cd0))(this, p0);
        else return EditorUI::onDeselectAll(p0);
    }

    void disableButton(CreateMenuItem p0) {
        if ((void($EditorUI::*)(CreateMenuItem)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem)){&D::disableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
        else return EditorUI::disableButton(p0);
    }

    void editButtonUsable() {
        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28f30))(this);
        else return EditorUI::editButtonUsable();
    }

    void editObject(cocos2d::CCObject p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject)){&D::editObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x195a0))(this, p0);
        else return EditorUI::editObject(p0);
    }

    void enableButton(CreateMenuItem p0) {
        if ((void($EditorUI::*)(CreateMenuItem)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem)){&D::enableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
        else return EditorUI::enableButton(p0);
    }

    CCMenuItemSpriteExtra* getCreateBtn(in p0, in p1) {
        if ((CCMenuItemSpriteExtra*($EditorUI::*)(in, in)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(in, in)){&D::getCreateBtn})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
        else return EditorUI::getCreateBtn(p0, p1);
    }

    void getGroupCenter(cocos2d::CCArray p0, boo p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray, boo)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray, boo)){&D::getGroupCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray, boo)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
        else return EditorUI::getGroupCenter(p0, p1);
    }

    cocos2d::CCArray* getSelectedObjects() {
        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            return reinterpret_cast<cocos2d::CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
        else return EditorUI::getSelectedObjects();
    }

    void init(LevelEditorLayer p0) {
        if ((void($EditorUI::*)(LevelEditorLayer)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer)){&D::init})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer)>(m->getOriginal(getBase()+0x8ae0))(this, p0);
        else return EditorUI::init(p0);
    }

    void keyDown(cocos2d::enumKeyCode p0) override {
        if ((void($EditorUI::*)(cocos2d::enumKeyCode)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCode)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCode)>(m->getOriginal(getBase()+0x30790))(this, p0);
        else return EditorUI::keyDown(p0);
    }

    void moveObject(GameObject p0, cocos2d::CCPoin p1) {
        if ((void($EditorUI::*)(GameObject, cocos2d::CCPoin)){&$EditorUI::moveObject} != (void(D::*)(GameObject, cocos2d::CCPoin)){&D::moveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject, cocos2d::CCPoin)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
        else return EditorUI::moveObject(p0, p1);
    }

    void onDuplicate(cocos2d::CCObject p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject)){&D::onDuplicate})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
        else return EditorUI::onDuplicate(p0);
    }

    void pasteObjects(std::strin p0) {
        if ((void($EditorUI::*)(std::strin)){&$EditorUI::pasteObjects} != (void(D::*)(std::strin)){&D::pasteObjects})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x232d0))(this, p0);
        else return EditorUI::pasteObjects(p0);
    }

    void playtestStopped() {
        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24790))(this);
        else return EditorUI::playtestStopped();
    }

    void redoLastAction(cocos2d::CCObject p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject)){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
        else return EditorUI::redoLastAction(p0);
    }

    void replaceGroupID(GameObject p0, in p1, in p2) {
        if ((void($EditorUI::*)(GameObject, in, in)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject, in, in)){&D::replaceGroupID})
            return reinterpret_cast<void(*)(decltype(this), GameObject, in, in)>(m->getOriginal(getBase()+0x27470))(this, p0, p1, p2);
        else return EditorUI::replaceGroupID(p0, p1, p2);
    }

    void scaleChanged(floa p0) {
        if ((void($EditorUI::*)(floa)){&$EditorUI::scaleChanged} != (void(D::*)(floa)){&D::scaleChanged})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x25490))(this, p0);
        else return EditorUI::scaleChanged(p0);
    }

    void scaleObjects(cocos2d::CCArray p0, floa p1, cocos2d::CCPoin p2) {
        if ((void($EditorUI::*)(cocos2d::CCArray, floa, cocos2d::CCPoin)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray, floa, cocos2d::CCPoin)){&D::scaleObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray, floa, cocos2d::CCPoin)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
        else return EditorUI::scaleObjects(p0, p1, p2);
    }

    void selectObjects(cocos2d::CCArray p0, boo p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray, boo)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray, boo)){&D::selectObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray, boo)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
        else return EditorUI::selectObjects(p0, p1);
    }

    void setupCreateMenu() {
        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xcb50))(this);
        else return EditorUI::setupCreateMenu();
    }

    void undoLastAction(cocos2d::CCObject p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject)){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0xb830))(this, p0);
        else return EditorUI::undoLastAction(p0);
    }

    void updateButtons() {
        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
        else return EditorUI::updateButtons();
    }

    void updateObjectInfoLabel() {
        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cb10))(this);
        else return EditorUI::updateObjectInfoLabel();
    }

    void updateSlider() {
        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18a90))(this);
        else return EditorUI::updateSlider();
    }

    void updateZoom(floa p0) {
        if ((void($EditorUI::*)(floa)){&$EditorUI::updateZoom} != (void(D::*)(floa)){&D::updateZoom})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x248c0))(this, p0);
        else return EditorUI::updateZoom(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            m->registerHook(getBase()+0x1c6d0, extract((void(D::*)()){&D::constrainGameLayerPosition}));

        if ((void($EditorUI::*)(LevelEditorLayer)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer)){&D::create})
            m->registerHook(getBase()+0x8a80, extract((void(D::*)(LevelEditorLayer)){&D::create}));

        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            m->registerHook(getBase()+0x1f300, extract((void(D::*)()){&D::deselectAll}));

        if ((void($EditorUI::*)(CCObject)){&$EditorUI::onDeselectAll} != (void(D::*)(CCObject)){&D::onDeselectAll})
            m->registerHook(getBase()+0x19cd0, extract((void(D::*)(CCObject)){&D::onDeselectAll}));

        if ((void($EditorUI::*)(CreateMenuItem)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem)){&D::disableButton})
            m->registerHook(getBase()+0x1c0f0, extract((void(D::*)(CreateMenuItem)){&D::disableButton}));

        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            m->registerHook(getBase()+0x28f30, extract((void(D::*)()){&D::editButtonUsable}));

        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject)){&D::editObject})
            m->registerHook(getBase()+0x195a0, extract((void(D::*)(cocos2d::CCObject)){&D::editObject}));

        if ((void($EditorUI::*)(CreateMenuItem)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem)){&D::enableButton})
            m->registerHook(getBase()+0x1bff0, extract((void(D::*)(CreateMenuItem)){&D::enableButton}));

        if ((CCMenuItemSpriteExtra*($EditorUI::*)(in, in)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(in, in)){&D::getCreateBtn})
            m->registerHook(getBase()+0x1f6c0, extract((CCMenuItemSpriteExtra*(D::*)(in, in)){&D::getCreateBtn}));

        if ((void($EditorUI::*)(cocos2d::CCArray, boo)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray, boo)){&D::getGroupCenter})
            m->registerHook(getBase()+0x23470, extract((void(D::*)(cocos2d::CCArray, boo)){&D::getGroupCenter}));

        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            m->registerHook(getBase()+0x23f30, extract((cocos2d::CCArray*(D::*)()){&D::getSelectedObjects}));

        if ((void($EditorUI::*)(LevelEditorLayer)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer)){&D::init})
            m->registerHook(getBase()+0x8ae0, extract((void(D::*)(LevelEditorLayer)){&D::init}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCode)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCode)){&D::keyDown})
            m->registerHook(getBase()+0x30790, extract((void(D::*)(cocos2d::enumKeyCode)){&D::keyDown}));

        if ((void($EditorUI::*)(GameObject, cocos2d::CCPoin)){&$EditorUI::moveObject} != (void(D::*)(GameObject, cocos2d::CCPoin)){&D::moveObject})
            m->registerHook(getBase()+0x24b10, extract((void(D::*)(GameObject, cocos2d::CCPoin)){&D::moveObject}));

        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject)){&D::onDuplicate})
            m->registerHook(getBase()+0x18ba0, extract((void(D::*)(cocos2d::CCObject)){&D::onDuplicate}));

        if ((void($EditorUI::*)(std::strin)){&$EditorUI::pasteObjects} != (void(D::*)(std::strin)){&D::pasteObjects})
            m->registerHook(getBase()+0x232d0, extract((void(D::*)(std::strin)){&D::pasteObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            m->registerHook(getBase()+0x24790, extract((void(D::*)()){&D::playtestStopped}));

        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject)){&D::redoLastAction})
            m->registerHook(getBase()+0xb8e0, extract((void(D::*)(cocos2d::CCObject)){&D::redoLastAction}));

        if ((void($EditorUI::*)(GameObject, in, in)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject, in, in)){&D::replaceGroupID})
            m->registerHook(getBase()+0x27470, extract((void(D::*)(GameObject, in, in)){&D::replaceGroupID}));

        if ((void($EditorUI::*)(floa)){&$EditorUI::scaleChanged} != (void(D::*)(floa)){&D::scaleChanged})
            m->registerHook(getBase()+0x25490, extract((void(D::*)(floa)){&D::scaleChanged}));

        if ((void($EditorUI::*)(cocos2d::CCArray, floa, cocos2d::CCPoin)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray, floa, cocos2d::CCPoin)){&D::scaleObjects})
            m->registerHook(getBase()+0x252e0, extract((void(D::*)(cocos2d::CCArray, floa, cocos2d::CCPoin)){&D::scaleObjects}));

        if ((void($EditorUI::*)(cocos2d::CCArray, boo)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray, boo)){&D::selectObjects})
            m->registerHook(getBase()+0x23940, extract((void(D::*)(cocos2d::CCArray, boo)){&D::selectObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            m->registerHook(getBase()+0xcb50, extract((void(D::*)()){&D::setupCreateMenu}));

        if ((void($EditorUI::*)(cocos2d::CCObject)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject)){&D::undoLastAction})
            m->registerHook(getBase()+0xb830, extract((void(D::*)(cocos2d::CCObject)){&D::undoLastAction}));

        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            m->registerHook(getBase()+0x1a300, extract((void(D::*)()){&D::updateButtons}));

        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            m->registerHook(getBase()+0x1cb10, extract((void(D::*)()){&D::updateObjectInfoLabel}));

        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            m->registerHook(getBase()+0x18a90, extract((void(D::*)()){&D::updateSlider}));

        if ((void($EditorUI::*)(floa)){&$EditorUI::updateZoom} != (void(D::*)(floa)){&D::updateZoom})
            m->registerHook(getBase()+0x248c0, extract((void(D::*)(floa)){&D::updateZoom}));
    }
};


template<class D>
class $EffectGameObject : public EffectGameObject, public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EffectGameObject() {}
    typedef EffectGameObject* __thistype;

    static EffectGameObject* create(char const p0) {
        if ((EffectGameObject*(*)(char const)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const)){&D::create})
            return reinterpret_cast<EffectGameObject*(*)(char const)>(m->getOriginal(getBase()+0xc9790))(p0);
        else return EffectGameObject::create(p0);
    }

    void getTargetColorIndex() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xca1f0))(this);
        else return EffectGameObject::getTargetColorIndex();
    }

    void triggerObject(GJBaseGameLayer p0) {
        if ((void($EffectGameObject::*)(GJBaseGameLayer)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer)>(m->getOriginal(getBase()+0xc9870))(this, p0);
        else return EffectGameObject::triggerObject(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((EffectGameObject*(*)(char const)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const)){&D::create})
            m->registerHook(getBase()+0xc9790, (EffectGameObject*(*)(char const)){&D::create});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            m->registerHook(getBase()+0xca1f0, extract((void(D::*)()){&D::getTargetColorIndex}));

        if ((void($EffectGameObject::*)(GJBaseGameLayer)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer)){&D::triggerObject})
            m->registerHook(getBase()+0xc9870, extract((void(D::*)(GJBaseGameLayer)){&D::triggerObject}));
    }
};


template<class D>
class $EndLevelLayer : public EndLevelLayer, public $CacBase {
 public:
    $EndLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EndLevelLayer() {}
    typedef EndLevelLayer* __thistype;

    static EndLevelLayer* create() {
        if ((EndLevelLayer*(*)()){&$EndLevelLayer::create} != (EndLevelLayer*(*)()){&D::create})
            return reinterpret_cast<EndLevelLayer*(*)()>(m->getOriginal(getBase()+0x2787d0))();
        else return EndLevelLayer::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((EndLevelLayer*(*)()){&$EndLevelLayer::create} != (EndLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x2787d0, (EndLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $EndPortalObject : public EndPortalObject, public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EndPortalObject() {}
    typedef EndPortalObject* __thistype;

    static EndPortalObject* create() {
        if ((EndPortalObject*(*)()){&$EndPortalObject::create} != (EndPortalObject*(*)()){&D::create})
            return reinterpret_cast<EndPortalObject*(*)()>(m->getOriginal(getBase()+0x1da8f0))();
        else return EndPortalObject::create();
    }

    void updateColors(cocos2d::_ccColor3 p0) {
        if ((void($EndPortalObject::*)(cocos2d::_ccColor3)){&$EndPortalObject::updateColors} != (void(D::*)(cocos2d::_ccColor3)){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
        else return EndPortalObject::updateColors(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((EndPortalObject*(*)()){&$EndPortalObject::create} != (EndPortalObject*(*)()){&D::create})
            m->registerHook(getBase()+0x1da8f0, (EndPortalObject*(*)()){&D::create});

        if ((void($EndPortalObject::*)(cocos2d::_ccColor3)){&$EndPortalObject::updateColors} != (void(D::*)(cocos2d::_ccColor3)){&D::updateColors})
            m->registerHook(getBase()+0x1dacb0, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateColors}));
    }
};


template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FLAlertLayer() {}
    typedef FLAlertLayer* __thistype;

    bool ccTouchBegan(cocos2d::CCTouch p0, cocos2d::CCEvent p1) {
        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch, cocos2d::CCEvent)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
        else return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    void ccTouchCancelled(cocos2d::CCTouch p0, cocos2d::CCEvent p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch, cocos2d::CCEvent)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
        else return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    void ccTouchEnded(cocos2d::CCTouch p0, cocos2d::CCEvent p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch, cocos2d::CCEvent)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
        else return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    void ccTouchMoved(cocos2d::CCTouch p0, cocos2d::CCEvent p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch, cocos2d::CCEvent)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
        else return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol p0, char const p1, std::strin p2, char const p3, char const p4, floa p5) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)>(m->getOriginal(getBase()+0x25e0e0))(p0, p1, p2, p3, p4, p5);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol p0, char const p1, std::strin p2, char const p3, char const p4, floa p5, boo p6, floa p7) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)>(m->getOriginal(getBase()+0x25dec0))(p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    bool init(FLAlertLayerProtocol p0, char const p1, std::strin p2, char const p3, char const p4, floa p5, boo p6, floa p7) {
        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::init(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void keyBackClicked() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25ed90))(this);
        else return FLAlertLayer::keyBackClicked();
    }

    void keyDown(cocos2d::enumKeyCode p0) {
        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCode)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCode)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCode)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
        else return FLAlertLayer::keyDown(p0);
    }

    void onEnter() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f350))(this);
        else return FLAlertLayer::onEnter();
    }

    void registerWithTouchDispatcher() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f2e0))(this);
        else return FLAlertLayer::registerWithTouchDispatcher();
    }

    void show() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f120))(this);
        else return FLAlertLayer::show();
    }

     ~FLAlertLayer() {
        if ((($FLAlertLayer::*)()){&$FLAlertLayer::~FLAlertLayer} != ((D::*)()){&D::~FLAlertLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x25da90))(this);
        else return FLAlertLayer::~FLAlertLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchBegan})
            m->registerHook(getBase()+0x25ee40, extract((bool(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchCancelled})
            m->registerHook(getBase()+0x25f020, extract((void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchEnded})
            m->registerHook(getBase()+0x25ef60, extract((void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchMoved})
            m->registerHook(getBase()+0x25f0a0, extract((void(D::*)(cocos2d::CCTouch, cocos2d::CCEvent)){&D::ccTouchMoved}));

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)){&D::create})
            m->registerHook(getBase()+0x25e0e0, (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa)){&D::create});

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::create})
            m->registerHook(getBase()+0x25dec0, (FLAlertLayer*(*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::create});

        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::init})
            m->registerHook(getBase()+0x25e1b0, extract((bool(D::*)(FLAlertLayerProtocol, char const, std::strin, char const, char const, floa, boo, floa)){&D::init}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x25ed90, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCode)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCode)){&D::keyDown})
            m->registerHook(getBase()+0x25ece0, extract((void(D::*)(cocos2d::enumKeyCode)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(getBase()+0x25f350, extract((void(D::*)()){&D::onEnter}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x25f2e0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x25f120, extract((void(D::*)()){&D::show}));

        if ((($FLAlertLayer::*)()){&$FLAlertLayer::~FLAlertLayer} != ((D::*)()){&D::~FLAlertLayer})
            m->registerHook(getBase()+0x25da90, extract(((D::*)()){&D::~FLAlertLayer}));
    }
};


template<class D>
class $FollowRewardPage : public FollowRewardPage, public $CacBase {
 public:
    $FollowRewardPage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FollowRewardPage() {}
    typedef FollowRewardPage* __thistype;

    static FollowRewardPage* create() {
        if ((FollowRewardPage*(*)()){&$FollowRewardPage::create} != (FollowRewardPage*(*)()){&D::create})
            return reinterpret_cast<FollowRewardPage*(*)()>(m->getOriginal(getBase()+0x22f140))();
        else return FollowRewardPage::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((FollowRewardPage*(*)()){&$FollowRewardPage::create} != (FollowRewardPage*(*)()){&D::create})
            m->registerHook(getBase()+0x22f140, (FollowRewardPage*(*)()){&D::create});
    }
};


template<class D>
class $GJAccountManager : public GJAccountManager, public $CacBase {
 public:
    $GJAccountManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJAccountManager() {}
    typedef GJAccountManager* __thistype;

    static GJAccountManager* sharedState() {
        if ((GJAccountManager*(*)()){&$GJAccountManager::sharedState} != (GJAccountManager*(*)()){&D::sharedState})
            return reinterpret_cast<GJAccountManager*(*)()>(m->getOriginal(getBase()+0x85070))();
        else return GJAccountManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJAccountManager*(*)()){&$GJAccountManager::sharedState} != (GJAccountManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x85070, (GJAccountManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $GJBaseGameLayer : public GJBaseGameLayer, public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJBaseGameLayer() {}
    typedef GJBaseGameLayer* __thistype;

    void addObjectCounter(LabelGameObject p0, in p1) {
        if ((void($GJBaseGameLayer::*)(LabelGameObject, in)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject, in)){&D::addObjectCounter})
            return reinterpret_cast<void(*)(decltype(this), LabelGameObject, in)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
        else return GJBaseGameLayer::addObjectCounter(p0, p1);
    }

    void addToGroup(GameObject p0, in p1, boo p2) {
        if ((void($GJBaseGameLayer::*)(GameObject, in, boo)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject, in, boo)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject, in, boo)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
        else return GJBaseGameLayer::addToGroup(p0, p1, p2);
    }

    void addToGroups(GameObject p0, boo p1) {
        if ((void($GJBaseGameLayer::*)(GameObject, boo)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject, boo)){&D::addToGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
        else return GJBaseGameLayer::addToGroups(p0, p1);
    }

    void addToSection(GameObject p0) {
        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject)){&D::addToSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
        else return GJBaseGameLayer::addToSection(p0);
    }

    void atlasValue(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(in)){&D::atlasValue})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
        else return GJBaseGameLayer::atlasValue(p0);
    }

    void bumpPlayer(PlayerObject p0, GameObject p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject, GameObject)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject, GameObject)){&D::bumpPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
        else return GJBaseGameLayer::bumpPlayer(p0, p1);
    }

    void calculateColorValues(EffectGameObject p0, EffectGameObject p1, in p2, floa p3, ColorActionSprite p4, GJEffectManager p5) override {
        if ((void($GJBaseGameLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
        else return GJBaseGameLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void calculateOpacityValues(EffectGameObject p0, EffectGameObject p1, floa p2, GJEffectManager p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject, EffectGameObject, floa, GJEffectManager)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject, EffectGameObject, floa, GJEffectManager)){&D::calculateOpacityValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, EffectGameObject, floa, GJEffectManager)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::calculateOpacityValues(p0, p1, p2, p3);
    }

    void checkSpawnObjects() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6f90))(this);
        else return GJBaseGameLayer::checkSpawnObjects();
    }

    void collectItem(in p0, in p1) {
        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::collectItem} != (void(D::*)(in, in)){&D::collectItem})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
        else return GJBaseGameLayer::collectItem(p0, p1);
    }

    void collectedObject(EffectGameObject p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject)){&D::collectedObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
        else return GJBaseGameLayer::collectedObject(p0);
    }

    void createMoveCommand(cocos2d::CCPoin p0, in p1, floa p2, in p3, floa p4, boo p5, boo p6, in p7) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJBaseGameLayer::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void createTextLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb5260))(this);
        else return GJBaseGameLayer::createTextLayers();
    }

    void damagingObjectsInRect(cocos2d::CCRec p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRec)){&D::damagingObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRec)>(m->getOriginal(getBase()+0xb6140))(this, p0);
        else return GJBaseGameLayer::damagingObjectsInRect(p0);
    }

    void enableHighCapacityMode() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb11e0))(this);
        else return GJBaseGameLayer::enableHighCapacityMode();
    }

    void flipGravity(PlayerObject p0, boo p1, boo p2) {
        if ((void($GJBaseGameLayer::*)(PlayerObject, boo, boo)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, boo, boo)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
        else return GJBaseGameLayer::flipGravity(p0, p1, p2);
    }

    void getCapacityString() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb2210))(this);
        else return GJBaseGameLayer::getCapacityString();
    }

    void getGroundHeightForMode(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(in)){&D::getGroundHeightForMode})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb6630))(this, p0);
        else return GJBaseGameLayer::getGroundHeightForMode(p0);
    }

    void getGroup(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getGroup} != (void(D::*)(in)){&D::getGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
        else return GJBaseGameLayer::getGroup(p0);
    }

    void getMoveDeltaForObjects(in p0, in p1) {
        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(in, in)){&D::getMoveDeltaForObjects})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
        else return GJBaseGameLayer::getMoveDeltaForObjects(p0, p1);
    }

    void getOptimizedGroup(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(in)){&D::getOptimizedGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb7940))(this, p0);
        else return GJBaseGameLayer::getOptimizedGroup(p0);
    }

    void getStaticGroup(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(in)){&D::getStaticGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
        else return GJBaseGameLayer::getStaticGroup(p0);
    }

    bool init() {
        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xafc90))(this);
        else return GJBaseGameLayer::init();
    }

    void isGroupDisabledForObject(GameObject p0) {
        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject)){&D::isGroupDisabledForObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
        else return GJBaseGameLayer::isGroupDisabledForObject(p0);
    }

    void isGroupDisabledForObjectFull(GameObject p0, cocos2d::CCArray p1) {
        if ((void($GJBaseGameLayer::*)(GameObject, cocos2d::CCArray)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject, cocos2d::CCArray)){&D::isGroupDisabledForObjectFull})
            return reinterpret_cast<void(*)(decltype(this), GameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
        else return GJBaseGameLayer::isGroupDisabledForObjectFull(p0, p1);
    }

    void loadUpToPosition(floa p0) {
        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(floa)){&D::loadUpToPosition})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xba680))(this, p0);
        else return GJBaseGameLayer::loadUpToPosition(p0);
    }

    void objectIntersectsCircle(GameObject p0, GameObject p1) {
        if ((void($GJBaseGameLayer::*)(GameObject, GameObject)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject, GameObject)){&D::objectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), GameObject, GameObject)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
        else return GJBaseGameLayer::objectIntersectsCircle(p0, p1);
    }

    void objectTriggered(EffectGameObject p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject)){&D::objectTriggered})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
        else return GJBaseGameLayer::objectTriggered(p0);
    }

    void objectsCollided(in p0, in p1) {
        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(in, in)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
        else return GJBaseGameLayer::objectsCollided(p0, p1);
    }

    void optimizeMoveGroups() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb96c0))(this);
        else return GJBaseGameLayer::optimizeMoveGroups();
    }

    void parentForZLayer(in p0, boo p1, in p2) {
        if ((void($GJBaseGameLayer::*)(in, boo, in)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(in, boo, in)){&D::parentForZLayer})
            return reinterpret_cast<void(*)(decltype(this), in, boo, in)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
        else return GJBaseGameLayer::parentForZLayer(p0, p1, p2);
    }

    void playerTouchedRing(PlayerObject p0, GameObject p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject, GameObject)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject, GameObject)){&D::playerTouchedRing})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
        else return GJBaseGameLayer::playerTouchedRing(p0, p1);
    }

    void processColorObject(EffectGameObject p0, in p1, cocos2d::CCDictionary p2, floa p3, GJEffectManager p4) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processColorObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::processColorObject(p0, p1, p2, p3, p4);
    }

    void processFollowActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8fd0))(this);
        else return GJBaseGameLayer::processFollowActions();
    }

    void processMoveActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb86c0))(this);
        else return GJBaseGameLayer::processMoveActions();
    }

    void processMoveActionsStep(floa p0) {
        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(floa)){&D::processMoveActionsStep})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
        else return GJBaseGameLayer::processMoveActionsStep(p0);
    }

    void processOpacityObject(EffectGameObject p0, cocos2d::CCDictionary p1, floa p2, GJEffectManager p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processOpacityObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::processOpacityObject(p0, p1, p2, p3);
    }

    void processPlayerFollowActions(floa p0) {
        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(floa)){&D::processPlayerFollowActions})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
        else return GJBaseGameLayer::processPlayerFollowActions(p0);
    }

    void processRotationActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb7fd0))(this);
        else return GJBaseGameLayer::processRotationActions();
    }

    void pushButton(in p0, boo p1) {
        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::pushButton} != (void(D::*)(in, boo)){&D::pushButton})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
        else return GJBaseGameLayer::pushButton(p0, p1);
    }

    void rectIntersectsCircle(cocos2d::CCRec p0, cocos2d::CCPoin p1, floa p2) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec, cocos2d::CCPoin, floa)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRec, cocos2d::CCPoin, floa)){&D::rectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRec, cocos2d::CCPoin, floa)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
        else return GJBaseGameLayer::rectIntersectsCircle(p0, p1, p2);
    }

    void refreshCounterLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9fc0))(this);
        else return GJBaseGameLayer::refreshCounterLabels();
    }

    void releaseButton(in p0, boo p1) {
        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(in, boo)){&D::releaseButton})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
        else return GJBaseGameLayer::releaseButton(p0, p1);
    }

    void removeFromGroup(GameObject p0, in p1) {
        if ((void($GJBaseGameLayer::*)(GameObject, in)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject, in)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject, in)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
        else return GJBaseGameLayer::removeFromGroup(p0, p1);
    }

    void removeFromGroups(GameObject p0) {
        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject)){&D::removeFromGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
        else return GJBaseGameLayer::removeFromGroups(p0);
    }

    void removeObjectFromSection(GameObject p0) {
        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject)){&D::removeObjectFromSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
        else return GJBaseGameLayer::removeObjectFromSection(p0);
    }

    void reorderObjectSection(GameObject p0) {
        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject)){&D::reorderObjectSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
        else return GJBaseGameLayer::reorderObjectSection(p0);
    }

    void resetGroupCounters(boo p0) {
        if ((void($GJBaseGameLayer::*)(boo)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(boo)){&D::resetGroupCounters})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0xba300))(this, p0);
        else return GJBaseGameLayer::resetGroupCounters(p0);
    }

    void resetMoveOptimizedValue() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9670))(this);
        else return GJBaseGameLayer::resetMoveOptimizedValue();
    }

    void sectionForPos(floa p0) {
        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(floa)){&D::sectionForPos})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xb6120))(this, p0);
        else return GJBaseGameLayer::sectionForPos(p0);
    }

    void setupLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xaffe0))(this);
        else return GJBaseGameLayer::setupLayers();
    }

    void shouldExitHackedLevel() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb1100))(this);
        else return GJBaseGameLayer::shouldExitHackedLevel();
    }

    void spawnGroup(in p0) {
        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(in)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0xb7050))(this, p0);
        else return GJBaseGameLayer::spawnGroup(p0);
    }

    void spawnGroupTriggered(in p0, floa p1, in p2) {
        if ((void($GJBaseGameLayer::*)(in, floa, in)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(in, floa, in)){&D::spawnGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), in, floa, in)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
        else return GJBaseGameLayer::spawnGroupTriggered(p0, p1, p2);
    }

    void staticObjectsInRect(cocos2d::CCRec p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRec)){&D::staticObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRec)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
        else return GJBaseGameLayer::staticObjectsInRect(p0);
    }

    void testInstantCountTrigger(in p0, in p1, in p2, boo p3, in p4) {
        if ((void($GJBaseGameLayer::*)(in, in, in, boo, in)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(in, in, in, boo, in)){&D::testInstantCountTrigger})
            return reinterpret_cast<void(*)(decltype(this), in, in, in, boo, in)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::testInstantCountTrigger(p0, p1, p2, p3, p4);
    }

    void toggleGroup(in p0, boo p1) {
        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(in, boo)){&D::toggleGroup})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroup(p0, p1);
    }

    void toggleGroupTriggered(in p0, boo p1) {
        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(in, boo)){&D::toggleGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroupTriggered(p0, p1);
    }

    void togglePlayerVisibility(boo p0) {
        if ((void($GJBaseGameLayer::*)(boo)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(boo)){&D::togglePlayerVisibility})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0xba910))(this, p0);
        else return GJBaseGameLayer::togglePlayerVisibility(p0);
    }

    void triggerMoveCommand(EffectGameObject p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject)){&D::triggerMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject)>(m->getOriginal(getBase()+0xb7290))(this, p0);
        else return GJBaseGameLayer::triggerMoveCommand(p0);
    }

    void updateCollisionBlocks() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6a30))(this);
        else return GJBaseGameLayer::updateCollisionBlocks();
    }

    void updateColor(cocos2d::_ccColor3 p0, floa p1, in p2, boo p3, floa p4, cocos2d::_ccHSVValu p5, in p6, boo p7, in p8, EffectGameObject p9) {
        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return GJBaseGameLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateCounters(in p0, in p1) {
        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(in, in)){&D::updateCounters})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
        else return GJBaseGameLayer::updateCounters(p0, p1);
    }

    void updateDisabledObjectsLastPos(cocos2d::CCArray p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray)){&D::updateDisabledObjectsLastPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
        else return GJBaseGameLayer::updateDisabledObjectsLastPos(p0);
    }

    void updateLayerCapacity(std::strin p0) {
        if ((void($GJBaseGameLayer::*)(std::strin)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::strin)){&D::updateLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0xb1680))(this, p0);
        else return GJBaseGameLayer::updateLayerCapacity(p0);
    }

    void updateLegacyLayerCapacity(in p0, in p1, in p2, in p3) {
        if ((void($GJBaseGameLayer::*)(in, in, in, in)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(in, in, in, in)){&D::updateLegacyLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), in, in, in, in)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::updateLegacyLayerCapacity(p0, p1, p2, p3);
    }

    void updateOBB2(cocos2d::CCRec p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRec)){&D::updateOBB2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRec)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
        else return GJBaseGameLayer::updateOBB2(p0);
    }

    void updateQueuedLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9f30))(this);
        else return GJBaseGameLayer::updateQueuedLabels();
    }

     ~GJBaseGameLayer() {
        if ((($GJBaseGameLayer::*)()){&$GJBaseGameLayer::~GJBaseGameLayer} != ((D::*)()){&D::~GJBaseGameLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0xaf990))(this);
        else return GJBaseGameLayer::~GJBaseGameLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GJBaseGameLayer::*)(LabelGameObject, in)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject, in)){&D::addObjectCounter})
            m->registerHook(getBase()+0xb9eb0, extract((void(D::*)(LabelGameObject, in)){&D::addObjectCounter}));

        if ((void($GJBaseGameLayer::*)(GameObject, in, boo)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject, in, boo)){&D::addToGroup})
            m->registerHook(getBase()+0xb77f0, extract((void(D::*)(GameObject, in, boo)){&D::addToGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject, boo)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject, boo)){&D::addToGroups})
            m->registerHook(getBase()+0xb7780, extract((void(D::*)(GameObject, boo)){&D::addToGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject)){&D::addToSection})
            m->registerHook(getBase()+0xb7b70, extract((void(D::*)(GameObject)){&D::addToSection}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(in)){&D::atlasValue})
            m->registerHook(getBase()+0xb21e0, extract((void(D::*)(in)){&D::atlasValue}));

        if ((void($GJBaseGameLayer::*)(PlayerObject, GameObject)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject, GameObject)){&D::bumpPlayer})
            m->registerHook(getBase()+0xb6860, extract((void(D::*)(PlayerObject, GameObject)){&D::bumpPlayer}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            m->registerHook(getBase()+0xba9a0, extract((void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject, EffectGameObject, floa, GJEffectManager)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject, EffectGameObject, floa, GJEffectManager)){&D::calculateOpacityValues})
            m->registerHook(getBase()+0xb5be0, extract((void(D::*)(EffectGameObject, EffectGameObject, floa, GJEffectManager)){&D::calculateOpacityValues}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            m->registerHook(getBase()+0xb6f90, extract((void(D::*)()){&D::checkSpawnObjects}));

        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::collectItem} != (void(D::*)(in, in)){&D::collectItem})
            m->registerHook(getBase()+0xb9e20, extract((void(D::*)(in, in)){&D::collectItem}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject)){&D::collectedObject})
            m->registerHook(getBase()+0xb9b60, extract((void(D::*)(EffectGameObject)){&D::collectedObject}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand})
            m->registerHook(getBase()+0xb73a0, extract((void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            m->registerHook(getBase()+0xb5260, extract((void(D::*)()){&D::createTextLayers}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRec)){&D::damagingObjectsInRect})
            m->registerHook(getBase()+0xb6140, extract((void(D::*)(cocos2d::CCRec)){&D::damagingObjectsInRect}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            m->registerHook(getBase()+0xb11e0, extract((void(D::*)()){&D::enableHighCapacityMode}));

        if ((void($GJBaseGameLayer::*)(PlayerObject, boo, boo)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            m->registerHook(getBase()+0xba990, extract((void(D::*)(PlayerObject, boo, boo)){&D::flipGravity}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            m->registerHook(getBase()+0xb2210, extract((void(D::*)()){&D::getCapacityString}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(in)){&D::getGroundHeightForMode})
            m->registerHook(getBase()+0xb6630, extract((void(D::*)(in)){&D::getGroundHeightForMode}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getGroup} != (void(D::*)(in)){&D::getGroup})
            m->registerHook(getBase()+0xb6f20, extract((void(D::*)(in)){&D::getGroup}));

        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(in, in)){&D::getMoveDeltaForObjects})
            m->registerHook(getBase()+0xb6db0, extract((void(D::*)(in, in)){&D::getMoveDeltaForObjects}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(in)){&D::getOptimizedGroup})
            m->registerHook(getBase()+0xb7940, extract((void(D::*)(in)){&D::getOptimizedGroup}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(in)){&D::getStaticGroup})
            m->registerHook(getBase()+0xb79a0, extract((void(D::*)(in)){&D::getStaticGroup}));

        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xafc90, extract((bool(D::*)()){&D::init}));

        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject)){&D::isGroupDisabledForObject})
            m->registerHook(getBase()+0xb5cc0, extract((void(D::*)(GameObject)){&D::isGroupDisabledForObject}));

        if ((void($GJBaseGameLayer::*)(GameObject, cocos2d::CCArray)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject, cocos2d::CCArray)){&D::isGroupDisabledForObjectFull})
            m->registerHook(getBase()+0xb5de0, extract((void(D::*)(GameObject, cocos2d::CCArray)){&D::isGroupDisabledForObjectFull}));

        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(floa)){&D::loadUpToPosition})
            m->registerHook(getBase()+0xba680, extract((void(D::*)(floa)){&D::loadUpToPosition}));

        if ((void($GJBaseGameLayer::*)(GameObject, GameObject)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject, GameObject)){&D::objectIntersectsCircle})
            m->registerHook(getBase()+0xb66e0, extract((void(D::*)(GameObject, GameObject)){&D::objectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject)){&D::objectTriggered})
            m->registerHook(getBase()+0xb71b0, extract((void(D::*)(EffectGameObject)){&D::objectTriggered}));

        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(in, in)){&D::objectsCollided})
            m->registerHook(getBase()+0xb6d90, extract((void(D::*)(in, in)){&D::objectsCollided}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            m->registerHook(getBase()+0xb96c0, extract((void(D::*)()){&D::optimizeMoveGroups}));

        if ((void($GJBaseGameLayer::*)(in, boo, in)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(in, boo, in)){&D::parentForZLayer})
            m->registerHook(getBase()+0xb55d0, extract((void(D::*)(in, boo, in)){&D::parentForZLayer}));

        if ((void($GJBaseGameLayer::*)(PlayerObject, GameObject)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject, GameObject)){&D::playerTouchedRing})
            m->registerHook(getBase()+0xb69e0, extract((void(D::*)(PlayerObject, GameObject)){&D::playerTouchedRing}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processColorObject})
            m->registerHook(getBase()+0xb5a90, extract((void(D::*)(EffectGameObject, in, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processColorObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            m->registerHook(getBase()+0xb8fd0, extract((void(D::*)()){&D::processFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            m->registerHook(getBase()+0xb86c0, extract((void(D::*)()){&D::processMoveActions}));

        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(floa)){&D::processMoveActionsStep})
            m->registerHook(getBase()+0xb7ea0, extract((void(D::*)(floa)){&D::processMoveActionsStep}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processOpacityObject})
            m->registerHook(getBase()+0xb5ae0, extract((void(D::*)(EffectGameObject, cocos2d::CCDictionary, floa, GJEffectManager)){&D::processOpacityObject}));

        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(floa)){&D::processPlayerFollowActions})
            m->registerHook(getBase()+0xb8b50, extract((void(D::*)(floa)){&D::processPlayerFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            m->registerHook(getBase()+0xb7fd0, extract((void(D::*)()){&D::processRotationActions}));

        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::pushButton} != (void(D::*)(in, boo)){&D::pushButton})
            m->registerHook(getBase()+0xb9920, extract((void(D::*)(in, boo)){&D::pushButton}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec, cocos2d::CCPoin, floa)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRec, cocos2d::CCPoin, floa)){&D::rectIntersectsCircle})
            m->registerHook(getBase()+0xb6470, extract((void(D::*)(cocos2d::CCRec, cocos2d::CCPoin, floa)){&D::rectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            m->registerHook(getBase()+0xb9fc0, extract((void(D::*)()){&D::refreshCounterLabels}));

        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(in, boo)){&D::releaseButton})
            m->registerHook(getBase()+0xb9a00, extract((void(D::*)(in, boo)){&D::releaseButton}));

        if ((void($GJBaseGameLayer::*)(GameObject, in)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject, in)){&D::removeFromGroup})
            m->registerHook(getBase()+0xb7a60, extract((void(D::*)(GameObject, in)){&D::removeFromGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject)){&D::removeFromGroups})
            m->registerHook(getBase()+0xb7a00, extract((void(D::*)(GameObject)){&D::removeFromGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject)){&D::removeObjectFromSection})
            m->registerHook(getBase()+0xb7e00, extract((void(D::*)(GameObject)){&D::removeObjectFromSection}));

        if ((void($GJBaseGameLayer::*)(GameObject)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject)){&D::reorderObjectSection})
            m->registerHook(getBase()+0xb7cb0, extract((void(D::*)(GameObject)){&D::reorderObjectSection}));

        if ((void($GJBaseGameLayer::*)(boo)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(boo)){&D::resetGroupCounters})
            m->registerHook(getBase()+0xba300, extract((void(D::*)(boo)){&D::resetGroupCounters}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            m->registerHook(getBase()+0xb9670, extract((void(D::*)()){&D::resetMoveOptimizedValue}));

        if ((void($GJBaseGameLayer::*)(floa)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(floa)){&D::sectionForPos})
            m->registerHook(getBase()+0xb6120, extract((void(D::*)(floa)){&D::sectionForPos}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            m->registerHook(getBase()+0xaffe0, extract((void(D::*)()){&D::setupLayers}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            m->registerHook(getBase()+0xb1100, extract((void(D::*)()){&D::shouldExitHackedLevel}));

        if ((void($GJBaseGameLayer::*)(in)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(in)){&D::spawnGroup})
            m->registerHook(getBase()+0xb7050, extract((void(D::*)(in)){&D::spawnGroup}));

        if ((void($GJBaseGameLayer::*)(in, floa, in)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(in, floa, in)){&D::spawnGroupTriggered})
            m->registerHook(getBase()+0xb7020, extract((void(D::*)(in, floa, in)){&D::spawnGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRec)){&D::staticObjectsInRect})
            m->registerHook(getBase()+0xb5f90, extract((void(D::*)(cocos2d::CCRec)){&D::staticObjectsInRect}));

        if ((void($GJBaseGameLayer::*)(in, in, in, boo, in)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(in, in, in, boo, in)){&D::testInstantCountTrigger})
            m->registerHook(getBase()+0xb9ae0, extract((void(D::*)(in, in, in, boo, in)){&D::testInstantCountTrigger}));

        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(in, boo)){&D::toggleGroup})
            m->registerHook(getBase()+0xb75f0, extract((void(D::*)(in, boo)){&D::toggleGroup}));

        if ((void($GJBaseGameLayer::*)(in, boo)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(in, boo)){&D::toggleGroupTriggered})
            m->registerHook(getBase()+0xb75a0, extract((void(D::*)(in, boo)){&D::toggleGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(boo)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(boo)){&D::togglePlayerVisibility})
            m->registerHook(getBase()+0xba910, extract((void(D::*)(boo)){&D::togglePlayerVisibility}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject)){&D::triggerMoveCommand})
            m->registerHook(getBase()+0xb7290, extract((void(D::*)(EffectGameObject)){&D::triggerMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            m->registerHook(getBase()+0xb6a30, extract((void(D::*)()){&D::updateCollisionBlocks}));

        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            m->registerHook(getBase()+0xb7420, extract((void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor}));

        if ((void($GJBaseGameLayer::*)(in, in)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(in, in)){&D::updateCounters})
            m->registerHook(getBase()+0xb9bc0, extract((void(D::*)(in, in)){&D::updateCounters}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray)){&D::updateDisabledObjectsLastPos})
            m->registerHook(getBase()+0xb95b0, extract((void(D::*)(cocos2d::CCArray)){&D::updateDisabledObjectsLastPos}));

        if ((void($GJBaseGameLayer::*)(std::strin)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::strin)){&D::updateLayerCapacity})
            m->registerHook(getBase()+0xb1680, extract((void(D::*)(std::strin)){&D::updateLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(in, in, in, in)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(in, in, in, in)){&D::updateLegacyLayerCapacity})
            m->registerHook(getBase()+0xb1590, extract((void(D::*)(in, in, in, in)){&D::updateLegacyLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRec)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRec)){&D::updateOBB2})
            m->registerHook(getBase()+0xb63f0, extract((void(D::*)(cocos2d::CCRec)){&D::updateOBB2}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            m->registerHook(getBase()+0xb9f30, extract((void(D::*)()){&D::updateQueuedLabels}));

        if ((($GJBaseGameLayer::*)()){&$GJBaseGameLayer::~GJBaseGameLayer} != ((D::*)()){&D::~GJBaseGameLayer})
            m->registerHook(getBase()+0xaf990, extract(((D::*)()){&D::~GJBaseGameLayer}));
    }
};


template<class D>
class $GJColorSetupLayer : public GJColorSetupLayer, public $CacBase {
 public:
    $GJColorSetupLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJColorSetupLayer() {}
    typedef GJColorSetupLayer* __thistype;

    void updateSpriteColors() {
        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors} != (void(D::*)()){&D::updateSpriteColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xefe50))(this);
        else return GJColorSetupLayer::updateSpriteColors();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors} != (void(D::*)()){&D::updateSpriteColors})
            m->registerHook(getBase()+0xefe50, extract((void(D::*)()){&D::updateSpriteColors}));
    }
};


template<class D>
class $GJDropDownLayer : public GJDropDownLayer, public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJDropDownLayer() {}
    typedef GJDropDownLayer* __thistype;

    static GJDropDownLayer* create(char const p0) {
        if ((GJDropDownLayer*(*)(char const)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const)){&D::create})
            return reinterpret_cast<GJDropDownLayer*(*)(char const)>(m->getOriginal(getBase()+0x352530))(p0);
        else return GJDropDownLayer::create(p0);
    }

    void customSetup() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352570))(this);
        else return GJDropDownLayer::customSetup();
    }

    void disableUI() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352580))(this);
        else return GJDropDownLayer::disableUI();
    }

    void draw() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352910))(this);
        else return GJDropDownLayer::draw();
    }

    void enableUI() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525a0))(this);
        else return GJDropDownLayer::enableUI();
    }

    void enterAnimFinished() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528a0))(this);
        else return GJDropDownLayer::enterAnimFinished();
    }

    void enterLayer() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525c0))(this);
        else return GJDropDownLayer::enterLayer();
    }

    void exitLayer(cocos2d::CCObject p0) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCObject)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x352670))(this, p0);
        else return GJDropDownLayer::exitLayer(p0);
    }

    void hideLayer(boo p0) {
        if ((void($GJDropDownLayer::*)(boo)){&$GJDropDownLayer::hideLayer} != (void(D::*)(boo)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
        else return GJDropDownLayer::hideLayer(p0);
    }

    bool init(char const p0, floa p1) {
        if ((bool($GJDropDownLayer::*)(char const, floa)){&$GJDropDownLayer::init} != (bool(D::*)(char const, floa)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), char const, floa)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
        else return GJDropDownLayer::init(p0, p1);
    }

    void layerHidden() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528d0))(this);
        else return GJDropDownLayer::layerHidden();
    }

    void layerVisible() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528b0))(this);
        else return GJDropDownLayer::layerVisible();
    }

    void registerWithTouchDispatcher() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525f0))(this);
        else return GJDropDownLayer::registerWithTouchDispatcher();
    }

    void showLayer(boo p0) {
        if ((void($GJDropDownLayer::*)(boo)){&$GJDropDownLayer::showLayer} != (void(D::*)(boo)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
        else return GJDropDownLayer::showLayer(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJDropDownLayer*(*)(char const)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const)){&D::create})
            m->registerHook(getBase()+0x352530, (GJDropDownLayer*(*)(char const)){&D::create});

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x352570, extract((void(D::*)()){&D::customSetup}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(getBase()+0x352580, extract((void(D::*)()){&D::disableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x352910, extract((void(D::*)()){&D::draw}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(getBase()+0x3525a0, extract((void(D::*)()){&D::enableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(getBase()+0x3528a0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(getBase()+0x3525c0, extract((void(D::*)()){&D::enterLayer}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCObject)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject)){&D::exitLayer})
            m->registerHook(getBase()+0x352670, extract((void(D::*)(cocos2d::CCObject)){&D::exitLayer}));

        if ((void($GJDropDownLayer::*)(boo)){&$GJDropDownLayer::hideLayer} != (void(D::*)(boo)){&D::hideLayer})
            m->registerHook(getBase()+0x3527b0, extract((void(D::*)(boo)){&D::hideLayer}));

        if ((bool($GJDropDownLayer::*)(char const, floa)){&$GJDropDownLayer::init} != (bool(D::*)(char const, floa)){&D::init})
            m->registerHook(getBase()+0x352100, extract((bool(D::*)(char const, floa)){&D::init}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(getBase()+0x3528d0, extract((void(D::*)()){&D::layerHidden}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(getBase()+0x3528b0, extract((void(D::*)()){&D::layerVisible}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x3525f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJDropDownLayer::*)(boo)){&$GJDropDownLayer::showLayer} != (void(D::*)(boo)){&D::showLayer})
            m->registerHook(getBase()+0x3526c0, extract((void(D::*)(boo)){&D::showLayer}));
    }
};


template<class D>
class $GJEffectManager : public GJEffectManager, public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJEffectManager() {}
    typedef GJEffectManager* __thistype;

    void activeColorForIndex(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::activeColorForIndex} != (void(D::*)(in)){&D::activeColorForIndex})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
        else return GJEffectManager::activeColorForIndex(p0);
    }

    void activeOpacityForIndex(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::activeOpacityForIndex} != (void(D::*)(in)){&D::activeOpacityForIndex})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180e10))(this, p0);
        else return GJEffectManager::activeOpacityForIndex(p0);
    }

    void addAllInheritedColorActions(cocos2d::CCArray p0) {
        if ((void($GJEffectManager::*)(cocos2d::CCArray)){&$GJEffectManager::addAllInheritedColorActions} != (void(D::*)(cocos2d::CCArray)){&D::addAllInheritedColorActions})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
        else return GJEffectManager::addAllInheritedColorActions(p0);
    }

    void addGroupPulseEffect(PulseEffectAction p0) {
        if ((void($GJEffectManager::*)(PulseEffectAction)){&$GJEffectManager::addGroupPulseEffect} != (void(D::*)(PulseEffectAction)){&D::addGroupPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), PulseEffectAction)>(m->getOriginal(getBase()+0x184c10))(this, p0);
        else return GJEffectManager::addGroupPulseEffect(p0);
    }

    void calculateBaseActiveColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors} != (void(D::*)()){&D::calculateBaseActiveColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180f70))(this);
        else return GJEffectManager::calculateBaseActiveColors();
    }

    void calculateInheritedColor(in p0, ColorAction p1) {
        if ((void($GJEffectManager::*)(in, ColorAction)){&$GJEffectManager::calculateInheritedColor} != (void(D::*)(in, ColorAction)){&D::calculateInheritedColor})
            return reinterpret_cast<void(*)(decltype(this), in, ColorAction)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
        else return GJEffectManager::calculateInheritedColor(p0, p1);
    }

    void calculateLightBGColor(cocos2d::_ccColor3 p0) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3)){&$GJEffectManager::calculateLightBGColor} != (void(D::*)(cocos2d::_ccColor3)){&D::calculateLightBGColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x185b90))(this, p0);
        else return GJEffectManager::calculateLightBGColor(p0);
    }

    void colorActionChanged(ColorAction p0) {
        if ((void($GJEffectManager::*)(ColorAction)){&$GJEffectManager::colorActionChanged} != (void(D::*)(ColorAction)){&D::colorActionChanged})
            return reinterpret_cast<void(*)(decltype(this), ColorAction)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
        else return GJEffectManager::colorActionChanged(p0);
    }

    void colorExists(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::colorExists} != (void(D::*)(in)){&D::colorExists})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x181da0))(this, p0);
        else return GJEffectManager::colorExists(p0);
    }

    void colorForEffect(cocos2d::_ccColor3 p0, cocos2d::_ccHSVValu p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccHSVValu)){&$GJEffectManager::colorForEffect} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccHSVValu)){&D::colorForEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, cocos2d::_ccHSVValu)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
        else return GJEffectManager::colorForEffect(p0, p1);
    }

    void colorForGroupID(in p0, cocos2d::_ccColor3B const p1, boo p2) {
        if ((void($GJEffectManager::*)(in, cocos2d::_ccColor3B const, boo)){&$GJEffectManager::colorForGroupID} != (void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::colorForGroupID})
            return reinterpret_cast<void(*)(decltype(this), in, cocos2d::_ccColor3B const, boo)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
        else return GJEffectManager::colorForGroupID(p0, p1, p2);
    }

    void colorForIndex(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::colorForIndex} != (void(D::*)(in)){&D::colorForIndex})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
        else return GJEffectManager::colorForIndex(p0);
    }

    void colorForPulseEffect(cocos2d::_ccColor3B const p0, PulseEffectAction p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B const, PulseEffectAction)){&$GJEffectManager::colorForPulseEffect} != (void(D::*)(cocos2d::_ccColor3B const, PulseEffectAction)){&D::colorForPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const, PulseEffectAction)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
        else return GJEffectManager::colorForPulseEffect(p0, p1);
    }

    void countChangedForItem(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::countChangedForItem} != (void(D::*)(in)){&D::countChangedForItem})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x185a40))(this, p0);
        else return GJEffectManager::countChangedForItem(p0);
    }

    void countForItem(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::countForItem} != (void(D::*)(in)){&D::countForItem})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x185a10))(this, p0);
        else return GJEffectManager::countForItem(p0);
    }

    static GJEffectManager* create() {
        if ((GJEffectManager*(*)()){&$GJEffectManager::create} != (GJEffectManager*(*)()){&D::create})
            return reinterpret_cast<GJEffectManager*(*)()>(m->getOriginal(getBase()+0x1800f0))();
        else return GJEffectManager::create();
    }

    void createFollowCommand(floa p0, floa p1, floa p2, in p3, in p4, boo p5, in p6) {
        if ((void($GJEffectManager::*)(floa, floa, floa, in, in, boo, in)){&$GJEffectManager::createFollowCommand} != (void(D::*)(floa, floa, floa, in, in, boo, in)){&D::createFollowCommand})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, floa, in, in, boo, in)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
        else return GJEffectManager::createFollowCommand(p0, p1, p2, p3, p4, p5, p6);
    }

    void createMoveCommand(cocos2d::CCPoin p0, in p1, floa p2, in p3, floa p4, boo p5, boo p6, in p7) {
        if ((void($GJEffectManager::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&$GJEffectManager::createMoveCommand} != (void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJEffectManager::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void createPlayerFollowCommand(floa p0, floa p1, in p2, floa p3, floa p4, in p5, in p6) {
        if ((void($GJEffectManager::*)(floa, floa, in, floa, floa, in, in)){&$GJEffectManager::createPlayerFollowCommand} != (void(D::*)(floa, floa, in, floa, floa, in, in)){&D::createPlayerFollowCommand})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, in, floa, floa, in, in)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
        else return GJEffectManager::createPlayerFollowCommand(p0, p1, p2, p3, p4, p5, p6);
    }

    void createRotateCommand(in p0, floa p1, in p2, in p3, in p4, floa p5, boo p6, in p7) {
        if ((void($GJEffectManager::*)(in, floa, in, in, in, floa, boo, in)){&$GJEffectManager::createRotateCommand} != (void(D::*)(in, floa, in, in, in, floa, boo, in)){&D::createRotateCommand})
            return reinterpret_cast<void(*)(decltype(this), in, floa, in, in, in, floa, boo, in)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJEffectManager::createRotateCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void getAllColorActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions} != (void(D::*)()){&D::getAllColorActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180980))(this);
        else return GJEffectManager::getAllColorActions();
    }

    void getAllColorSprites() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites} != (void(D::*)()){&D::getAllColorSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1809e0))(this);
        else return GJEffectManager::getAllColorSprites();
    }

    const cocos2d::_ccColor3B& getColorAction(in p0) {
        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(in)){&$GJEffectManager::getColorAction} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorAction})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180b00))(this, p0);
        else return GJEffectManager::getColorAction(p0);
    }

    const cocos2d::_ccColor3B& getColorSprite(in p0) {
        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(in)){&$GJEffectManager::getColorSprite} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorSprite})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180d00))(this, p0);
        else return GJEffectManager::getColorSprite(p0);
    }

    void getCurrentStateString() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString} != (void(D::*)()){&D::getCurrentStateString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1867e0))(this);
        else return GJEffectManager::getCurrentStateString();
    }

    void getLoadedMoveOffset() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset} != (void(D::*)()){&D::getLoadedMoveOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x184390))(this);
        else return GJEffectManager::getLoadedMoveOffset();
    }

    void getMixedColor(cocos2d::_ccColor3 p0, cocos2d::_ccColor3 p1, floa p2) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&$GJEffectManager::getMixedColor} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::getMixedColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, cocos2d::_ccColor3, floa)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
        else return GJEffectManager::getMixedColor(p0, p1, p2);
    }

    uint8_t getOpacityActionForGroup(in p0) {
        if ((uint8_t($GJEffectManager::*)(in)){&$GJEffectManager::getOpacityActionForGroup} != (uint8_t(D::*)(in)){&D::getOpacityActionForGroup})
            return reinterpret_cast<uint8_t(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
        else return GJEffectManager::getOpacityActionForGroup(p0);
    }

    void getSaveString() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185e90))(this);
        else return GJEffectManager::getSaveString();
    }

    void handleObjectCollision(boo p0, in p1, in p2) {
        if ((void($GJEffectManager::*)(boo, in, in)){&$GJEffectManager::handleObjectCollision} != (void(D::*)(boo, in, in)){&D::handleObjectCollision})
            return reinterpret_cast<void(*)(decltype(this), boo, in, in)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
        else return GJEffectManager::handleObjectCollision(p0, p1, p2);
    }

    void hasActiveDualTouch() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch} != (void(D::*)()){&D::hasActiveDualTouch})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185540))(this);
        else return GJEffectManager::hasActiveDualTouch();
    }

    void hasBeenTriggered(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::hasBeenTriggered} != (void(D::*)(in)){&D::hasBeenTriggered})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
        else return GJEffectManager::hasBeenTriggered(p0);
    }

    void hasPulseEffectForGroupID(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::hasPulseEffectForGroupID} != (void(D::*)(in)){&D::hasPulseEffectForGroupID})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x184f60))(this, p0);
        else return GJEffectManager::hasPulseEffectForGroupID(p0);
    }

    bool init() {
        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x180230))(this);
        else return GJEffectManager::init();
    }

    bool isGroupEnabled(in p0) {
        if ((bool($GJEffectManager::*)(in)){&$GJEffectManager::isGroupEnabled} != (bool(D::*)(in)){&D::isGroupEnabled})
            return reinterpret_cast<bool(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
        else return GJEffectManager::isGroupEnabled(p0);
    }

    void keyForGroupIDColor(in p0, cocos2d::_ccColor3B const p1, boo p2) {
        if ((void($GJEffectManager::*)(in, cocos2d::_ccColor3B const, boo)){&$GJEffectManager::keyForGroupIDColor} != (void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::keyForGroupIDColor})
            return reinterpret_cast<void(*)(decltype(this), in, cocos2d::_ccColor3B const, boo)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
        else return GJEffectManager::keyForGroupIDColor(p0, p1, p2);
    }

    void loadState(std::strin p0) {
        if ((void($GJEffectManager::*)(std::strin)){&$GJEffectManager::loadState} != (void(D::*)(std::strin)){&D::loadState})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x188db0))(this, p0);
        else return GJEffectManager::loadState(p0);
    }

    void objectsCollided(in p0, in p1) {
        if ((void($GJEffectManager::*)(in, in)){&$GJEffectManager::objectsCollided} != (void(D::*)(in, in)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
        else return GJEffectManager::objectsCollided(p0, p1);
    }

    void opacityForIndex(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::opacityForIndex} != (void(D::*)(in)){&D::opacityForIndex})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180c80))(this, p0);
        else return GJEffectManager::opacityForIndex(p0);
    }

    float opacityModForGroup(in p0) {
        if ((float($GJEffectManager::*)(in)){&$GJEffectManager::opacityModForGroup} != (float(D::*)(in)){&D::opacityModForGroup})
            return reinterpret_cast<float(*)(decltype(this), in)>(m->getOriginal(getBase()+0x184740))(this, p0);
        else return GJEffectManager::opacityModForGroup(p0);
    }

    void playerButton(boo p0, boo p1) {
        if ((void($GJEffectManager::*)(boo, boo)){&$GJEffectManager::playerButton} != (void(D::*)(boo, boo)){&D::playerButton})
            return reinterpret_cast<void(*)(decltype(this), boo, boo)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
        else return GJEffectManager::playerButton(p0, p1);
    }

    void playerDied() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::playerDied} != (void(D::*)()){&D::playerDied})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185860))(this);
        else return GJEffectManager::playerDied();
    }

    void postCollisionCheck() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck} != (void(D::*)()){&D::postCollisionCheck})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182720))(this);
        else return GJEffectManager::postCollisionCheck();
    }

    void preCollisionCheck() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck} != (void(D::*)()){&D::preCollisionCheck})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182680))(this);
        else return GJEffectManager::preCollisionCheck();
    }

    void prepareMoveActions(floa p0, boo p1) {
        if ((void($GJEffectManager::*)(floa, boo)){&$GJEffectManager::prepareMoveActions} != (void(D::*)(floa, boo)){&D::prepareMoveActions})
            return reinterpret_cast<void(*)(decltype(this), floa, boo)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
        else return GJEffectManager::prepareMoveActions(p0, p1);
    }

    void processColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processColors} != (void(D::*)()){&D::processColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180e70))(this);
        else return GJEffectManager::processColors();
    }

    void processCopyColorPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions} != (void(D::*)()){&D::processCopyColorPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181530))(this);
        else return GJEffectManager::processCopyColorPulseActions();
    }

    void processInheritedColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors} != (void(D::*)()){&D::processInheritedColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181190))(this);
        else return GJEffectManager::processInheritedColors();
    }

    void processPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions} != (void(D::*)()){&D::processPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181040))(this);
        else return GJEffectManager::processPulseActions();
    }

    void registerCollisionTrigger(in p0, in p1, in p2, boo p3, boo p4, in p5) {
        if ((void($GJEffectManager::*)(in, in, in, boo, boo, in)){&$GJEffectManager::registerCollisionTrigger} != (void(D::*)(in, in, in, boo, boo, in)){&D::registerCollisionTrigger})
            return reinterpret_cast<void(*)(decltype(this), in, in, in, boo, boo, in)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
        else return GJEffectManager::registerCollisionTrigger(p0, p1, p2, p3, p4, p5);
    }

    void removeAllPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions} != (void(D::*)()){&D::removeAllPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1825e0))(this);
        else return GJEffectManager::removeAllPulseActions();
    }

    void removeColorAction(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::removeColorAction} != (void(D::*)(in)){&D::removeColorAction})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x181d60))(this, p0);
        else return GJEffectManager::removeColorAction(p0);
    }

    void reset() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::reset} != (void(D::*)()){&D::reset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180690))(this);
        else return GJEffectManager::reset();
    }

    void resetColorCache() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache} != (void(D::*)()){&D::resetColorCache})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185280))(this);
        else return GJEffectManager::resetColorCache();
    }

    void resetEffects() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetEffects} != (void(D::*)()){&D::resetEffects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1807d0))(this);
        else return GJEffectManager::resetEffects();
    }

    void resetMoveActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions} != (void(D::*)()){&D::resetMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180940))(this);
        else return GJEffectManager::resetMoveActions();
    }

    void resetToggledGroups() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1853f0))(this);
        else return GJEffectManager::resetToggledGroups();
    }

    void resetTriggeredIDs() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs} != (void(D::*)()){&D::resetTriggeredIDs})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182630))(this);
        else return GJEffectManager::resetTriggeredIDs();
    }

    void runCountTrigger(in p0, in p1, boo p2, in p3, boo p4, in p5) {
        if ((void($GJEffectManager::*)(in, in, boo, in, boo, in)){&$GJEffectManager::runCountTrigger} != (void(D::*)(in, in, boo, in, boo, in)){&D::runCountTrigger})
            return reinterpret_cast<void(*)(decltype(this), in, in, boo, in, boo, in)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
        else return GJEffectManager::runCountTrigger(p0, p1, p2, p3, p4, p5);
    }

    void runDeathTrigger(in p0, boo p1, in p2) {
        if ((void($GJEffectManager::*)(in, boo, in)){&$GJEffectManager::runDeathTrigger} != (void(D::*)(in, boo, in)){&D::runDeathTrigger})
            return reinterpret_cast<void(*)(decltype(this), in, boo, in)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
        else return GJEffectManager::runDeathTrigger(p0, p1, p2);
    }

    void runOpacityActionOnGroup(in p0, floa p1, floa p2, in p3) {
        if ((void($GJEffectManager::*)(in, floa, floa, in)){&$GJEffectManager::runOpacityActionOnGroup} != (void(D::*)(in, floa, floa, in)){&D::runOpacityActionOnGroup})
            return reinterpret_cast<void(*)(decltype(this), in, floa, floa, in)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
        else return GJEffectManager::runOpacityActionOnGroup(p0, p1, p2, p3);
    }

    void runPulseEffect(in p0, boo p1, floa p2, floa p3, floa p4, PulseEffectTyp p5, cocos2d::_ccColor3 p6, cocos2d::_ccHSVValu p7, in p8, boo p9, boo p10, boo p11, in p12) {
        if ((void($GJEffectManager::*)(in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)){&$GJEffectManager::runPulseEffect} != (void(D::*)(in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)){&D::runPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
        else return GJEffectManager::runPulseEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    void runTouchTriggerCommand(in p0, boo p1, TouchTriggerTyp p2, boo p3, in p4) {
        if ((void($GJEffectManager::*)(in, boo, TouchTriggerTyp, boo, in)){&$GJEffectManager::runTouchTriggerCommand} != (void(D::*)(in, boo, TouchTriggerTyp, boo, in)){&D::runTouchTriggerCommand})
            return reinterpret_cast<void(*)(decltype(this), in, boo, TouchTriggerTyp, boo, in)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
        else return GJEffectManager::runTouchTriggerCommand(p0, p1, p2, p3, p4);
    }

    void setColorAction(ColorAction p0, in p1) {
        if ((void($GJEffectManager::*)(ColorAction, in)){&$GJEffectManager::setColorAction} != (void(D::*)(ColorAction, in)){&D::setColorAction})
            return reinterpret_cast<void(*)(decltype(this), ColorAction, in)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
        else return GJEffectManager::setColorAction(p0, p1);
    }

    void setFollowing(in p0, in p1, boo p2) {
        if ((void($GJEffectManager::*)(in, in, boo)){&$GJEffectManager::setFollowing} != (void(D::*)(in, in, boo)){&D::setFollowing})
            return reinterpret_cast<void(*)(decltype(this), in, in, boo)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
        else return GJEffectManager::setFollowing(p0, p1, p2);
    }

    void setupFromString(std::strin p0) {
        if ((void($GJEffectManager::*)(std::strin)){&$GJEffectManager::setupFromString} != (void(D::*)(std::strin)){&D::setupFromString})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x186290))(this, p0);
        else return GJEffectManager::setupFromString(p0);
    }

    void shouldBlend(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::shouldBlend} != (void(D::*)(in)){&D::shouldBlend})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x180e40))(this, p0);
        else return GJEffectManager::shouldBlend(p0);
    }

    void spawnGroup(in p0, floa p1, in p2) {
        if ((void($GJEffectManager::*)(in, floa, in)){&$GJEffectManager::spawnGroup} != (void(D::*)(in, floa, in)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), in, floa, in)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
        else return GJEffectManager::spawnGroup(p0, p1, p2);
    }

    void stopActionsForTrigger(EffectGameObject p0) {
        if ((void($GJEffectManager::*)(EffectGameObject)){&$GJEffectManager::stopActionsForTrigger} != (void(D::*)(EffectGameObject)){&D::stopActionsForTrigger})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject)>(m->getOriginal(getBase()+0x183150))(this, p0);
        else return GJEffectManager::stopActionsForTrigger(p0);
    }

    void stopMoveActionsForGroup(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::stopMoveActionsForGroup} != (void(D::*)(in)){&D::stopMoveActionsForGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
        else return GJEffectManager::stopMoveActionsForGroup(p0);
    }

    void storeTriggeredID(in p0) {
        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::storeTriggeredID} != (void(D::*)(in)){&D::storeTriggeredID})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x185380))(this, p0);
        else return GJEffectManager::storeTriggeredID(p0);
    }

    void toggleGroup(in p0, boo p1) {
        if ((void($GJEffectManager::*)(in, boo)){&$GJEffectManager::toggleGroup} != (void(D::*)(in, boo)){&D::toggleGroup})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
        else return GJEffectManager::toggleGroup(p0, p1);
    }

    void traverseInheritanceChain(InheritanceNode p0) {
        if ((void($GJEffectManager::*)(InheritanceNode)){&$GJEffectManager::traverseInheritanceChain} != (void(D::*)(InheritanceNode)){&D::traverseInheritanceChain})
            return reinterpret_cast<void(*)(decltype(this), InheritanceNode)>(m->getOriginal(getBase()+0x181850))(this, p0);
        else return GJEffectManager::traverseInheritanceChain(p0);
    }

    void updateActiveOpacityEffects() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects} != (void(D::*)()){&D::updateActiveOpacityEffects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1847e0))(this);
        else return GJEffectManager::updateActiveOpacityEffects();
    }

    void updateColorAction(ColorAction p0) {
        if ((void($GJEffectManager::*)(ColorAction)){&$GJEffectManager::updateColorAction} != (void(D::*)(ColorAction)){&D::updateColorAction})
            return reinterpret_cast<void(*)(decltype(this), ColorAction)>(m->getOriginal(getBase()+0x184560))(this, p0);
        else return GJEffectManager::updateColorAction(p0);
    }

    void updateColorEffects(floa p0) {
        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateColorEffects} != (void(D::*)(floa)){&D::updateColorEffects})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x181f40))(this, p0);
        else return GJEffectManager::updateColorEffects(p0);
    }

    void updateColors(cocos2d::_ccColor3 p0, cocos2d::_ccColor3 p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccColor3)){&$GJEffectManager::updateColors} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
        else return GJEffectManager::updateColors(p0, p1);
    }

    void updateEffects(floa p0) {
        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateEffects} != (void(D::*)(floa)){&D::updateEffects})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x181df0))(this, p0);
        else return GJEffectManager::updateEffects(p0);
    }

    void updateOpacityAction(OpacityEffectAction p0) {
        if ((void($GJEffectManager::*)(OpacityEffectAction)){&$GJEffectManager::updateOpacityAction} != (void(D::*)(OpacityEffectAction)){&D::updateOpacityAction})
            return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction)>(m->getOriginal(getBase()+0x184780))(this, p0);
        else return GJEffectManager::updateOpacityAction(p0);
    }

    void updateOpacityEffects(floa p0) {
        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateOpacityEffects} != (void(D::*)(floa)){&D::updateOpacityEffects})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
        else return GJEffectManager::updateOpacityEffects(p0);
    }

    void updatePulseEffects(floa p0) {
        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updatePulseEffects} != (void(D::*)(floa)){&D::updatePulseEffects})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x182130))(this, p0);
        else return GJEffectManager::updatePulseEffects(p0);
    }

    void updateSpawnTriggers(floa p0) {
        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateSpawnTriggers} != (void(D::*)(floa)){&D::updateSpawnTriggers})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x182510))(this, p0);
        else return GJEffectManager::updateSpawnTriggers(p0);
    }

    void wasFollowing(in p0, in p1) {
        if ((void($GJEffectManager::*)(in, in)){&$GJEffectManager::wasFollowing} != (void(D::*)(in, in)){&D::wasFollowing})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
        else return GJEffectManager::wasFollowing(p0, p1);
    }

    void wouldCreateLoop(InheritanceNode p0, in p1) {
        if ((void($GJEffectManager::*)(InheritanceNode, in)){&$GJEffectManager::wouldCreateLoop} != (void(D::*)(InheritanceNode, in)){&D::wouldCreateLoop})
            return reinterpret_cast<void(*)(decltype(this), InheritanceNode, in)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
        else return GJEffectManager::wouldCreateLoop(p0, p1);
    }

     ~GJEffectManager() {
        if ((($GJEffectManager::*)()){&$GJEffectManager::~GJEffectManager} != ((D::*)()){&D::~GJEffectManager})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x17fe00))(this);
        else return GJEffectManager::~GJEffectManager();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::activeColorForIndex} != (void(D::*)(in)){&D::activeColorForIndex})
            m->registerHook(getBase()+0x180cb0, extract((void(D::*)(in)){&D::activeColorForIndex}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::activeOpacityForIndex} != (void(D::*)(in)){&D::activeOpacityForIndex})
            m->registerHook(getBase()+0x180e10, extract((void(D::*)(in)){&D::activeOpacityForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::CCArray)){&$GJEffectManager::addAllInheritedColorActions} != (void(D::*)(cocos2d::CCArray)){&D::addAllInheritedColorActions})
            m->registerHook(getBase()+0x1817a0, extract((void(D::*)(cocos2d::CCArray)){&D::addAllInheritedColorActions}));

        if ((void($GJEffectManager::*)(PulseEffectAction)){&$GJEffectManager::addGroupPulseEffect} != (void(D::*)(PulseEffectAction)){&D::addGroupPulseEffect})
            m->registerHook(getBase()+0x184c10, extract((void(D::*)(PulseEffectAction)){&D::addGroupPulseEffect}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors} != (void(D::*)()){&D::calculateBaseActiveColors})
            m->registerHook(getBase()+0x180f70, extract((void(D::*)()){&D::calculateBaseActiveColors}));

        if ((void($GJEffectManager::*)(in, ColorAction)){&$GJEffectManager::calculateInheritedColor} != (void(D::*)(in, ColorAction)){&D::calculateInheritedColor})
            m->registerHook(getBase()+0x1818f0, extract((void(D::*)(in, ColorAction)){&D::calculateInheritedColor}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3)){&$GJEffectManager::calculateLightBGColor} != (void(D::*)(cocos2d::_ccColor3)){&D::calculateLightBGColor})
            m->registerHook(getBase()+0x185b90, extract((void(D::*)(cocos2d::_ccColor3)){&D::calculateLightBGColor}));

        if ((void($GJEffectManager::*)(ColorAction)){&$GJEffectManager::colorActionChanged} != (void(D::*)(ColorAction)){&D::colorActionChanged})
            m->registerHook(getBase()+0x181dc0, extract((void(D::*)(ColorAction)){&D::colorActionChanged}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::colorExists} != (void(D::*)(in)){&D::colorExists})
            m->registerHook(getBase()+0x181da0, extract((void(D::*)(in)){&D::colorExists}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccHSVValu)){&$GJEffectManager::colorForEffect} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccHSVValu)){&D::colorForEffect})
            m->registerHook(getBase()+0x182650, extract((void(D::*)(cocos2d::_ccColor3, cocos2d::_ccHSVValu)){&D::colorForEffect}));

        if ((void($GJEffectManager::*)(in, cocos2d::_ccColor3B const, boo)){&$GJEffectManager::colorForGroupID} != (void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::colorForGroupID})
            m->registerHook(getBase()+0x184f90, extract((void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::colorForGroupID}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::colorForIndex} != (void(D::*)(in)){&D::colorForIndex})
            m->registerHook(getBase()+0x180ad0, extract((void(D::*)(in)){&D::colorForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B const, PulseEffectAction)){&$GJEffectManager::colorForPulseEffect} != (void(D::*)(cocos2d::_ccColor3B const, PulseEffectAction)){&D::colorForPulseEffect})
            m->registerHook(getBase()+0x181bf0, extract((void(D::*)(cocos2d::_ccColor3B const, PulseEffectAction)){&D::colorForPulseEffect}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::countChangedForItem} != (void(D::*)(in)){&D::countChangedForItem})
            m->registerHook(getBase()+0x185a40, extract((void(D::*)(in)){&D::countChangedForItem}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::countForItem} != (void(D::*)(in)){&D::countForItem})
            m->registerHook(getBase()+0x185a10, extract((void(D::*)(in)){&D::countForItem}));

        if ((GJEffectManager*(*)()){&$GJEffectManager::create} != (GJEffectManager*(*)()){&D::create})
            m->registerHook(getBase()+0x1800f0, (GJEffectManager*(*)()){&D::create});

        if ((void($GJEffectManager::*)(floa, floa, floa, in, in, boo, in)){&$GJEffectManager::createFollowCommand} != (void(D::*)(floa, floa, floa, in, in, boo, in)){&D::createFollowCommand})
            m->registerHook(getBase()+0x182ed0, extract((void(D::*)(floa, floa, floa, in, in, boo, in)){&D::createFollowCommand}));

        if ((void($GJEffectManager::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&$GJEffectManager::createMoveCommand} != (void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand})
            m->registerHook(getBase()+0x182cc0, extract((void(D::*)(cocos2d::CCPoin, in, floa, in, floa, boo, boo, in)){&D::createMoveCommand}));

        if ((void($GJEffectManager::*)(floa, floa, in, floa, floa, in, in)){&$GJEffectManager::createPlayerFollowCommand} != (void(D::*)(floa, floa, in, floa, floa, in, in)){&D::createPlayerFollowCommand})
            m->registerHook(getBase()+0x182fe0, extract((void(D::*)(floa, floa, in, floa, floa, in, in)){&D::createPlayerFollowCommand}));

        if ((void($GJEffectManager::*)(in, floa, in, in, in, floa, boo, in)){&$GJEffectManager::createRotateCommand} != (void(D::*)(in, floa, in, in, in, floa, boo, in)){&D::createRotateCommand})
            m->registerHook(getBase()+0x182df0, extract((void(D::*)(in, floa, in, in, in, floa, boo, in)){&D::createRotateCommand}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions} != (void(D::*)()){&D::getAllColorActions})
            m->registerHook(getBase()+0x180980, extract((void(D::*)()){&D::getAllColorActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites} != (void(D::*)()){&D::getAllColorSprites})
            m->registerHook(getBase()+0x1809e0, extract((void(D::*)()){&D::getAllColorSprites}));

        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(in)){&$GJEffectManager::getColorAction} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorAction})
            m->registerHook(getBase()+0x180b00, extract((const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorAction}));

        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(in)){&$GJEffectManager::getColorSprite} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorSprite})
            m->registerHook(getBase()+0x180d00, extract((const cocos2d::_ccColor3B&(D::*)(in)){&D::getColorSprite}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString} != (void(D::*)()){&D::getCurrentStateString})
            m->registerHook(getBase()+0x1867e0, extract((void(D::*)()){&D::getCurrentStateString}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset} != (void(D::*)()){&D::getLoadedMoveOffset})
            m->registerHook(getBase()+0x184390, extract((void(D::*)()){&D::getLoadedMoveOffset}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&$GJEffectManager::getMixedColor} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::getMixedColor})
            m->registerHook(getBase()+0x185d30, extract((void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::getMixedColor}));

        if ((uint8_t($GJEffectManager::*)(in)){&$GJEffectManager::getOpacityActionForGroup} != (uint8_t(D::*)(in)){&D::getOpacityActionForGroup})
            m->registerHook(getBase()+0x1845b0, extract((uint8_t(D::*)(in)){&D::getOpacityActionForGroup}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x185e90, extract((void(D::*)()){&D::getSaveString}));

        if ((void($GJEffectManager::*)(boo, in, in)){&$GJEffectManager::handleObjectCollision} != (void(D::*)(boo, in, in)){&D::handleObjectCollision})
            m->registerHook(getBase()+0x1828f0, extract((void(D::*)(boo, in, in)){&D::handleObjectCollision}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch} != (void(D::*)()){&D::hasActiveDualTouch})
            m->registerHook(getBase()+0x185540, extract((void(D::*)()){&D::hasActiveDualTouch}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::hasBeenTriggered} != (void(D::*)(in)){&D::hasBeenTriggered})
            m->registerHook(getBase()+0x1853b0, extract((void(D::*)(in)){&D::hasBeenTriggered}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::hasPulseEffectForGroupID} != (void(D::*)(in)){&D::hasPulseEffectForGroupID})
            m->registerHook(getBase()+0x184f60, extract((void(D::*)(in)){&D::hasPulseEffectForGroupID}));

        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x180230, extract((bool(D::*)()){&D::init}));

        if ((bool($GJEffectManager::*)(in)){&$GJEffectManager::isGroupEnabled} != (bool(D::*)(in)){&D::isGroupEnabled})
            m->registerHook(getBase()+0x1853d0, extract((bool(D::*)(in)){&D::isGroupEnabled}));

        if ((void($GJEffectManager::*)(in, cocos2d::_ccColor3B const, boo)){&$GJEffectManager::keyForGroupIDColor} != (void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::keyForGroupIDColor})
            m->registerHook(getBase()+0x184c90, extract((void(D::*)(in, cocos2d::_ccColor3B const, boo)){&D::keyForGroupIDColor}));

        if ((void($GJEffectManager::*)(std::strin)){&$GJEffectManager::loadState} != (void(D::*)(std::strin)){&D::loadState})
            m->registerHook(getBase()+0x188db0, extract((void(D::*)(std::strin)){&D::loadState}));

        if ((void($GJEffectManager::*)(in, in)){&$GJEffectManager::objectsCollided} != (void(D::*)(in, in)){&D::objectsCollided})
            m->registerHook(getBase()+0x182a00, extract((void(D::*)(in, in)){&D::objectsCollided}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::opacityForIndex} != (void(D::*)(in)){&D::opacityForIndex})
            m->registerHook(getBase()+0x180c80, extract((void(D::*)(in)){&D::opacityForIndex}));

        if ((float($GJEffectManager::*)(in)){&$GJEffectManager::opacityModForGroup} != (float(D::*)(in)){&D::opacityModForGroup})
            m->registerHook(getBase()+0x184740, extract((float(D::*)(in)){&D::opacityModForGroup}));

        if ((void($GJEffectManager::*)(boo, boo)){&$GJEffectManager::playerButton} != (void(D::*)(boo, boo)){&D::playerButton})
            m->registerHook(getBase()+0x1855a0, extract((void(D::*)(boo, boo)){&D::playerButton}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::playerDied} != (void(D::*)()){&D::playerDied})
            m->registerHook(getBase()+0x185860, extract((void(D::*)()){&D::playerDied}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck} != (void(D::*)()){&D::postCollisionCheck})
            m->registerHook(getBase()+0x182720, extract((void(D::*)()){&D::postCollisionCheck}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck} != (void(D::*)()){&D::preCollisionCheck})
            m->registerHook(getBase()+0x182680, extract((void(D::*)()){&D::preCollisionCheck}));

        if ((void($GJEffectManager::*)(floa, boo)){&$GJEffectManager::prepareMoveActions} != (void(D::*)(floa, boo)){&D::prepareMoveActions})
            m->registerHook(getBase()+0x183660, extract((void(D::*)(floa, boo)){&D::prepareMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processColors} != (void(D::*)()){&D::processColors})
            m->registerHook(getBase()+0x180e70, extract((void(D::*)()){&D::processColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions} != (void(D::*)()){&D::processCopyColorPulseActions})
            m->registerHook(getBase()+0x181530, extract((void(D::*)()){&D::processCopyColorPulseActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors} != (void(D::*)()){&D::processInheritedColors})
            m->registerHook(getBase()+0x181190, extract((void(D::*)()){&D::processInheritedColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions} != (void(D::*)()){&D::processPulseActions})
            m->registerHook(getBase()+0x181040, extract((void(D::*)()){&D::processPulseActions}));

        if ((void($GJEffectManager::*)(in, in, in, boo, boo, in)){&$GJEffectManager::registerCollisionTrigger} != (void(D::*)(in, in, in, boo, boo, in)){&D::registerCollisionTrigger})
            m->registerHook(getBase()+0x182b70, extract((void(D::*)(in, in, in, boo, boo, in)){&D::registerCollisionTrigger}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions} != (void(D::*)()){&D::removeAllPulseActions})
            m->registerHook(getBase()+0x1825e0, extract((void(D::*)()){&D::removeAllPulseActions}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::removeColorAction} != (void(D::*)(in)){&D::removeColorAction})
            m->registerHook(getBase()+0x181d60, extract((void(D::*)(in)){&D::removeColorAction}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x180690, extract((void(D::*)()){&D::reset}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache} != (void(D::*)()){&D::resetColorCache})
            m->registerHook(getBase()+0x185280, extract((void(D::*)()){&D::resetColorCache}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetEffects} != (void(D::*)()){&D::resetEffects})
            m->registerHook(getBase()+0x1807d0, extract((void(D::*)()){&D::resetEffects}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions} != (void(D::*)()){&D::resetMoveActions})
            m->registerHook(getBase()+0x180940, extract((void(D::*)()){&D::resetMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x1853f0, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs} != (void(D::*)()){&D::resetTriggeredIDs})
            m->registerHook(getBase()+0x182630, extract((void(D::*)()){&D::resetTriggeredIDs}));

        if ((void($GJEffectManager::*)(in, in, boo, in, boo, in)){&$GJEffectManager::runCountTrigger} != (void(D::*)(in, in, boo, in, boo, in)){&D::runCountTrigger})
            m->registerHook(getBase()+0x1858d0, extract((void(D::*)(in, in, boo, in, boo, in)){&D::runCountTrigger}));

        if ((void($GJEffectManager::*)(in, boo, in)){&$GJEffectManager::runDeathTrigger} != (void(D::*)(in, boo, in)){&D::runDeathTrigger})
            m->registerHook(getBase()+0x1857a0, extract((void(D::*)(in, boo, in)){&D::runDeathTrigger}));

        if ((void($GJEffectManager::*)(in, floa, floa, in)){&$GJEffectManager::runOpacityActionOnGroup} != (void(D::*)(in, floa, floa, in)){&D::runOpacityActionOnGroup})
            m->registerHook(getBase()+0x1845d0, extract((void(D::*)(in, floa, floa, in)){&D::runOpacityActionOnGroup}));

        if ((void($GJEffectManager::*)(in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)){&$GJEffectManager::runPulseEffect} != (void(D::*)(in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)){&D::runPulseEffect})
            m->registerHook(getBase()+0x184890, extract((void(D::*)(in, boo, floa, floa, floa, PulseEffectTyp, cocos2d::_ccColor3, cocos2d::_ccHSVValu, in, boo, boo, boo, in)){&D::runPulseEffect}));

        if ((void($GJEffectManager::*)(in, boo, TouchTriggerTyp, boo, in)){&$GJEffectManager::runTouchTriggerCommand} != (void(D::*)(in, boo, TouchTriggerTyp, boo, in)){&D::runTouchTriggerCommand})
            m->registerHook(getBase()+0x185460, extract((void(D::*)(in, boo, TouchTriggerTyp, boo, in)){&D::runTouchTriggerCommand}));

        if ((void($GJEffectManager::*)(ColorAction, in)){&$GJEffectManager::setColorAction} != (void(D::*)(ColorAction, in)){&D::setColorAction})
            m->registerHook(getBase()+0x181d00, extract((void(D::*)(ColorAction, in)){&D::setColorAction}));

        if ((void($GJEffectManager::*)(in, in, boo)){&$GJEffectManager::setFollowing} != (void(D::*)(in, in, boo)){&D::setFollowing})
            m->registerHook(getBase()+0x185e00, extract((void(D::*)(in, in, boo)){&D::setFollowing}));

        if ((void($GJEffectManager::*)(std::strin)){&$GJEffectManager::setupFromString} != (void(D::*)(std::strin)){&D::setupFromString})
            m->registerHook(getBase()+0x186290, extract((void(D::*)(std::strin)){&D::setupFromString}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::shouldBlend} != (void(D::*)(in)){&D::shouldBlend})
            m->registerHook(getBase()+0x180e40, extract((void(D::*)(in)){&D::shouldBlend}));

        if ((void($GJEffectManager::*)(in, floa, in)){&$GJEffectManager::spawnGroup} != (void(D::*)(in, floa, in)){&D::spawnGroup})
            m->registerHook(getBase()+0x1852a0, extract((void(D::*)(in, floa, in)){&D::spawnGroup}));

        if ((void($GJEffectManager::*)(EffectGameObject)){&$GJEffectManager::stopActionsForTrigger} != (void(D::*)(EffectGameObject)){&D::stopActionsForTrigger})
            m->registerHook(getBase()+0x183150, extract((void(D::*)(EffectGameObject)){&D::stopActionsForTrigger}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::stopMoveActionsForGroup} != (void(D::*)(in)){&D::stopMoveActionsForGroup})
            m->registerHook(getBase()+0x1830e0, extract((void(D::*)(in)){&D::stopMoveActionsForGroup}));

        if ((void($GJEffectManager::*)(in)){&$GJEffectManager::storeTriggeredID} != (void(D::*)(in)){&D::storeTriggeredID})
            m->registerHook(getBase()+0x185380, extract((void(D::*)(in)){&D::storeTriggeredID}));

        if ((void($GJEffectManager::*)(in, boo)){&$GJEffectManager::toggleGroup} != (void(D::*)(in, boo)){&D::toggleGroup})
            m->registerHook(getBase()+0x182c80, extract((void(D::*)(in, boo)){&D::toggleGroup}));

        if ((void($GJEffectManager::*)(InheritanceNode)){&$GJEffectManager::traverseInheritanceChain} != (void(D::*)(InheritanceNode)){&D::traverseInheritanceChain})
            m->registerHook(getBase()+0x181850, extract((void(D::*)(InheritanceNode)){&D::traverseInheritanceChain}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects} != (void(D::*)()){&D::updateActiveOpacityEffects})
            m->registerHook(getBase()+0x1847e0, extract((void(D::*)()){&D::updateActiveOpacityEffects}));

        if ((void($GJEffectManager::*)(ColorAction)){&$GJEffectManager::updateColorAction} != (void(D::*)(ColorAction)){&D::updateColorAction})
            m->registerHook(getBase()+0x184560, extract((void(D::*)(ColorAction)){&D::updateColorAction}));

        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateColorEffects} != (void(D::*)(floa)){&D::updateColorEffects})
            m->registerHook(getBase()+0x181f40, extract((void(D::*)(floa)){&D::updateColorEffects}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3, cocos2d::_ccColor3)){&$GJEffectManager::updateColors} != (void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::updateColors})
            m->registerHook(getBase()+0x180a40, extract((void(D::*)(cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::updateColors}));

        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateEffects} != (void(D::*)(floa)){&D::updateEffects})
            m->registerHook(getBase()+0x181df0, extract((void(D::*)(floa)){&D::updateEffects}));

        if ((void($GJEffectManager::*)(OpacityEffectAction)){&$GJEffectManager::updateOpacityAction} != (void(D::*)(OpacityEffectAction)){&D::updateOpacityAction})
            m->registerHook(getBase()+0x184780, extract((void(D::*)(OpacityEffectAction)){&D::updateOpacityAction}));

        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateOpacityEffects} != (void(D::*)(floa)){&D::updateOpacityEffects})
            m->registerHook(getBase()+0x1823e0, extract((void(D::*)(floa)){&D::updateOpacityEffects}));

        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updatePulseEffects} != (void(D::*)(floa)){&D::updatePulseEffects})
            m->registerHook(getBase()+0x182130, extract((void(D::*)(floa)){&D::updatePulseEffects}));

        if ((void($GJEffectManager::*)(floa)){&$GJEffectManager::updateSpawnTriggers} != (void(D::*)(floa)){&D::updateSpawnTriggers})
            m->registerHook(getBase()+0x182510, extract((void(D::*)(floa)){&D::updateSpawnTriggers}));

        if ((void($GJEffectManager::*)(in, in)){&$GJEffectManager::wasFollowing} != (void(D::*)(in, in)){&D::wasFollowing})
            m->registerHook(getBase()+0x185e60, extract((void(D::*)(in, in)){&D::wasFollowing}));

        if ((void($GJEffectManager::*)(InheritanceNode, in)){&$GJEffectManager::wouldCreateLoop} != (void(D::*)(InheritanceNode, in)){&D::wouldCreateLoop})
            m->registerHook(getBase()+0x181820, extract((void(D::*)(InheritanceNode, in)){&D::wouldCreateLoop}));

        if ((($GJEffectManager::*)()){&$GJEffectManager::~GJEffectManager} != ((D::*)()){&D::~GJEffectManager})
            m->registerHook(getBase()+0x17fe00, extract(((D::*)()){&D::~GJEffectManager}));
    }
};


template<class D>
class $GJFollowCommandLayer : public GJFollowCommandLayer, public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJFollowCommandLayer() {}
    typedef GJFollowCommandLayer* __thistype;

    static GJFollowCommandLayer* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJFollowCommandLayer::create} != (GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x16a550))(p0, p1);
        else return GJFollowCommandLayer::create(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject p0) {
        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject)){&$GJFollowCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x16c8f0))(this, p0);
        else return GJFollowCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject p0) {
        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject)){&$GJFollowCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x16c9e0))(this, p0);
        else return GJFollowCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x16d480))(this, p0);
        else return GJFollowCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16cfe0))(this);
        else return GJFollowCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16d1c0))(this);
        else return GJFollowCommandLayer::updateTargetGroupID2();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJFollowCommandLayer::create} != (GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x16a550, (GJFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject)){&$GJFollowCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x16c8f0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID}));

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject)){&$GJFollowCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x16c9e0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x16d480, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x16cfe0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x16d1c0, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJGameLevel : public GJGameLevel, public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJGameLevel() {}
    typedef GJGameLevel* __thistype;

    static GJGameLevel* create() {
        if ((GJGameLevel*(*)()){&$GJGameLevel::create} != (GJGameLevel*(*)()){&D::create})
            return reinterpret_cast<GJGameLevel*(*)()>(m->getOriginal(getBase()+0x2b83e0))();
        else return GJGameLevel::create();
    }

    void getAudioFileName() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName} != (void(D::*)()){&D::getAudioFileName})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2dbe70))(this);
        else return GJGameLevel::getAudioFileName();
    }

    void getCoinKey(in p0) {
        if ((void($GJGameLevel::*)(in)){&$GJGameLevel::getCoinKey} != (void(D::*)(in)){&D::getCoinKey})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
        else return GJGameLevel::getCoinKey(p0);
    }

    void getLengthKey(in p0) {
        if ((void($GJGameLevel::*)(in)){&$GJGameLevel::getLengthKey} != (void(D::*)(in)){&D::getLengthKey})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x2dbba0))(this, p0);
        else return GJGameLevel::getLengthKey(p0);
    }

    void getNormalPercent() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent} != (void(D::*)()){&D::getNormalPercent})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8b20))(this);
        else return GJGameLevel::getNormalPercent();
    }

    void levelWasAltered() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered} != (void(D::*)()){&D::levelWasAltered})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2db530))(this);
        else return GJGameLevel::levelWasAltered();
    }

    void savePercentage(in p0, boo p1, in p2, in p3, boo p4) {
        if ((void($GJGameLevel::*)(in, boo, in, in, boo)){&$GJGameLevel::savePercentage} != (void(D::*)(in, boo, in, in, boo)){&D::savePercentage})
            return reinterpret_cast<void(*)(decltype(this), in, boo, in, in, boo)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
        else return GJGameLevel::savePercentage(p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJGameLevel*(*)()){&$GJGameLevel::create} != (GJGameLevel*(*)()){&D::create})
            m->registerHook(getBase()+0x2b83e0, (GJGameLevel*(*)()){&D::create});

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName} != (void(D::*)()){&D::getAudioFileName})
            m->registerHook(getBase()+0x2dbe70, extract((void(D::*)()){&D::getAudioFileName}));

        if ((void($GJGameLevel::*)(in)){&$GJGameLevel::getCoinKey} != (void(D::*)(in)){&D::getCoinKey})
            m->registerHook(getBase()+0x2ce360, extract((void(D::*)(in)){&D::getCoinKey}));

        if ((void($GJGameLevel::*)(in)){&$GJGameLevel::getLengthKey} != (void(D::*)(in)){&D::getLengthKey})
            m->registerHook(getBase()+0x2dbba0, extract((void(D::*)(in)){&D::getLengthKey}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent} != (void(D::*)()){&D::getNormalPercent})
            m->registerHook(getBase()+0x2b8b20, extract((void(D::*)()){&D::getNormalPercent}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered} != (void(D::*)()){&D::levelWasAltered})
            m->registerHook(getBase()+0x2db530, extract((void(D::*)()){&D::levelWasAltered}));

        if ((void($GJGameLevel::*)(in, boo, in, in, boo)){&$GJGameLevel::savePercentage} != (void(D::*)(in, boo, in, in, boo)){&D::savePercentage})
            m->registerHook(getBase()+0x2db700, extract((void(D::*)(in, boo, in, in, boo)){&D::savePercentage}));
    }
};


template<class D>
class $GJGroundLayer : public GJGroundLayer, public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJGroundLayer() {}
    typedef GJGroundLayer* __thistype;

    static GJGroundLayer* create(in p0, in p1) {
        if ((GJGroundLayer*(*)(in, in)){&$GJGroundLayer::create} != (GJGroundLayer*(*)(in, in)){&D::create})
            return reinterpret_cast<GJGroundLayer*(*)(in, in)>(m->getOriginal(getBase()+0x355c00))(p0, p1);
        else return GJGroundLayer::create(p0, p1);
    }

    void deactivateGround() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround} != (void(D::*)()){&D::deactivateGround})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356a40))(this);
        else return GJGroundLayer::deactivateGround();
    }

    void getGroundY() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY} != (void(D::*)()){&D::getGroundY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356ac0))(this);
        else return GJGroundLayer::getGroundY();
    }

    void updateGround01Color(cocos2d::_ccColor3 p0) {
        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3)){&$GJGroundLayer::updateGround01Color} != (void(D::*)(cocos2d::_ccColor3)){&D::updateGround01Color})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x356640))(this, p0);
        else return GJGroundLayer::updateGround01Color(p0);
    }

    void updateGround02Color(cocos2d::_ccColor3 p0) {
        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3)){&$GJGroundLayer::updateGround02Color} != (void(D::*)(cocos2d::_ccColor3)){&D::updateGround02Color})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x356710))(this, p0);
        else return GJGroundLayer::updateGround02Color(p0);
    }

    void updateGroundPos(cocos2d::CCPoin p0) {
        if ((void($GJGroundLayer::*)(cocos2d::CCPoin)){&$GJGroundLayer::updateGroundPos} != (void(D::*)(cocos2d::CCPoin)){&D::updateGroundPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
        else return GJGroundLayer::updateGroundPos(p0);
    }

    void updateGroundWidth() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356790))(this);
        else return GJGroundLayer::updateGroundWidth();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJGroundLayer*(*)(in, in)){&$GJGroundLayer::create} != (GJGroundLayer*(*)(in, in)){&D::create})
            m->registerHook(getBase()+0x355c00, (GJGroundLayer*(*)(in, in)){&D::create});

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround} != (void(D::*)()){&D::deactivateGround})
            m->registerHook(getBase()+0x356a40, extract((void(D::*)()){&D::deactivateGround}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY} != (void(D::*)()){&D::getGroundY})
            m->registerHook(getBase()+0x356ac0, extract((void(D::*)()){&D::getGroundY}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3)){&$GJGroundLayer::updateGround01Color} != (void(D::*)(cocos2d::_ccColor3)){&D::updateGround01Color})
            m->registerHook(getBase()+0x356640, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateGround01Color}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3)){&$GJGroundLayer::updateGround02Color} != (void(D::*)(cocos2d::_ccColor3)){&D::updateGround02Color})
            m->registerHook(getBase()+0x356710, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateGround02Color}));

        if ((void($GJGroundLayer::*)(cocos2d::CCPoin)){&$GJGroundLayer::updateGroundPos} != (void(D::*)(cocos2d::CCPoin)){&D::updateGroundPos})
            m->registerHook(getBase()+0x3566c0, extract((void(D::*)(cocos2d::CCPoin)){&D::updateGroundPos}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x356790, extract((void(D::*)()){&D::updateGroundWidth}));
    }
};


template<class D>
class $GJMoveCommandLayer : public GJMoveCommandLayer, public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJMoveCommandLayer() {}
    typedef GJMoveCommandLayer* __thistype;

    static GJMoveCommandLayer* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJMoveCommandLayer::create} != (GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x36f8a0))(p0, p1);
        else return GJMoveCommandLayer::create(p0, p1);
    }

    bool init(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((bool($GJMoveCommandLayer::*)(EffectGameObject, cocos2d::CCArray)){&$GJMoveCommandLayer::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
        else return GJMoveCommandLayer::init(p0, p1);
    }

    void keyBackClicked() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374970))(this);
        else return GJMoveCommandLayer::keyBackClicked();
    }

    void onUpdateGroupID(cocos2d::CCObject p0) {
        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject)){&$GJMoveCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x373350))(this, p0);
        else return GJMoveCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject p0) {
        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject)){&$GJMoveCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
        else return GJMoveCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x374470))(this, p0);
        else return GJMoveCommandLayer::textChanged(p0);
    }

    void textInputClosed(CCTextInputNode p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x374430))(this, p0);
        else return GJMoveCommandLayer::textInputClosed(p0);
    }

    void textInputReturn(CCTextInputNode p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x374c10))(this, p0);
        else return GJMoveCommandLayer::textInputReturn(p0);
    }

    void textInputShouldOffset(CCTextInputNode p0, floa p1) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode, floa)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode, floa)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode, floa)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
        else return GJMoveCommandLayer::textInputShouldOffset(p0, p1);
    }

    void updateEditorLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374110))(this);
        else return GJMoveCommandLayer::updateEditorLabel();
    }

    void updateMoveTargetElements() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements} != (void(D::*)()){&D::updateMoveTargetElements})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373ac0))(this);
        else return GJMoveCommandLayer::updateMoveTargetElements();
    }

    void updateTargetGroupID() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374050))(this);
        else return GJMoveCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374230))(this);
        else return GJMoveCommandLayer::updateTargetGroupID2();
    }

    void updateTextInputLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373680))(this);
        else return GJMoveCommandLayer::updateTextInputLabel();
    }

    void updateTextInputLabel2() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2} != (void(D::*)()){&D::updateTextInputLabel2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373760))(this);
        else return GJMoveCommandLayer::updateTextInputLabel2();
    }

    void updateValueXLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel} != (void(D::*)()){&D::updateValueXLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373840))(this);
        else return GJMoveCommandLayer::updateValueXLabel();
    }

    void updateValueYLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel} != (void(D::*)()){&D::updateValueYLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373950))(this);
        else return GJMoveCommandLayer::updateValueYLabel();
    }

    void valuePopupClosed(ConfigureValuePopup p0, floa p1) {
        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup, floa)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup, floa)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup, floa)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
        else return GJMoveCommandLayer::valuePopupClosed(p0, p1);
    }

     ~GJMoveCommandLayer() {
        if ((($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::~GJMoveCommandLayer} != ((D::*)()){&D::~GJMoveCommandLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x36f6b0))(this);
        else return GJMoveCommandLayer::~GJMoveCommandLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJMoveCommandLayer::create} != (GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x36f8a0, (GJMoveCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((bool($GJMoveCommandLayer::*)(EffectGameObject, cocos2d::CCArray)){&$GJMoveCommandLayer::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            m->registerHook(getBase()+0x36fac0, extract((bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x374970, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject)){&$GJMoveCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x373350, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject)){&$GJMoveCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x3734c0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x374470, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode)){&D::textInputClosed})
            m->registerHook(getBase()+0x374430, extract((void(D::*)(CCTextInputNode)){&D::textInputClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode)){&D::textInputReturn})
            m->registerHook(getBase()+0x374c10, extract((void(D::*)(CCTextInputNode)){&D::textInputReturn}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode, floa)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode, floa)){&D::textInputShouldOffset})
            m->registerHook(getBase()+0x374b50, extract((void(D::*)(CCTextInputNode, floa)){&D::textInputShouldOffset}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x374110, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements} != (void(D::*)()){&D::updateMoveTargetElements})
            m->registerHook(getBase()+0x373ac0, extract((void(D::*)()){&D::updateMoveTargetElements}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x374050, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x374230, extract((void(D::*)()){&D::updateTargetGroupID2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x373680, extract((void(D::*)()){&D::updateTextInputLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2} != (void(D::*)()){&D::updateTextInputLabel2})
            m->registerHook(getBase()+0x373760, extract((void(D::*)()){&D::updateTextInputLabel2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel} != (void(D::*)()){&D::updateValueXLabel})
            m->registerHook(getBase()+0x373840, extract((void(D::*)()){&D::updateValueXLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel} != (void(D::*)()){&D::updateValueYLabel})
            m->registerHook(getBase()+0x373950, extract((void(D::*)()){&D::updateValueYLabel}));

        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup, floa)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup, floa)){&D::valuePopupClosed})
            m->registerHook(getBase()+0x373c20, extract((void(D::*)(ConfigureValuePopup, floa)){&D::valuePopupClosed}));

        if ((($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::~GJMoveCommandLayer} != ((D::*)()){&D::~GJMoveCommandLayer})
            m->registerHook(getBase()+0x36f6b0, extract(((D::*)()){&D::~GJMoveCommandLayer}));
    }
};


template<class D>
class $GJPFollowCommandLayer : public GJPFollowCommandLayer, public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJPFollowCommandLayer() {}
    typedef GJPFollowCommandLayer* __thistype;

    static GJPFollowCommandLayer* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJPFollowCommandLayer::create} != (GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1aea20))(p0, p1);
        else return GJPFollowCommandLayer::create(p0, p1);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x1b1dc0))(this, p0);
        else return GJPFollowCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1b1a60))(this);
        else return GJPFollowCommandLayer::updateTargetGroupID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJPFollowCommandLayer::create} != (GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1aea20, (GJPFollowCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x1b1dc0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x1b1a60, extract((void(D::*)()){&D::updateTargetGroupID}));
    }
};


template<class D>
class $GJRobotSprite : public GJRobotSprite, public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJRobotSprite() {}
    typedef GJRobotSprite* __thistype;

    static GJRobotSprite* create() {
        if ((GJRobotSprite*(*)()){&$GJRobotSprite::create} != (GJRobotSprite*(*)()){&D::create})
            return reinterpret_cast<GJRobotSprite*(*)()>(m->getOriginal(getBase()+0x34ac00))();
        else return GJRobotSprite::create();
    }

    void updateColor02(cocos2d::_ccColor3 p0) {
        if ((void($GJRobotSprite::*)(cocos2d::_ccColor3)){&$GJRobotSprite::updateColor02} != (void(D::*)(cocos2d::_ccColor3)){&D::updateColor02})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
        else return GJRobotSprite::updateColor02(p0);
    }

    void updateFrame(in p0) {
        if ((void($GJRobotSprite::*)(in)){&$GJRobotSprite::updateFrame} != (void(D::*)(in)){&D::updateFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
        else return GJRobotSprite::updateFrame(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJRobotSprite*(*)()){&$GJRobotSprite::create} != (GJRobotSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34ac00, (GJRobotSprite*(*)()){&D::create});

        if ((void($GJRobotSprite::*)(cocos2d::_ccColor3)){&$GJRobotSprite::updateColor02} != (void(D::*)(cocos2d::_ccColor3)){&D::updateColor02})
            m->registerHook(getBase()+0x34bbd0, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateColor02}));

        if ((void($GJRobotSprite::*)(in)){&$GJRobotSprite::updateFrame} != (void(D::*)(in)){&D::updateFrame})
            m->registerHook(getBase()+0x34bdd0, extract((void(D::*)(in)){&D::updateFrame}));
    }
};


template<class D>
class $GJRotateCommandLayer : public GJRotateCommandLayer, public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJRotateCommandLayer() {}
    typedef GJRotateCommandLayer* __thistype;

    static GJRotateCommandLayer* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJRotateCommandLayer::create} != (GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1ba0))(p0, p1);
        else return GJRotateCommandLayer::create(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject p0) {
        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject)){&$GJRotateCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4bb0))(this, p0);
        else return GJRotateCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject p0) {
        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject)){&$GJRotateCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x4ca0))(this, p0);
        else return GJRotateCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x58d0))(this, p0);
        else return GJRotateCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x54b0))(this);
        else return GJRotateCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5690))(this);
        else return GJRotateCommandLayer::updateTargetGroupID2();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$GJRotateCommandLayer::create} != (GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1ba0, (GJRotateCommandLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject)){&$GJRotateCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x4bb0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID}));

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject)){&$GJRotateCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x4ca0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateGroupID2}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x58d0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x54b0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x5690, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJSearchObject : public GJSearchObject, public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSearchObject() {}
    typedef GJSearchObject* __thistype;

    static GJSearchObject* create(SearchTyp p0) {
        if ((GJSearchObject*(*)(SearchTyp)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchTyp)){&D::create})
            return reinterpret_cast<GJSearchObject*(*)(SearchTyp)>(m->getOriginal(getBase()+0x2df120))(p0);
        else return GJSearchObject::create(p0);
    }

    static GJSearchObject* create(SearchTyp p0, std::strin p1, std::strin p2, std::strin p3, in p4, boo p5, boo p6, boo p7, in p8, boo p9, boo p10, boo p11, boo p12, boo p13, boo p14, boo p15, boo p16, in p17, in p18) {
        if ((GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)){&D::create})
            return reinterpret_cast<GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)>(m->getOriginal(getBase()+0x2dee30))(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
        else return GJSearchObject::create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    void getPageObject(in p0) {
        if ((void($GJSearchObject::*)(in)){&$GJSearchObject::getPageObject} != (void(D::*)(in)){&D::getPageObject})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x2df9a0))(this, p0);
        else return GJSearchObject::getPageObject(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJSearchObject*(*)(SearchTyp)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchTyp)){&D::create})
            m->registerHook(getBase()+0x2df120, (GJSearchObject*(*)(SearchTyp)){&D::create});

        if ((GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)){&D::create})
            m->registerHook(getBase()+0x2dee30, (GJSearchObject*(*)(SearchTyp, std::strin, std::strin, std::strin, in, boo, boo, boo, in, boo, boo, boo, boo, boo, boo, boo, boo, in, in)){&D::create});

        if ((void($GJSearchObject::*)(in)){&$GJSearchObject::getPageObject} != (void(D::*)(in)){&D::getPageObject})
            m->registerHook(getBase()+0x2df9a0, extract((void(D::*)(in)){&D::getPageObject}));
    }
};


template<class D>
class $GJSpecialColorSelect : public GJSpecialColorSelect, public $CacBase {
 public:
    $GJSpecialColorSelect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSpecialColorSelect() {}
    typedef GJSpecialColorSelect* __thistype;

    void textForColorIdx(in p0) {
        if ((void($GJSpecialColorSelect::*)(in)){&$GJSpecialColorSelect::textForColorIdx} != (void(D::*)(in)){&D::textForColorIdx})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x383a50))(this, p0);
        else return GJSpecialColorSelect::textForColorIdx(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GJSpecialColorSelect::*)(in)){&$GJSpecialColorSelect::textForColorIdx} != (void(D::*)(in)){&D::textForColorIdx})
            m->registerHook(getBase()+0x383a50, extract((void(D::*)(in)){&D::textForColorIdx}));
    }
};


template<class D>
class $GJSpiderSprite : public GJSpiderSprite, public $CacBase {
 public:
    $GJSpiderSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSpiderSprite() {}
    typedef GJSpiderSprite* __thistype;

    static GJSpiderSprite* create() {
        if ((GJSpiderSprite*(*)()){&$GJSpiderSprite::create} != (GJSpiderSprite*(*)()){&D::create})
            return reinterpret_cast<GJSpiderSprite*(*)()>(m->getOriginal(getBase()+0x34c5b0))();
        else return GJSpiderSprite::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJSpiderSprite*(*)()){&$GJSpiderSprite::create} != (GJSpiderSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34c5b0, (GJSpiderSprite*(*)()){&D::create});
    }
};


template<class D>
class $GManager : public GManager, public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GManager() {}
    typedef GManager* __thistype;

    void save() {
        if ((void($GManager::*)()){&$GManager::save} != (void(D::*)()){&D::save})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26f300))(this);
        else return GManager::save();
    }

    void saveData(DS_Dictionary p0, std::strin p1) {
        if ((void($GManager::*)(DS_Dictionary, std::strin)){&$GManager::saveData} != (void(D::*)(DS_Dictionary, std::strin)){&D::saveData})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary, std::strin)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
        else return GManager::saveData(p0, p1);
    }

    void saveGMTo(std::strin p0) {
        if ((void($GManager::*)(std::strin)){&$GManager::saveGMTo} != (void(D::*)(std::strin)){&D::saveGMTo})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
        else return GManager::saveGMTo(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GManager::*)()){&$GManager::save} != (void(D::*)()){&D::save})
            m->registerHook(getBase()+0x26f300, extract((void(D::*)()){&D::save}));

        if ((void($GManager::*)(DS_Dictionary, std::strin)){&$GManager::saveData} != (void(D::*)(DS_Dictionary, std::strin)){&D::saveData})
            m->registerHook(getBase()+0x26f4b0, extract((void(D::*)(DS_Dictionary, std::strin)){&D::saveData}));

        if ((void($GManager::*)(std::strin)){&$GManager::saveGMTo} != (void(D::*)(std::strin)){&D::saveGMTo})
            m->registerHook(getBase()+0x26f3b0, extract((void(D::*)(std::strin)){&D::saveGMTo}));
    }
};


template<class D>
class $GameLevelManager : public GameLevelManager, public $CacBase {
 public:
    $GameLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameLevelManager() {}
    typedef GameLevelManager* __thistype;

    GJGameLevel* createNewLevel() {
        if ((GJGameLevel*($GameLevelManager::*)()){&$GameLevelManager::createNewLevel} != (GJGameLevel*(D::*)()){&D::createNewLevel})
            return reinterpret_cast<GJGameLevel*(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8180))(this);
        else return GameLevelManager::createNewLevel();
    }

    static GameLevelManager* sharedState() {
        if ((GameLevelManager*(*)()){&$GameLevelManager::sharedState} != (GameLevelManager*(*)()){&D::sharedState})
            return reinterpret_cast<GameLevelManager*(*)()>(m->getOriginal(getBase()+0x2a8340))();
        else return GameLevelManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GJGameLevel*($GameLevelManager::*)()){&$GameLevelManager::createNewLevel} != (GJGameLevel*(D::*)()){&D::createNewLevel})
            m->registerHook(getBase()+0x2b8180, extract((GJGameLevel*(D::*)()){&D::createNewLevel}));

        if ((GameLevelManager*(*)()){&$GameLevelManager::sharedState} != (GameLevelManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x2a8340, (GameLevelManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $GameManager : public GameManager, public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameManager() {}
    typedef GameManager* __thistype;

    void accountStatusChanged() {
        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
        else return GameManager::accountStatusChanged();
    }

    const cocos2d::_ccColor3B& colorForIdx(in p0) {
        if ((const cocos2d::_ccColor3B&($GameManager::*)(in)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::colorForIdx})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
        else return GameManager::colorForIdx(p0);
    }

    void didExitPlayscene() {
        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0230))(this);
        else return GameManager::didExitPlayscene();
    }

    void doQuickSave() {
        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
        else return GameManager::doQuickSave();
    }

    void fadeInMusic(char const p0) {
        if ((void($GameManager::*)(char const)){&$GameManager::fadeInMusic} != (void(D::*)(char const)){&D::fadeInMusic})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
        else return GameManager::fadeInMusic(p0);
    }

    void getBGTexture(in p0) {
        if ((void($GameManager::*)(in)){&$GameManager::getBGTexture} != (void(D::*)(in)){&D::getBGTexture})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
        else return GameManager::getBGTexture(p0);
    }

    void getFontFile(in p0) {
        if ((void($GameManager::*)(in)){&$GameManager::getFontFile} != (void(D::*)(in)){&D::getFontFile})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
        else return GameManager::getFontFile(p0);
    }

    bool getGameVariable(char const p0) {
        if ((bool($GameManager::*)(char const)){&$GameManager::getGameVariable} != (bool(D::*)(char const)){&D::getGameVariable})
            return reinterpret_cast<bool(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
        else return GameManager::getGameVariable(p0);
    }

    int getIntGameVariable(char const p0) {
        if ((int($GameManager::*)(char const)){&$GameManager::getIntGameVariable} != (int(D::*)(char const)){&D::getIntGameVariable})
            return reinterpret_cast<int(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
        else return GameManager::getIntGameVariable(p0);
    }

    void getUGV(char const p0) {
        if ((void($GameManager::*)(char const)){&$GameManager::getUGV} != (void(D::*)(char const)){&D::getUGV})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
        else return GameManager::getUGV(p0);
    }

    void loadDeathEffect(in p0) {
        if ((void($GameManager::*)(in)){&$GameManager::loadDeathEffect} != (void(D::*)(in)){&D::loadDeathEffect})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
        else return GameManager::loadDeathEffect(p0);
    }

    void loadFont(in p0) {
        if ((void($GameManager::*)(in)){&$GameManager::loadFont} != (void(D::*)(in)){&D::loadFont})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
        else return GameManager::loadFont(p0);
    }

    void reloadAll(boo p0, boo p1, boo p2) {
        if ((void($GameManager::*)(boo, boo, boo)){&$GameManager::reloadAll} != (void(D::*)(boo, boo, boo)){&D::reloadAll})
            return reinterpret_cast<void(*)(decltype(this), boo, boo, boo)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
        else return GameManager::reloadAll(p0, p1, p2);
    }

    void reloadAllStep5() {
        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
        else return GameManager::reloadAllStep5();
    }

    void reportPercentageForLevel(in p0, in p1, boo p2) {
        if ((void($GameManager::*)(in, in, boo)){&$GameManager::reportPercentageForLevel} != (void(D::*)(in, in, boo)){&D::reportPercentageForLevel})
            return reinterpret_cast<void(*)(decltype(this), in, in, boo)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
        else return GameManager::reportPercentageForLevel(p0, p1, p2);
    }

    void setGameVariable(char const p0, boo p1) {
        if ((void($GameManager::*)(char const, boo)){&$GameManager::setGameVariable} != (void(D::*)(char const, boo)){&D::setGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const, boo)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
        else return GameManager::setGameVariable(p0, p1);
    }

    void setIntGameVariable(char const p0, in p1) {
        if ((void($GameManager::*)(char const, in)){&$GameManager::setIntGameVariable} != (void(D::*)(char const, in)){&D::setIntGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const, in)>(m->getOriginal(getBase()+0x1cd0e0))(this, p0, p1);
        else return GameManager::setIntGameVariable(p0, p1);
    }

    void setUGV(char const p0, boo p1) {
        if ((void($GameManager::*)(char const, boo)){&$GameManager::setUGV} != (void(D::*)(char const, boo)){&D::setUGV})
            return reinterpret_cast<void(*)(decltype(this), char const, boo)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
        else return GameManager::setUGV(p0, p1);
    }

    static GameManager* sharedState() {
        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            return reinterpret_cast<GameManager*(*)()>(m->getOriginal(getBase()+0x1c2b30))();
        else return GameManager::sharedState();
    }

     ~GameManager() {
        if ((($GameManager::*)()){&$GameManager::~GameManager} != ((D::*)()){&D::~GameManager})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0e00))(this);
        else return GameManager::~GameManager();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(getBase()+0x1cdad0, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((const cocos2d::_ccColor3B&($GameManager::*)(in)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(in)){&D::colorForIdx})
            m->registerHook(getBase()+0x1cbc80, extract((const cocos2d::_ccColor3B&(D::*)(in)){&D::colorForIdx}));

        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            m->registerHook(getBase()+0x1d0230, extract((void(D::*)()){&D::didExitPlayscene}));

        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            m->registerHook(getBase()+0x1d0200, extract((void(D::*)()){&D::doQuickSave}));

        if ((void($GameManager::*)(char const)){&$GameManager::fadeInMusic} != (void(D::*)(char const)){&D::fadeInMusic})
            m->registerHook(getBase()+0x1c2ff0, extract((void(D::*)(char const)){&D::fadeInMusic}));

        if ((void($GameManager::*)(in)){&$GameManager::getBGTexture} != (void(D::*)(in)){&D::getBGTexture})
            m->registerHook(getBase()+0x1cca00, extract((void(D::*)(in)){&D::getBGTexture}));

        if ((void($GameManager::*)(in)){&$GameManager::getFontFile} != (void(D::*)(in)){&D::getFontFile})
            m->registerHook(getBase()+0x1cc5f0, extract((void(D::*)(in)){&D::getFontFile}));

        if ((bool($GameManager::*)(char const)){&$GameManager::getGameVariable} != (bool(D::*)(char const)){&D::getGameVariable})
            m->registerHook(getBase()+0x1cccd0, extract((bool(D::*)(char const)){&D::getGameVariable}));

        if ((int($GameManager::*)(char const)){&$GameManager::getIntGameVariable} != (int(D::*)(char const)){&D::getIntGameVariable})
            m->registerHook(getBase()+0x1cd1d0, extract((int(D::*)(char const)){&D::getIntGameVariable}));

        if ((void($GameManager::*)(char const)){&$GameManager::getUGV} != (void(D::*)(char const)){&D::getUGV})
            m->registerHook(getBase()+0x1ccfa0, extract((void(D::*)(char const)){&D::getUGV}));

        if ((void($GameManager::*)(in)){&$GameManager::loadDeathEffect} != (void(D::*)(in)){&D::loadDeathEffect})
            m->registerHook(getBase()+0x1cc690, extract((void(D::*)(in)){&D::loadDeathEffect}));

        if ((void($GameManager::*)(in)){&$GameManager::loadFont} != (void(D::*)(in)){&D::loadFont})
            m->registerHook(getBase()+0x1cc550, extract((void(D::*)(in)){&D::loadFont}));

        if ((void($GameManager::*)(boo, boo, boo)){&$GameManager::reloadAll} != (void(D::*)(boo, boo, boo)){&D::reloadAll})
            m->registerHook(getBase()+0x1d08a0, extract((void(D::*)(boo, boo, boo)){&D::reloadAll}));

        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            m->registerHook(getBase()+0x1d0b00, extract((void(D::*)()){&D::reloadAllStep5}));

        if ((void($GameManager::*)(in, in, boo)){&$GameManager::reportPercentageForLevel} != (void(D::*)(in, in, boo)){&D::reportPercentageForLevel})
            m->registerHook(getBase()+0x1c5b00, extract((void(D::*)(in, in, boo)){&D::reportPercentageForLevel}));

        if ((void($GameManager::*)(char const, boo)){&$GameManager::setGameVariable} != (void(D::*)(char const, boo)){&D::setGameVariable})
            m->registerHook(getBase()+0x1cca80, extract((void(D::*)(char const, boo)){&D::setGameVariable}));

        if ((void($GameManager::*)(char const, in)){&$GameManager::setIntGameVariable} != (void(D::*)(char const, in)){&D::setIntGameVariable})
            m->registerHook(getBase()+0x1cd0e0, extract((void(D::*)(char const, in)){&D::setIntGameVariable}));

        if ((void($GameManager::*)(char const, boo)){&$GameManager::setUGV} != (void(D::*)(char const, boo)){&D::setUGV})
            m->registerHook(getBase()+0x1cce50, extract((void(D::*)(char const, boo)){&D::setUGV}));

        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x1c2b30, (GameManager*(*)()){&D::sharedState});

        if ((($GameManager::*)()){&$GameManager::~GameManager} != ((D::*)()){&D::~GameManager})
            m->registerHook(getBase()+0x1d0e00, extract(((D::*)()){&D::~GameManager}));
    }
};


template<class D>
class $GameObject : public GameObject, public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameObject() {}
    typedef GameObject* __thistype;

    void activateObject() {
        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2faf60))(this);
        else return GameObject::activateObject();
    }

    void activatedByPlayer(GameObject p0) {
        if ((void($GameObject::*)(GameObject)){&$GameObject::activatedByPlayer} != (void(D::*)(GameObject)){&D::activatedByPlayer})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x342a20))(this, p0);
        else return GameObject::activatedByPlayer(p0);
    }

    void addColorSprite() {
        if ((void($GameObject::*)()){&$GameObject::addColorSprite} != (void(D::*)()){&D::addColorSprite})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7fe0))(this);
        else return GameObject::addColorSprite();
    }

    void addColorSpriteToParent(boo p0) {
        if ((void($GameObject::*)(boo)){&$GameObject::addColorSpriteToParent} != (void(D::*)(boo)){&D::addColorSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
        else return GameObject::addColorSpriteToParent(p0);
    }

    void addMainSpriteToParent(boo p0) {
        if ((void($GameObject::*)(boo)){&$GameObject::addMainSpriteToParent} != (void(D::*)(boo)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
        else return GameObject::addMainSpriteToParent(p0);
    }

    void addToGroup(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::addToGroup} != (void(D::*)(in)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
        else return GameObject::addToGroup(p0);
    }

    void addToTempOffset(floa p0, floa p1) {
        if ((void($GameObject::*)(floa, floa)){&$GameObject::addToTempOffset} != (void(D::*)(floa, floa)){&D::addToTempOffset})
            return reinterpret_cast<void(*)(decltype(this), floa, floa)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
        else return GameObject::addToTempOffset(p0, p1);
    }

    void calculateOrientedBox() {
        if ((void($GameObject::*)()){&$GameObject::calculateOrientedBox} != (void(D::*)()){&D::calculateOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b20))(this);
        else return GameObject::calculateOrientedBox();
    }

    void calculateSpawnXPos() {
        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
        else return GameObject::calculateSpawnXPos();
    }

    void canChangeCustomColor() {
        if ((void($GameObject::*)()){&$GameObject::canChangeCustomColor} != (void(D::*)()){&D::canChangeCustomColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342db0))(this);
        else return GameObject::canChangeCustomColor();
    }

    void colorForMode(in p0, boo p1) {
        if ((void($GameObject::*)(in, boo)){&$GameObject::colorForMode} != (void(D::*)(in, boo)){&D::colorForMode})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
        else return GameObject::colorForMode(p0, p1);
    }

    void commonSetup() {
        if ((void($GameObject::*)()){&$GameObject::commonSetup} != (void(D::*)()){&D::commonSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5570))(this);
        else return GameObject::commonSetup();
    }

    void copyGroups(GameObject p0) {
        if ((void($GameObject::*)(GameObject)){&$GameObject::copyGroups} != (void(D::*)(GameObject)){&D::copyGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
        else return GameObject::copyGroups(p0);
    }

    static GameObject* createWithFrame(char const p0) {
        if ((GameObject*(*)(char const)){&$GameObject::createWithFrame} != (GameObject*(*)(char const)){&D::createWithFrame})
            return reinterpret_cast<GameObject*(*)(char const)>(m->getOriginal(getBase()+0x2f5490))(p0);
        else return GameObject::createWithFrame(p0);
    }

    static GameObject* createWithKey(in p0) {
        if ((GameObject*(*)(in)){&$GameObject::createWithKey} != (GameObject*(*)(in)){&D::createWithKey})
            return reinterpret_cast<GameObject*(*)(in)>(m->getOriginal(getBase()+0x2f4ce0))(p0);
        else return GameObject::createWithKey(p0);
    }

    void customSetup() {
        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fbba0))(this);
        else return GameObject::customSetup();
    }

    void deactivateObject(boo p0) {
        if ((void($GameObject::*)(boo)){&$GameObject::deactivateObject} != (void(D::*)(boo)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
        else return GameObject::deactivateObject(p0);
    }

    void destroyObject() {
        if ((void($GameObject::*)()){&$GameObject::destroyObject} != (void(D::*)()){&D::destroyObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
        else return GameObject::destroyObject();
    }

    void determineSlopeDirection() {
        if ((void($GameObject::*)()){&$GameObject::determineSlopeDirection} != (void(D::*)()){&D::determineSlopeDirection})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33a9e0))(this);
        else return GameObject::determineSlopeDirection();
    }

    void getActiveColorForMode(in p0, boo p1) {
        if ((void($GameObject::*)(in, boo)){&$GameObject::getActiveColorForMode} != (void(D::*)(in, boo)){&D::getActiveColorForMode})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
        else return GameObject::getActiveColorForMode(p0, p1);
    }

    void getBallFrame(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::getBallFrame} != (void(D::*)(in)){&D::getBallFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
        else return GameObject::getBallFrame(p0);
    }

    void getBoxOffset() {
        if ((void($GameObject::*)()){&$GameObject::getBoxOffset} != (void(D::*)()){&D::getBoxOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3353d0))(this);
        else return GameObject::getBoxOffset();
    }

    const cocos2d::_ccColor3B& getColorIndex() {
        if ((const cocos2d::_ccColor3B&($GameObject::*)()){&$GameObject::getColorIndex} != (const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this))>(m->getOriginal(getBase()+0x343b90))(this);
        else return GameObject::getColorIndex();
    }

    void getDidUpdateLastPosition() {
        if ((void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition} != (void(D::*)()){&D::getDidUpdateLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a20))(this);
        else return GameObject::getDidUpdateLastPosition();
    }

    void getGroupID(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::getGroupID} != (void(D::*)(in)){&D::getGroupID})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
        else return GameObject::getGroupID(p0);
    }

    void getLastPosition() {
        if ((void($GameObject::*)()){&$GameObject::getLastPosition} != (void(D::*)()){&D::getLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3439d0))(this);
        else return GameObject::getLastPosition();
    }

    void getMainColorMode() {
        if ((void($GameObject::*)()){&$GameObject::getMainColorMode} != (void(D::*)()){&D::getMainColorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x334c30))(this);
        else return GameObject::getMainColorMode();
    }

    cocos2d::CCRect* getObjectRect() {
        if ((cocos2d::CCRect*($GameObject::*)()){&$GameObject::getObjectRect} != (cocos2d::CCRect*(D::*)()){&D::getObjectRect})
            return reinterpret_cast<cocos2d::CCRect*(*)(decltype(this))>(m->getOriginal(getBase()+0x3352b0))(this);
        else return GameObject::getObjectRect();
    }

    void getObjectRect(floa p0, floa p1) {
        if ((void($GameObject::*)(floa, floa)){&$GameObject::getObjectRect} != (void(D::*)(floa, floa)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), floa, floa)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
        else return GameObject::getObjectRect(p0, p1);
    }

    void getObjectRect2(floa p0, floa p1) {
        if ((void($GameObject::*)(floa, floa)){&$GameObject::getObjectRect2} != (void(D::*)(floa, floa)){&D::getObjectRect2})
            return reinterpret_cast<void(*)(decltype(this), floa, floa)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
        else return GameObject::getObjectRect2(p0, p1);
    }

    void getObjectRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1d0))(this);
        else return GameObject::getObjectRectDirty();
    }

    void getObjectTextureRect() {
        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3355b0))(this);
        else return GameObject::getObjectTextureRect();
    }

    void getObjectZOrder() {
        if ((void($GameObject::*)()){&$GameObject::getObjectZOrder} != (void(D::*)()){&D::getObjectZOrder})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337d70))(this);
        else return GameObject::getObjectZOrder();
    }

    void getOrientedRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1f0))(this);
        else return GameObject::getOrientedRectDirty();
    }

    void getRScaleX() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e50))(this);
        else return GameObject::getRScaleX();
    }

    void getRScaleY() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e80))(this);
        else return GameObject::getRScaleY();
    }

    std::string getSaveString() {
        if ((std::string($GameObject::*)()){&$GameObject::getSaveString} != (std::string(D::*)()){&D::getSaveString})
            return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x33d3d0))(this);
        else return GameObject::getSaveString();
    }

    void getSecondaryColorMode() {
        if ((void($GameObject::*)()){&$GameObject::getSecondaryColorMode} != (void(D::*)()){&D::getSecondaryColorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x341c20))(this);
        else return GameObject::getSecondaryColorMode();
    }

    void getSectionIdx() {
        if ((void($GameObject::*)()){&$GameObject::getSectionIdx} != (void(D::*)()){&D::getSectionIdx})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a00))(this);
        else return GameObject::getSectionIdx();
    }

    void getStartPos() {
        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc230))(this);
        else return GameObject::getStartPos();
    }

    void getType() {
        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc210))(this);
        else return GameObject::getType();
    }

    void groupWasDisabled() {
        if ((void($GameObject::*)()){&$GameObject::groupWasDisabled} != (void(D::*)()){&D::groupWasDisabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b110))(this);
        else return GameObject::groupWasDisabled();
    }

    void groupWasEnabled() {
        if ((void($GameObject::*)()){&$GameObject::groupWasEnabled} != (void(D::*)()){&D::groupWasEnabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b0f0))(this);
        else return GameObject::groupWasEnabled();
    }

    void hasBeenActivated() {
        if ((void($GameObject::*)()){&$GameObject::hasBeenActivated} != (void(D::*)()){&D::hasBeenActivated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342a80))(this);
        else return GameObject::hasBeenActivated();
    }

    void hasBeenActivatedByPlayer(GameObject p0) {
        if ((void($GameObject::*)(GameObject)){&$GameObject::hasBeenActivatedByPlayer} != (void(D::*)(GameObject)){&D::hasBeenActivatedByPlayer})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x342a50))(this, p0);
        else return GameObject::hasBeenActivatedByPlayer(p0);
    }

    void hasSecondaryColor() {
        if ((void($GameObject::*)()){&$GameObject::hasSecondaryColor} != (void(D::*)()){&D::hasSecondaryColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342f80))(this);
        else return GameObject::hasSecondaryColor();
    }

    void ignoreEnter() {
        if ((void($GameObject::*)()){&$GameObject::ignoreEnter} != (void(D::*)()){&D::ignoreEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352a0))(this);
        else return GameObject::ignoreEnter();
    }

    void ignoreFade() {
        if ((void($GameObject::*)()){&$GameObject::ignoreFade} != (void(D::*)()){&D::ignoreFade})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335290))(this);
        else return GameObject::ignoreFade();
    }

    bool initWithTexture(cocos2d::CCTexture2D p0) {
        if ((bool($GameObject::*)(cocos2d::CCTexture2D)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D)){&D::initWithTexture})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
        else return GameObject::initWithTexture(p0);
    }

    void isBasicTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isBasicTrigger} != (void(D::*)()){&D::isBasicTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343d10))(this);
        else return GameObject::isBasicTrigger();
    }

    void isColorTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isColorTrigger} != (void(D::*)()){&D::isColorTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b40))(this);
        else return GameObject::isColorTrigger();
    }

    void isFlipX() {
        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a40))(this);
        else return GameObject::isFlipX();
    }

    void isFlipY() {
        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a50))(this);
        else return GameObject::isFlipY();
    }

    void isSpawnableTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isSpawnableTrigger} != (void(D::*)()){&D::isSpawnableTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a60))(this);
        else return GameObject::isSpawnableTrigger();
    }

    void isSpecialObject() {
        if ((void($GameObject::*)()){&$GameObject::isSpecialObject} != (void(D::*)()){&D::isSpecialObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343c40))(this);
        else return GameObject::isSpecialObject();
    }

    static GameObject* objectFromString(std::strin p0, boo p1) {
        if ((GameObject*(*)(std::strin, boo)){&$GameObject::objectFromString} != (GameObject*(*)(std::strin, boo)){&D::objectFromString})
            return reinterpret_cast<GameObject*(*)(std::strin, boo)>(m->getOriginal(getBase()+0x33b720))(p0, p1);
        else return GameObject::objectFromString(p0, p1);
    }

    void playShineEffect() {
        if ((void($GameObject::*)()){&$GameObject::playShineEffect} != (void(D::*)()){&D::playShineEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
        else return GameObject::playShineEffect();
    }

    void powerOffObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369c0))(this);
        else return GameObject::powerOffObject();
    }

    void powerOnObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369a0))(this);
        else return GameObject::powerOnObject();
    }

    void quickUpdatePosition() {
        if ((void($GameObject::*)()){&$GameObject::quickUpdatePosition} != (void(D::*)()){&D::quickUpdatePosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335790))(this);
        else return GameObject::quickUpdatePosition();
    }

    void removeFromGroup(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::removeFromGroup} != (void(D::*)(in)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
        else return GameObject::removeFromGroup(p0);
    }

    void removeGlow() {
        if ((void($GameObject::*)()){&$GameObject::removeGlow} != (void(D::*)()){&D::removeGlow})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7f70))(this);
        else return GameObject::removeGlow();
    }

    void resetGroupDisabled() {
        if ((void($GameObject::*)()){&$GameObject::resetGroupDisabled} != (void(D::*)()){&D::resetGroupDisabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa7e0))(this);
        else return GameObject::resetGroupDisabled();
    }

    void saveActiveColors() {
        if ((void($GameObject::*)()){&$GameObject::saveActiveColors} != (void(D::*)()){&D::saveActiveColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d250))(this);
        else return GameObject::saveActiveColors();
    }

    void selectObject(cocos2d::_ccColor3 p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3)){&$GameObject::selectObject} != (void(D::*)(cocos2d::_ccColor3)){&D::selectObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x341f90))(this, p0);
        else return GameObject::selectObject(p0);
    }

    void setChildColor(cocos2d::_ccColor3B const p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setChildColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x341f20))(this, p0);
        else return GameObject::setChildColor(p0);
    }

    void setDefaultMainColorMode(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::setDefaultMainColorMode} != (void(D::*)(in)){&D::setDefaultMainColorMode})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
        else return GameObject::setDefaultMainColorMode(p0);
    }

    void setDidUpdateLastPosition(bool const p0) {
        if ((void($GameObject::*)(bool const)){&$GameObject::setDidUpdateLastPosition} != (void(D::*)(bool const)){&D::setDidUpdateLastPosition})
            return reinterpret_cast<void(*)(decltype(this), bool const)>(m->getOriginal(getBase()+0x343a30))(this, p0);
        else return GameObject::setDidUpdateLastPosition(p0);
    }

    void setGlowColor(cocos2d::_ccColor3B const p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setGlowColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
        else return GameObject::setGlowColor(p0);
    }

    void setGlowOpacity(unsigned cha p0) {
        if ((void($GameObject::*)(unsigned cha)){&$GameObject::setGlowOpacity} != (void(D::*)(unsigned cha)){&D::setGlowOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned cha)>(m->getOriginal(getBase()+0x336200))(this, p0);
        else return GameObject::setGlowOpacity(p0);
    }

    void setLastPosition(cocos2d::CCPoint const p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint const)){&$GameObject::setLastPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setLastPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
        else return GameObject::setLastPosition(p0);
    }

    void setMainColorMode(in p0) {
        if ((void($GameObject::*)(in)){&$GameObject::setMainColorMode} != (void(D::*)(in)){&D::setMainColorMode})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x342e70))(this, p0);
        else return GameObject::setMainColorMode(p0);
    }

    void setObjectColor(cocos2d::_ccColor3B const p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x341c90))(this, p0);
        else return GameObject::setObjectColor(p0);
    }

    void setObjectRectDirty(boo p0) {
        if ((void($GameObject::*)(boo)){&$GameObject::setObjectRectDirty} != (void(D::*)(boo)){&D::setObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
        else return GameObject::setObjectRectDirty(p0);
    }

    void setOrientedRectDirty(boo p0) {
        if ((void($GameObject::*)(boo)){&$GameObject::setOrientedRectDirty} != (void(D::*)(boo)){&D::setOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0xdc200))(this, p0);
        else return GameObject::setOrientedRectDirty(p0);
    }

    void setPosition(cocos2d::CCPoint const p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint const)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const)>(m->getOriginal(getBase()+0x335850))(this, p0);
        else return GameObject::setPosition(p0);
    }

    void setRScale(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::setRScale} != (void(D::*)(floa)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x335e10))(this, p0);
        else return GameObject::setRScale(p0);
    }

    void setRScaleX(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::setRScaleX} != (void(D::*)(floa)){&D::setRScaleX})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
        else return GameObject::setRScaleX(p0);
    }

    void setRScaleY(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::setRScaleY} != (void(D::*)(floa)){&D::setRScaleY})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x335d60))(this, p0);
        else return GameObject::setRScaleY(p0);
    }

    void setSectionIdx(int const p0) {
        if ((void($GameObject::*)(int const)){&$GameObject::setSectionIdx} != (void(D::*)(int const)){&D::setSectionIdx})
            return reinterpret_cast<void(*)(decltype(this), int const)>(m->getOriginal(getBase()+0x343a10))(this, p0);
        else return GameObject::setSectionIdx(p0);
    }

    void setStartPos(cocos2d::CCPoin p0) {
        if ((void($GameObject::*)(cocos2d::CCPoin)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoin)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
        else return GameObject::setStartPos(p0);
    }

    void setType(GameObjectTyp p0) {
        if ((void($GameObject::*)(GameObjectTyp)){&$GameObject::setType} != (void(D::*)(GameObjectTyp)){&D::setType})
            return reinterpret_cast<void(*)(decltype(this), GameObjectTyp)>(m->getOriginal(getBase()+0xdc220))(this, p0);
        else return GameObject::setType(p0);
    }

    void setupCoinArt() {
        if ((void($GameObject::*)()){&$GameObject::setupCoinArt} != (void(D::*)()){&D::setupCoinArt})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
        else return GameObject::setupCoinArt();
    }

    void setupCustomSprites() {
        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x307f60))(this);
        else return GameObject::setupCustomSprites();
    }

    void slopeFloorTop() {
        if ((void($GameObject::*)()){&$GameObject::slopeFloorTop} != (void(D::*)()){&D::slopeFloorTop})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342800))(this);
        else return GameObject::slopeFloorTop();
    }

    void slopeWallLeft() {
        if ((void($GameObject::*)()){&$GameObject::slopeWallLeft} != (void(D::*)()){&D::slopeWallLeft})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3427e0))(this);
        else return GameObject::slopeWallLeft();
    }

    void spawnXPosition() {
        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1b0))(this);
        else return GameObject::spawnXPosition();
    }

    void triggerActivated(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::triggerActivated} != (void(D::*)(floa)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x336990))(this, p0);
        else return GameObject::triggerActivated(p0);
    }

    void triggerObject(GJBaseGameLayer p0) {
        if ((void($GameObject::*)(GJBaseGameLayer)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
        else return GameObject::triggerObject(p0);
    }

    void updateCustomScale(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::updateCustomScale} != (void(D::*)(floa)){&D::updateCustomScale})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
        else return GameObject::updateCustomScale(p0);
    }

    void updateMainColor() {
        if ((void($GameObject::*)()){&$GameObject::updateMainColor} != (void(D::*)()){&D::updateMainColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343340))(this);
        else return GameObject::updateMainColor();
    }

    void updateOrientedBox() {
        if ((void($GameObject::*)()){&$GameObject::updateOrientedBox} != (void(D::*)()){&D::updateOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b50))(this);
        else return GameObject::updateOrientedBox();
    }

    void updateSecondaryColor() {
        if ((void($GameObject::*)()){&$GameObject::updateSecondaryColor} != (void(D::*)()){&D::updateSecondaryColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343740))(this);
        else return GameObject::updateSecondaryColor();
    }

    void updateStartPos() {
        if ((void($GameObject::*)()){&$GameObject::updateStartPos} != (void(D::*)()){&D::updateStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa590))(this);
        else return GameObject::updateStartPos();
    }

    void updateStartValues() {
        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa800))(this);
        else return GameObject::updateStartValues();
    }

    void updateState() {
        if ((void($GameObject::*)()){&$GameObject::updateState} != (void(D::*)()){&D::updateState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369e0))(this);
        else return GameObject::updateState();
    }

    void updateSyncedAnimation(floa p0) {
        if ((void($GameObject::*)(floa)){&$GameObject::updateSyncedAnimation} != (void(D::*)(floa)){&D::updateSyncedAnimation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x337f00))(this, p0);
        else return GameObject::updateSyncedAnimation(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(getBase()+0x2faf60, extract((void(D::*)()){&D::activateObject}));

        if ((void($GameObject::*)(GameObject)){&$GameObject::activatedByPlayer} != (void(D::*)(GameObject)){&D::activatedByPlayer})
            m->registerHook(getBase()+0x342a20, extract((void(D::*)(GameObject)){&D::activatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::addColorSprite} != (void(D::*)()){&D::addColorSprite})
            m->registerHook(getBase()+0x2f7fe0, extract((void(D::*)()){&D::addColorSprite}));

        if ((void($GameObject::*)(boo)){&$GameObject::addColorSpriteToParent} != (void(D::*)(boo)){&D::addColorSpriteToParent})
            m->registerHook(getBase()+0x2fb470, extract((void(D::*)(boo)){&D::addColorSpriteToParent}));

        if ((void($GameObject::*)(boo)){&$GameObject::addMainSpriteToParent} != (void(D::*)(boo)){&D::addMainSpriteToParent})
            m->registerHook(getBase()+0x33a5b0, extract((void(D::*)(boo)){&D::addMainSpriteToParent}));

        if ((void($GameObject::*)(in)){&$GameObject::addToGroup} != (void(D::*)(in)){&D::addToGroup})
            m->registerHook(getBase()+0x33ad00, extract((void(D::*)(in)){&D::addToGroup}));

        if ((void($GameObject::*)(floa, floa)){&$GameObject::addToTempOffset} != (void(D::*)(floa, floa)){&D::addToTempOffset})
            m->registerHook(getBase()+0x335700, extract((void(D::*)(floa, floa)){&D::addToTempOffset}));

        if ((void($GameObject::*)()){&$GameObject::calculateOrientedBox} != (void(D::*)()){&D::calculateOrientedBox})
            m->registerHook(getBase()+0x342b20, extract((void(D::*)()){&D::calculateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(getBase()+0x336970, extract((void(D::*)()){&D::calculateSpawnXPos}));

        if ((void($GameObject::*)()){&$GameObject::canChangeCustomColor} != (void(D::*)()){&D::canChangeCustomColor})
            m->registerHook(getBase()+0x342db0, extract((void(D::*)()){&D::canChangeCustomColor}));

        if ((void($GameObject::*)(in, boo)){&$GameObject::colorForMode} != (void(D::*)(in, boo)){&D::colorForMode})
            m->registerHook(getBase()+0x343460, extract((void(D::*)(in, boo)){&D::colorForMode}));

        if ((void($GameObject::*)()){&$GameObject::commonSetup} != (void(D::*)()){&D::commonSetup})
            m->registerHook(getBase()+0x2f5570, extract((void(D::*)()){&D::commonSetup}));

        if ((void($GameObject::*)(GameObject)){&$GameObject::copyGroups} != (void(D::*)(GameObject)){&D::copyGroups})
            m->registerHook(getBase()+0x33ae30, extract((void(D::*)(GameObject)){&D::copyGroups}));

        if ((GameObject*(*)(char const)){&$GameObject::createWithFrame} != (GameObject*(*)(char const)){&D::createWithFrame})
            m->registerHook(getBase()+0x2f5490, (GameObject*(*)(char const)){&D::createWithFrame});

        if ((GameObject*(*)(in)){&$GameObject::createWithKey} != (GameObject*(*)(in)){&D::createWithKey})
            m->registerHook(getBase()+0x2f4ce0, (GameObject*(*)(in)){&D::createWithKey});

        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x2fbba0, extract((void(D::*)()){&D::customSetup}));

        if ((void($GameObject::*)(boo)){&$GameObject::deactivateObject} != (void(D::*)(boo)){&D::deactivateObject})
            m->registerHook(getBase()+0x2fb8f0, extract((void(D::*)(boo)){&D::deactivateObject}));

        if ((void($GameObject::*)()){&$GameObject::destroyObject} != (void(D::*)()){&D::destroyObject})
            m->registerHook(getBase()+0x336a00, extract((void(D::*)()){&D::destroyObject}));

        if ((void($GameObject::*)()){&$GameObject::determineSlopeDirection} != (void(D::*)()){&D::determineSlopeDirection})
            m->registerHook(getBase()+0x33a9e0, extract((void(D::*)()){&D::determineSlopeDirection}));

        if ((void($GameObject::*)(in, boo)){&$GameObject::getActiveColorForMode} != (void(D::*)(in, boo)){&D::getActiveColorForMode})
            m->registerHook(getBase()+0x343860, extract((void(D::*)(in, boo)){&D::getActiveColorForMode}));

        if ((void($GameObject::*)(in)){&$GameObject::getBallFrame} != (void(D::*)(in)){&D::getBallFrame})
            m->registerHook(getBase()+0x341bf0, extract((void(D::*)(in)){&D::getBallFrame}));

        if ((void($GameObject::*)()){&$GameObject::getBoxOffset} != (void(D::*)()){&D::getBoxOffset})
            m->registerHook(getBase()+0x3353d0, extract((void(D::*)()){&D::getBoxOffset}));

        if ((const cocos2d::_ccColor3B&($GameObject::*)()){&$GameObject::getColorIndex} != (const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex})
            m->registerHook(getBase()+0x343b90, extract((const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex}));

        if ((void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition} != (void(D::*)()){&D::getDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a20, extract((void(D::*)()){&D::getDidUpdateLastPosition}));

        if ((void($GameObject::*)(in)){&$GameObject::getGroupID} != (void(D::*)(in)){&D::getGroupID})
            m->registerHook(getBase()+0x33ae10, extract((void(D::*)(in)){&D::getGroupID}));

        if ((void($GameObject::*)()){&$GameObject::getLastPosition} != (void(D::*)()){&D::getLastPosition})
            m->registerHook(getBase()+0x3439d0, extract((void(D::*)()){&D::getLastPosition}));

        if ((void($GameObject::*)()){&$GameObject::getMainColorMode} != (void(D::*)()){&D::getMainColorMode})
            m->registerHook(getBase()+0x334c30, extract((void(D::*)()){&D::getMainColorMode}));

        if ((cocos2d::CCRect*($GameObject::*)()){&$GameObject::getObjectRect} != (cocos2d::CCRect*(D::*)()){&D::getObjectRect})
            m->registerHook(getBase()+0x3352b0, extract((cocos2d::CCRect*(D::*)()){&D::getObjectRect}));

        if ((void($GameObject::*)(floa, floa)){&$GameObject::getObjectRect} != (void(D::*)(floa, floa)){&D::getObjectRect})
            m->registerHook(getBase()+0x3352d0, extract((void(D::*)(floa, floa)){&D::getObjectRect}));

        if ((void($GameObject::*)(floa, floa)){&$GameObject::getObjectRect2} != (void(D::*)(floa, floa)){&D::getObjectRect2})
            m->registerHook(getBase()+0x3354e0, extract((void(D::*)(floa, floa)){&D::getObjectRect2}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            m->registerHook(getBase()+0xdc1d0, extract((void(D::*)()){&D::getObjectRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            m->registerHook(getBase()+0x3355b0, extract((void(D::*)()){&D::getObjectTextureRect}));

        if ((void($GameObject::*)()){&$GameObject::getObjectZOrder} != (void(D::*)()){&D::getObjectZOrder})
            m->registerHook(getBase()+0x337d70, extract((void(D::*)()){&D::getObjectZOrder}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            m->registerHook(getBase()+0xdc1f0, extract((void(D::*)()){&D::getOrientedRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            m->registerHook(getBase()+0x335e50, extract((void(D::*)()){&D::getRScaleX}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            m->registerHook(getBase()+0x335e80, extract((void(D::*)()){&D::getRScaleY}));

        if ((std::string($GameObject::*)()){&$GameObject::getSaveString} != (std::string(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x33d3d0, extract((std::string(D::*)()){&D::getSaveString}));

        if ((void($GameObject::*)()){&$GameObject::getSecondaryColorMode} != (void(D::*)()){&D::getSecondaryColorMode})
            m->registerHook(getBase()+0x341c20, extract((void(D::*)()){&D::getSecondaryColorMode}));

        if ((void($GameObject::*)()){&$GameObject::getSectionIdx} != (void(D::*)()){&D::getSectionIdx})
            m->registerHook(getBase()+0x343a00, extract((void(D::*)()){&D::getSectionIdx}));

        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            m->registerHook(getBase()+0xdc230, extract((void(D::*)()){&D::getStartPos}));

        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            m->registerHook(getBase()+0xdc210, extract((void(D::*)()){&D::getType}));

        if ((void($GameObject::*)()){&$GameObject::groupWasDisabled} != (void(D::*)()){&D::groupWasDisabled})
            m->registerHook(getBase()+0x33b110, extract((void(D::*)()){&D::groupWasDisabled}));

        if ((void($GameObject::*)()){&$GameObject::groupWasEnabled} != (void(D::*)()){&D::groupWasEnabled})
            m->registerHook(getBase()+0x33b0f0, extract((void(D::*)()){&D::groupWasEnabled}));

        if ((void($GameObject::*)()){&$GameObject::hasBeenActivated} != (void(D::*)()){&D::hasBeenActivated})
            m->registerHook(getBase()+0x342a80, extract((void(D::*)()){&D::hasBeenActivated}));

        if ((void($GameObject::*)(GameObject)){&$GameObject::hasBeenActivatedByPlayer} != (void(D::*)(GameObject)){&D::hasBeenActivatedByPlayer})
            m->registerHook(getBase()+0x342a50, extract((void(D::*)(GameObject)){&D::hasBeenActivatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::hasSecondaryColor} != (void(D::*)()){&D::hasSecondaryColor})
            m->registerHook(getBase()+0x342f80, extract((void(D::*)()){&D::hasSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::ignoreEnter} != (void(D::*)()){&D::ignoreEnter})
            m->registerHook(getBase()+0x3352a0, extract((void(D::*)()){&D::ignoreEnter}));

        if ((void($GameObject::*)()){&$GameObject::ignoreFade} != (void(D::*)()){&D::ignoreFade})
            m->registerHook(getBase()+0x335290, extract((void(D::*)()){&D::ignoreFade}));

        if ((bool($GameObject::*)(cocos2d::CCTexture2D)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D)){&D::initWithTexture})
            m->registerHook(getBase()+0x2f56a0, extract((bool(D::*)(cocos2d::CCTexture2D)){&D::initWithTexture}));

        if ((void($GameObject::*)()){&$GameObject::isBasicTrigger} != (void(D::*)()){&D::isBasicTrigger})
            m->registerHook(getBase()+0x343d10, extract((void(D::*)()){&D::isBasicTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isColorTrigger} != (void(D::*)()){&D::isColorTrigger})
            m->registerHook(getBase()+0x343b40, extract((void(D::*)()){&D::isColorTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            m->registerHook(getBase()+0x335a40, extract((void(D::*)()){&D::isFlipX}));

        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            m->registerHook(getBase()+0x335a50, extract((void(D::*)()){&D::isFlipY}));

        if ((void($GameObject::*)()){&$GameObject::isSpawnableTrigger} != (void(D::*)()){&D::isSpawnableTrigger})
            m->registerHook(getBase()+0x343a60, extract((void(D::*)()){&D::isSpawnableTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isSpecialObject} != (void(D::*)()){&D::isSpecialObject})
            m->registerHook(getBase()+0x343c40, extract((void(D::*)()){&D::isSpecialObject}));

        if ((GameObject*(*)(std::strin, boo)){&$GameObject::objectFromString} != (GameObject*(*)(std::strin, boo)){&D::objectFromString})
            m->registerHook(getBase()+0x33b720, (GameObject*(*)(std::strin, boo)){&D::objectFromString});

        if ((void($GameObject::*)()){&$GameObject::playShineEffect} != (void(D::*)()){&D::playShineEffect})
            m->registerHook(getBase()+0x2fa9d0, extract((void(D::*)()){&D::playShineEffect}));

        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(getBase()+0x3369c0, extract((void(D::*)()){&D::powerOffObject}));

        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(getBase()+0x3369a0, extract((void(D::*)()){&D::powerOnObject}));

        if ((void($GameObject::*)()){&$GameObject::quickUpdatePosition} != (void(D::*)()){&D::quickUpdatePosition})
            m->registerHook(getBase()+0x335790, extract((void(D::*)()){&D::quickUpdatePosition}));

        if ((void($GameObject::*)(in)){&$GameObject::removeFromGroup} != (void(D::*)(in)){&D::removeFromGroup})
            m->registerHook(getBase()+0x33ada0, extract((void(D::*)(in)){&D::removeFromGroup}));

        if ((void($GameObject::*)()){&$GameObject::removeGlow} != (void(D::*)()){&D::removeGlow})
            m->registerHook(getBase()+0x2f7f70, extract((void(D::*)()){&D::removeGlow}));

        if ((void($GameObject::*)()){&$GameObject::resetGroupDisabled} != (void(D::*)()){&D::resetGroupDisabled})
            m->registerHook(getBase()+0x2fa7e0, extract((void(D::*)()){&D::resetGroupDisabled}));

        if ((void($GameObject::*)()){&$GameObject::saveActiveColors} != (void(D::*)()){&D::saveActiveColors})
            m->registerHook(getBase()+0x33d250, extract((void(D::*)()){&D::saveActiveColors}));

        if ((void($GameObject::*)(cocos2d::_ccColor3)){&$GameObject::selectObject} != (void(D::*)(cocos2d::_ccColor3)){&D::selectObject})
            m->registerHook(getBase()+0x341f90, extract((void(D::*)(cocos2d::_ccColor3)){&D::selectObject}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setChildColor})
            m->registerHook(getBase()+0x341f20, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setChildColor}));

        if ((void($GameObject::*)(in)){&$GameObject::setDefaultMainColorMode} != (void(D::*)(in)){&D::setDefaultMainColorMode})
            m->registerHook(getBase()+0x304fc0, extract((void(D::*)(in)){&D::setDefaultMainColorMode}));

        if ((void($GameObject::*)(bool const)){&$GameObject::setDidUpdateLastPosition} != (void(D::*)(bool const)){&D::setDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a30, extract((void(D::*)(bool const)){&D::setDidUpdateLastPosition}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setGlowColor})
            m->registerHook(getBase()+0x341ed0, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setGlowColor}));

        if ((void($GameObject::*)(unsigned cha)){&$GameObject::setGlowOpacity} != (void(D::*)(unsigned cha)){&D::setGlowOpacity})
            m->registerHook(getBase()+0x336200, extract((void(D::*)(unsigned cha)){&D::setGlowOpacity}));

        if ((void($GameObject::*)(cocos2d::CCPoint const)){&$GameObject::setLastPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setLastPosition})
            m->registerHook(getBase()+0x3439e0, extract((void(D::*)(cocos2d::CCPoint const)){&D::setLastPosition}));

        if ((void($GameObject::*)(in)){&$GameObject::setMainColorMode} != (void(D::*)(in)){&D::setMainColorMode})
            m->registerHook(getBase()+0x342e70, extract((void(D::*)(in)){&D::setMainColorMode}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor})
            m->registerHook(getBase()+0x341c90, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor}));

        if ((void($GameObject::*)(boo)){&$GameObject::setObjectRectDirty} != (void(D::*)(boo)){&D::setObjectRectDirty})
            m->registerHook(getBase()+0xdc1e0, extract((void(D::*)(boo)){&D::setObjectRectDirty}));

        if ((void($GameObject::*)(boo)){&$GameObject::setOrientedRectDirty} != (void(D::*)(boo)){&D::setOrientedRectDirty})
            m->registerHook(getBase()+0xdc200, extract((void(D::*)(boo)){&D::setOrientedRectDirty}));

        if ((void($GameObject::*)(cocos2d::CCPoint const)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setPosition})
            m->registerHook(getBase()+0x335850, extract((void(D::*)(cocos2d::CCPoint const)){&D::setPosition}));

        if ((void($GameObject::*)(floa)){&$GameObject::setRScale} != (void(D::*)(floa)){&D::setRScale})
            m->registerHook(getBase()+0x335e10, extract((void(D::*)(floa)){&D::setRScale}));

        if ((void($GameObject::*)(floa)){&$GameObject::setRScaleX} != (void(D::*)(floa)){&D::setRScaleX})
            m->registerHook(getBase()+0x335cb0, extract((void(D::*)(floa)){&D::setRScaleX}));

        if ((void($GameObject::*)(floa)){&$GameObject::setRScaleY} != (void(D::*)(floa)){&D::setRScaleY})
            m->registerHook(getBase()+0x335d60, extract((void(D::*)(floa)){&D::setRScaleY}));

        if ((void($GameObject::*)(int const)){&$GameObject::setSectionIdx} != (void(D::*)(int const)){&D::setSectionIdx})
            m->registerHook(getBase()+0x343a10, extract((void(D::*)(int const)){&D::setSectionIdx}));

        if ((void($GameObject::*)(cocos2d::CCPoin)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoin)){&D::setStartPos})
            m->registerHook(getBase()+0x2fa520, extract((void(D::*)(cocos2d::CCPoin)){&D::setStartPos}));

        if ((void($GameObject::*)(GameObjectTyp)){&$GameObject::setType} != (void(D::*)(GameObjectTyp)){&D::setType})
            m->registerHook(getBase()+0xdc220, extract((void(D::*)(GameObjectTyp)){&D::setType}));

        if ((void($GameObject::*)()){&$GameObject::setupCoinArt} != (void(D::*)()){&D::setupCoinArt})
            m->registerHook(getBase()+0x337dd0, extract((void(D::*)()){&D::setupCoinArt}));

        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(getBase()+0x307f60, extract((void(D::*)()){&D::setupCustomSprites}));

        if ((void($GameObject::*)()){&$GameObject::slopeFloorTop} != (void(D::*)()){&D::slopeFloorTop})
            m->registerHook(getBase()+0x342800, extract((void(D::*)()){&D::slopeFloorTop}));

        if ((void($GameObject::*)()){&$GameObject::slopeWallLeft} != (void(D::*)()){&D::slopeWallLeft})
            m->registerHook(getBase()+0x3427e0, extract((void(D::*)()){&D::slopeWallLeft}));

        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(getBase()+0xdc1b0, extract((void(D::*)()){&D::spawnXPosition}));

        if ((void($GameObject::*)(floa)){&$GameObject::triggerActivated} != (void(D::*)(floa)){&D::triggerActivated})
            m->registerHook(getBase()+0x336990, extract((void(D::*)(floa)){&D::triggerActivated}));

        if ((void($GameObject::*)(GJBaseGameLayer)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer)){&D::triggerObject})
            m->registerHook(getBase()+0x2fa8f0, extract((void(D::*)(GJBaseGameLayer)){&D::triggerObject}));

        if ((void($GameObject::*)(floa)){&$GameObject::updateCustomScale} != (void(D::*)(floa)){&D::updateCustomScale})
            m->registerHook(getBase()+0x335eb0, extract((void(D::*)(floa)){&D::updateCustomScale}));

        if ((void($GameObject::*)()){&$GameObject::updateMainColor} != (void(D::*)()){&D::updateMainColor})
            m->registerHook(getBase()+0x343340, extract((void(D::*)()){&D::updateMainColor}));

        if ((void($GameObject::*)()){&$GameObject::updateOrientedBox} != (void(D::*)()){&D::updateOrientedBox})
            m->registerHook(getBase()+0x342b50, extract((void(D::*)()){&D::updateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::updateSecondaryColor} != (void(D::*)()){&D::updateSecondaryColor})
            m->registerHook(getBase()+0x343740, extract((void(D::*)()){&D::updateSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::updateStartPos} != (void(D::*)()){&D::updateStartPos})
            m->registerHook(getBase()+0x2fa590, extract((void(D::*)()){&D::updateStartPos}));

        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            m->registerHook(getBase()+0x2fa800, extract((void(D::*)()){&D::updateStartValues}));

        if ((void($GameObject::*)()){&$GameObject::updateState} != (void(D::*)()){&D::updateState})
            m->registerHook(getBase()+0x3369e0, extract((void(D::*)()){&D::updateState}));

        if ((void($GameObject::*)(floa)){&$GameObject::updateSyncedAnimation} != (void(D::*)(floa)){&D::updateSyncedAnimation})
            m->registerHook(getBase()+0x337f00, extract((void(D::*)(floa)){&D::updateSyncedAnimation}));
    }
};


template<class D>
class $GameObjectCopy : public GameObjectCopy, public $CacBase {
 public:
    $GameObjectCopy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameObjectCopy() {}
    typedef GameObjectCopy* __thistype;

    static GameObjectCopy* create(GameObject p0) {
        if ((GameObjectCopy*(*)(GameObject)){&$GameObjectCopy::create} != (GameObjectCopy*(*)(GameObject)){&D::create})
            return reinterpret_cast<GameObjectCopy*(*)(GameObject)>(m->getOriginal(getBase()+0x975a0))(p0);
        else return GameObjectCopy::create(p0);
    }

    void resetObject() {
        if ((void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x976a0))(this);
        else return GameObjectCopy::resetObject();
    }

     ~GameObjectCopy() {
        if ((($GameObjectCopy::*)()){&$GameObjectCopy::~GameObjectCopy} != ((D::*)()){&D::~GameObjectCopy})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x97710))(this);
        else return GameObjectCopy::~GameObjectCopy();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GameObjectCopy*(*)(GameObject)){&$GameObjectCopy::create} != (GameObjectCopy*(*)(GameObject)){&D::create})
            m->registerHook(getBase()+0x975a0, (GameObjectCopy*(*)(GameObject)){&D::create});

        if ((void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x976a0, extract((void(D::*)()){&D::resetObject}));

        if ((($GameObjectCopy::*)()){&$GameObjectCopy::~GameObjectCopy} != ((D::*)()){&D::~GameObjectCopy})
            m->registerHook(getBase()+0x97710, extract(((D::*)()){&D::~GameObjectCopy}));
    }
};


template<class D>
class $GameSoundManager : public GameSoundManager, public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameSoundManager() {}
    typedef GameSoundManager* __thistype;

    void disableMetering() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::disableMetering} != (void(D::*)()){&D::disableMetering})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d80))(this);
        else return GameSoundManager::disableMetering();
    }

    void enableMetering() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::enableMetering} != (void(D::*)()){&D::enableMetering})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d00))(this);
        else return GameSoundManager::enableMetering();
    }

    void getMeteringValue() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue} != (void(D::*)()){&D::getMeteringValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362db0))(this);
        else return GameSoundManager::getMeteringValue();
    }

    void playBackgroundMusic(std::strin p0, boo p1, boo p2) {
        if ((void($GameSoundManager::*)(std::strin, boo, boo)){&$GameSoundManager::playBackgroundMusic} != (void(D::*)(std::strin, boo, boo)){&D::playBackgroundMusic})
            return reinterpret_cast<void(*)(decltype(this), std::strin, boo, boo)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
        else return GameSoundManager::playBackgroundMusic(p0, p1, p2);
    }

    void playEffect(std::strin p0, floa p1, floa p2, floa p3) {
        if ((void($GameSoundManager::*)(std::strin, floa, floa, floa)){&$GameSoundManager::playEffect} != (void(D::*)(std::strin, floa, floa, floa)){&D::playEffect})
            return reinterpret_cast<void(*)(decltype(this), std::strin, floa, floa, floa)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
        else return GameSoundManager::playEffect(p0, p1, p2, p3);
    }

    void sharedManager() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::sharedManager} != (void(D::*)()){&D::sharedManager})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3610f0))(this);
        else return GameSoundManager::sharedManager();
    }

    void stopBackgroundMusic() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic} != (void(D::*)()){&D::stopBackgroundMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
        else return GameSoundManager::stopBackgroundMusic();
    }

     ~GameSoundManager() {
        if ((($GameSoundManager::*)()){&$GameSoundManager::~GameSoundManager} != ((D::*)()){&D::~GameSoundManager})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x362c00))(this);
        else return GameSoundManager::~GameSoundManager();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GameSoundManager::*)()){&$GameSoundManager::disableMetering} != (void(D::*)()){&D::disableMetering})
            m->registerHook(getBase()+0x362d80, extract((void(D::*)()){&D::disableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::enableMetering} != (void(D::*)()){&D::enableMetering})
            m->registerHook(getBase()+0x362d00, extract((void(D::*)()){&D::enableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue} != (void(D::*)()){&D::getMeteringValue})
            m->registerHook(getBase()+0x362db0, extract((void(D::*)()){&D::getMeteringValue}));

        if ((void($GameSoundManager::*)(std::strin, boo, boo)){&$GameSoundManager::playBackgroundMusic} != (void(D::*)(std::strin, boo, boo)){&D::playBackgroundMusic})
            m->registerHook(getBase()+0x362070, extract((void(D::*)(std::strin, boo, boo)){&D::playBackgroundMusic}));

        if ((void($GameSoundManager::*)(std::strin, floa, floa, floa)){&$GameSoundManager::playEffect} != (void(D::*)(std::strin, floa, floa, floa)){&D::playEffect})
            m->registerHook(getBase()+0x3623d0, extract((void(D::*)(std::strin, floa, floa, floa)){&D::playEffect}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::sharedManager} != (void(D::*)()){&D::sharedManager})
            m->registerHook(getBase()+0x3610f0, extract((void(D::*)()){&D::sharedManager}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic} != (void(D::*)()){&D::stopBackgroundMusic})
            m->registerHook(getBase()+0x362130, extract((void(D::*)()){&D::stopBackgroundMusic}));

        if ((($GameSoundManager::*)()){&$GameSoundManager::~GameSoundManager} != ((D::*)()){&D::~GameSoundManager})
            m->registerHook(getBase()+0x362c00, extract(((D::*)()){&D::~GameSoundManager}));
    }
};


template<class D>
class $GameStatsManager : public GameStatsManager, public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameStatsManager() {}
    typedef GameStatsManager* __thistype;

    void awardCurrencyForLevel(GJGameLevel p0) {
        if ((void($GameStatsManager::*)(GJGameLevel)){&$GameStatsManager::awardCurrencyForLevel} != (void(D::*)(GJGameLevel)){&D::awardCurrencyForLevel})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x43600))(this, p0);
        else return GameStatsManager::awardCurrencyForLevel(p0);
    }

    void awardDiamondsForLevel(GJGameLevel p0) {
        if ((void($GameStatsManager::*)(GJGameLevel)){&$GameStatsManager::awardDiamondsForLevel} != (void(D::*)(GJGameLevel)){&D::awardDiamondsForLevel})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x43c60))(this, p0);
        else return GameStatsManager::awardDiamondsForLevel(p0);
    }

    void awardSecretKey() {
        if ((void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey} != (void(D::*)()){&D::awardSecretKey})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x4b1e0))(this);
        else return GameStatsManager::awardSecretKey();
    }

    void getSecretCoinKey(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::getSecretCoinKey} != (void(D::*)(char const)){&D::getSecretCoinKey})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x429f0))(this, p0);
        else return GameStatsManager::getSecretCoinKey(p0);
    }

    void getStat(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::getStat} != (void(D::*)(char const)){&D::getStat})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x3d310))(this, p0);
        else return GameStatsManager::getStat(p0);
    }

    void hasPendingUserCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasPendingUserCoin} != (void(D::*)(char const)){&D::hasPendingUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x42730))(this, p0);
        else return GameStatsManager::hasPendingUserCoin(p0);
    }

    void hasSecretCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasSecretCoin} != (void(D::*)(char const)){&D::hasSecretCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x40730))(this, p0);
        else return GameStatsManager::hasSecretCoin(p0);
    }

    void hasUserCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasUserCoin} != (void(D::*)(char const)){&D::hasUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x427e0))(this, p0);
        else return GameStatsManager::hasUserCoin(p0);
    }

    void incrementStat(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::incrementStat} != (void(D::*)(char const)){&D::incrementStat})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
        else return GameStatsManager::incrementStat(p0);
    }

    void incrementStat(char const p0, in p1) {
        if ((void($GameStatsManager::*)(char const, in)){&$GameStatsManager::incrementStat} != (void(D::*)(char const, in)){&D::incrementStat})
            return reinterpret_cast<void(*)(decltype(this), char const, in)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
        else return GameStatsManager::incrementStat(p0, p1);
    }

    void sharedState() {
        if ((void($GameStatsManager::*)()){&$GameStatsManager::sharedState} != (void(D::*)()){&D::sharedState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x38f20))(this);
        else return GameStatsManager::sharedState();
    }

    void storePendingUserCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storePendingUserCoin} != (void(D::*)(char const)){&D::storePendingUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x42940))(this, p0);
        else return GameStatsManager::storePendingUserCoin(p0);
    }

    void storeSecretCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storeSecretCoin} != (void(D::*)(char const)){&D::storeSecretCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x42a10))(this, p0);
        else return GameStatsManager::storeSecretCoin(p0);
    }

    void storeUserCoin(char const p0) {
        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storeUserCoin} != (void(D::*)(char const)){&D::storeUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x42890))(this, p0);
        else return GameStatsManager::storeUserCoin(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GameStatsManager::*)(GJGameLevel)){&$GameStatsManager::awardCurrencyForLevel} != (void(D::*)(GJGameLevel)){&D::awardCurrencyForLevel})
            m->registerHook(getBase()+0x43600, extract((void(D::*)(GJGameLevel)){&D::awardCurrencyForLevel}));

        if ((void($GameStatsManager::*)(GJGameLevel)){&$GameStatsManager::awardDiamondsForLevel} != (void(D::*)(GJGameLevel)){&D::awardDiamondsForLevel})
            m->registerHook(getBase()+0x43c60, extract((void(D::*)(GJGameLevel)){&D::awardDiamondsForLevel}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey} != (void(D::*)()){&D::awardSecretKey})
            m->registerHook(getBase()+0x4b1e0, extract((void(D::*)()){&D::awardSecretKey}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::getSecretCoinKey} != (void(D::*)(char const)){&D::getSecretCoinKey})
            m->registerHook(getBase()+0x429f0, extract((void(D::*)(char const)){&D::getSecretCoinKey}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::getStat} != (void(D::*)(char const)){&D::getStat})
            m->registerHook(getBase()+0x3d310, extract((void(D::*)(char const)){&D::getStat}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasPendingUserCoin} != (void(D::*)(char const)){&D::hasPendingUserCoin})
            m->registerHook(getBase()+0x42730, extract((void(D::*)(char const)){&D::hasPendingUserCoin}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasSecretCoin} != (void(D::*)(char const)){&D::hasSecretCoin})
            m->registerHook(getBase()+0x40730, extract((void(D::*)(char const)){&D::hasSecretCoin}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::hasUserCoin} != (void(D::*)(char const)){&D::hasUserCoin})
            m->registerHook(getBase()+0x427e0, extract((void(D::*)(char const)){&D::hasUserCoin}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::incrementStat} != (void(D::*)(char const)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6d0, extract((void(D::*)(char const)){&D::incrementStat}));

        if ((void($GameStatsManager::*)(char const, in)){&$GameStatsManager::incrementStat} != (void(D::*)(char const, in)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6e0, extract((void(D::*)(char const, in)){&D::incrementStat}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x38f20, extract((void(D::*)()){&D::sharedState}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storePendingUserCoin} != (void(D::*)(char const)){&D::storePendingUserCoin})
            m->registerHook(getBase()+0x42940, extract((void(D::*)(char const)){&D::storePendingUserCoin}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storeSecretCoin} != (void(D::*)(char const)){&D::storeSecretCoin})
            m->registerHook(getBase()+0x42a10, extract((void(D::*)(char const)){&D::storeSecretCoin}));

        if ((void($GameStatsManager::*)(char const)){&$GameStatsManager::storeUserCoin} != (void(D::*)(char const)){&D::storeUserCoin})
            m->registerHook(getBase()+0x42890, extract((void(D::*)(char const)){&D::storeUserCoin}));
    }
};


template<class D>
class $GameToolbox : public GameToolbox, public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameToolbox() {}
    typedef GameToolbox* __thistype;

    void createToggleButton(std::strin p0, cocos2d::SEL_CallFunc p1, boo p2, cocos2d::CCMenu p3, cocos2d::CCPoin p4, cocos2d::CCNode p5, cocos2d::CCNode p6, floa p7, floa p8, floa p9, cocos2d::CCPoin p10, char const p11, boo p12, in p13, cocos2d::CCArray p14) {
        if ((void($GameToolbox::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)){&$GameToolbox::createToggleButton} != (void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)){&D::createToggleButton})
            return reinterpret_cast<void(*)(decltype(this), std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)>(m->getOriginal(getBase()+0x28bdd0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
        else return GameToolbox::createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

    static void getRelativeOffset(GameObject p0, cocos2d::CCPoin p1) {
        if ((void(*)(GameObject, cocos2d::CCPoin)){&$GameToolbox::getRelativeOffset} != (void(*)(GameObject, cocos2d::CCPoin)){&D::getRelativeOffset})
            return reinterpret_cast<void(*)(GameObject, cocos2d::CCPoin)>(m->getOriginal(getBase()+0x28c060))(p0, p1);
        else return GameToolbox::getRelativeOffset(p0, p1);
    }

    static void multipliedColorValue(cocos2d::_ccColor3 p0, cocos2d::_ccColor3 p1, floa p2) {
        if ((void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&$GameToolbox::multipliedColorValue} != (void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::multipliedColorValue})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)>(m->getOriginal(getBase()+0x28cb90))(p0, p1, p2);
        else return GameToolbox::multipliedColorValue(p0, p1, p2);
    }

    static void stringSetupToDict(std::strin p0, char const p1) {
        if ((void(*)(std::strin, char const)){&$GameToolbox::stringSetupToDict} != (void(*)(std::strin, char const)){&D::stringSetupToDict})
            return reinterpret_cast<void(*)(std::strin, char const)>(m->getOriginal(getBase()+0x28d700))(p0, p1);
        else return GameToolbox::stringSetupToDict(p0, p1);
    }

    void stringSetupToMap(std::strin p0, char const p1) {
        if ((void($GameToolbox::*)(std::strin, char const)){&$GameToolbox::stringSetupToMap} != (void(D::*)(std::strin, char const)){&D::stringSetupToMap})
            return reinterpret_cast<void(*)(decltype(this), std::strin, char const)>(m->getOriginal(getBase()+0x28d4c0))(this, p0, p1);
        else return GameToolbox::stringSetupToMap(p0, p1);
    }

    static void transformColor(cocos2d::_ccColor3B const p0, cocos2d::_ccHSVValu p1) {
        if ((void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)){&D::transformColor})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)>(m->getOriginal(getBase()+0x28c950))(p0, p1);
        else return GameToolbox::transformColor(p0, p1);
    }

    static void transformColor(cocos2d::_ccColor3B const p0, floa p1, floa p2, floa p3) {
        if ((void(*)(cocos2d::_ccColor3B const, floa, floa, floa)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const, floa, floa, floa)){&D::transformColor})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3B const, floa, floa, floa)>(m->getOriginal(getBase()+0x28c930))(p0, p1, p2, p3);
        else return GameToolbox::transformColor(p0, p1, p2, p3);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($GameToolbox::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)){&$GameToolbox::createToggleButton} != (void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)){&D::createToggleButton})
            m->registerHook(getBase()+0x28bdd0, extract((void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCNode, cocos2d::CCNode, floa, floa, floa, cocos2d::CCPoin, char const, boo, in, cocos2d::CCArray)){&D::createToggleButton}));

        if ((void(*)(GameObject, cocos2d::CCPoin)){&$GameToolbox::getRelativeOffset} != (void(*)(GameObject, cocos2d::CCPoin)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x28c060, (void(*)(GameObject, cocos2d::CCPoin)){&D::getRelativeOffset});

        if ((void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&$GameToolbox::multipliedColorValue} != (void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::multipliedColorValue})
            m->registerHook(getBase()+0x28cb90, (void(*)(cocos2d::_ccColor3, cocos2d::_ccColor3, floa)){&D::multipliedColorValue});

        if ((void(*)(std::strin, char const)){&$GameToolbox::stringSetupToDict} != (void(*)(std::strin, char const)){&D::stringSetupToDict})
            m->registerHook(getBase()+0x28d700, (void(*)(std::strin, char const)){&D::stringSetupToDict});

        if ((void($GameToolbox::*)(std::strin, char const)){&$GameToolbox::stringSetupToMap} != (void(D::*)(std::strin, char const)){&D::stringSetupToMap})
            m->registerHook(getBase()+0x28d4c0, extract((void(D::*)(std::strin, char const)){&D::stringSetupToMap}));

        if ((void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)){&D::transformColor})
            m->registerHook(getBase()+0x28c950, (void(*)(cocos2d::_ccColor3B const, cocos2d::_ccHSVValu)){&D::transformColor});

        if ((void(*)(cocos2d::_ccColor3B const, floa, floa, floa)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const, floa, floa, floa)){&D::transformColor})
            m->registerHook(getBase()+0x28c930, (void(*)(cocos2d::_ccColor3B const, floa, floa, floa)){&D::transformColor});
    }
};


template<class D>
class $GravityEffectSprite : public GravityEffectSprite, public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GravityEffectSprite() {}
    typedef GravityEffectSprite* __thistype;

    static GravityEffectSprite* create() {
        if ((GravityEffectSprite*(*)()){&$GravityEffectSprite::create} != (GravityEffectSprite*(*)()){&D::create})
            return reinterpret_cast<GravityEffectSprite*(*)()>(m->getOriginal(getBase()+0x6d0a0))();
        else return GravityEffectSprite::create();
    }

    bool init() {
        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x80b20))(this);
        else return GravityEffectSprite::init();
    }

    void updateSpritesColor(cocos2d::_ccColor3 p0) {
        if ((void($GravityEffectSprite::*)(cocos2d::_ccColor3)){&$GravityEffectSprite::updateSpritesColor} != (void(D::*)(cocos2d::_ccColor3)){&D::updateSpritesColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
        else return GravityEffectSprite::updateSpritesColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GravityEffectSprite*(*)()){&$GravityEffectSprite::create} != (GravityEffectSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x6d0a0, (GravityEffectSprite*(*)()){&D::create});

        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x80b20, extract((bool(D::*)()){&D::init}));

        if ((void($GravityEffectSprite::*)(cocos2d::_ccColor3)){&$GravityEffectSprite::updateSpritesColor} != (void(D::*)(cocos2d::_ccColor3)){&D::updateSpritesColor})
            m->registerHook(getBase()+0x7ce30, extract((void(D::*)(cocos2d::_ccColor3)){&D::updateSpritesColor}));
    }
};


template<class D>
class $GroupCommandObject : public GroupCommandObject, public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GroupCommandObject() {}
    typedef GroupCommandObject* __thistype;

    static GroupCommandObject* create() {
        if ((GroupCommandObject*(*)()){&$GroupCommandObject::create} != (GroupCommandObject*(*)()){&D::create})
            return reinterpret_cast<GroupCommandObject*(*)()>(m->getOriginal(getBase()+0x18b460))();
        else return GroupCommandObject::create();
    }

    static GroupCommandObject* createFromString(std::strin p0) {
        if ((GroupCommandObject*(*)(std::strin)){&$GroupCommandObject::createFromString} != (GroupCommandObject*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<GroupCommandObject*(*)(std::strin)>(m->getOriginal(getBase()+0x16ece0))(p0);
        else return GroupCommandObject::createFromString(p0);
    }

    void easeToText(in p0) {
        if ((void($GroupCommandObject::*)(in)){&$GroupCommandObject::easeToText} != (void(D::*)(in)){&D::easeToText})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
        else return GroupCommandObject::easeToText(p0);
    }

    void getEasedAction(cocos2d::CCActionInterval p0, in p1, floa p2) {
        if ((void($GroupCommandObject::*)(cocos2d::CCActionInterval, in, floa)){&$GroupCommandObject::getEasedAction} != (void(D::*)(cocos2d::CCActionInterval, in, floa)){&D::getEasedAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval, in, floa)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
        else return GroupCommandObject::getEasedAction(p0, p1, p2);
    }

    void runMoveCommand(cocos2d::CCPoin p0, floa p1, in p2, floa p3, boo p4, boo p5) {
        if ((void($GroupCommandObject::*)(cocos2d::CCPoin, floa, in, floa, boo, boo)){&$GroupCommandObject::runMoveCommand} != (void(D::*)(cocos2d::CCPoin, floa, in, floa, boo, boo)){&D::runMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, floa, in, floa, boo, boo)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
        else return GroupCommandObject::runMoveCommand(p0, p1, p2, p3, p4, p5);
    }

    void runRotateCommand(floa p0, floa p1, in p2, floa p3, boo p4) {
        if ((void($GroupCommandObject::*)(floa, floa, in, floa, boo)){&$GroupCommandObject::runRotateCommand} != (void(D::*)(floa, floa, in, floa, boo)){&D::runRotateCommand})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, in, floa, boo)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
        else return GroupCommandObject::runRotateCommand(p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((GroupCommandObject*(*)()){&$GroupCommandObject::create} != (GroupCommandObject*(*)()){&D::create})
            m->registerHook(getBase()+0x18b460, (GroupCommandObject*(*)()){&D::create});

        if ((GroupCommandObject*(*)(std::strin)){&$GroupCommandObject::createFromString} != (GroupCommandObject*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x16ece0, (GroupCommandObject*(*)(std::strin)){&D::createFromString});

        if ((void($GroupCommandObject::*)(in)){&$GroupCommandObject::easeToText} != (void(D::*)(in)){&D::easeToText})
            m->registerHook(getBase()+0x16ecb0, extract((void(D::*)(in)){&D::easeToText}));

        if ((void($GroupCommandObject::*)(cocos2d::CCActionInterval, in, floa)){&$GroupCommandObject::getEasedAction} != (void(D::*)(cocos2d::CCActionInterval, in, floa)){&D::getEasedAction})
            m->registerHook(getBase()+0x16e7b0, extract((void(D::*)(cocos2d::CCActionInterval, in, floa)){&D::getEasedAction}));

        if ((void($GroupCommandObject::*)(cocos2d::CCPoin, floa, in, floa, boo, boo)){&$GroupCommandObject::runMoveCommand} != (void(D::*)(cocos2d::CCPoin, floa, in, floa, boo, boo)){&D::runMoveCommand})
            m->registerHook(getBase()+0x16e640, extract((void(D::*)(cocos2d::CCPoin, floa, in, floa, boo, boo)){&D::runMoveCommand}));

        if ((void($GroupCommandObject::*)(floa, floa, in, floa, boo)){&$GroupCommandObject::runRotateCommand} != (void(D::*)(floa, floa, in, floa, boo)){&D::runRotateCommand})
            m->registerHook(getBase()+0x16e8f0, extract((void(D::*)(floa, floa, in, floa, boo)){&D::runRotateCommand}));
    }
};


template<class D>
class $HardStreak : public HardStreak, public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$HardStreak() {}
    typedef HardStreak* __thistype;

    void addPoint(cocos2d::CCPoin p0) {
        if ((void($HardStreak::*)(cocos2d::CCPoin)){&$HardStreak::addPoint} != (void(D::*)(cocos2d::CCPoin)){&D::addPoint})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x5c950))(this, p0);
        else return HardStreak::addPoint(p0);
    }

    void reset() {
        if ((void($HardStreak::*)()){&$HardStreak::reset} != (void(D::*)()){&D::reset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c930))(this);
        else return HardStreak::reset();
    }

    void resumeStroke() {
        if ((void($HardStreak::*)()){&$HardStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c210))(this);
        else return HardStreak::resumeStroke();
    }

    void stopStroke() {
        if ((void($HardStreak::*)()){&$HardStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c8f0))(this);
        else return HardStreak::stopStroke();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($HardStreak::*)(cocos2d::CCPoin)){&$HardStreak::addPoint} != (void(D::*)(cocos2d::CCPoin)){&D::addPoint})
            m->registerHook(getBase()+0x5c950, extract((void(D::*)(cocos2d::CCPoin)){&D::addPoint}));

        if ((void($HardStreak::*)()){&$HardStreak::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x5c930, extract((void(D::*)()){&D::reset}));

        if ((void($HardStreak::*)()){&$HardStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            m->registerHook(getBase()+0x5c210, extract((void(D::*)()){&D::resumeStroke}));

        if ((void($HardStreak::*)()){&$HardStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            m->registerHook(getBase()+0x5c8f0, extract((void(D::*)()){&D::stopStroke}));
    }
};


template<class D>
class $InfoLayer : public InfoLayer, public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$InfoLayer() {}
    typedef InfoLayer* __thistype;

    void loadPage(in p0, boo p1) {
        if ((void($InfoLayer::*)(in, boo)){&$InfoLayer::loadPage} != (void(D::*)(in, boo)){&D::loadPage})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
        else return InfoLayer::loadPage(p0, p1);
    }

    void onRefreshComments(cocos2d::CCObject p0) {
        if ((void($InfoLayer::*)(cocos2d::CCObject)){&$InfoLayer::onRefreshComments} != (void(D::*)(cocos2d::CCObject)){&D::onRefreshComments})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x459b60))(this, p0);
        else return InfoLayer::onRefreshComments(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($InfoLayer::*)(in, boo)){&$InfoLayer::loadPage} != (void(D::*)(in, boo)){&D::loadPage})
            m->registerHook(getBase()+0x458fb0, extract((void(D::*)(in, boo)){&D::loadPage}));

        if ((void($InfoLayer::*)(cocos2d::CCObject)){&$InfoLayer::onRefreshComments} != (void(D::*)(cocos2d::CCObject)){&D::onRefreshComments})
            m->registerHook(getBase()+0x459b60, extract((void(D::*)(cocos2d::CCObject)){&D::onRefreshComments}));
    }
};


template<class D>
class $LabelGameObject : public LabelGameObject, public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LabelGameObject() {}
    typedef LabelGameObject* __thistype;

    bool init() {
        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5520))(this);
        else return LabelGameObject::init();
    }

    void setObjectColor(cocos2d::_ccColor3B const p0) {
        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
        else return LabelGameObject::setObjectColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x2f5520, extract((bool(D::*)()){&D::init}));

        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor})
            m->registerHook(getBase()+0xdbca0, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setObjectColor}));
    }
};


template<class D>
class $LevelBrowserLayer : public LevelBrowserLayer, public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelBrowserLayer() {}
    typedef LevelBrowserLayer* __thistype;

    void loadPage(GJSearchObject p0) {
        if ((void($LevelBrowserLayer::*)(GJSearchObject)){&$LevelBrowserLayer::loadPage} != (void(D::*)(GJSearchObject)){&D::loadPage})
            return reinterpret_cast<void(*)(decltype(this), GJSearchObject)>(m->getOriginal(getBase()+0x253650))(this, p0);
        else return LevelBrowserLayer::loadPage(p0);
    }

    static cocos2d::CCScene* scene(GJSearchObject p0) {
        if ((cocos2d::CCScene*(*)(GJSearchObject)){&$LevelBrowserLayer::scene} != (cocos2d::CCScene*(*)(GJSearchObject)){&D::scene})
            return reinterpret_cast<cocos2d::CCScene*(*)(GJSearchObject)>(m->getOriginal(getBase()+0x2511d0))(p0);
        else return LevelBrowserLayer::scene(p0);
    }

    void setIDPopupClosed(SetIDPopup p0, in p1) {
        if ((void($LevelBrowserLayer::*)(SetIDPopup, in)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup, in)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup, in)>(m->getOriginal(getBase()+0x2554f0))(this, p0, p1);
        else return LevelBrowserLayer::setIDPopupClosed(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($LevelBrowserLayer::*)(GJSearchObject)){&$LevelBrowserLayer::loadPage} != (void(D::*)(GJSearchObject)){&D::loadPage})
            m->registerHook(getBase()+0x253650, extract((void(D::*)(GJSearchObject)){&D::loadPage}));

        if ((cocos2d::CCScene*(*)(GJSearchObject)){&$LevelBrowserLayer::scene} != (cocos2d::CCScene*(*)(GJSearchObject)){&D::scene})
            m->registerHook(getBase()+0x2511d0, (cocos2d::CCScene*(*)(GJSearchObject)){&D::scene});

        if ((void($LevelBrowserLayer::*)(SetIDPopup, in)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup, in)){&D::setIDPopupClosed})
            m->registerHook(getBase()+0x2554f0, extract((void(D::*)(SetIDPopup, in)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $LevelEditorLayer : public LevelEditorLayer, public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelEditorLayer() {}
    typedef LevelEditorLayer* __thistype;

    void activateTriggerEffect(EffectGameObject p0, floa p1, floa p2, floa p3) {
        if ((void($LevelEditorLayer::*)(EffectGameObject, floa, floa, floa)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject, floa, floa, floa)){&D::activateTriggerEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, floa, floa, floa)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::activateTriggerEffect(p0, p1, p2, p3);
    }

    GameObject* addObjectFromString(std::strin p0) {
        if ((GameObject*($LevelEditorLayer::*)(std::strin)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::strin)){&D::addObjectFromString})
            return reinterpret_cast<GameObject*(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x94640))(this, p0);
        else return LevelEditorLayer::addObjectFromString(p0);
    }

    void addSpecial(GameObject p0) {
        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject)){&D::addSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x94f30))(this, p0);
        else return LevelEditorLayer::addSpecial(p0);
    }

    void addToGroup(GameObject p0, in p1, boo p2) {
        if ((void($LevelEditorLayer::*)(GameObject, in, boo)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject, in, boo)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject, in, boo)>(m->getOriginal(getBase()+0x9dab0))(this, p0, p1, p2);
        else return LevelEditorLayer::addToGroup(p0, p1, p2);
    }

    void addToRedoList(UndoObject p0) {
        if ((void($LevelEditorLayer::*)(UndoObject)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject)){&D::addToRedoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject)>(m->getOriginal(getBase()+0x96f80))(this, p0);
        else return LevelEditorLayer::addToRedoList(p0);
    }

    void addToUndoList(UndoObject p0, boo p1) {
        if ((void($LevelEditorLayer::*)(UndoObject, boo)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject, boo)){&D::addToUndoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject, boo)>(m->getOriginal(getBase()+0x94e20))(this, p0, p1);
        else return LevelEditorLayer::addToUndoList(p0, p1);
    }

    void animateInDualGround(GameObject p0, floa p1, boo p2) {
        if ((void($LevelEditorLayer::*)(GameObject, floa, boo)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject, floa, boo)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject, floa, boo)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
        else return LevelEditorLayer::animateInDualGround(p0, p1, p2);
    }

    void calculateColorValues(EffectGameObject p0, EffectGameObject p1, in p2, floa p3, ColorActionSprite p4, GJEffectManager p5) override {
        if ((void($LevelEditorLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)>(m->getOriginal(getBase()+0x9c590))(this, p0, p1, p2, p3, p4, p5);
        else return LevelEditorLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void checkCollisions(PlayerObject p0, floa p1) {
        if ((void($LevelEditorLayer::*)(PlayerObject, floa)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject, floa)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, floa)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
        else return LevelEditorLayer::checkCollisions(p0, p1);
    }

    static LevelEditorLayer* create(GJGameLevel p0) {
        if ((LevelEditorLayer*(*)(GJGameLevel)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel)){&D::create})
            return reinterpret_cast<LevelEditorLayer*(*)(GJGameLevel)>(m->getOriginal(getBase()+0x90fb0))(p0);
        else return LevelEditorLayer::create(p0);
    }

    void createBackground() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x929f0))(this);
        else return LevelEditorLayer::createBackground();
    }

    void createGroundLayer() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92840))(this);
        else return LevelEditorLayer::createGroundLayer();
    }

    GameObject* createObject(in p0, cocos2d::CCPoin p1, boo p2) {
        if ((GameObject*($LevelEditorLayer::*)(in, cocos2d::CCPoin, boo)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(in, cocos2d::CCPoin, boo)){&D::createObject})
            return reinterpret_cast<GameObject*(*)(decltype(this), in, cocos2d::CCPoin, boo)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
        else return LevelEditorLayer::createObject(p0, p1, p2);
    }

    void createObjectsFromSetup(std::strin p0) {
        if ((void($LevelEditorLayer::*)(std::strin)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::strin)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x92230))(this, p0);
        else return LevelEditorLayer::createObjectsFromSetup(p0);
    }

    void createObjectsFromString(std::strin p0, boo p1) {
        if ((void($LevelEditorLayer::*)(std::strin, boo)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::strin, boo)){&D::createObjectsFromString})
            return reinterpret_cast<void(*)(decltype(this), std::strin, boo)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
        else return LevelEditorLayer::createObjectsFromString(p0, p1);
    }

    void draw() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa2a70))(this);
        else return LevelEditorLayer::draw();
    }

    void flipGravity(PlayerObject p0, boo p1, boo p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject, boo, boo)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, boo, boo)>(m->getOriginal(getBase()+0xa04e0))(this, p0, p1, p2);
        else return LevelEditorLayer::flipGravity(p0, p1, p2);
    }

    void getLastObjectX() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c860))(this);
        else return LevelEditorLayer::getLastObjectX();
    }

    void getLevelString() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97790))(this);
        else return LevelEditorLayer::getLevelString();
    }

    void getNextColorChannel() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a610))(this);
        else return LevelEditorLayer::getNextColorChannel();
    }

    void getNextFreeBlockID(cocos2d::CCArray p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray)){&D::getNextFreeBlockID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray)>(m->getOriginal(getBase()+0x9a4e0))(this, p0);
        else return LevelEditorLayer::getNextFreeBlockID(p0);
    }

    int getNextFreeGroupID(cocos2d::CCArray p0) {
        if ((int($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray)){&D::getNextFreeGroupID})
            return reinterpret_cast<int(*)(decltype(this), cocos2d::CCArray)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
        else return LevelEditorLayer::getNextFreeGroupID(p0);
    }

    void getNextFreeItemID(cocos2d::CCArray p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray)){&D::getNextFreeItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray)>(m->getOriginal(getBase()+0x9a390))(this, p0);
        else return LevelEditorLayer::getNextFreeItemID(p0);
    }

    void getObjectRect(GameObject p0, boo p1) {
        if ((void($LevelEditorLayer::*)(GameObject, boo)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject, boo)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo)>(m->getOriginal(getBase()+0x96240))(this, p0, p1);
        else return LevelEditorLayer::getObjectRect(p0, p1);
    }

    void getRelativeOffset(GameObject p0) {
        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject)){&D::getRelativeOffset})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x96840))(this, p0);
        else return LevelEditorLayer::getRelativeOffset(p0);
    }

    void handleAction(boo p0, cocos2d::CCArray p1) {
        if ((void($LevelEditorLayer::*)(boo, cocos2d::CCArray)){&$LevelEditorLayer::handleAction} != (void(D::*)(boo, cocos2d::CCArray)){&D::handleAction})
            return reinterpret_cast<void(*)(decltype(this), boo, cocos2d::CCArray)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
        else return LevelEditorLayer::handleAction(p0, p1);
    }

    bool init(GJGameLevel p0) {
        if ((bool($LevelEditorLayer::*)(GJGameLevel)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x91010))(this, p0);
        else return LevelEditorLayer::init(p0);
    }

    void levelSettingsUpdated() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93f30))(this);
        else return LevelEditorLayer::levelSettingsUpdated();
    }

    void objectAtPosition(cocos2d::CCPoin p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCPoin)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoin)){&D::objectAtPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x960c0))(this, p0);
        else return LevelEditorLayer::objectAtPosition(p0);
    }

    void objectMoved(GameObject p0) {
        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject)){&D::objectMoved})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x999f0))(this, p0);
        else return LevelEditorLayer::objectMoved(p0);
    }

    void objectsInRect(cocos2d::CCRec p0, boo p1) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCRec, boo)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRec, boo)){&D::objectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRec, boo)>(m->getOriginal(getBase()+0x95e60))(this, p0, p1);
        else return LevelEditorLayer::objectsInRect(p0, p1);
    }

    void onPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa06b0))(this);
        else return LevelEditorLayer::onPlaytest();
    }

    void onStopPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa1780))(this);
        else return LevelEditorLayer::onStopPlaytest();
    }

    void playMusic() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa13c0))(this);
        else return LevelEditorLayer::playMusic();
    }

    void recreateGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9dbf0))(this);
        else return LevelEditorLayer::recreateGroups();
    }

    void redoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
        else return LevelEditorLayer::redoLastAction();
    }

    void removeAllObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
        else return LevelEditorLayer::removeAllObjects();
    }

    void removeAllObjectsOfType(in p0) {
        if ((void($LevelEditorLayer::*)(in)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(in)){&D::removeAllObjectsOfType})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x96d40))(this, p0);
        else return LevelEditorLayer::removeAllObjectsOfType(p0);
    }

    void removeFromGroup(GameObject p0, in p1) {
        if ((void($LevelEditorLayer::*)(GameObject, in)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject, in)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject, in)>(m->getOriginal(getBase()+0x9db60))(this, p0, p1);
        else return LevelEditorLayer::removeFromGroup(p0, p1);
    }

    void removeObject(GameObject p0, boo p1) {
        if ((void($LevelEditorLayer::*)(GameObject, boo)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject, boo)){&D::removeObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
        else return LevelEditorLayer::removeObject(p0, p1);
    }

    void removeSpecial(GameObject p0) {
        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject)){&D::removeSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x969c0))(this, p0);
        else return LevelEditorLayer::removeSpecial(p0);
    }

    void resetMovingObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9ddc0))(this);
        else return LevelEditorLayer::resetMovingObjects();
    }

    void resetObjectVector() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c4b0))(this);
        else return LevelEditorLayer::resetObjectVector();
    }

    void resetToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9aa70))(this);
        else return LevelEditorLayer::resetToggledGroups();
    }

    void resetToggledGroupsAndObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c3c0))(this);
        else return LevelEditorLayer::resetToggledGroupsAndObjects();
    }

    void resetUnusedColorChannels() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a870))(this);
        else return LevelEditorLayer::resetUnusedColorChannels();
    }

    void rotationForSlopeNearObject(GameObject p0) {
        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject)){&D::rotationForSlopeNearObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x95cd0))(this, p0);
        else return LevelEditorLayer::rotationForSlopeNearObject(p0);
    }

    void runColorEffect(EffectGameObject p0, in p1, floa p2, floa p3, boo p4) {
        if ((void($LevelEditorLayer::*)(EffectGameObject, in, floa, floa, boo)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject, in, floa, floa, boo)){&D::runColorEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, in, floa, floa, boo)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
        else return LevelEditorLayer::runColorEffect(p0, p1, p2, p3, p4);
    }

    void scene(GJGameLevel p0) {
        if ((void($LevelEditorLayer::*)(GJGameLevel)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x90f20))(this, p0);
        else return LevelEditorLayer::scene(p0);
    }

    void setupLevelStart(LevelSettingsObject p0) {
        if ((void($LevelEditorLayer::*)(LevelSettingsObject)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
        else return LevelEditorLayer::setupLevelStart(p0);
    }

    void sortStickyGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92b10))(this);
        else return LevelEditorLayer::sortStickyGroups();
    }

    void stopTriggersInGroup(in p0, floa p1) {
        if ((void($LevelEditorLayer::*)(in, floa)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(in, floa)){&D::stopTriggersInGroup})
            return reinterpret_cast<void(*)(decltype(this), in, floa)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
        else return LevelEditorLayer::stopTriggersInGroup(p0, p1);
    }

    void timeForXPos(floa p0) {
        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x9c7d0))(this, p0);
        else return LevelEditorLayer::timeForXPos(p0);
    }

    void toggleDualMode(GameObject p0, boo p1, PlayerObject p2, boo p3) {
        if ((void($LevelEditorLayer::*)(GameObject, boo, PlayerObject, boo)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo, PlayerObject, boo)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::toggleDualMode(p0, p1, p2, p3);
    }

    void toggleGroupPreview(in p0, boo p1) {
        if ((void($LevelEditorLayer::*)(in, boo)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(in, boo)){&D::toggleGroupPreview})
            return reinterpret_cast<void(*)(decltype(this), in, boo)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
        else return LevelEditorLayer::toggleGroupPreview(p0, p1);
    }

    void transferDefaultColors(GJEffectManager p0, GJEffectManager p1) {
        if ((void($LevelEditorLayer::*)(GJEffectManager, GJEffectManager)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager, GJEffectManager)){&D::transferDefaultColors})
            return reinterpret_cast<void(*)(decltype(this), GJEffectManager, GJEffectManager)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
        else return LevelEditorLayer::transferDefaultColors(p0, p1);
    }

    void undoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
        else return LevelEditorLayer::undoLastAction();
    }

    void update(floa p0) {
        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::update} != (void(D::*)(floa)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
        else return LevelEditorLayer::update(p0);
    }

    void updateBGAndGColors() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9b9b0))(this);
        else return LevelEditorLayer::updateBGAndGColors();
    }

    void updateBlendValues() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bc60))(this);
        else return LevelEditorLayer::updateBlendValues();
    }

    void updateColor(cocos2d::_ccColor3 p0, floa p1, in p2, boo p3, floa p4, cocos2d::_ccHSVValu p5, in p6, boo p7, in p8, EffectGameObject p9) {
        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)>(m->getOriginal(getBase()+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return LevelEditorLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject p0, in p1, boo p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject, in, boo)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject, in, boo)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, in, boo)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
        else return LevelEditorLayer::updateDualGround(p0, p1, p2);
    }

    void updateEditorMode() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93b50))(this);
        else return LevelEditorLayer::updateEditorMode();
    }

    void updateGameObjectsNew() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9adc0))(this);
        else return LevelEditorLayer::updateGameObjectsNew();
    }

    void updateGround(floa p0) {
        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::updateGround} != (void(D::*)(floa)){&D::updateGround})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x93a60))(this, p0);
        else return LevelEditorLayer::updateGround(p0);
    }

    void updateGroundWidth() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92af0))(this);
        else return LevelEditorLayer::updateGroundWidth();
    }

    void updateOptions() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x91ed0))(this);
        else return LevelEditorLayer::updateOptions();
    }

    void updateToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bb10))(this);
        else return LevelEditorLayer::updateToggledGroups();
    }

    void updateVisibility(floa p0) {
        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(floa)){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x92c70))(this, p0);
        else return LevelEditorLayer::updateVisibility(p0);
    }

    void xPosForTime(floa p0) {
        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x9c800))(this, p0);
        else return LevelEditorLayer::xPosForTime(p0);
    }

     ~LevelEditorLayer() {
        if ((($LevelEditorLayer::*)()){&$LevelEditorLayer::~LevelEditorLayer} != ((D::*)()){&D::~LevelEditorLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x90a00))(this);
        else return LevelEditorLayer::~LevelEditorLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($LevelEditorLayer::*)(EffectGameObject, floa, floa, floa)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject, floa, floa, floa)){&D::activateTriggerEffect})
            m->registerHook(getBase()+0x9b520, extract((void(D::*)(EffectGameObject, floa, floa, floa)){&D::activateTriggerEffect}));

        if ((GameObject*($LevelEditorLayer::*)(std::strin)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::strin)){&D::addObjectFromString})
            m->registerHook(getBase()+0x94640, extract((GameObject*(D::*)(std::strin)){&D::addObjectFromString}));

        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject)){&D::addSpecial})
            m->registerHook(getBase()+0x94f30, extract((void(D::*)(GameObject)){&D::addSpecial}));

        if ((void($LevelEditorLayer::*)(GameObject, in, boo)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject, in, boo)){&D::addToGroup})
            m->registerHook(getBase()+0x9dab0, extract((void(D::*)(GameObject, in, boo)){&D::addToGroup}));

        if ((void($LevelEditorLayer::*)(UndoObject)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject)){&D::addToRedoList})
            m->registerHook(getBase()+0x96f80, extract((void(D::*)(UndoObject)){&D::addToRedoList}));

        if ((void($LevelEditorLayer::*)(UndoObject, boo)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject, boo)){&D::addToUndoList})
            m->registerHook(getBase()+0x94e20, extract((void(D::*)(UndoObject, boo)){&D::addToUndoList}));

        if ((void($LevelEditorLayer::*)(GameObject, floa, boo)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject, floa, boo)){&D::animateInDualGround})
            m->registerHook(getBase()+0xa2780, extract((void(D::*)(GameObject, floa, boo)){&D::animateInDualGround}));

        if ((void($LevelEditorLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            m->registerHook(getBase()+0x9c590, extract((void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues}));

        if ((void($LevelEditorLayer::*)(PlayerObject, floa)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject, floa)){&D::checkCollisions})
            m->registerHook(getBase()+0x9e620, extract((void(D::*)(PlayerObject, floa)){&D::checkCollisions}));

        if ((LevelEditorLayer*(*)(GJGameLevel)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel)){&D::create})
            m->registerHook(getBase()+0x90fb0, (LevelEditorLayer*(*)(GJGameLevel)){&D::create});

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            m->registerHook(getBase()+0x929f0, extract((void(D::*)()){&D::createBackground}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            m->registerHook(getBase()+0x92840, extract((void(D::*)()){&D::createGroundLayer}));

        if ((GameObject*($LevelEditorLayer::*)(in, cocos2d::CCPoin, boo)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(in, cocos2d::CCPoin, boo)){&D::createObject})
            m->registerHook(getBase()+0x957c0, extract((GameObject*(D::*)(in, cocos2d::CCPoin, boo)){&D::createObject}));

        if ((void($LevelEditorLayer::*)(std::strin)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::strin)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x92230, extract((void(D::*)(std::strin)){&D::createObjectsFromSetup}));

        if ((void($LevelEditorLayer::*)(std::strin, boo)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::strin, boo)){&D::createObjectsFromString})
            m->registerHook(getBase()+0x94730, extract((void(D::*)(std::strin, boo)){&D::createObjectsFromString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0xa2a70, extract((void(D::*)()){&D::draw}));

        if ((void($LevelEditorLayer::*)(PlayerObject, boo, boo)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            m->registerHook(getBase()+0xa04e0, extract((void(D::*)(PlayerObject, boo, boo)){&D::flipGravity}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            m->registerHook(getBase()+0x9c860, extract((void(D::*)()){&D::getLastObjectX}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            m->registerHook(getBase()+0x97790, extract((void(D::*)()){&D::getLevelString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            m->registerHook(getBase()+0x9a610, extract((void(D::*)()){&D::getNextColorChannel}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray)){&D::getNextFreeBlockID})
            m->registerHook(getBase()+0x9a4e0, extract((void(D::*)(cocos2d::CCArray)){&D::getNextFreeBlockID}));

        if ((int($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray)){&D::getNextFreeGroupID})
            m->registerHook(getBase()+0x9a1b0, extract((int(D::*)(cocos2d::CCArray)){&D::getNextFreeGroupID}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray)){&D::getNextFreeItemID})
            m->registerHook(getBase()+0x9a390, extract((void(D::*)(cocos2d::CCArray)){&D::getNextFreeItemID}));

        if ((void($LevelEditorLayer::*)(GameObject, boo)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject, boo)){&D::getObjectRect})
            m->registerHook(getBase()+0x96240, extract((void(D::*)(GameObject, boo)){&D::getObjectRect}));

        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x96840, extract((void(D::*)(GameObject)){&D::getRelativeOffset}));

        if ((void($LevelEditorLayer::*)(boo, cocos2d::CCArray)){&$LevelEditorLayer::handleAction} != (void(D::*)(boo, cocos2d::CCArray)){&D::handleAction})
            m->registerHook(getBase()+0x97020, extract((void(D::*)(boo, cocos2d::CCArray)){&D::handleAction}));

        if ((bool($LevelEditorLayer::*)(GJGameLevel)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel)){&D::init})
            m->registerHook(getBase()+0x91010, extract((bool(D::*)(GJGameLevel)){&D::init}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            m->registerHook(getBase()+0x93f30, extract((void(D::*)()){&D::levelSettingsUpdated}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCPoin)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoin)){&D::objectAtPosition})
            m->registerHook(getBase()+0x960c0, extract((void(D::*)(cocos2d::CCPoin)){&D::objectAtPosition}));

        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject)){&D::objectMoved})
            m->registerHook(getBase()+0x999f0, extract((void(D::*)(GameObject)){&D::objectMoved}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCRec, boo)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRec, boo)){&D::objectsInRect})
            m->registerHook(getBase()+0x95e60, extract((void(D::*)(cocos2d::CCRec, boo)){&D::objectsInRect}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            m->registerHook(getBase()+0xa06b0, extract((void(D::*)()){&D::onPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            m->registerHook(getBase()+0xa1780, extract((void(D::*)()){&D::onStopPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            m->registerHook(getBase()+0xa13c0, extract((void(D::*)()){&D::playMusic}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            m->registerHook(getBase()+0x9dbf0, extract((void(D::*)()){&D::recreateGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            m->registerHook(getBase()+0x97750, extract((void(D::*)()){&D::redoLastAction}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x93d80, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($LevelEditorLayer::*)(in)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(in)){&D::removeAllObjectsOfType})
            m->registerHook(getBase()+0x96d40, extract((void(D::*)(in)){&D::removeAllObjectsOfType}));

        if ((void($LevelEditorLayer::*)(GameObject, in)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject, in)){&D::removeFromGroup})
            m->registerHook(getBase()+0x9db60, extract((void(D::*)(GameObject, in)){&D::removeFromGroup}));

        if ((void($LevelEditorLayer::*)(GameObject, boo)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject, boo)){&D::removeObject})
            m->registerHook(getBase()+0x96890, extract((void(D::*)(GameObject, boo)){&D::removeObject}));

        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject)){&D::removeSpecial})
            m->registerHook(getBase()+0x969c0, extract((void(D::*)(GameObject)){&D::removeSpecial}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            m->registerHook(getBase()+0x9ddc0, extract((void(D::*)()){&D::resetMovingObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            m->registerHook(getBase()+0x9c4b0, extract((void(D::*)()){&D::resetObjectVector}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x9aa70, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            m->registerHook(getBase()+0x9c3c0, extract((void(D::*)()){&D::resetToggledGroupsAndObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            m->registerHook(getBase()+0x9a870, extract((void(D::*)()){&D::resetUnusedColorChannels}));

        if ((void($LevelEditorLayer::*)(GameObject)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject)){&D::rotationForSlopeNearObject})
            m->registerHook(getBase()+0x95cd0, extract((void(D::*)(GameObject)){&D::rotationForSlopeNearObject}));

        if ((void($LevelEditorLayer::*)(EffectGameObject, in, floa, floa, boo)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject, in, floa, floa, boo)){&D::runColorEffect})
            m->registerHook(getBase()+0x9bd30, extract((void(D::*)(EffectGameObject, in, floa, floa, boo)){&D::runColorEffect}));

        if ((void($LevelEditorLayer::*)(GJGameLevel)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel)){&D::scene})
            m->registerHook(getBase()+0x90f20, extract((void(D::*)(GJGameLevel)){&D::scene}));

        if ((void($LevelEditorLayer::*)(LevelSettingsObject)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject)){&D::setupLevelStart})
            m->registerHook(getBase()+0xa0ca0, extract((void(D::*)(LevelSettingsObject)){&D::setupLevelStart}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            m->registerHook(getBase()+0x92b10, extract((void(D::*)()){&D::sortStickyGroups}));

        if ((void($LevelEditorLayer::*)(in, floa)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(in, floa)){&D::stopTriggersInGroup})
            m->registerHook(getBase()+0x9c030, extract((void(D::*)(in, floa)){&D::stopTriggersInGroup}));

        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            m->registerHook(getBase()+0x9c7d0, extract((void(D::*)(floa)){&D::timeForXPos}));

        if ((void($LevelEditorLayer::*)(GameObject, boo, PlayerObject, boo)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode})
            m->registerHook(getBase()+0xa0200, extract((void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode}));

        if ((void($LevelEditorLayer::*)(in, boo)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(in, boo)){&D::toggleGroupPreview})
            m->registerHook(getBase()+0x9bea0, extract((void(D::*)(in, boo)){&D::toggleGroupPreview}));

        if ((void($LevelEditorLayer::*)(GJEffectManager, GJEffectManager)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager, GJEffectManager)){&D::transferDefaultColors})
            m->registerHook(getBase()+0x9ab50, extract((void(D::*)(GJEffectManager, GJEffectManager)){&D::transferDefaultColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            m->registerHook(getBase()+0x97770, extract((void(D::*)()){&D::undoLastAction}));

        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::update} != (void(D::*)(floa)){&D::update})
            m->registerHook(getBase()+0xa1b70, extract((void(D::*)(floa)){&D::update}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            m->registerHook(getBase()+0x9b9b0, extract((void(D::*)()){&D::updateBGAndGColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            m->registerHook(getBase()+0x9bc60, extract((void(D::*)()){&D::updateBlendValues}));

        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            m->registerHook(getBase()+0x9c200, extract((void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor}));

        if ((void($LevelEditorLayer::*)(PlayerObject, in, boo)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject, in, boo)){&D::updateDualGround})
            m->registerHook(getBase()+0xa1a60, extract((void(D::*)(PlayerObject, in, boo)){&D::updateDualGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            m->registerHook(getBase()+0x93b50, extract((void(D::*)()){&D::updateEditorMode}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            m->registerHook(getBase()+0x9adc0, extract((void(D::*)()){&D::updateGameObjectsNew}));

        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::updateGround} != (void(D::*)(floa)){&D::updateGround})
            m->registerHook(getBase()+0x93a60, extract((void(D::*)(floa)){&D::updateGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x92af0, extract((void(D::*)()){&D::updateGroundWidth}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            m->registerHook(getBase()+0x91ed0, extract((void(D::*)()){&D::updateOptions}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            m->registerHook(getBase()+0x9bb10, extract((void(D::*)()){&D::updateToggledGroups}));

        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(floa)){&D::updateVisibility})
            m->registerHook(getBase()+0x92c70, extract((void(D::*)(floa)){&D::updateVisibility}));

        if ((void($LevelEditorLayer::*)(floa)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c800, extract((void(D::*)(floa)){&D::xPosForTime}));

        if ((($LevelEditorLayer::*)()){&$LevelEditorLayer::~LevelEditorLayer} != ((D::*)()){&D::~LevelEditorLayer})
            m->registerHook(getBase()+0x90a00, extract(((D::*)()){&D::~LevelEditorLayer}));
    }
};


template<class D>
class $LevelSettingsLayer : public LevelSettingsLayer, public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelSettingsLayer() {}
    typedef LevelSettingsLayer* __thistype;

    static LevelSettingsLayer* create(LevelSettingsObject p0, LevelEditorLayer p1) {
        if ((LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)){&$LevelSettingsLayer::create} != (LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)){&D::create})
            return reinterpret_cast<LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)>(m->getOriginal(getBase()+0xa7c30))(p0, p1);
        else return LevelSettingsLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)){&$LevelSettingsLayer::create} != (LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)){&D::create})
            m->registerHook(getBase()+0xa7c30, (LevelSettingsLayer*(*)(LevelSettingsObject, LevelEditorLayer)){&D::create});
    }
};


template<class D>
class $LevelSettingsObject : public LevelSettingsObject, public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelSettingsObject() {}
    typedef LevelSettingsObject* __thistype;

    static LevelSettingsObject* create() {
        if ((LevelSettingsObject*(*)()){&$LevelSettingsObject::create} != (LevelSettingsObject*(*)()){&D::create})
            return reinterpret_cast<LevelSettingsObject*(*)()>(m->getOriginal(getBase()+0x92760))();
        else return LevelSettingsObject::create();
    }

    bool init() {
        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xa5690))(this);
        else return LevelSettingsObject::init();
    }

    void objectFromDict(cocos2d::CCDictionary p0) {
        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary)){&$LevelSettingsObject::objectFromDict} != (void(D::*)(cocos2d::CCDictionary)){&D::objectFromDict})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary)>(m->getOriginal(getBase()+0xa5810))(this, p0);
        else return LevelSettingsObject::objectFromDict(p0);
    }

    static LevelSettingsObject* objectFromString(std::strin p0) {
        if ((LevelSettingsObject*(*)(std::strin)){&$LevelSettingsObject::objectFromString} != (LevelSettingsObject*(*)(std::strin)){&D::objectFromString})
            return reinterpret_cast<LevelSettingsObject*(*)(std::strin)>(m->getOriginal(getBase()+0x945a0))(p0);
        else return LevelSettingsObject::objectFromString(p0);
    }

    void setupColorsFromLegacyMode(cocos2d::CCDictionary p0) {
        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary)){&$LevelSettingsObject::setupColorsFromLegacyMode} != (void(D::*)(cocos2d::CCDictionary)){&D::setupColorsFromLegacyMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
        else return LevelSettingsObject::setupColorsFromLegacyMode(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((LevelSettingsObject*(*)()){&$LevelSettingsObject::create} != (LevelSettingsObject*(*)()){&D::create})
            m->registerHook(getBase()+0x92760, (LevelSettingsObject*(*)()){&D::create});

        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xa5690, extract((bool(D::*)()){&D::init}));

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary)){&$LevelSettingsObject::objectFromDict} != (void(D::*)(cocos2d::CCDictionary)){&D::objectFromDict})
            m->registerHook(getBase()+0xa5810, extract((void(D::*)(cocos2d::CCDictionary)){&D::objectFromDict}));

        if ((LevelSettingsObject*(*)(std::strin)){&$LevelSettingsObject::objectFromString} != (LevelSettingsObject*(*)(std::strin)){&D::objectFromString})
            m->registerHook(getBase()+0x945a0, (LevelSettingsObject*(*)(std::strin)){&D::objectFromString});

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary)){&$LevelSettingsObject::setupColorsFromLegacyMode} != (void(D::*)(cocos2d::CCDictionary)){&D::setupColorsFromLegacyMode})
            m->registerHook(getBase()+0xa6a30, extract((void(D::*)(cocos2d::CCDictionary)){&D::setupColorsFromLegacyMode}));
    }
};


template<class D>
class $LevelTools : public LevelTools, public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelTools() {}
    typedef LevelTools* __thistype;

    void getAudioString(in p0) {
        if ((void($LevelTools::*)(in)){&$LevelTools::getAudioString} != (void(D::*)(in)){&D::getAudioString})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x293880))(this, p0);
        else return LevelTools::getAudioString(p0);
    }

    void verifyLevelIntegrity(std::strin p0, in p1) {
        if ((void($LevelTools::*)(std::strin, in)){&$LevelTools::verifyLevelIntegrity} != (void(D::*)(std::strin, in)){&D::verifyLevelIntegrity})
            return reinterpret_cast<void(*)(decltype(this), std::strin, in)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
        else return LevelTools::verifyLevelIntegrity(p0, p1);
    }

    void xPosForTime(floa p0, cocos2d::CCArray p1, in p2) {
        if ((void($LevelTools::*)(floa, cocos2d::CCArray, in)){&$LevelTools::xPosForTime} != (void(D::*)(floa, cocos2d::CCArray, in)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), floa, cocos2d::CCArray, in)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
        else return LevelTools::xPosForTime(p0, p1, p2);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($LevelTools::*)(in)){&$LevelTools::getAudioString} != (void(D::*)(in)){&D::getAudioString})
            m->registerHook(getBase()+0x293880, extract((void(D::*)(in)){&D::getAudioString}));

        if ((void($LevelTools::*)(std::strin, in)){&$LevelTools::verifyLevelIntegrity} != (void(D::*)(std::strin, in)){&D::verifyLevelIntegrity})
            m->registerHook(getBase()+0x294360, extract((void(D::*)(std::strin, in)){&D::verifyLevelIntegrity}));

        if ((void($LevelTools::*)(floa, cocos2d::CCArray, in)){&$LevelTools::xPosForTime} != (void(D::*)(floa, cocos2d::CCArray, in)){&D::xPosForTime})
            m->registerHook(getBase()+0x293d90, extract((void(D::*)(floa, cocos2d::CCArray, in)){&D::xPosForTime}));
    }
};


template<class D>
class $LoadingLayer : public LoadingLayer, public $CacBase {
 public:
    $LoadingLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LoadingLayer() {}
    typedef LoadingLayer* __thistype;

    void loadAssets() {
        if ((void($LoadingLayer::*)()){&$LoadingLayer::loadAssets} != (void(D::*)()){&D::loadAssets})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1dfb20))(this);
        else return LoadingLayer::loadAssets();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($LoadingLayer::*)()){&$LoadingLayer::loadAssets} != (void(D::*)()){&D::loadAssets})
            m->registerHook(getBase()+0x1dfb20, extract((void(D::*)()){&D::loadAssets}));
    }
};


template<class D>
class $LocalLevelManager : public LocalLevelManager, public $CacBase {
 public:
    $LocalLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LocalLevelManager() {}
    typedef LocalLevelManager* __thistype;

    static LocalLevelManager* sharedState() {
        if ((LocalLevelManager*(*)()){&$LocalLevelManager::sharedState} != (LocalLevelManager*(*)()){&D::sharedState})
            return reinterpret_cast<LocalLevelManager*(*)()>(m->getOriginal(getBase()+0x35dd60))();
        else return LocalLevelManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((LocalLevelManager*(*)()){&$LocalLevelManager::sharedState} != (LocalLevelManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x35dd60, (LocalLevelManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $MenuGameLayer : public MenuGameLayer, public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MenuGameLayer() {}
    typedef MenuGameLayer* __thistype;

    void resetPlayer() {
        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer} != (void(D::*)()){&D::resetPlayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28fdc0))(this);
        else return MenuGameLayer::resetPlayer();
    }

    void update(floa p0) {
        if ((void($MenuGameLayer::*)(floa)){&$MenuGameLayer::update} != (void(D::*)(floa)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
        else return MenuGameLayer::update(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer} != (void(D::*)()){&D::resetPlayer})
            m->registerHook(getBase()+0x28fdc0, extract((void(D::*)()){&D::resetPlayer}));

        if ((void($MenuGameLayer::*)(floa)){&$MenuGameLayer::update} != (void(D::*)(floa)){&D::update})
            m->registerHook(getBase()+0x28fa70, extract((void(D::*)(floa)){&D::update}));
    }
};


template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MenuLayer() {}
    typedef MenuLayer* __thistype;

    void keyBackClicked() override {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3160))(this);
        else return MenuLayer::keyBackClicked();
    }

    void onMoreGames(cocos2d::CCObject p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject)){&D::onMoreGames})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
        else return MenuLayer::onMoreGames(p0);
    }

    void onQuit(cocos2d::CCObject p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject)){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
        else return MenuLayer::onQuit(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x1d3160, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::CCObject)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject)){&D::onMoreGames})
            m->registerHook(getBase()+0x1d2ad0, extract((void(D::*)(cocos2d::CCObject)){&D::onMoreGames}));

        if ((void($MenuLayer::*)(cocos2d::CCObject)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject)){&D::onQuit})
            m->registerHook(getBase()+0x1d2b40, extract((void(D::*)(cocos2d::CCObject)){&D::onQuit}));
    }
};


template<class D>
class $MoreVideoOptionsLayer : public MoreVideoOptionsLayer, public $CacBase {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MoreVideoOptionsLayer() {}
    typedef MoreVideoOptionsLayer* __thistype;

    static MoreVideoOptionsLayer* create() {
        if ((MoreVideoOptionsLayer*(*)()){&$MoreVideoOptionsLayer::create} != (MoreVideoOptionsLayer*(*)()){&D::create})
            return reinterpret_cast<MoreVideoOptionsLayer*(*)()>(m->getOriginal(getBase()+0x443c10))();
        else return MoreVideoOptionsLayer::create();
    }

    bool init() {
        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
        else return MoreVideoOptionsLayer::init();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((MoreVideoOptionsLayer*(*)()){&$MoreVideoOptionsLayer::create} != (MoreVideoOptionsLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x443c10, (MoreVideoOptionsLayer*(*)()){&D::create});

        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x444150, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $MusicDownloadManager : public MusicDownloadManager, public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MusicDownloadManager() {}
    typedef MusicDownloadManager* __thistype;

    void incrementPriorityForSong(in p0) {
        if ((void($MusicDownloadManager::*)(in)){&$MusicDownloadManager::incrementPriorityForSong} != (void(D::*)(in)){&D::incrementPriorityForSong})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
        else return MusicDownloadManager::incrementPriorityForSong(p0);
    }

    static MusicDownloadManager* sharedState() {
        if ((MusicDownloadManager*(*)()){&$MusicDownloadManager::sharedState} != (MusicDownloadManager*(*)()){&D::sharedState})
            return reinterpret_cast<MusicDownloadManager*(*)()>(m->getOriginal(getBase()+0x2ee4c0))();
        else return MusicDownloadManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($MusicDownloadManager::*)(in)){&$MusicDownloadManager::incrementPriorityForSong} != (void(D::*)(in)){&D::incrementPriorityForSong})
            m->registerHook(getBase()+0x2ef750, extract((void(D::*)(in)){&D::incrementPriorityForSong}));

        if ((MusicDownloadManager*(*)()){&$MusicDownloadManager::sharedState} != (MusicDownloadManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x2ee4c0, (MusicDownloadManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $OBB2D : public OBB2D, public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$OBB2D() {}
    typedef OBB2D* __thistype;

    void calculateWithCenter(cocos2d::CCPoin p0, floa p1, floa p2, floa p3) {
        if ((void($OBB2D::*)(cocos2d::CCPoin, floa, floa, floa)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::calculateWithCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, floa, floa, floa)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
        else return OBB2D::calculateWithCenter(p0, p1, p2, p3);
    }

    static OBB2D* create(cocos2d::CCPoin p0, floa p1, floa p2, floa p3) {
        if ((OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)){&D::create})
            return reinterpret_cast<OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)>(m->getOriginal(getBase()+0x35a890))(p0, p1, p2, p3);
        else return OBB2D::create(p0, p1, p2, p3);
    }

    void getBoundingRect() {
        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35b2b0))(this);
        else return OBB2D::getBoundingRect();
    }

    void overlaps(OBB2D p0) {
        if ((void($OBB2D::*)(OBB2D)){&$OBB2D::overlaps} != (void(D::*)(OBB2D)){&D::overlaps})
            return reinterpret_cast<void(*)(decltype(this), OBB2D)>(m->getOriginal(getBase()+0x35b0a0))(this, p0);
        else return OBB2D::overlaps(p0);
    }

    void overlaps1Way(OBB2D p0) {
        if ((void($OBB2D::*)(OBB2D)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D)){&D::overlaps1Way})
            return reinterpret_cast<void(*)(decltype(this), OBB2D)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
        else return OBB2D::overlaps1Way(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($OBB2D::*)(cocos2d::CCPoin, floa, floa, floa)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::calculateWithCenter})
            m->registerHook(getBase()+0x35a9c0, extract((void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::calculateWithCenter}));

        if ((OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)){&D::create})
            m->registerHook(getBase()+0x35a890, (OBB2D*(*)(cocos2d::CCPoin, floa, floa, floa)){&D::create});

        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            m->registerHook(getBase()+0x35b2b0, extract((void(D::*)()){&D::getBoundingRect}));

        if ((void($OBB2D::*)(OBB2D)){&$OBB2D::overlaps} != (void(D::*)(OBB2D)){&D::overlaps})
            m->registerHook(getBase()+0x35b0a0, extract((void(D::*)(OBB2D)){&D::overlaps}));

        if ((void($OBB2D::*)(OBB2D)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D)){&D::overlaps1Way})
            m->registerHook(getBase()+0x35b0d0, extract((void(D::*)(OBB2D)){&D::overlaps1Way}));
    }
};


template<class D>
class $ObjectToolbox : public ObjectToolbox, public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ObjectToolbox() {}
    typedef ObjectToolbox* __thistype;

    bool init() {
        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2d80))(this);
        else return ObjectToolbox::init();
    }

    void intKeyToFrame(in p0) {
        if ((void($ObjectToolbox::*)(in)){&$ObjectToolbox::intKeyToFrame} != (void(D::*)(in)){&D::intKeyToFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
        else return ObjectToolbox::intKeyToFrame(p0);
    }

    static ObjectToolbox* sharedState() {
        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            return reinterpret_cast<ObjectToolbox*(*)()>(m->getOriginal(getBase()+0x3b2bc0))();
        else return ObjectToolbox::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x3b2d80, extract((bool(D::*)()){&D::init}));

        if ((void($ObjectToolbox::*)(in)){&$ObjectToolbox::intKeyToFrame} != (void(D::*)(in)){&D::intKeyToFrame})
            m->registerHook(getBase()+0x4173b0, extract((void(D::*)(in)){&D::intKeyToFrame}));

        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x3b2bc0, (ObjectToolbox*(*)()){&D::sharedState});
    }
};


template<class D>
class $OpacityEffectAction : public OpacityEffectAction, public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$OpacityEffectAction() {}
    typedef OpacityEffectAction* __thistype;

    static OpacityEffectAction* create(floa p0, floa p1, floa p2, in p3) {
        if ((OpacityEffectAction*(*)(floa, floa, floa, in)){&$OpacityEffectAction::create} != (OpacityEffectAction*(*)(floa, floa, floa, in)){&D::create})
            return reinterpret_cast<OpacityEffectAction*(*)(floa, floa, floa, in)>(m->getOriginal(getBase()+0x1789f0))(p0, p1, p2, p3);
        else return OpacityEffectAction::create(p0, p1, p2, p3);
    }

    static OpacityEffectAction* createFromString(std::strin p0) {
        if ((OpacityEffectAction*(*)(std::strin)){&$OpacityEffectAction::createFromString} != (OpacityEffectAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<OpacityEffectAction*(*)(std::strin)>(m->getOriginal(getBase()+0x178c10))(p0);
        else return OpacityEffectAction::createFromString(p0);
    }

    bool init(floa p0, floa p1, floa p2, in p3) {
        if ((bool($OpacityEffectAction::*)(floa, floa, floa, in)){&$OpacityEffectAction::init} != (bool(D::*)(floa, floa, floa, in)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), floa, floa, floa, in)>(m->getOriginal(getBase()+0x178b00))(this, p0, p1, p2, p3);
        else return OpacityEffectAction::init(p0, p1, p2, p3);
    }

    void step(floa p0) {
        if ((void($OpacityEffectAction::*)(floa)){&$OpacityEffectAction::step} != (void(D::*)(floa)){&D::step})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x178b90))(this, p0);
        else return OpacityEffectAction::step(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((OpacityEffectAction*(*)(floa, floa, floa, in)){&$OpacityEffectAction::create} != (OpacityEffectAction*(*)(floa, floa, floa, in)){&D::create})
            m->registerHook(getBase()+0x1789f0, (OpacityEffectAction*(*)(floa, floa, floa, in)){&D::create});

        if ((OpacityEffectAction*(*)(std::strin)){&$OpacityEffectAction::createFromString} != (OpacityEffectAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x178c10, (OpacityEffectAction*(*)(std::strin)){&D::createFromString});

        if ((bool($OpacityEffectAction::*)(floa, floa, floa, in)){&$OpacityEffectAction::init} != (bool(D::*)(floa, floa, floa, in)){&D::init})
            m->registerHook(getBase()+0x178b00, extract((bool(D::*)(floa, floa, floa, in)){&D::init}));

        if ((void($OpacityEffectAction::*)(floa)){&$OpacityEffectAction::step} != (void(D::*)(floa)){&D::step})
            m->registerHook(getBase()+0x178b90, extract((void(D::*)(floa)){&D::step}));
    }
};


template<class D>
class $PauseLayer : public PauseLayer, public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PauseLayer() {}
    typedef PauseLayer* __thistype;

    static PauseLayer* create(boo p0) {
        if ((PauseLayer*(*)(boo)){&$PauseLayer::create} != (PauseLayer*(*)(boo)){&D::create})
            return reinterpret_cast<PauseLayer*(*)(boo)>(m->getOriginal(getBase()+0x20b1e0))(p0);
        else return PauseLayer::create(p0);
    }

    void onEdit(cocos2d::CCObject p0) {
        if ((void($PauseLayer::*)(cocos2d::CCObject)){&$PauseLayer::onEdit} != (void(D::*)(cocos2d::CCObject)){&D::onEdit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x20c630))(this, p0);
        else return PauseLayer::onEdit(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((PauseLayer*(*)(boo)){&$PauseLayer::create} != (PauseLayer*(*)(boo)){&D::create})
            m->registerHook(getBase()+0x20b1e0, (PauseLayer*(*)(boo)){&D::create});

        if ((void($PauseLayer::*)(cocos2d::CCObject)){&$PauseLayer::onEdit} != (void(D::*)(cocos2d::CCObject)){&D::onEdit})
            m->registerHook(getBase()+0x20c630, extract((void(D::*)(cocos2d::CCObject)){&D::onEdit}));
    }
};


template<class D>
class $PlatformToolbox : public PlatformToolbox, public $CacBase {
 public:
    $PlatformToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlatformToolbox() {}
    typedef PlatformToolbox* __thistype;

    void hideCursor() {
        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor} != (void(D::*)()){&D::hideCursor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c340))(this);
        else return PlatformToolbox::hideCursor();
    }

    void showCursor() {
        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor} != (void(D::*)()){&D::showCursor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c360))(this);
        else return PlatformToolbox::showCursor();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor} != (void(D::*)()){&D::hideCursor})
            m->registerHook(getBase()+0x27c340, extract((void(D::*)()){&D::hideCursor}));

        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor} != (void(D::*)()){&D::showCursor})
            m->registerHook(getBase()+0x27c360, extract((void(D::*)()){&D::showCursor}));
    }
};


template<class D>
class $PlayLayer : public PlayLayer, public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayLayer() {}
    typedef PlayLayer* __thistype;

    void addCircle(CCCircleWave p0) {
        if ((void($PlayLayer::*)(CCCircleWave)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave)){&D::addCircle})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
        else return PlayLayer::addCircle(p0);
    }

    void addObject(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addObject} != (void(D::*)(GameObject)){&D::addObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x70e50))(this, p0);
        else return PlayLayer::addObject(p0);
    }

    void addToGroupOld(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject)){&D::addToGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x77680))(this, p0);
        else return PlayLayer::addToGroupOld(p0);
    }

    void addToSpeedObjects(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject)){&D::addToSpeedObjects})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
        else return PlayLayer::addToSpeedObjects(p0);
    }

    void animateInDualGround(GameObject p0, floa p1, boo p2) {
        if ((void($PlayLayer::*)(GameObject, floa, boo)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject, floa, boo)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject, floa, boo)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
        else return PlayLayer::animateInDualGround(p0, p1, p2);
    }

    void animateInGround(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::animateInGround} != (void(D::*)(boo)){&D::animateInGround})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
        else return PlayLayer::animateInGround(p0);
    }

    void animateOutGround(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::animateOutGround} != (void(D::*)(boo)){&D::animateOutGround})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x6f350))(this, p0);
        else return PlayLayer::animateOutGround(p0);
    }

    void animateOutGroundFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7de80))(this);
        else return PlayLayer::animateOutGroundFinished();
    }

    void applyEnterEffect(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject)){&D::applyEnterEffect})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x7c310))(this, p0);
        else return PlayLayer::applyEnterEffect(p0);
    }

    void calculateColorValues(EffectGameObject p0, EffectGameObject p1, in p2, floa p3, ColorActionSprite p4, GJEffectManager p5) override {
        if ((void($PlayLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void cameraMoveX(floa p0, floa p1, floa p2) {
        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::cameraMoveX} != (void(D::*)(floa, floa, floa)){&D::cameraMoveX})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, floa)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveX(p0, p1, p2);
    }

    void cameraMoveY(floa p0, floa p1, floa p2) {
        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::cameraMoveY} != (void(D::*)(floa, floa, floa)){&D::cameraMoveY})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, floa)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveY(p0, p1, p2);
    }

    void checkCollisions(PlayerObject p0, floa p1) {
        if ((void($PlayLayer::*)(PlayerObject, floa)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject, floa)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, floa)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
        else return PlayLayer::checkCollisions(p0, p1);
    }

    void circleWaveWillBeRemoved(CCCircleWave p0) {
        if ((void($PlayLayer::*)(CCCircleWave)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave)){&D::circleWaveWillBeRemoved})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave)>(m->getOriginal(getBase()+0x7e110))(this, p0);
        else return PlayLayer::circleWaveWillBeRemoved(p0);
    }

    void claimParticle(std::strin p0) {
        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::claimParticle} != (void(D::*)(std::strin)){&D::claimParticle})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
        else return PlayLayer::claimParticle(p0);
    }

    void clearPickedUpItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cfa0))(this);
        else return PlayLayer::clearPickedUpItems();
    }

    void colorObject(in p0, cocos2d::_ccColor3 p1) {
        if ((void($PlayLayer::*)(in, cocos2d::_ccColor3)){&$PlayLayer::colorObject} != (void(D::*)(in, cocos2d::_ccColor3)){&D::colorObject})
            return reinterpret_cast<void(*)(decltype(this), in, cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
        else return PlayLayer::colorObject(p0, p1);
    }

    void commitJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x737e0))(this);
        else return PlayLayer::commitJumps();
    }

    static PlayLayer* create(GJGameLevel p0) {
        if ((PlayLayer*(*)(GJGameLevel)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel)){&D::create})
            return reinterpret_cast<PlayLayer*(*)(GJGameLevel)>(m->getOriginal(getBase()+0x6b590))(p0);
        else return PlayLayer::create(p0);
    }

    void createCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e470))(this);
        else return PlayLayer::createCheckpoint();
    }

    void createObjectsFromSetup(std::strin p0) {
        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::strin)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x6d130))(this, p0);
        else return PlayLayer::createObjectsFromSetup(p0);
    }

    void createParticle(in p0, char const p1, in p2, cocos2d::tCCPositionTyp p3) {
        if ((void($PlayLayer::*)(in, char const, in, cocos2d::tCCPositionTyp)){&$PlayLayer::createParticle} != (void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::createParticle})
            return reinterpret_cast<void(*)(decltype(this), in, char const, in, cocos2d::tCCPositionTyp)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
        else return PlayLayer::createParticle(p0, p1, p2, p3);
    }

    void currencyWillExit(CurrencyRewardLayer p0) {
        if ((void($PlayLayer::*)(CurrencyRewardLayer)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer)>(m->getOriginal(getBase()+0x7e070))(this, p0);
        else return PlayLayer::currencyWillExit(p0);
    }

    void delayedResetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e050))(this);
        else return PlayLayer::delayedResetLevel();
    }

    void destroyPlayer(PlayerObject p0, GameObject p1) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject, GameObject)){&D::destroyPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
        else return PlayLayer::destroyPlayer(p0, p1);
    }

    void dialogClosed(DialogLayer p0) {
        if ((void($PlayLayer::*)(DialogLayer)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
        else return PlayLayer::dialogClosed(p0);
    }

    void draw() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d160))(this);
        else return PlayLayer::draw();
    }

    void enterDualMode(GameObject p0, boo p1) {
        if ((void($PlayLayer::*)(GameObject, boo)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject, boo)){&D::enterDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
        else return PlayLayer::enterDualMode(p0, p1);
    }

    void exitAirMode() {
        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7dd40))(this);
        else return PlayLayer::exitAirMode();
    }

    void exitBirdMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject)){&D::exitBirdMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
        else return PlayLayer::exitBirdMode(p0);
    }

    void exitDartMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject)){&D::exitDartMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
        else return PlayLayer::exitDartMode(p0);
    }

    void exitFlyMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject)){&D::exitFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
        else return PlayLayer::exitFlyMode(p0);
    }

    void exitRobotMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject)){&D::exitRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7de20))(this, p0);
        else return PlayLayer::exitRobotMode(p0);
    }

    void exitRollMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject)){&D::exitRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7de60))(this, p0);
        else return PlayLayer::exitRollMode(p0);
    }

    void exitSpiderMode(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject)){&D::exitSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7de40))(this, p0);
        else return PlayLayer::exitSpiderMode(p0);
    }

    void flipFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e150))(this);
        else return PlayLayer::flipFinished();
    }

    void flipGravity(PlayerObject p0, boo p1, boo p2) override {
        if ((void($PlayLayer::*)(PlayerObject, boo, boo)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, boo, boo)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
        else return PlayLayer::flipGravity(p0, p1, p2);
    }

    void flipObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76130))(this);
        else return PlayLayer::flipObjects();
    }

    void fullReset() {
        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f8e0))(this);
        else return PlayLayer::fullReset();
    }

    void getLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f840))(this);
        else return PlayLayer::getLastCheckpoint();
    }

    void getMaxPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b4e0))(this);
        else return PlayLayer::getMaxPortalY();
    }

    void getMinPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b550))(this);
        else return PlayLayer::getMinPortalY();
    }

    void getObjectsState() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e9d0))(this);
        else return PlayLayer::getObjectsState();
    }

    void getOtherPlayer(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject)){&D::getOtherPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
        else return PlayLayer::getOtherPlayer(p0);
    }

    void getParticleKey(in p0, char const p1, in p2, cocos2d::tCCPositionTyp p3) {
        if ((void($PlayLayer::*)(in, char const, in, cocos2d::tCCPositionTyp)){&$PlayLayer::getParticleKey} != (void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::getParticleKey})
            return reinterpret_cast<void(*)(decltype(this), in, char const, in, cocos2d::tCCPositionTyp)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
        else return PlayLayer::getParticleKey(p0, p1, p2, p3);
    }

    void getParticleKey2(std::strin p0) {
        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::strin)){&D::getParticleKey2})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x767b0))(this, p0);
        else return PlayLayer::getParticleKey2(p0);
    }

    void getRelativeMod(cocos2d::CCPoin p0, floa p1, floa p2, floa p3) {
        if ((void($PlayLayer::*)(cocos2d::CCPoin, floa, floa, floa)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::getRelativeMod})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, floa, floa, floa)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
        else return PlayLayer::getRelativeMod(p0, p1, p2, p3);
    }

    void getTempMilliTime() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x778e0))(this);
        else return PlayLayer::getTempMilliTime();
    }

    void gravityEffectFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cec0))(this);
        else return PlayLayer::gravityEffectFinished();
    }

    void hasItem(in p0) {
        if ((void($PlayLayer::*)(in)){&$PlayLayer::hasItem} != (void(D::*)(in)){&D::hasItem})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
        else return PlayLayer::hasItem(p0);
    }

    void hasUniqueCoin(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject)){&D::hasUniqueCoin})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x77510))(this, p0);
        else return PlayLayer::hasUniqueCoin(p0);
    }

    void incrementJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ff40))(this);
        else return PlayLayer::incrementJumps();
    }

    bool init(GJGameLevel p0) {
        if ((bool($PlayLayer::*)(GJGameLevel)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
        else return PlayLayer::init(p0);
    }

    void isFlipping() {
        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76100))(this);
        else return PlayLayer::isFlipping();
    }

    void levelComplete() {
        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72b80))(this);
        else return PlayLayer::levelComplete();
    }

    void lightningFlash(cocos2d::CCPoin p0, cocos2d::CCPoin p1, cocos2d::_ccColor3 p2, floa p3, floa p4, in p5, boo p6, floa p7) {
        if ((void($PlayLayer::*)(cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return PlayLayer::lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void lightningFlash(cocos2d::CCPoin p0, cocos2d::_ccColor3 p1) {
        if ((void($PlayLayer::*)(cocos2d::CCPoin, cocos2d::_ccColor3)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin, cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
        else return PlayLayer::lightningFlash(p0, p1);
    }

    void loadDefaultColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ef30))(this);
        else return PlayLayer::loadDefaultColors();
    }

    void loadFromCheckpoint(CheckpointObject p0) {
        if ((void($PlayLayer::*)(CheckpointObject)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject)){&D::loadFromCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject)>(m->getOriginal(getBase()+0x7f000))(this, p0);
        else return PlayLayer::loadFromCheckpoint(p0);
    }

    void loadLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7efc0))(this);
        else return PlayLayer::loadLastCheckpoint();
    }

    void loadSavedObjectsState(std::strin p0) {
        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::strin)){&D::loadSavedObjectsState})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
        else return PlayLayer::loadSavedObjectsState(p0);
    }

    void markCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef60))(this);
        else return PlayLayer::markCheckpoint();
    }

    void moveCameraToPos(cocos2d::CCPoin p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoin)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoin)){&D::moveCameraToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x7c980))(this, p0);
        else return PlayLayer::moveCameraToPos(p0);
    }

    void onEnterTransitionDidFinish() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x806e0))(this);
        else return PlayLayer::onEnterTransitionDidFinish();
    }

    void onExit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80710))(this);
        else return PlayLayer::onExit();
    }

    void onQuit() {
        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72710))(this);
        else return PlayLayer::onQuit();
    }

    void optimizeColorGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dad0))(this);
        else return PlayLayer::optimizeColorGroups();
    }

    void optimizeOpacityGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dc20))(this);
        else return PlayLayer::optimizeOpacityGroups();
    }

    void optimizeSaveRequiredGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dd70))(this);
        else return PlayLayer::optimizeSaveRequiredGroups();
    }

    void pauseGame(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::pauseGame} != (void(D::*)(boo)){&D::pauseGame})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x802d0))(this, p0);
        else return PlayLayer::pauseGame(p0);
    }

    void pickupItem(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject)){&D::pickupItem})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
        else return PlayLayer::pickupItem(p0);
    }

    void playAnimationCommand(in p0, in p1) {
        if ((void($PlayLayer::*)(in, in)){&$PlayLayer::playAnimationCommand} != (void(D::*)(in, in)){&D::playAnimationCommand})
            return reinterpret_cast<void(*)(decltype(this), in, in)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
        else return PlayLayer::playAnimationCommand(p0, p1);
    }

    void playEndAnimationToPos(cocos2d::CCPoin p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoin)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoin)){&D::playEndAnimationToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoin)>(m->getOriginal(getBase()+0x759a0))(this, p0);
        else return PlayLayer::playEndAnimationToPos(p0);
    }

    void playExitDualEffect(PlayerObject p0) {
        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject)){&D::playExitDualEffect})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
        else return PlayLayer::playExitDualEffect(p0);
    }

    void playFlashEffect(floa p0, in p1, floa p2) {
        if ((void($PlayLayer::*)(floa, in, floa)){&$PlayLayer::playFlashEffect} != (void(D::*)(floa, in, floa)){&D::playFlashEffect})
            return reinterpret_cast<void(*)(decltype(this), floa, in, floa)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
        else return PlayLayer::playFlashEffect(p0, p1, p2);
    }

    void playGravityEffect(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::playGravityEffect} != (void(D::*)(boo)){&D::playGravityEffect})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
        else return PlayLayer::playGravityEffect(p0);
    }

    void playSpeedParticle(floa p0) {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::playSpeedParticle} != (void(D::*)(floa)){&D::playSpeedParticle})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x77030))(this, p0);
        else return PlayLayer::playSpeedParticle(p0);
    }

    void playerWillSwitchMode(PlayerObject p0, GameObject p1) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject, GameObject)){&D::playerWillSwitchMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
        else return PlayLayer::playerWillSwitchMode(p0, p1);
    }

    void prepareSpawnObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fc00))(this);
        else return PlayLayer::prepareSpawnObjects();
    }

    void processItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x735c0))(this);
        else return PlayLayer::processItems();
    }

    void processLoadedMoveActions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a7c0))(this);
        else return PlayLayer::processLoadedMoveActions();
    }

    void recordAction(boo p0, PlayerObject p1) {
        if ((void($PlayLayer::*)(boo, PlayerObject)){&$PlayLayer::recordAction} != (void(D::*)(boo, PlayerObject)){&D::recordAction})
            return reinterpret_cast<void(*)(decltype(this), boo, PlayerObject)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
        else return PlayLayer::recordAction(p0, p1);
    }

    void registerActiveObject(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject)){&D::registerActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x77620))(this, p0);
        else return PlayLayer::registerActiveObject(p0);
    }

    void registerStateObject(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject)){&D::registerStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x777b0))(this, p0);
        else return PlayLayer::registerStateObject(p0);
    }

    void removeAllObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x727b0))(this);
        else return PlayLayer::removeAllObjects();
    }

    void removeFromGroupOld(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject)){&D::removeFromGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x77750))(this, p0);
        else return PlayLayer::removeFromGroupOld(p0);
    }

    void removeLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f870))(this);
        else return PlayLayer::removeLastCheckpoint();
    }

    void removePlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d630))(this);
        else return PlayLayer::removePlayer2();
    }

    void resetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
        else return PlayLayer::resetLevel();
    }

    void resume() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80480))(this);
        else return PlayLayer::resume();
    }

    void resumeAndRestart() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80400))(this);
        else return PlayLayer::resumeAndRestart();
    }

    void saveRecordAction(boo p0, PlayerObject p1) {
        if ((void($PlayLayer::*)(boo, PlayerObject)){&$PlayLayer::saveRecordAction} != (void(D::*)(boo, PlayerObject)){&D::saveRecordAction})
            return reinterpret_cast<void(*)(decltype(this), boo, PlayerObject)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
        else return PlayLayer::saveRecordAction(p0, p1);
    }

    void scene(GJGameLevel p0) {
        if ((void($PlayLayer::*)(GJGameLevel)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel)>(m->getOriginal(getBase()+0x6b500))(this, p0);
        else return PlayLayer::scene(p0);
    }

    void setupLevelStart(LevelSettingsObject p0) {
        if ((void($PlayLayer::*)(LevelSettingsObject)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject)>(m->getOriginal(getBase()+0x6f560))(this, p0);
        else return PlayLayer::setupLevelStart(p0);
    }

    void setupReplay(std::strin p0) {
        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::setupReplay} != (void(D::*)(std::strin)){&D::setupReplay})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
        else return PlayLayer::setupReplay(p0);
    }

    void shakeCamera(floa p0, floa p1, floa p2) {
        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::shakeCamera} != (void(D::*)(floa, floa, floa)){&D::shakeCamera})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, floa)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
        else return PlayLayer::shakeCamera(p0, p1, p2);
    }

    void shouldBlend(in p0) {
        if ((void($PlayLayer::*)(in)){&$PlayLayer::shouldBlend} != (void(D::*)(in)){&D::shouldBlend})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x771b0))(this, p0);
        else return PlayLayer::shouldBlend(p0);
    }

    void showCompleteEffect() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x738e0))(this);
        else return PlayLayer::showCompleteEffect();
    }

    void showCompleteText() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73be0))(this);
        else return PlayLayer::showCompleteText();
    }

    void showEndLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74450))(this);
        else return PlayLayer::showEndLayer();
    }

    void showHint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7deb0))(this);
        else return PlayLayer::showHint();
    }

    void showNewBest(boo p0, in p1, in p2, boo p3, boo p4, boo p5) {
        if ((void($PlayLayer::*)(boo, in, in, boo, boo, boo)){&$PlayLayer::showNewBest} != (void(D::*)(boo, in, in, boo, boo, boo)){&D::showNewBest})
            return reinterpret_cast<void(*)(decltype(this), boo, in, in, boo, boo, boo)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::showNewBest(p0, p1, p2, p3, p4, p5);
    }

    void showRetryLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ba0))(this);
        else return PlayLayer::showRetryLayer();
    }

    void showTwoPlayerGuide() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6df00))(this);
        else return PlayLayer::showTwoPlayerGuide();
    }

    void sortGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d9e0))(this);
        else return PlayLayer::sortGroups();
    }

    void spawnCircle() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73820))(this);
        else return PlayLayer::spawnCircle();
    }

    void spawnFirework() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74200))(this);
        else return PlayLayer::spawnFirework();
    }

    void spawnParticle(char const p0, in p1, cocos2d::tCCPositionTyp p2, cocos2d::CCPoin p3) {
        if ((void($PlayLayer::*)(char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)){&$PlayLayer::spawnParticle} != (void(D::*)(char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)){&D::spawnParticle})
            return reinterpret_cast<void(*)(decltype(this), char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
        else return PlayLayer::spawnParticle(p0, p1, p2, p3);
    }

    void spawnPlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d170))(this);
        else return PlayLayer::spawnPlayer2();
    }

    void startGame() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x726b0))(this);
        else return PlayLayer::startGame();
    }

    void startMusic() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72910))(this);
        else return PlayLayer::startMusic();
    }

    void startRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fec0))(this);
        else return PlayLayer::startRecording();
    }

    void startRecordingDelayed() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fed0))(this);
        else return PlayLayer::startRecordingDelayed();
    }

    void stopCameraShake() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75900))(this);
        else return PlayLayer::stopCameraShake();
    }

    void stopRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d090))(this);
        else return PlayLayer::stopRecording();
    }

    void storeCheckpoint(CheckpointObject p0) {
        if ((void($PlayLayer::*)(CheckpointObject)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject)){&D::storeCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
        else return PlayLayer::storeCheckpoint(p0);
    }

    void switchToFlyMode(PlayerObject p0, GameObject p1, boo p2, in p3) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo, in)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject, GameObject, boo, in)){&D::switchToFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject, boo, in)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
        else return PlayLayer::switchToFlyMode(p0, p1, p2, p3);
    }

    void switchToRobotMode(PlayerObject p0, GameObject p1, boo p2) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject, boo)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
        else return PlayLayer::switchToRobotMode(p0, p1, p2);
    }

    void switchToRollMode(PlayerObject p0, GameObject p1, boo p2) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject, boo)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
        else return PlayLayer::switchToRollMode(p0, p1, p2);
    }

    void switchToSpiderMode(PlayerObject p0, GameObject p1, boo p2) {
        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, GameObject, boo)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
        else return PlayLayer::switchToSpiderMode(p0, p1, p2);
    }

    void timeForXPos(floa p0) {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x7d120))(this, p0);
        else return PlayLayer::timeForXPos(p0);
    }

    void timeForXPos2(floa p0, boo p1) {
        if ((void($PlayLayer::*)(floa, boo)){&$PlayLayer::timeForXPos2} != (void(D::*)(floa, boo)){&D::timeForXPos2})
            return reinterpret_cast<void(*)(decltype(this), floa, boo)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
        else return PlayLayer::timeForXPos2(p0, p1);
    }

    void toggleBGEffectVisibility(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(boo)){&D::toggleBGEffectVisibility})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
        else return PlayLayer::toggleBGEffectVisibility(p0);
    }

    void toggleDualMode(GameObject p0, boo p1, PlayerObject p2, boo p3) {
        if ((void($PlayLayer::*)(GameObject, boo, PlayerObject, boo)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject, boo, PlayerObject, boo)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
        else return PlayLayer::toggleDualMode(p0, p1, p2, p3);
    }

    void toggleFlipped(boo p0, boo p1) {
        if ((void($PlayLayer::*)(boo, boo)){&$PlayLayer::toggleFlipped} != (void(D::*)(boo, boo)){&D::toggleFlipped})
            return reinterpret_cast<void(*)(decltype(this), boo, boo)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
        else return PlayLayer::toggleFlipped(p0, p1);
    }

    void toggleGhostEffect(in p0) {
        if ((void($PlayLayer::*)(in)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(in)){&D::toggleGhostEffect})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
        else return PlayLayer::toggleGhostEffect(p0);
    }

    void toggleGlitter(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::toggleGlitter} != (void(D::*)(boo)){&D::toggleGlitter})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x70e00))(this, p0);
        else return PlayLayer::toggleGlitter(p0);
    }

    void togglePracticeMode(boo p0) {
        if ((void($PlayLayer::*)(boo)){&$PlayLayer::togglePracticeMode} != (void(D::*)(boo)){&D::togglePracticeMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
        else return PlayLayer::togglePracticeMode(p0);
    }

    void toggleProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6eeb0))(this);
        else return PlayLayer::toggleProgressbar();
    }

    void tryStartRecord() {
        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fe00))(this);
        else return PlayLayer::tryStartRecord();
    }

    void unclaimParticle(char const p0, cocos2d::CCParticleSystemQuad p1) {
        if ((void($PlayLayer::*)(char const, cocos2d::CCParticleSystemQuad)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const, cocos2d::CCParticleSystemQuad)){&D::unclaimParticle})
            return reinterpret_cast<void(*)(decltype(this), char const, cocos2d::CCParticleSystemQuad)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
        else return PlayLayer::unclaimParticle(p0, p1);
    }

    void unregisterActiveObject(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject)){&D::unregisterActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x77660))(this, p0);
        else return PlayLayer::unregisterActiveObject(p0);
    }

    void unregisterStateObject(GameObject p0) {
        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject)){&D::unregisterStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x777f0))(this, p0);
        else return PlayLayer::unregisterStateObject(p0);
    }

    void update(floa p0) override {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::update} != (void(D::*)(floa)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x77900))(this, p0);
        else return PlayLayer::update(p0);
    }

    void updateAttempts() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcd0))(this);
        else return PlayLayer::updateAttempts();
    }

    void updateCamera(floa p0) {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::updateCamera} != (void(D::*)(floa)){&D::updateCamera})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
        else return PlayLayer::updateCamera(p0);
    }

    void updateColor(cocos2d::_ccColor3 p0, floa p1, in p2, boo p3, floa p4, cocos2d::_ccHSVValu p5, in p6, boo p7, in p8, EffectGameObject p9) override {
        if ((void($PlayLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return PlayLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject p0, in p1, boo p2) {
        if ((void($PlayLayer::*)(PlayerObject, in, boo)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject, in, boo)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject, in, boo)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
        else return PlayLayer::updateDualGround(p0, p1, p2);
    }

    void updateEffectPositions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a6d0))(this);
        else return PlayLayer::updateEffectPositions();
    }

    void updateLevelColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6f1e0))(this);
        else return PlayLayer::updateLevelColors();
    }

    void updateMoveObjectsLastPosition() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a720))(this);
        else return PlayLayer::updateMoveObjectsLastPosition();
    }

    void updateProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ed70))(this);
        else return PlayLayer::updateProgressbar();
    }

    void updateReplay(floa p0) {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::updateReplay} != (void(D::*)(floa)){&D::updateReplay})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x78b60))(this, p0);
        else return PlayLayer::updateReplay(p0);
    }

    void updateTimeMod(floa p0, boo p1) {
        if ((void($PlayLayer::*)(floa, boo)){&$PlayLayer::updateTimeMod} != (void(D::*)(floa, boo)){&D::updateTimeMod})
            return reinterpret_cast<void(*)(decltype(this), floa, boo)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
        else return PlayLayer::updateTimeMod(p0, p1);
    }

    void updateTweenAction(floa p0, char const p1) override {
        if ((void($PlayLayer::*)(floa, char const)){&$PlayLayer::updateTweenAction} != (void(D::*)(floa, char const)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), floa, char const)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
        else return PlayLayer::updateTweenAction(p0, p1);
    }

    void updateVisibility() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6fb90))(this);
        else return PlayLayer::updateVisibility();
    }

    void vfDChk() {
        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcb0))(this);
        else return PlayLayer::vfDChk();
    }

    void visit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ef0))(this);
        else return PlayLayer::visit();
    }

    void visitWithColorFlash() {
        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x761f0))(this);
        else return PlayLayer::visitWithColorFlash();
    }

    void willSwitchToMode(in p0, PlayerObject p1) {
        if ((void($PlayLayer::*)(in, PlayerObject)){&$PlayLayer::willSwitchToMode} != (void(D::*)(in, PlayerObject)){&D::willSwitchToMode})
            return reinterpret_cast<void(*)(decltype(this), in, PlayerObject)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
        else return PlayLayer::willSwitchToMode(p0, p1);
    }

    void xPosForTime(floa p0) {
        if ((void($PlayLayer::*)(floa)){&$PlayLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x7d140))(this, p0);
        else return PlayLayer::xPosForTime(p0);
    }

     ~PlayLayer() {
        if ((($PlayLayer::*)()){&$PlayLayer::~PlayLayer} != ((D::*)()){&D::~PlayLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x6b090))(this);
        else return PlayLayer::~PlayLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($PlayLayer::*)(CCCircleWave)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave)){&D::addCircle})
            m->registerHook(getBase()+0x7e0f0, extract((void(D::*)(CCCircleWave)){&D::addCircle}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addObject} != (void(D::*)(GameObject)){&D::addObject})
            m->registerHook(getBase()+0x70e50, extract((void(D::*)(GameObject)){&D::addObject}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject)){&D::addToGroupOld})
            m->registerHook(getBase()+0x77680, extract((void(D::*)(GameObject)){&D::addToGroupOld}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x7cfc0, extract((void(D::*)(GameObject)){&D::addToSpeedObjects}));

        if ((void($PlayLayer::*)(GameObject, floa, boo)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject, floa, boo)){&D::animateInDualGround})
            m->registerHook(getBase()+0x7d710, extract((void(D::*)(GameObject, floa, boo)){&D::animateInDualGround}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::animateInGround} != (void(D::*)(boo)){&D::animateInGround})
            m->registerHook(getBase()+0x7d9d0, extract((void(D::*)(boo)){&D::animateInGround}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::animateOutGround} != (void(D::*)(boo)){&D::animateOutGround})
            m->registerHook(getBase()+0x6f350, extract((void(D::*)(boo)){&D::animateOutGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            m->registerHook(getBase()+0x7de80, extract((void(D::*)()){&D::animateOutGroundFinished}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject)){&D::applyEnterEffect})
            m->registerHook(getBase()+0x7c310, extract((void(D::*)(GameObject)){&D::applyEnterEffect}));

        if ((void($PlayLayer::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues})
            m->registerHook(getBase()+0x7aa10, extract((void(D::*)(EffectGameObject, EffectGameObject, in, floa, ColorActionSprite, GJEffectManager)){&D::calculateColorValues}));

        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::cameraMoveX} != (void(D::*)(floa, floa, floa)){&D::cameraMoveX})
            m->registerHook(getBase()+0x7cbe0, extract((void(D::*)(floa, floa, floa)){&D::cameraMoveX}));

        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::cameraMoveY} != (void(D::*)(floa, floa, floa)){&D::cameraMoveY})
            m->registerHook(getBase()+0x7cc60, extract((void(D::*)(floa, floa, floa)){&D::cameraMoveY}));

        if ((void($PlayLayer::*)(PlayerObject, floa)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject, floa)){&D::checkCollisions})
            m->registerHook(getBase()+0x78c90, extract((void(D::*)(PlayerObject, floa)){&D::checkCollisions}));

        if ((void($PlayLayer::*)(CCCircleWave)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave)){&D::circleWaveWillBeRemoved})
            m->registerHook(getBase()+0x7e110, extract((void(D::*)(CCCircleWave)){&D::circleWaveWillBeRemoved}));

        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::claimParticle} != (void(D::*)(std::strin)){&D::claimParticle})
            m->registerHook(getBase()+0x76ba0, extract((void(D::*)(std::strin)){&D::claimParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            m->registerHook(getBase()+0x7cfa0, extract((void(D::*)()){&D::clearPickedUpItems}));

        if ((void($PlayLayer::*)(in, cocos2d::_ccColor3)){&$PlayLayer::colorObject} != (void(D::*)(in, cocos2d::_ccColor3)){&D::colorObject})
            m->registerHook(getBase()+0x77810, extract((void(D::*)(in, cocos2d::_ccColor3)){&D::colorObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            m->registerHook(getBase()+0x737e0, extract((void(D::*)()){&D::commitJumps}));

        if ((PlayLayer*(*)(GJGameLevel)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel)){&D::create})
            m->registerHook(getBase()+0x6b590, (PlayLayer*(*)(GJGameLevel)){&D::create});

        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            m->registerHook(getBase()+0x7e470, extract((void(D::*)()){&D::createCheckpoint}));

        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::strin)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x6d130, extract((void(D::*)(std::strin)){&D::createObjectsFromSetup}));

        if ((void($PlayLayer::*)(in, char const, in, cocos2d::tCCPositionTyp)){&$PlayLayer::createParticle} != (void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::createParticle})
            m->registerHook(getBase()+0x76800, extract((void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::createParticle}));

        if ((void($PlayLayer::*)(CurrencyRewardLayer)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer)){&D::currencyWillExit})
            m->registerHook(getBase()+0x7e070, extract((void(D::*)(CurrencyRewardLayer)){&D::currencyWillExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            m->registerHook(getBase()+0x7e050, extract((void(D::*)()){&D::delayedResetLevel}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject, GameObject)){&D::destroyPlayer})
            m->registerHook(getBase()+0x7ab80, extract((void(D::*)(PlayerObject, GameObject)){&D::destroyPlayer}));

        if ((void($PlayLayer::*)(DialogLayer)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer)){&D::dialogClosed})
            m->registerHook(getBase()+0x7e0b0, extract((void(D::*)(DialogLayer)){&D::dialogClosed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x7d160, extract((void(D::*)()){&D::draw}));

        if ((void($PlayLayer::*)(GameObject, boo)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject, boo)){&D::enterDualMode})
            m->registerHook(getBase()+0x7d6a0, extract((void(D::*)(GameObject, boo)){&D::enterDualMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            m->registerHook(getBase()+0x7dd40, extract((void(D::*)()){&D::exitAirMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject)){&D::exitBirdMode})
            m->registerHook(getBase()+0x7dd80, extract((void(D::*)(PlayerObject)){&D::exitBirdMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject)){&D::exitDartMode})
            m->registerHook(getBase()+0x7ddd0, extract((void(D::*)(PlayerObject)){&D::exitDartMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject)){&D::exitFlyMode})
            m->registerHook(getBase()+0x7dcf0, extract((void(D::*)(PlayerObject)){&D::exitFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject)){&D::exitRobotMode})
            m->registerHook(getBase()+0x7de20, extract((void(D::*)(PlayerObject)){&D::exitRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject)){&D::exitRollMode})
            m->registerHook(getBase()+0x7de60, extract((void(D::*)(PlayerObject)){&D::exitRollMode}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject)){&D::exitSpiderMode})
            m->registerHook(getBase()+0x7de40, extract((void(D::*)(PlayerObject)){&D::exitSpiderMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            m->registerHook(getBase()+0x7e150, extract((void(D::*)()){&D::flipFinished}));

        if ((void($PlayLayer::*)(PlayerObject, boo, boo)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject, boo, boo)){&D::flipGravity})
            m->registerHook(getBase()+0x7cd10, extract((void(D::*)(PlayerObject, boo, boo)){&D::flipGravity}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            m->registerHook(getBase()+0x76130, extract((void(D::*)()){&D::flipObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            m->registerHook(getBase()+0x7f8e0, extract((void(D::*)()){&D::fullReset}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            m->registerHook(getBase()+0x7f840, extract((void(D::*)()){&D::getLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            m->registerHook(getBase()+0x7b4e0, extract((void(D::*)()){&D::getMaxPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            m->registerHook(getBase()+0x7b550, extract((void(D::*)()){&D::getMinPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            m->registerHook(getBase()+0x7e9d0, extract((void(D::*)()){&D::getObjectsState}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject)){&D::getOtherPlayer})
            m->registerHook(getBase()+0x7dcc0, extract((void(D::*)(PlayerObject)){&D::getOtherPlayer}));

        if ((void($PlayLayer::*)(in, char const, in, cocos2d::tCCPositionTyp)){&$PlayLayer::getParticleKey} != (void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::getParticleKey})
            m->registerHook(getBase()+0x764d0, extract((void(D::*)(in, char const, in, cocos2d::tCCPositionTyp)){&D::getParticleKey}));

        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::strin)){&D::getParticleKey2})
            m->registerHook(getBase()+0x767b0, extract((void(D::*)(std::strin)){&D::getParticleKey2}));

        if ((void($PlayLayer::*)(cocos2d::CCPoin, floa, floa, floa)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::getRelativeMod})
            m->registerHook(getBase()+0x7c2a0, extract((void(D::*)(cocos2d::CCPoin, floa, floa, floa)){&D::getRelativeMod}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            m->registerHook(getBase()+0x778e0, extract((void(D::*)()){&D::getTempMilliTime}));

        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            m->registerHook(getBase()+0x7cec0, extract((void(D::*)()){&D::gravityEffectFinished}));

        if ((void($PlayLayer::*)(in)){&$PlayLayer::hasItem} != (void(D::*)(in)){&D::hasItem})
            m->registerHook(getBase()+0x7cee0, extract((void(D::*)(in)){&D::hasItem}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject)){&D::hasUniqueCoin})
            m->registerHook(getBase()+0x77510, extract((void(D::*)(GameObject)){&D::hasUniqueCoin}));

        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x7ff40, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayLayer::*)(GJGameLevel)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel)){&D::init})
            m->registerHook(getBase()+0x6b5f0, extract((bool(D::*)(GJGameLevel)){&D::init}));

        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            m->registerHook(getBase()+0x76100, extract((void(D::*)()){&D::isFlipping}));

        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            m->registerHook(getBase()+0x72b80, extract((void(D::*)()){&D::levelComplete}));

        if ((void($PlayLayer::*)(cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)){&D::lightningFlash})
            m->registerHook(getBase()+0x75cc0, extract((void(D::*)(cocos2d::CCPoin, cocos2d::CCPoin, cocos2d::_ccColor3, floa, floa, in, boo, floa)){&D::lightningFlash}));

        if ((void($PlayLayer::*)(cocos2d::CCPoin, cocos2d::_ccColor3)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3)){&D::lightningFlash})
            m->registerHook(getBase()+0x75bf0, extract((void(D::*)(cocos2d::CCPoin, cocos2d::_ccColor3)){&D::lightningFlash}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            m->registerHook(getBase()+0x6ef30, extract((void(D::*)()){&D::loadDefaultColors}));

        if ((void($PlayLayer::*)(CheckpointObject)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x7f000, extract((void(D::*)(CheckpointObject)){&D::loadFromCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            m->registerHook(getBase()+0x7efc0, extract((void(D::*)()){&D::loadLastCheckpoint}));

        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::strin)){&D::loadSavedObjectsState})
            m->registerHook(getBase()+0x7f3d0, extract((void(D::*)(std::strin)){&D::loadSavedObjectsState}));

        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            m->registerHook(getBase()+0x7ef60, extract((void(D::*)()){&D::markCheckpoint}));

        if ((void($PlayLayer::*)(cocos2d::CCPoin)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoin)){&D::moveCameraToPos})
            m->registerHook(getBase()+0x7c980, extract((void(D::*)(cocos2d::CCPoin)){&D::moveCameraToPos}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(getBase()+0x806e0, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(getBase()+0x80710, extract((void(D::*)()){&D::onExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            m->registerHook(getBase()+0x72710, extract((void(D::*)()){&D::onQuit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            m->registerHook(getBase()+0x6dad0, extract((void(D::*)()){&D::optimizeColorGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            m->registerHook(getBase()+0x6dc20, extract((void(D::*)()){&D::optimizeOpacityGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            m->registerHook(getBase()+0x6dd70, extract((void(D::*)()){&D::optimizeSaveRequiredGroups}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::pauseGame} != (void(D::*)(boo)){&D::pauseGame})
            m->registerHook(getBase()+0x802d0, extract((void(D::*)(boo)){&D::pauseGame}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject)){&D::pickupItem})
            m->registerHook(getBase()+0x7c1d0, extract((void(D::*)(GameObject)){&D::pickupItem}));

        if ((void($PlayLayer::*)(in, in)){&$PlayLayer::playAnimationCommand} != (void(D::*)(in, in)){&D::playAnimationCommand})
            m->registerHook(getBase()+0x75930, extract((void(D::*)(in, in)){&D::playAnimationCommand}));

        if ((void($PlayLayer::*)(cocos2d::CCPoin)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoin)){&D::playEndAnimationToPos})
            m->registerHook(getBase()+0x759a0, extract((void(D::*)(cocos2d::CCPoin)){&D::playEndAnimationToPos}));

        if ((void($PlayLayer::*)(PlayerObject)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject)){&D::playExitDualEffect})
            m->registerHook(getBase()+0x7d1d0, extract((void(D::*)(PlayerObject)){&D::playExitDualEffect}));

        if ((void($PlayLayer::*)(floa, in, floa)){&$PlayLayer::playFlashEffect} != (void(D::*)(floa, in, floa)){&D::playFlashEffect})
            m->registerHook(getBase()+0x75e50, extract((void(D::*)(floa, in, floa)){&D::playFlashEffect}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::playGravityEffect} != (void(D::*)(boo)){&D::playGravityEffect})
            m->registerHook(getBase()+0x7b5a0, extract((void(D::*)(boo)){&D::playGravityEffect}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::playSpeedParticle} != (void(D::*)(floa)){&D::playSpeedParticle})
            m->registerHook(getBase()+0x77030, extract((void(D::*)(floa)){&D::playSpeedParticle}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject, GameObject)){&D::playerWillSwitchMode})
            m->registerHook(getBase()+0x7b820, extract((void(D::*)(PlayerObject, GameObject)){&D::playerWillSwitchMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            m->registerHook(getBase()+0x7fc00, extract((void(D::*)()){&D::prepareSpawnObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            m->registerHook(getBase()+0x735c0, extract((void(D::*)()){&D::processItems}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            m->registerHook(getBase()+0x7a7c0, extract((void(D::*)()){&D::processLoadedMoveActions}));

        if ((void($PlayLayer::*)(boo, PlayerObject)){&$PlayLayer::recordAction} != (void(D::*)(boo, PlayerObject)){&D::recordAction})
            m->registerHook(getBase()+0x7e190, extract((void(D::*)(boo, PlayerObject)){&D::recordAction}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject)){&D::registerActiveObject})
            m->registerHook(getBase()+0x77620, extract((void(D::*)(GameObject)){&D::registerActiveObject}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject)){&D::registerStateObject})
            m->registerHook(getBase()+0x777b0, extract((void(D::*)(GameObject)){&D::registerStateObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x727b0, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject)){&D::removeFromGroupOld})
            m->registerHook(getBase()+0x77750, extract((void(D::*)(GameObject)){&D::removeFromGroupOld}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            m->registerHook(getBase()+0x7f870, extract((void(D::*)()){&D::removeLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            m->registerHook(getBase()+0x7d630, extract((void(D::*)()){&D::removePlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            m->registerHook(getBase()+0x71c50, extract((void(D::*)()){&D::resetLevel}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            m->registerHook(getBase()+0x80480, extract((void(D::*)()){&D::resume}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            m->registerHook(getBase()+0x80400, extract((void(D::*)()){&D::resumeAndRestart}));

        if ((void($PlayLayer::*)(boo, PlayerObject)){&$PlayLayer::saveRecordAction} != (void(D::*)(boo, PlayerObject)){&D::saveRecordAction})
            m->registerHook(getBase()+0x78750, extract((void(D::*)(boo, PlayerObject)){&D::saveRecordAction}));

        if ((void($PlayLayer::*)(GJGameLevel)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel)){&D::scene})
            m->registerHook(getBase()+0x6b500, extract((void(D::*)(GJGameLevel)){&D::scene}));

        if ((void($PlayLayer::*)(LevelSettingsObject)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject)){&D::setupLevelStart})
            m->registerHook(getBase()+0x6f560, extract((void(D::*)(LevelSettingsObject)){&D::setupLevelStart}));

        if ((void($PlayLayer::*)(std::strin)){&$PlayLayer::setupReplay} != (void(D::*)(std::strin)){&D::setupReplay})
            m->registerHook(getBase()+0x7e1e0, extract((void(D::*)(std::strin)){&D::setupReplay}));

        if ((void($PlayLayer::*)(floa, floa, floa)){&$PlayLayer::shakeCamera} != (void(D::*)(floa, floa, floa)){&D::shakeCamera})
            m->registerHook(getBase()+0x744a0, extract((void(D::*)(floa, floa, floa)){&D::shakeCamera}));

        if ((void($PlayLayer::*)(in)){&$PlayLayer::shouldBlend} != (void(D::*)(in)){&D::shouldBlend})
            m->registerHook(getBase()+0x771b0, extract((void(D::*)(in)){&D::shouldBlend}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            m->registerHook(getBase()+0x738e0, extract((void(D::*)()){&D::showCompleteEffect}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            m->registerHook(getBase()+0x73be0, extract((void(D::*)()){&D::showCompleteText}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            m->registerHook(getBase()+0x74450, extract((void(D::*)()){&D::showEndLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            m->registerHook(getBase()+0x7deb0, extract((void(D::*)()){&D::showHint}));

        if ((void($PlayLayer::*)(boo, in, in, boo, boo, boo)){&$PlayLayer::showNewBest} != (void(D::*)(boo, in, in, boo, boo, boo)){&D::showNewBest})
            m->registerHook(getBase()+0x74580, extract((void(D::*)(boo, in, in, boo, boo, boo)){&D::showNewBest}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            m->registerHook(getBase()+0x75ba0, extract((void(D::*)()){&D::showRetryLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            m->registerHook(getBase()+0x6df00, extract((void(D::*)()){&D::showTwoPlayerGuide}));

        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            m->registerHook(getBase()+0x6d9e0, extract((void(D::*)()){&D::sortGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x73820, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            m->registerHook(getBase()+0x74200, extract((void(D::*)()){&D::spawnFirework}));

        if ((void($PlayLayer::*)(char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)){&$PlayLayer::spawnParticle} != (void(D::*)(char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)){&D::spawnParticle})
            m->registerHook(getBase()+0x76330, extract((void(D::*)(char const, in, cocos2d::tCCPositionTyp, cocos2d::CCPoin)){&D::spawnParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            m->registerHook(getBase()+0x7d170, extract((void(D::*)()){&D::spawnPlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            m->registerHook(getBase()+0x726b0, extract((void(D::*)()){&D::startGame}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            m->registerHook(getBase()+0x72910, extract((void(D::*)()){&D::startMusic}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            m->registerHook(getBase()+0x7fec0, extract((void(D::*)()){&D::startRecording}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            m->registerHook(getBase()+0x7fed0, extract((void(D::*)()){&D::startRecordingDelayed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            m->registerHook(getBase()+0x75900, extract((void(D::*)()){&D::stopCameraShake}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            m->registerHook(getBase()+0x6d090, extract((void(D::*)()){&D::stopRecording}));

        if ((void($PlayLayer::*)(CheckpointObject)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject)){&D::storeCheckpoint})
            m->registerHook(getBase()+0x7ef10, extract((void(D::*)(CheckpointObject)){&D::storeCheckpoint}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo, in)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject, GameObject, boo, in)){&D::switchToFlyMode})
            m->registerHook(getBase()+0x7baf0, extract((void(D::*)(PlayerObject, GameObject, boo, in)){&D::switchToFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRobotMode})
            m->registerHook(getBase()+0x7bc80, extract((void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRollMode})
            m->registerHook(getBase()+0x7bbe0, extract((void(D::*)(PlayerObject, GameObject, boo)){&D::switchToRollMode}));

        if ((void($PlayLayer::*)(PlayerObject, GameObject, boo)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject, GameObject, boo)){&D::switchToSpiderMode})
            m->registerHook(getBase()+0x7bd20, extract((void(D::*)(PlayerObject, GameObject, boo)){&D::switchToSpiderMode}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::timeForXPos} != (void(D::*)(floa)){&D::timeForXPos})
            m->registerHook(getBase()+0x7d120, extract((void(D::*)(floa)){&D::timeForXPos}));

        if ((void($PlayLayer::*)(floa, boo)){&$PlayLayer::timeForXPos2} != (void(D::*)(floa, boo)){&D::timeForXPos2})
            m->registerHook(getBase()+0x293eb0, extract((void(D::*)(floa, boo)){&D::timeForXPos2}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(boo)){&D::toggleBGEffectVisibility})
            m->registerHook(getBase()+0x7fe80, extract((void(D::*)(boo)){&D::toggleBGEffectVisibility}));

        if ((void($PlayLayer::*)(GameObject, boo, PlayerObject, boo)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode})
            m->registerHook(getBase()+0x7bf90, extract((void(D::*)(GameObject, boo, PlayerObject, boo)){&D::toggleDualMode}));

        if ((void($PlayLayer::*)(boo, boo)){&$PlayLayer::toggleFlipped} != (void(D::*)(boo, boo)){&D::toggleFlipped})
            m->registerHook(getBase()+0x7bdc0, extract((void(D::*)(boo, boo)){&D::toggleFlipped}));

        if ((void($PlayLayer::*)(in)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(in)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x7fe40, extract((void(D::*)(in)){&D::toggleGhostEffect}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::toggleGlitter} != (void(D::*)(boo)){&D::toggleGlitter})
            m->registerHook(getBase()+0x70e00, extract((void(D::*)(boo)){&D::toggleGlitter}));

        if ((void($PlayLayer::*)(boo)){&$PlayLayer::togglePracticeMode} != (void(D::*)(boo)){&D::togglePracticeMode})
            m->registerHook(getBase()+0x7f9e0, extract((void(D::*)(boo)){&D::togglePracticeMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            m->registerHook(getBase()+0x6eeb0, extract((void(D::*)()){&D::toggleProgressbar}));

        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            m->registerHook(getBase()+0x7fe00, extract((void(D::*)()){&D::tryStartRecord}));

        if ((void($PlayLayer::*)(char const, cocos2d::CCParticleSystemQuad)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const, cocos2d::CCParticleSystemQuad)){&D::unclaimParticle})
            m->registerHook(getBase()+0x76e00, extract((void(D::*)(char const, cocos2d::CCParticleSystemQuad)){&D::unclaimParticle}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject)){&D::unregisterActiveObject})
            m->registerHook(getBase()+0x77660, extract((void(D::*)(GameObject)){&D::unregisterActiveObject}));

        if ((void($PlayLayer::*)(GameObject)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject)){&D::unregisterStateObject})
            m->registerHook(getBase()+0x777f0, extract((void(D::*)(GameObject)){&D::unregisterStateObject}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::update} != (void(D::*)(floa)){&D::update})
            m->registerHook(getBase()+0x77900, extract((void(D::*)(floa)){&D::update}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            m->registerHook(getBase()+0x7fcd0, extract((void(D::*)()){&D::updateAttempts}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::updateCamera} != (void(D::*)(floa)){&D::updateCamera})
            m->registerHook(getBase()+0x6e2b0, extract((void(D::*)(floa)){&D::updateCamera}));

        if ((void($PlayLayer::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor})
            m->registerHook(getBase()+0x7c7f0, extract((void(D::*)(cocos2d::_ccColor3, floa, in, boo, floa, cocos2d::_ccHSVValu, in, boo, in, EffectGameObject)){&D::updateColor}));

        if ((void($PlayLayer::*)(PlayerObject, in, boo)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject, in, boo)){&D::updateDualGround})
            m->registerHook(getBase()+0x7caa0, extract((void(D::*)(PlayerObject, in, boo)){&D::updateDualGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            m->registerHook(getBase()+0x7a6d0, extract((void(D::*)()){&D::updateEffectPositions}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            m->registerHook(getBase()+0x6f1e0, extract((void(D::*)()){&D::updateLevelColors}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            m->registerHook(getBase()+0x7a720, extract((void(D::*)()){&D::updateMoveObjectsLastPosition}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            m->registerHook(getBase()+0x6ed70, extract((void(D::*)()){&D::updateProgressbar}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::updateReplay} != (void(D::*)(floa)){&D::updateReplay})
            m->registerHook(getBase()+0x78b60, extract((void(D::*)(floa)){&D::updateReplay}));

        if ((void($PlayLayer::*)(floa, boo)){&$PlayLayer::updateTimeMod} != (void(D::*)(floa, boo)){&D::updateTimeMod})
            m->registerHook(getBase()+0x786f0, extract((void(D::*)(floa, boo)){&D::updateTimeMod}));

        if ((void($PlayLayer::*)(floa, char const)){&$PlayLayer::updateTweenAction} != (void(D::*)(floa, char const)){&D::updateTweenAction})
            m->registerHook(getBase()+0x7ffb0, extract((void(D::*)(floa, char const)){&D::updateTweenAction}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            m->registerHook(getBase()+0x6fb90, extract((void(D::*)()){&D::updateVisibility}));

        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            m->registerHook(getBase()+0x7fcb0, extract((void(D::*)()){&D::vfDChk}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0x75ef0, extract((void(D::*)()){&D::visit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            m->registerHook(getBase()+0x761f0, extract((void(D::*)()){&D::visitWithColorFlash}));

        if ((void($PlayLayer::*)(in, PlayerObject)){&$PlayLayer::willSwitchToMode} != (void(D::*)(in, PlayerObject)){&D::willSwitchToMode})
            m->registerHook(getBase()+0x7b9e0, extract((void(D::*)(in, PlayerObject)){&D::willSwitchToMode}));

        if ((void($PlayLayer::*)(floa)){&$PlayLayer::xPosForTime} != (void(D::*)(floa)){&D::xPosForTime})
            m->registerHook(getBase()+0x7d140, extract((void(D::*)(floa)){&D::xPosForTime}));

        if ((($PlayLayer::*)()){&$PlayLayer::~PlayLayer} != ((D::*)()){&D::~PlayLayer})
            m->registerHook(getBase()+0x6b090, extract(((D::*)()){&D::~PlayLayer}));
    }
};


template<class D>
class $PlayerCheckpoint : public PlayerCheckpoint, public $CacBase {
 public:
    $PlayerCheckpoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayerCheckpoint() {}
    typedef PlayerCheckpoint* __thistype;

    static PlayerCheckpoint* create() {
        if ((PlayerCheckpoint*(*)()){&$PlayerCheckpoint::create} != (PlayerCheckpoint*(*)()){&D::create})
            return reinterpret_cast<PlayerCheckpoint*(*)()>(m->getOriginal(getBase()+0x7e8c0))();
        else return PlayerCheckpoint::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((PlayerCheckpoint*(*)()){&$PlayerCheckpoint::create} != (PlayerCheckpoint*(*)()){&D::create})
            m->registerHook(getBase()+0x7e8c0, (PlayerCheckpoint*(*)()){&D::create});
    }
};


template<class D>
class $PlayerObject : public PlayerObject, public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayerObject() {}
    typedef PlayerObject* __thistype;

    void activateStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::activateStreak} != (void(D::*)()){&D::activateStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21aef0))(this);
        else return PlayerObject::activateStreak();
    }

    void addAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::addAllParticles} != (void(D::*)()){&D::addAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
        else return PlayerObject::addAllParticles();
    }

    void addToTouchedRings(GameObject p0) {
        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::addToTouchedRings} != (void(D::*)(GameObject)){&D::addToTouchedRings})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x22b800))(this, p0);
        else return PlayerObject::addToTouchedRings(p0);
    }

    void animationFinished(char const p0) override {
        if ((void($PlayerObject::*)(char const)){&$PlayerObject::animationFinished} != (void(D::*)(char const)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
        else return PlayerObject::animationFinished(p0);
    }

    void boostPlayer(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::boostPlayer} != (void(D::*)(floa)){&D::boostPlayer})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
        else return PlayerObject::boostPlayer(p0);
    }

    void bumpPlayer(floa p0, in p1) {
        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::bumpPlayer} != (void(D::*)(floa, in)){&D::bumpPlayer})
            return reinterpret_cast<void(*)(decltype(this), floa, in)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
        else return PlayerObject::bumpPlayer(p0, p1);
    }

    void buttonDown(PlayerButto p0) {
        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::buttonDown} != (void(D::*)(PlayerButto)){&D::buttonDown})
            return reinterpret_cast<void(*)(decltype(this), PlayerButto)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
        else return PlayerObject::buttonDown(p0);
    }

    void checkSnapJumpToObject(GameObject p0) {
        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::checkSnapJumpToObject} != (void(D::*)(GameObject)){&D::checkSnapJumpToObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
        else return PlayerObject::checkSnapJumpToObject(p0);
    }

    void collidedWithObject(floa p0, GameObject p1) {
        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::collidedWithObject} != (void(D::*)(floa, GameObject)){&D::collidedWithObject})
            return reinterpret_cast<void(*)(decltype(this), floa, GameObject)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
        else return PlayerObject::collidedWithObject(p0, p1);
    }

    void collidedWithObject(floa p0, GameObject p1, cocos2d::CCRec p2) {
        if ((void($PlayerObject::*)(floa, GameObject, cocos2d::CCRec)){&$PlayerObject::collidedWithObject} != (void(D::*)(floa, GameObject, cocos2d::CCRec)){&D::collidedWithObject})
            return reinterpret_cast<void(*)(decltype(this), floa, GameObject, cocos2d::CCRec)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
        else return PlayerObject::collidedWithObject(p0, p1, p2);
    }

    void collidedWithSlope(floa p0, GameObject p1, boo p2) {
        if ((void($PlayerObject::*)(floa, GameObject, boo)){&$PlayerObject::collidedWithSlope} != (void(D::*)(floa, GameObject, boo)){&D::collidedWithSlope})
            return reinterpret_cast<void(*)(decltype(this), floa, GameObject, boo)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
        else return PlayerObject::collidedWithSlope(p0, p1, p2);
    }

    void convertToClosestRotation(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::convertToClosestRotation} != (void(D::*)(floa)){&D::convertToClosestRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21c860))(this, p0);
        else return PlayerObject::convertToClosestRotation(p0);
    }

    void copyAttributes(PlayerObject p0) {
        if ((void($PlayerObject::*)(PlayerObject)){&$PlayerObject::copyAttributes} != (void(D::*)(PlayerObject)){&D::copyAttributes})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
        else return PlayerObject::copyAttributes(p0);
    }

    static PlayerObject* create(in p0, in p1, cocos2d::CCLayer p2) {
        if ((PlayerObject*(*)(in, in, cocos2d::CCLayer)){&$PlayerObject::create} != (PlayerObject*(*)(in, in, cocos2d::CCLayer)){&D::create})
            return reinterpret_cast<PlayerObject*(*)(in, in, cocos2d::CCLayer)>(m->getOriginal(getBase()+0x217260))(p0, p1, p2);
        else return PlayerObject::create(p0, p1, p2);
    }

    void deactivateParticle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::deactivateParticle} != (void(D::*)()){&D::deactivateParticle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a540))(this);
        else return PlayerObject::deactivateParticle();
    }

    void deactivateStreak(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::deactivateStreak} != (void(D::*)(boo)){&D::deactivateStreak})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x218b30))(this, p0);
        else return PlayerObject::deactivateStreak(p0);
    }

    void fadeOutStreak2(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::fadeOutStreak2} != (void(D::*)(floa)){&D::fadeOutStreak2})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x225890))(this, p0);
        else return PlayerObject::fadeOutStreak2(p0);
    }

    void flashPlayer(floa p0, floa p1, cocos2d::_ccColor3 p2, cocos2d::_ccColor3 p3) {
        if ((void($PlayerObject::*)(floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)){&$PlayerObject::flashPlayer} != (void(D::*)(floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::flashPlayer})
            return reinterpret_cast<void(*)(decltype(this), floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
        else return PlayerObject::flashPlayer(p0, p1, p2, p3);
    }

    void flipGravity(boo p0, boo p1) {
        if ((void($PlayerObject::*)(boo, boo)){&$PlayerObject::flipGravity} != (void(D::*)(boo, boo)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), boo, boo)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
        else return PlayerObject::flipGravity(p0, p1);
    }

    void flipMod() {
        if ((void($PlayerObject::*)()){&$PlayerObject::flipMod} != (void(D::*)()){&D::flipMod})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4c0))(this);
        else return PlayerObject::flipMod();
    }

    void getActiveMode() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getActiveMode} != (void(D::*)()){&D::getActiveMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b950))(this);
        else return PlayerObject::getActiveMode();
    }

    void getModifiedSlopeYVel() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel} != (void(D::*)()){&D::getModifiedSlopeYVel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21bff0))(this);
        else return PlayerObject::getModifiedSlopeYVel();
    }

    void getOldPosition(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::getOldPosition} != (void(D::*)(floa)){&D::getOldPosition})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21a830))(this, p0);
        else return PlayerObject::getOldPosition(p0);
    }

    void getOrientedBox() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dee0))(this);
        else return PlayerObject::getOrientedBox();
    }

    void getRealPosition() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d5f0))(this);
        else return PlayerObject::getRealPosition();
    }

    void getSecondColor() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getSecondColor} != (void(D::*)()){&D::getSecondColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cee0))(this);
        else return PlayerObject::getSecondColor();
    }

    void gravityDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::gravityDown} != (void(D::*)()){&D::gravityDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e930))(this);
        else return PlayerObject::gravityDown();
    }

    void gravityUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::gravityUp} != (void(D::*)()){&D::gravityUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e900))(this);
        else return PlayerObject::gravityUp();
    }

    void hardFlipGravity() {
        if ((void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity} != (void(D::*)()){&D::hardFlipGravity})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b860))(this);
        else return PlayerObject::hardFlipGravity();
    }

    void hitGround(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::hitGround} != (void(D::*)(boo)){&D::hitGround})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x220a30))(this, p0);
        else return PlayerObject::hitGround(p0);
    }

    void incrementJumps() {
        if ((void($PlayerObject::*)()){&$PlayerObject::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c050))(this);
        else return PlayerObject::incrementJumps();
    }

    bool init(in p0, in p1, cocos2d::CCLayer p2) {
        if ((bool($PlayerObject::*)(in, in, cocos2d::CCLayer)){&$PlayerObject::init} != (bool(D::*)(in, in, cocos2d::CCLayer)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), in, in, cocos2d::CCLayer)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
        else return PlayerObject::init(p0, p1, p2);
    }

    void isBoostValid(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isBoostValid} != (void(D::*)(floa)){&D::isBoostValid})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21d650))(this, p0);
        else return PlayerObject::isBoostValid(p0);
    }

    void isFlying() {
        if ((void($PlayerObject::*)()){&$PlayerObject::isFlying} != (void(D::*)()){&D::isFlying})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4e0))(this);
        else return PlayerObject::isFlying();
    }

    void isSafeFlip(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeFlip} != (void(D::*)(floa)){&D::isSafeFlip})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
        else return PlayerObject::isSafeFlip(p0);
    }

    void isSafeMode(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeMode} != (void(D::*)(floa)){&D::isSafeMode})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
        else return PlayerObject::isSafeMode(p0);
    }

    void isSafeSpiderFlip(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeSpiderFlip} != (void(D::*)(floa)){&D::isSafeSpiderFlip})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x221be0))(this, p0);
        else return PlayerObject::isSafeSpiderFlip(p0);
    }

    void levelFlipFinished() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished} != (void(D::*)()){&D::levelFlipFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b060))(this);
        else return PlayerObject::levelFlipFinished();
    }

    void levelFlipping() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipping} != (void(D::*)()){&D::levelFlipping})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a510))(this);
        else return PlayerObject::levelFlipping();
    }

    void levelWillFlip() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelWillFlip} != (void(D::*)()){&D::levelWillFlip})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b020))(this);
        else return PlayerObject::levelWillFlip();
    }

    void loadFromCheckpoint(PlayerCheckpoint p0) {
        if ((void($PlayerObject::*)(PlayerCheckpoint)){&$PlayerObject::loadFromCheckpoint} != (void(D::*)(PlayerCheckpoint)){&D::loadFromCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint)>(m->getOriginal(getBase()+0x22e420))(this, p0);
        else return PlayerObject::loadFromCheckpoint(p0);
    }

    void lockPlayer() {
        if ((void($PlayerObject::*)()){&$PlayerObject::lockPlayer} != (void(D::*)()){&D::lockPlayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d680))(this);
        else return PlayerObject::lockPlayer();
    }

    void logValues() {
        if ((void($PlayerObject::*)()){&$PlayerObject::logValues} != (void(D::*)()){&D::logValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x221220))(this);
        else return PlayerObject::logValues();
    }

    void modeDidChange() {
        if ((void($PlayerObject::*)()){&$PlayerObject::modeDidChange} != (void(D::*)()){&D::modeDidChange})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bfd0))(this);
        else return PlayerObject::modeDidChange();
    }

    void placeStreakPoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint} != (void(D::*)()){&D::placeStreakPoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21af90))(this);
        else return PlayerObject::placeStreakPoint();
    }

    void playBurstEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playBurstEffect} != (void(D::*)()){&D::playBurstEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c780))(this);
        else return PlayerObject::playBurstEffect();
    }

    void playDeathEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playDeathEffect} != (void(D::*)()){&D::playDeathEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225930))(this);
        else return PlayerObject::playDeathEffect();
    }

    void playDynamicSpiderRun() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun} != (void(D::*)()){&D::playDynamicSpiderRun})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222ec0))(this);
        else return PlayerObject::playDynamicSpiderRun();
    }

    void playerDestroyed(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::playerDestroyed} != (void(D::*)(boo)){&D::playerDestroyed})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
        else return PlayerObject::playerDestroyed(p0);
    }

    void playerIsFalling() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playerIsFalling} != (void(D::*)()){&D::playerIsFalling})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c730))(this);
        else return PlayerObject::playerIsFalling();
    }

    void playerTeleported() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playerTeleported} != (void(D::*)()){&D::playerTeleported})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b840))(this);
        else return PlayerObject::playerTeleported();
    }

    void playingEndEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playingEndEffect} != (void(D::*)()){&D::playingEndEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d7e0))(this);
        else return PlayerObject::playingEndEffect();
    }

    void postCollision(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::postCollision} != (void(D::*)(floa)){&D::postCollision})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
        else return PlayerObject::postCollision(p0);
    }

    void preCollision() {
        if ((void($PlayerObject::*)()){&$PlayerObject::preCollision} != (void(D::*)()){&D::preCollision})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ccc0))(this);
        else return PlayerObject::preCollision();
    }

    void preSlopeCollision(floa p0, GameObject p1) {
        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::preSlopeCollision} != (void(D::*)(floa, GameObject)){&D::preSlopeCollision})
            return reinterpret_cast<void(*)(decltype(this), floa, GameObject)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
        else return PlayerObject::preSlopeCollision(p0, p1);
    }

    void propellPlayer(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::propellPlayer} != (void(D::*)(floa)){&D::propellPlayer})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
        else return PlayerObject::propellPlayer(p0);
    }

    void pushButton(PlayerButto p0) {
        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::pushButton} != (void(D::*)(PlayerButto)){&D::pushButton})
            return reinterpret_cast<void(*)(decltype(this), PlayerButto)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
        else return PlayerObject::pushButton(p0);
    }

    void pushDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::pushDown} != (void(D::*)()){&D::pushDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbd0))(this);
        else return PlayerObject::pushDown();
    }

    void pushPlayer(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::pushPlayer} != (void(D::*)(floa)){&D::pushPlayer})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
        else return PlayerObject::pushPlayer(p0);
    }

    void releaseButton(PlayerButto p0) {
        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::releaseButton} != (void(D::*)(PlayerButto)){&D::releaseButton})
            return reinterpret_cast<void(*)(decltype(this), PlayerButto)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
        else return PlayerObject::releaseButton(p0);
    }

    void removeAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::removeAllParticles} != (void(D::*)()){&D::removeAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218ac0))(this);
        else return PlayerObject::removeAllParticles();
    }

    void removePendingCheckpoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint} != (void(D::*)()){&D::removePendingCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2237b0))(this);
        else return PlayerObject::removePendingCheckpoint();
    }

    void resetAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetAllParticles} != (void(D::*)()){&D::resetAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21adb0))(this);
        else return PlayerObject::resetAllParticles();
    }

    void resetCollisionLog() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog} != (void(D::*)()){&D::resetCollisionLog})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cc20))(this);
        else return PlayerObject::resetCollisionLog();
    }

    void resetObject() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223170))(this);
        else return PlayerObject::resetObject();
    }

    void resetPlayerIcon() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon} != (void(D::*)()){&D::resetPlayerIcon})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22be00))(this);
        else return PlayerObject::resetPlayerIcon();
    }

    void resetStateVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetStateVariables} != (void(D::*)()){&D::resetStateVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223760))(this);
        else return PlayerObject::resetStateVariables();
    }

    void resetStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetStreak} != (void(D::*)()){&D::resetStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ae10))(this);
        else return PlayerObject::resetStreak();
    }

    void ringJump(GameObject p0) {
        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::ringJump} != (void(D::*)(GameObject)){&D::ringJump})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
        else return PlayerObject::ringJump(p0);
    }

    void runBallRotation(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::runBallRotation} != (void(D::*)(floa)){&D::runBallRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
        else return PlayerObject::runBallRotation(p0);
    }

    void runBallRotation2() {
        if ((void($PlayerObject::*)()){&$PlayerObject::runBallRotation2} != (void(D::*)()){&D::runBallRotation2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cb10))(this);
        else return PlayerObject::runBallRotation2();
    }

    void runNormalRotation() {
        if ((void($PlayerObject::*)()){&$PlayerObject::runNormalRotation} != (void(D::*)()){&D::runNormalRotation})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c960))(this);
        else return PlayerObject::runNormalRotation();
    }

    void runRotateAction(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::runRotateAction} != (void(D::*)(boo)){&D::runRotateAction})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x21c570))(this, p0);
        else return PlayerObject::runRotateAction(p0);
    }

    void saveToCheckpoint(PlayerCheckpoint p0) {
        if ((void($PlayerObject::*)(PlayerCheckpoint)){&$PlayerObject::saveToCheckpoint} != (void(D::*)(PlayerCheckpoint)){&D::saveToCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
        else return PlayerObject::saveToCheckpoint(p0);
    }

    void setColor(cocos2d::_ccColor3B const p0) override {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
        else return PlayerObject::setColor(p0);
    }

    void setFlipX(boo p0) override {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setFlipX} != (void(D::*)(boo)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x22e720))(this, p0);
        else return PlayerObject::setFlipX(p0);
    }

    void setFlipY(boo p0) override {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setFlipY} != (void(D::*)(boo)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
        else return PlayerObject::setFlipY(p0);
    }

    void setOpacity(unsigned cha p0) override {
        if ((void($PlayerObject::*)(unsigned cha)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned cha)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned cha)>(m->getOriginal(getBase()+0x22d400))(this, p0);
        else return PlayerObject::setOpacity(p0);
    }

    void setPosition(cocos2d::CCPoint const p0) override {
        if ((void($PlayerObject::*)(cocos2d::CCPoint const)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
        else return PlayerObject::setPosition(p0);
    }

    void setRotation(floa p0) override {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setRotation} != (void(D::*)(floa)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
        else return PlayerObject::setRotation(p0);
    }

    void setScale(floa p0) override {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScale} != (void(D::*)(floa)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22e870))(this, p0);
        else return PlayerObject::setScale(p0);
    }

    void setScaleX(floa p0) override {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScaleX} != (void(D::*)(floa)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
        else return PlayerObject::setScaleX(p0);
    }

    void setScaleY(floa p0) override {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScaleY} != (void(D::*)(floa)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22e830))(this, p0);
        else return PlayerObject::setScaleY(p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const p0) {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const)){&$PlayerObject::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x219610))(this, p0);
        else return PlayerObject::setSecondColor(p0);
    }

    void setVisible(boo p0) override {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setVisible} != (void(D::*)(boo)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
        else return PlayerObject::setVisible(p0);
    }

    void setupStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::setupStreak} != (void(D::*)()){&D::setupStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218720))(this);
        else return PlayerObject::setupStreak();
    }

    void spawnCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225480))(this);
        else return PlayerObject::spawnCircle();
    }

    void spawnCircle2() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle2} != (void(D::*)()){&D::spawnCircle2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2252a0))(this);
        else return PlayerObject::spawnCircle2();
    }

    void spawnDualCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle} != (void(D::*)()){&D::spawnDualCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2255c0))(this);
        else return PlayerObject::spawnDualCircle();
    }

    void spawnFromPlayer(PlayerObject p0) {
        if ((void($PlayerObject::*)(PlayerObject)){&$PlayerObject::spawnFromPlayer} != (void(D::*)(PlayerObject)){&D::spawnFromPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
        else return PlayerObject::spawnFromPlayer(p0);
    }

    void spawnPortalCircle(cocos2d::_ccColor3 p0, floa p1) {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3, floa)){&$PlayerObject::spawnPortalCircle} != (void(D::*)(cocos2d::_ccColor3, floa)){&D::spawnPortalCircle})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3, floa)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
        else return PlayerObject::spawnPortalCircle(p0, p1);
    }

    void spawnScaleCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle} != (void(D::*)()){&D::spawnScaleCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2251b0))(this);
        else return PlayerObject::spawnScaleCircle();
    }

    void specialGroundHit() {
        if ((void($PlayerObject::*)()){&$PlayerObject::specialGroundHit} != (void(D::*)()){&D::specialGroundHit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbf0))(this);
        else return PlayerObject::specialGroundHit();
    }

    void speedDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::speedDown} != (void(D::*)()){&D::speedDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e970))(this);
        else return PlayerObject::speedDown();
    }

    void speedUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::speedUp} != (void(D::*)()){&D::speedUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e950))(this);
        else return PlayerObject::speedUp();
    }

    void spiderTestJump(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::spiderTestJump} != (void(D::*)(boo)){&D::spiderTestJump})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x21b160))(this, p0);
        else return PlayerObject::spiderTestJump(p0);
    }

    void startDashing(GameObject p0) {
        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::startDashing} != (void(D::*)(GameObject)){&D::startDashing})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x221d70))(this, p0);
        else return PlayerObject::startDashing(p0);
    }

    void stopBurstEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect} != (void(D::*)()){&D::stopBurstEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22c680))(this);
        else return PlayerObject::stopBurstEffect();
    }

    void stopDashing() {
        if ((void($PlayerObject::*)()){&$PlayerObject::stopDashing} != (void(D::*)()){&D::stopDashing})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222990))(this);
        else return PlayerObject::stopDashing();
    }

    void stopRotation(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::stopRotation} != (void(D::*)(boo)){&D::stopRotation})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x21c830))(this, p0);
        else return PlayerObject::stopRotation(p0);
    }

    void storeCollision(boo p0, in p1) {
        if ((void($PlayerObject::*)(boo, in)){&$PlayerObject::storeCollision} != (void(D::*)(boo, in)){&D::storeCollision})
            return reinterpret_cast<void(*)(decltype(this), boo, in)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
        else return PlayerObject::storeCollision(p0, p1);
    }

    void switchedToMode(GameObjectTyp p0) {
        if ((void($PlayerObject::*)(GameObjectTyp)){&$PlayerObject::switchedToMode} != (void(D::*)(GameObjectTyp)){&D::switchedToMode})
            return reinterpret_cast<void(*)(decltype(this), GameObjectTyp)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
        else return PlayerObject::switchedToMode(p0);
    }

    void testForMoving(floa p0, GameObject p1) {
        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::testForMoving} != (void(D::*)(floa, GameObject)){&D::testForMoving})
            return reinterpret_cast<void(*)(decltype(this), floa, GameObject)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
        else return PlayerObject::testForMoving(p0, p1);
    }

    void toggleBirdMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleBirdMode} != (void(D::*)(boo)){&D::toggleBirdMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x224070))(this, p0);
        else return PlayerObject::toggleBirdMode(p0);
    }

    void toggleDartMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleDartMode} != (void(D::*)(boo)){&D::toggleDartMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
        else return PlayerObject::toggleDartMode(p0);
    }

    void toggleFlyMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleFlyMode} != (void(D::*)(boo)){&D::toggleFlyMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x223820))(this, p0);
        else return PlayerObject::toggleFlyMode(p0);
    }

    void toggleGhostEffect(GhostTyp p0) {
        if ((void($PlayerObject::*)(GhostTyp)){&$PlayerObject::toggleGhostEffect} != (void(D::*)(GhostTyp)){&D::toggleGhostEffect})
            return reinterpret_cast<void(*)(decltype(this), GhostTyp)>(m->getOriginal(getBase()+0x225000))(this, p0);
        else return PlayerObject::toggleGhostEffect(p0);
    }

    void togglePlayerScale(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::togglePlayerScale} != (void(D::*)(boo)){&D::togglePlayerScale})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
        else return PlayerObject::togglePlayerScale(p0);
    }

    void toggleRobotMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleRobotMode} != (void(D::*)(boo)){&D::toggleRobotMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x223c70))(this, p0);
        else return PlayerObject::toggleRobotMode(p0);
    }

    void toggleRollMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleRollMode} != (void(D::*)(boo)){&D::toggleRollMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x223b20))(this, p0);
        else return PlayerObject::toggleRollMode(p0);
    }

    void toggleSpiderMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleSpiderMode} != (void(D::*)(boo)){&D::toggleSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x224830))(this, p0);
        else return PlayerObject::toggleSpiderMode(p0);
    }

    void toggleVisibility(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleVisibility} != (void(D::*)(boo)){&D::toggleVisibility})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
        else return PlayerObject::toggleVisibility(p0);
    }

    void touchedObject(GameObject p0) {
        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::touchedObject} != (void(D::*)(GameObject)){&D::touchedObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject)>(m->getOriginal(getBase()+0x22e660))(this, p0);
        else return PlayerObject::touchedObject(p0);
    }

    void tryPlaceCheckpoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint} != (void(D::*)()){&D::tryPlaceCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a950))(this);
        else return PlayerObject::tryPlaceCheckpoint();
    }

    void update(floa p0) override {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::update} != (void(D::*)(floa)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
        else return PlayerObject::update(p0);
    }

    void updateCheckpointMode(boo p0) {
        if ((void($PlayerObject::*)(boo)){&$PlayerObject::updateCheckpointMode} != (void(D::*)(boo)){&D::updateCheckpointMode})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x218980))(this, p0);
        else return PlayerObject::updateCheckpointMode(p0);
    }

    void updateCheckpointTest() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest} != (void(D::*)()){&D::updateCheckpointTest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a890))(this);
        else return PlayerObject::updateCheckpointTest();
    }

    void updateCollide(boo p0, in p1) {
        if ((void($PlayerObject::*)(boo, in)){&$PlayerObject::updateCollide} != (void(D::*)(boo, in)){&D::updateCollide})
            return reinterpret_cast<void(*)(decltype(this), boo, in)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
        else return PlayerObject::updateCollide(p0, p1);
    }

    void updateCollideBottom(floa p0, in p1) {
        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::updateCollideBottom} != (void(D::*)(floa, in)){&D::updateCollideBottom})
            return reinterpret_cast<void(*)(decltype(this), floa, in)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
        else return PlayerObject::updateCollideBottom(p0, p1);
    }

    void updateCollideTop(floa p0, in p1) {
        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::updateCollideTop} != (void(D::*)(floa, in)){&D::updateCollideTop})
            return reinterpret_cast<void(*)(decltype(this), floa, in)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
        else return PlayerObject::updateCollideTop(p0, p1);
    }

    void updateDashAnimation() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation} != (void(D::*)()){&D::updateDashAnimation})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a570))(this);
        else return PlayerObject::updateDashAnimation();
    }

    void updateDashArt() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashArt} != (void(D::*)()){&D::updateDashArt})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222520))(this);
        else return PlayerObject::updateDashArt();
    }

    void updateGlowColor() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateGlowColor} != (void(D::*)()){&D::updateGlowColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cf10))(this);
        else return PlayerObject::updateGlowColor();
    }

    void updateJump(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateJump} != (void(D::*)(floa)){&D::updateJump})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x219680))(this, p0);
        else return PlayerObject::updateJump(p0);
    }

    void updateJumpVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables} != (void(D::*)()){&D::updateJumpVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a740))(this);
        else return PlayerObject::updateJumpVariables();
    }

    void updatePlayerBirdFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerBirdFrame} != (void(D::*)(in)){&D::updatePlayerBirdFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
        else return PlayerObject::updatePlayerBirdFrame(p0);
    }

    void updatePlayerDartFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerDartFrame} != (void(D::*)(in)){&D::updatePlayerDartFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22c260))(this, p0);
        else return PlayerObject::updatePlayerDartFrame(p0);
    }

    void updatePlayerFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerFrame} != (void(D::*)(in)){&D::updatePlayerFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22c470))(this, p0);
        else return PlayerObject::updatePlayerFrame(p0);
    }

    void updatePlayerGlow() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow} != (void(D::*)()){&D::updatePlayerGlow})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bc50))(this);
        else return PlayerObject::updatePlayerGlow();
    }

    void updatePlayerRobotFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerRobotFrame} != (void(D::*)(in)){&D::updatePlayerRobotFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22d620))(this, p0);
        else return PlayerObject::updatePlayerRobotFrame(p0);
    }

    void updatePlayerRollFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerRollFrame} != (void(D::*)(in)){&D::updatePlayerRollFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
        else return PlayerObject::updatePlayerRollFrame(p0);
    }

    void updatePlayerScale() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale} != (void(D::*)()){&D::updatePlayerScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b8b0))(this);
        else return PlayerObject::updatePlayerScale();
    }

    void updatePlayerShipFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerShipFrame} != (void(D::*)(in)){&D::updatePlayerShipFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
        else return PlayerObject::updatePlayerShipFrame(p0);
    }

    void updatePlayerSpiderFrame(in p0) {
        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerSpiderFrame} != (void(D::*)(in)){&D::updatePlayerSpiderFrame})
            return reinterpret_cast<void(*)(decltype(this), in)>(m->getOriginal(getBase()+0x22d650))(this, p0);
        else return PlayerObject::updatePlayerSpiderFrame(p0);
    }

    void updatePlayerSpriteExtra(std::strin p0) {
        if ((void($PlayerObject::*)(std::strin)){&$PlayerObject::updatePlayerSpriteExtra} != (void(D::*)(std::strin)){&D::updatePlayerSpriteExtra})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x218440))(this, p0);
        else return PlayerObject::updatePlayerSpriteExtra(p0);
    }

    void updateRobotAnimationSpeed() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed} != (void(D::*)()){&D::updateRobotAnimationSpeed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df40))(this);
        else return PlayerObject::updateRobotAnimationSpeed();
    }

    void updateRotation(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateRotation} != (void(D::*)(floa)){&D::updateRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
        else return PlayerObject::updateRotation(p0);
    }

    void updateRotation(floa p0, floa p1) {
        if ((void($PlayerObject::*)(floa, floa)){&$PlayerObject::updateRotation} != (void(D::*)(floa, floa)){&D::updateRotation})
            return reinterpret_cast<void(*)(decltype(this), floa, floa)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
        else return PlayerObject::updateRotation(p0, p1);
    }

    void updateShipRotation(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateShipRotation} != (void(D::*)(floa)){&D::updateShipRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x221310))(this, p0);
        else return PlayerObject::updateShipRotation(p0);
    }

    void updateShipSpriteExtra(std::strin p0) {
        if ((void($PlayerObject::*)(std::strin)){&$PlayerObject::updateShipSpriteExtra} != (void(D::*)(std::strin)){&D::updateShipSpriteExtra})
            return reinterpret_cast<void(*)(decltype(this), std::strin)>(m->getOriginal(getBase()+0x218510))(this, p0);
        else return PlayerObject::updateShipSpriteExtra(p0);
    }

    void updateSlopeRotation(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSlopeRotation} != (void(D::*)(floa)){&D::updateSlopeRotation})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x221030))(this, p0);
        else return PlayerObject::updateSlopeRotation(p0);
    }

    void updateSlopeYVelocity(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSlopeYVelocity} != (void(D::*)(floa)){&D::updateSlopeYVelocity})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x22e920))(this, p0);
        else return PlayerObject::updateSlopeYVelocity(p0);
    }

    void updateSpecial(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSpecial} != (void(D::*)(floa)){&D::updateSpecial})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x21a790))(this, p0);
        else return PlayerObject::updateSpecial(p0);
    }

    void updateStateVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateStateVariables} != (void(D::*)()){&D::updateStateVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a770))(this);
        else return PlayerObject::updateStateVariables();
    }

    void updateTimeMod(floa p0) {
        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateTimeMod} != (void(D::*)(floa)){&D::updateTimeMod})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
        else return PlayerObject::updateTimeMod(p0);
    }

    void usingWallLimitedMode() {
        if ((void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode} != (void(D::*)()){&D::usingWallLimitedMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df00))(this);
        else return PlayerObject::usingWallLimitedMode();
    }

    void yStartDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::yStartDown} != (void(D::*)()){&D::yStartDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e9b0))(this);
        else return PlayerObject::yStartDown();
    }

    void yStartUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::yStartUp} != (void(D::*)()){&D::yStartUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e990))(this);
        else return PlayerObject::yStartUp();
    }

     ~PlayerObject() {
        if ((($PlayerObject::*)()){&$PlayerObject::~PlayerObject} != ((D::*)()){&D::~PlayerObject})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x217100))(this);
        else return PlayerObject::~PlayerObject();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($PlayerObject::*)()){&$PlayerObject::activateStreak} != (void(D::*)()){&D::activateStreak})
            m->registerHook(getBase()+0x21aef0, extract((void(D::*)()){&D::activateStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::addAllParticles} != (void(D::*)()){&D::addAllParticles})
            m->registerHook(getBase()+0x2189b0, extract((void(D::*)()){&D::addAllParticles}));

        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::addToTouchedRings} != (void(D::*)(GameObject)){&D::addToTouchedRings})
            m->registerHook(getBase()+0x22b800, extract((void(D::*)(GameObject)){&D::addToTouchedRings}));

        if ((void($PlayerObject::*)(char const)){&$PlayerObject::animationFinished} != (void(D::*)(char const)){&D::animationFinished})
            m->registerHook(getBase()+0x22e9d0, extract((void(D::*)(char const)){&D::animationFinished}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::boostPlayer} != (void(D::*)(floa)){&D::boostPlayer})
            m->registerHook(getBase()+0x21d6b0, extract((void(D::*)(floa)){&D::boostPlayer}));

        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::bumpPlayer} != (void(D::*)(floa, in)){&D::bumpPlayer})
            m->registerHook(getBase()+0x22d890, extract((void(D::*)(floa, in)){&D::bumpPlayer}));

        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::buttonDown} != (void(D::*)(PlayerButto)){&D::buttonDown})
            m->registerHook(getBase()+0x22b7e0, extract((void(D::*)(PlayerButto)){&D::buttonDown}));

        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::checkSnapJumpToObject} != (void(D::*)(GameObject)){&D::checkSnapJumpToObject})
            m->registerHook(getBase()+0x2217f0, extract((void(D::*)(GameObject)){&D::checkSnapJumpToObject}));

        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::collidedWithObject} != (void(D::*)(floa, GameObject)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21d880, extract((void(D::*)(floa, GameObject)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(floa, GameObject, cocos2d::CCRec)){&$PlayerObject::collidedWithObject} != (void(D::*)(floa, GameObject, cocos2d::CCRec)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21f0b0, extract((void(D::*)(floa, GameObject, cocos2d::CCRec)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(floa, GameObject, boo)){&$PlayerObject::collidedWithSlope} != (void(D::*)(floa, GameObject, boo)){&D::collidedWithSlope})
            m->registerHook(getBase()+0x21d8d0, extract((void(D::*)(floa, GameObject, boo)){&D::collidedWithSlope}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::convertToClosestRotation} != (void(D::*)(floa)){&D::convertToClosestRotation})
            m->registerHook(getBase()+0x21c860, extract((void(D::*)(floa)){&D::convertToClosestRotation}));

        if ((void($PlayerObject::*)(PlayerObject)){&$PlayerObject::copyAttributes} != (void(D::*)(PlayerObject)){&D::copyAttributes})
            m->registerHook(getBase()+0x22dc70, extract((void(D::*)(PlayerObject)){&D::copyAttributes}));

        if ((PlayerObject*(*)(in, in, cocos2d::CCLayer)){&$PlayerObject::create} != (PlayerObject*(*)(in, in, cocos2d::CCLayer)){&D::create})
            m->registerHook(getBase()+0x217260, (PlayerObject*(*)(in, in, cocos2d::CCLayer)){&D::create});

        if ((void($PlayerObject::*)()){&$PlayerObject::deactivateParticle} != (void(D::*)()){&D::deactivateParticle})
            m->registerHook(getBase()+0x21a540, extract((void(D::*)()){&D::deactivateParticle}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::deactivateStreak} != (void(D::*)(boo)){&D::deactivateStreak})
            m->registerHook(getBase()+0x218b30, extract((void(D::*)(boo)){&D::deactivateStreak}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::fadeOutStreak2} != (void(D::*)(floa)){&D::fadeOutStreak2})
            m->registerHook(getBase()+0x225890, extract((void(D::*)(floa)){&D::fadeOutStreak2}));

        if ((void($PlayerObject::*)(floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)){&$PlayerObject::flashPlayer} != (void(D::*)(floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::flashPlayer})
            m->registerHook(getBase()+0x221c80, extract((void(D::*)(floa, floa, cocos2d::_ccColor3, cocos2d::_ccColor3)){&D::flashPlayer}));

        if ((void($PlayerObject::*)(boo, boo)){&$PlayerObject::flipGravity} != (void(D::*)(boo, boo)){&D::flipGravity})
            m->registerHook(getBase()+0x21c090, extract((void(D::*)(boo, boo)){&D::flipGravity}));

        if ((void($PlayerObject::*)()){&$PlayerObject::flipMod} != (void(D::*)()){&D::flipMod})
            m->registerHook(getBase()+0x21a4c0, extract((void(D::*)()){&D::flipMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getActiveMode} != (void(D::*)()){&D::getActiveMode})
            m->registerHook(getBase()+0x22b950, extract((void(D::*)()){&D::getActiveMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel} != (void(D::*)()){&D::getModifiedSlopeYVel})
            m->registerHook(getBase()+0x21bff0, extract((void(D::*)()){&D::getModifiedSlopeYVel}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::getOldPosition} != (void(D::*)(floa)){&D::getOldPosition})
            m->registerHook(getBase()+0x21a830, extract((void(D::*)(floa)){&D::getOldPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(getBase()+0x22dee0, extract((void(D::*)()){&D::getOrientedBox}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(getBase()+0x22d5f0, extract((void(D::*)()){&D::getRealPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getSecondColor} != (void(D::*)()){&D::getSecondColor})
            m->registerHook(getBase()+0x22cee0, extract((void(D::*)()){&D::getSecondColor}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityDown} != (void(D::*)()){&D::gravityDown})
            m->registerHook(getBase()+0x22e930, extract((void(D::*)()){&D::gravityDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityUp} != (void(D::*)()){&D::gravityUp})
            m->registerHook(getBase()+0x22e900, extract((void(D::*)()){&D::gravityUp}));

        if ((void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity} != (void(D::*)()){&D::hardFlipGravity})
            m->registerHook(getBase()+0x22b860, extract((void(D::*)()){&D::hardFlipGravity}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::hitGround} != (void(D::*)(boo)){&D::hitGround})
            m->registerHook(getBase()+0x220a30, extract((void(D::*)(boo)){&D::hitGround}));

        if ((void($PlayerObject::*)()){&$PlayerObject::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x21c050, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayerObject::*)(in, in, cocos2d::CCLayer)){&$PlayerObject::init} != (bool(D::*)(in, in, cocos2d::CCLayer)){&D::init})
            m->registerHook(getBase()+0x2172e0, extract((bool(D::*)(in, in, cocos2d::CCLayer)){&D::init}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isBoostValid} != (void(D::*)(floa)){&D::isBoostValid})
            m->registerHook(getBase()+0x21d650, extract((void(D::*)(floa)){&D::isBoostValid}));

        if ((void($PlayerObject::*)()){&$PlayerObject::isFlying} != (void(D::*)()){&D::isFlying})
            m->registerHook(getBase()+0x21a4e0, extract((void(D::*)()){&D::isFlying}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeFlip} != (void(D::*)(floa)){&D::isSafeFlip})
            m->registerHook(getBase()+0x2209f0, extract((void(D::*)(floa)){&D::isSafeFlip}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeMode} != (void(D::*)(floa)){&D::isSafeMode})
            m->registerHook(getBase()+0x2209b0, extract((void(D::*)(floa)){&D::isSafeMode}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::isSafeSpiderFlip} != (void(D::*)(floa)){&D::isSafeSpiderFlip})
            m->registerHook(getBase()+0x221be0, extract((void(D::*)(floa)){&D::isSafeSpiderFlip}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished} != (void(D::*)()){&D::levelFlipFinished})
            m->registerHook(getBase()+0x21b060, extract((void(D::*)()){&D::levelFlipFinished}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipping} != (void(D::*)()){&D::levelFlipping})
            m->registerHook(getBase()+0x21a510, extract((void(D::*)()){&D::levelFlipping}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelWillFlip} != (void(D::*)()){&D::levelWillFlip})
            m->registerHook(getBase()+0x21b020, extract((void(D::*)()){&D::levelWillFlip}));

        if ((void($PlayerObject::*)(PlayerCheckpoint)){&$PlayerObject::loadFromCheckpoint} != (void(D::*)(PlayerCheckpoint)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x22e420, extract((void(D::*)(PlayerCheckpoint)){&D::loadFromCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::lockPlayer} != (void(D::*)()){&D::lockPlayer})
            m->registerHook(getBase()+0x22d680, extract((void(D::*)()){&D::lockPlayer}));

        if ((void($PlayerObject::*)()){&$PlayerObject::logValues} != (void(D::*)()){&D::logValues})
            m->registerHook(getBase()+0x221220, extract((void(D::*)()){&D::logValues}));

        if ((void($PlayerObject::*)()){&$PlayerObject::modeDidChange} != (void(D::*)()){&D::modeDidChange})
            m->registerHook(getBase()+0x22bfd0, extract((void(D::*)()){&D::modeDidChange}));

        if ((void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint} != (void(D::*)()){&D::placeStreakPoint})
            m->registerHook(getBase()+0x21af90, extract((void(D::*)()){&D::placeStreakPoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playBurstEffect} != (void(D::*)()){&D::playBurstEffect})
            m->registerHook(getBase()+0x21c780, extract((void(D::*)()){&D::playBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDeathEffect} != (void(D::*)()){&D::playDeathEffect})
            m->registerHook(getBase()+0x225930, extract((void(D::*)()){&D::playDeathEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun} != (void(D::*)()){&D::playDynamicSpiderRun})
            m->registerHook(getBase()+0x222ec0, extract((void(D::*)()){&D::playDynamicSpiderRun}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::playerDestroyed} != (void(D::*)(boo)){&D::playerDestroyed})
            m->registerHook(getBase()+0x2256d0, extract((void(D::*)(boo)){&D::playerDestroyed}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerIsFalling} != (void(D::*)()){&D::playerIsFalling})
            m->registerHook(getBase()+0x21c730, extract((void(D::*)()){&D::playerIsFalling}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerTeleported} != (void(D::*)()){&D::playerTeleported})
            m->registerHook(getBase()+0x22b840, extract((void(D::*)()){&D::playerTeleported}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playingEndEffect} != (void(D::*)()){&D::playingEndEffect})
            m->registerHook(getBase()+0x22d7e0, extract((void(D::*)()){&D::playingEndEffect}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::postCollision} != (void(D::*)(floa)){&D::postCollision})
            m->registerHook(getBase()+0x21cd10, extract((void(D::*)(floa)){&D::postCollision}));

        if ((void($PlayerObject::*)()){&$PlayerObject::preCollision} != (void(D::*)()){&D::preCollision})
            m->registerHook(getBase()+0x21ccc0, extract((void(D::*)()){&D::preCollision}));

        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::preSlopeCollision} != (void(D::*)(floa, GameObject)){&D::preSlopeCollision})
            m->registerHook(getBase()+0x21ec80, extract((void(D::*)(floa, GameObject)){&D::preSlopeCollision}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::propellPlayer} != (void(D::*)(floa)){&D::propellPlayer})
            m->registerHook(getBase()+0x22d8e0, extract((void(D::*)(floa)){&D::propellPlayer}));

        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::pushButton} != (void(D::*)(PlayerButto)){&D::pushButton})
            m->registerHook(getBase()+0x22aa00, extract((void(D::*)(PlayerButto)){&D::pushButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::pushDown} != (void(D::*)()){&D::pushDown})
            m->registerHook(getBase()+0x22dbd0, extract((void(D::*)()){&D::pushDown}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::pushPlayer} != (void(D::*)(floa)){&D::pushPlayer})
            m->registerHook(getBase()+0x22dbb0, extract((void(D::*)(floa)){&D::pushPlayer}));

        if ((void($PlayerObject::*)(PlayerButto)){&$PlayerObject::releaseButton} != (void(D::*)(PlayerButto)){&D::releaseButton})
            m->registerHook(getBase()+0x22b6f0, extract((void(D::*)(PlayerButto)){&D::releaseButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removeAllParticles} != (void(D::*)()){&D::removeAllParticles})
            m->registerHook(getBase()+0x218ac0, extract((void(D::*)()){&D::removeAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint} != (void(D::*)()){&D::removePendingCheckpoint})
            m->registerHook(getBase()+0x2237b0, extract((void(D::*)()){&D::removePendingCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetAllParticles} != (void(D::*)()){&D::resetAllParticles})
            m->registerHook(getBase()+0x21adb0, extract((void(D::*)()){&D::resetAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog} != (void(D::*)()){&D::resetCollisionLog})
            m->registerHook(getBase()+0x21cc20, extract((void(D::*)()){&D::resetCollisionLog}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x223170, extract((void(D::*)()){&D::resetObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon} != (void(D::*)()){&D::resetPlayerIcon})
            m->registerHook(getBase()+0x22be00, extract((void(D::*)()){&D::resetPlayerIcon}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStateVariables} != (void(D::*)()){&D::resetStateVariables})
            m->registerHook(getBase()+0x223760, extract((void(D::*)()){&D::resetStateVariables}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStreak} != (void(D::*)()){&D::resetStreak})
            m->registerHook(getBase()+0x21ae10, extract((void(D::*)()){&D::resetStreak}));

        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::ringJump} != (void(D::*)(GameObject)){&D::ringJump})
            m->registerHook(getBase()+0x22abf0, extract((void(D::*)(GameObject)){&D::ringJump}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::runBallRotation} != (void(D::*)(floa)){&D::runBallRotation})
            m->registerHook(getBase()+0x21ca10, extract((void(D::*)(floa)){&D::runBallRotation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runBallRotation2} != (void(D::*)()){&D::runBallRotation2})
            m->registerHook(getBase()+0x21cb10, extract((void(D::*)()){&D::runBallRotation2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runNormalRotation} != (void(D::*)()){&D::runNormalRotation})
            m->registerHook(getBase()+0x21c960, extract((void(D::*)()){&D::runNormalRotation}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::runRotateAction} != (void(D::*)(boo)){&D::runRotateAction})
            m->registerHook(getBase()+0x21c570, extract((void(D::*)(boo)){&D::runRotateAction}));

        if ((void($PlayerObject::*)(PlayerCheckpoint)){&$PlayerObject::saveToCheckpoint} != (void(D::*)(PlayerCheckpoint)){&D::saveToCheckpoint})
            m->registerHook(getBase()+0x22e2f0, extract((void(D::*)(PlayerCheckpoint)){&D::saveToCheckpoint}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setColor})
            m->registerHook(getBase()+0x22cdf0, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setColor}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setFlipX} != (void(D::*)(boo)){&D::setFlipX})
            m->registerHook(getBase()+0x22e720, extract((void(D::*)(boo)){&D::setFlipX}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setFlipY} != (void(D::*)(boo)){&D::setFlipY})
            m->registerHook(getBase()+0x22e7b0, extract((void(D::*)(boo)){&D::setFlipY}));

        if ((void($PlayerObject::*)(unsigned cha)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned cha)){&D::setOpacity})
            m->registerHook(getBase()+0x22d400, extract((void(D::*)(unsigned cha)){&D::setOpacity}));

        if ((void($PlayerObject::*)(cocos2d::CCPoint const)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const)){&D::setPosition})
            m->registerHook(getBase()+0x22c8b0, extract((void(D::*)(cocos2d::CCPoint const)){&D::setPosition}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setRotation} != (void(D::*)(floa)){&D::setRotation})
            m->registerHook(getBase()+0x22e6e0, extract((void(D::*)(floa)){&D::setRotation}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScale} != (void(D::*)(floa)){&D::setScale})
            m->registerHook(getBase()+0x22e870, extract((void(D::*)(floa)){&D::setScale}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScaleX} != (void(D::*)(floa)){&D::setScaleX})
            m->registerHook(getBase()+0x22e7f0, extract((void(D::*)(floa)){&D::setScaleX}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::setScaleY} != (void(D::*)(floa)){&D::setScaleY})
            m->registerHook(getBase()+0x22e830, extract((void(D::*)(floa)){&D::setScaleY}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const)){&$PlayerObject::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor})
            m->registerHook(getBase()+0x219610, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::setVisible} != (void(D::*)(boo)){&D::setVisible})
            m->registerHook(getBase()+0x22e8b0, extract((void(D::*)(boo)){&D::setVisible}));

        if ((void($PlayerObject::*)()){&$PlayerObject::setupStreak} != (void(D::*)()){&D::setupStreak})
            m->registerHook(getBase()+0x218720, extract((void(D::*)()){&D::setupStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x225480, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle2} != (void(D::*)()){&D::spawnCircle2})
            m->registerHook(getBase()+0x2252a0, extract((void(D::*)()){&D::spawnCircle2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle} != (void(D::*)()){&D::spawnDualCircle})
            m->registerHook(getBase()+0x2255c0, extract((void(D::*)()){&D::spawnDualCircle}));

        if ((void($PlayerObject::*)(PlayerObject)){&$PlayerObject::spawnFromPlayer} != (void(D::*)(PlayerObject)){&D::spawnFromPlayer})
            m->registerHook(getBase()+0x22dde0, extract((void(D::*)(PlayerObject)){&D::spawnFromPlayer}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3, floa)){&$PlayerObject::spawnPortalCircle} != (void(D::*)(cocos2d::_ccColor3, floa)){&D::spawnPortalCircle})
            m->registerHook(getBase()+0x225350, extract((void(D::*)(cocos2d::_ccColor3, floa)){&D::spawnPortalCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle} != (void(D::*)()){&D::spawnScaleCircle})
            m->registerHook(getBase()+0x2251b0, extract((void(D::*)()){&D::spawnScaleCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::specialGroundHit} != (void(D::*)()){&D::specialGroundHit})
            m->registerHook(getBase()+0x22dbf0, extract((void(D::*)()){&D::specialGroundHit}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedDown} != (void(D::*)()){&D::speedDown})
            m->registerHook(getBase()+0x22e970, extract((void(D::*)()){&D::speedDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedUp} != (void(D::*)()){&D::speedUp})
            m->registerHook(getBase()+0x22e950, extract((void(D::*)()){&D::speedUp}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::spiderTestJump} != (void(D::*)(boo)){&D::spiderTestJump})
            m->registerHook(getBase()+0x21b160, extract((void(D::*)(boo)){&D::spiderTestJump}));

        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::startDashing} != (void(D::*)(GameObject)){&D::startDashing})
            m->registerHook(getBase()+0x221d70, extract((void(D::*)(GameObject)){&D::startDashing}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect} != (void(D::*)()){&D::stopBurstEffect})
            m->registerHook(getBase()+0x22c680, extract((void(D::*)()){&D::stopBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopDashing} != (void(D::*)()){&D::stopDashing})
            m->registerHook(getBase()+0x222990, extract((void(D::*)()){&D::stopDashing}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::stopRotation} != (void(D::*)(boo)){&D::stopRotation})
            m->registerHook(getBase()+0x21c830, extract((void(D::*)(boo)){&D::stopRotation}));

        if ((void($PlayerObject::*)(boo, in)){&$PlayerObject::storeCollision} != (void(D::*)(boo, in)){&D::storeCollision})
            m->registerHook(getBase()+0x21cc60, extract((void(D::*)(boo, in)){&D::storeCollision}));

        if ((void($PlayerObject::*)(GameObjectTyp)){&$PlayerObject::switchedToMode} != (void(D::*)(GameObjectTyp)){&D::switchedToMode})
            m->registerHook(getBase()+0x22b9a0, extract((void(D::*)(GameObjectTyp)){&D::switchedToMode}));

        if ((void($PlayerObject::*)(floa, GameObject)){&$PlayerObject::testForMoving} != (void(D::*)(floa, GameObject)){&D::testForMoving})
            m->registerHook(getBase()+0x21eb70, extract((void(D::*)(floa, GameObject)){&D::testForMoving}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleBirdMode} != (void(D::*)(boo)){&D::toggleBirdMode})
            m->registerHook(getBase()+0x224070, extract((void(D::*)(boo)){&D::toggleBirdMode}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleDartMode} != (void(D::*)(boo)){&D::toggleDartMode})
            m->registerHook(getBase()+0x2243f0, extract((void(D::*)(boo)){&D::toggleDartMode}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleFlyMode} != (void(D::*)(boo)){&D::toggleFlyMode})
            m->registerHook(getBase()+0x223820, extract((void(D::*)(boo)){&D::toggleFlyMode}));

        if ((void($PlayerObject::*)(GhostTyp)){&$PlayerObject::toggleGhostEffect} != (void(D::*)(GhostTyp)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x225000, extract((void(D::*)(GhostTyp)){&D::toggleGhostEffect}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::togglePlayerScale} != (void(D::*)(boo)){&D::togglePlayerScale})
            m->registerHook(getBase()+0x224bd0, extract((void(D::*)(boo)){&D::togglePlayerScale}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleRobotMode} != (void(D::*)(boo)){&D::toggleRobotMode})
            m->registerHook(getBase()+0x223c70, extract((void(D::*)(boo)){&D::toggleRobotMode}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleRollMode} != (void(D::*)(boo)){&D::toggleRollMode})
            m->registerHook(getBase()+0x223b20, extract((void(D::*)(boo)){&D::toggleRollMode}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleSpiderMode} != (void(D::*)(boo)){&D::toggleSpiderMode})
            m->registerHook(getBase()+0x224830, extract((void(D::*)(boo)){&D::toggleSpiderMode}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::toggleVisibility} != (void(D::*)(boo)){&D::toggleVisibility})
            m->registerHook(getBase()+0x21abf0, extract((void(D::*)(boo)){&D::toggleVisibility}));

        if ((void($PlayerObject::*)(GameObject)){&$PlayerObject::touchedObject} != (void(D::*)(GameObject)){&D::touchedObject})
            m->registerHook(getBase()+0x22e660, extract((void(D::*)(GameObject)){&D::touchedObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint} != (void(D::*)()){&D::tryPlaceCheckpoint})
            m->registerHook(getBase()+0x21a950, extract((void(D::*)()){&D::tryPlaceCheckpoint}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::update} != (void(D::*)(floa)){&D::update})
            m->registerHook(getBase()+0x218bf0, extract((void(D::*)(floa)){&D::update}));

        if ((void($PlayerObject::*)(boo)){&$PlayerObject::updateCheckpointMode} != (void(D::*)(boo)){&D::updateCheckpointMode})
            m->registerHook(getBase()+0x218980, extract((void(D::*)(boo)){&D::updateCheckpointMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest} != (void(D::*)()){&D::updateCheckpointTest})
            m->registerHook(getBase()+0x21a890, extract((void(D::*)()){&D::updateCheckpointTest}));

        if ((void($PlayerObject::*)(boo, in)){&$PlayerObject::updateCollide} != (void(D::*)(boo, in)){&D::updateCollide})
            m->registerHook(getBase()+0x220f10, extract((void(D::*)(boo, in)){&D::updateCollide}));

        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::updateCollideBottom} != (void(D::*)(floa, in)){&D::updateCollideBottom})
            m->registerHook(getBase()+0x221790, extract((void(D::*)(floa, in)){&D::updateCollideBottom}));

        if ((void($PlayerObject::*)(floa, in)){&$PlayerObject::updateCollideTop} != (void(D::*)(floa, in)){&D::updateCollideTop})
            m->registerHook(getBase()+0x221c20, extract((void(D::*)(floa, in)){&D::updateCollideTop}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation} != (void(D::*)()){&D::updateDashAnimation})
            m->registerHook(getBase()+0x21a570, extract((void(D::*)()){&D::updateDashAnimation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashArt} != (void(D::*)()){&D::updateDashArt})
            m->registerHook(getBase()+0x222520, extract((void(D::*)()){&D::updateDashArt}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateGlowColor} != (void(D::*)()){&D::updateGlowColor})
            m->registerHook(getBase()+0x22cf10, extract((void(D::*)()){&D::updateGlowColor}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateJump} != (void(D::*)(floa)){&D::updateJump})
            m->registerHook(getBase()+0x219680, extract((void(D::*)(floa)){&D::updateJump}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables} != (void(D::*)()){&D::updateJumpVariables})
            m->registerHook(getBase()+0x21a740, extract((void(D::*)()){&D::updateJumpVariables}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerBirdFrame} != (void(D::*)(in)){&D::updatePlayerBirdFrame})
            m->registerHook(getBase()+0x22bfe0, extract((void(D::*)(in)){&D::updatePlayerBirdFrame}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerDartFrame} != (void(D::*)(in)){&D::updatePlayerDartFrame})
            m->registerHook(getBase()+0x22c260, extract((void(D::*)(in)){&D::updatePlayerDartFrame}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerFrame} != (void(D::*)(in)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x22c470, extract((void(D::*)(in)){&D::updatePlayerFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow} != (void(D::*)()){&D::updatePlayerGlow})
            m->registerHook(getBase()+0x22bc50, extract((void(D::*)()){&D::updatePlayerGlow}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerRobotFrame} != (void(D::*)(in)){&D::updatePlayerRobotFrame})
            m->registerHook(getBase()+0x22d620, extract((void(D::*)(in)){&D::updatePlayerRobotFrame}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerRollFrame} != (void(D::*)(in)){&D::updatePlayerRollFrame})
            m->registerHook(getBase()+0x22c6a0, extract((void(D::*)(in)){&D::updatePlayerRollFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale} != (void(D::*)()){&D::updatePlayerScale})
            m->registerHook(getBase()+0x22b8b0, extract((void(D::*)()){&D::updatePlayerScale}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerShipFrame} != (void(D::*)(in)){&D::updatePlayerShipFrame})
            m->registerHook(getBase()+0x22ba40, extract((void(D::*)(in)){&D::updatePlayerShipFrame}));

        if ((void($PlayerObject::*)(in)){&$PlayerObject::updatePlayerSpiderFrame} != (void(D::*)(in)){&D::updatePlayerSpiderFrame})
            m->registerHook(getBase()+0x22d650, extract((void(D::*)(in)){&D::updatePlayerSpiderFrame}));

        if ((void($PlayerObject::*)(std::strin)){&$PlayerObject::updatePlayerSpriteExtra} != (void(D::*)(std::strin)){&D::updatePlayerSpriteExtra})
            m->registerHook(getBase()+0x218440, extract((void(D::*)(std::strin)){&D::updatePlayerSpriteExtra}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed} != (void(D::*)()){&D::updateRobotAnimationSpeed})
            m->registerHook(getBase()+0x22df40, extract((void(D::*)()){&D::updateRobotAnimationSpeed}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateRotation} != (void(D::*)(floa)){&D::updateRotation})
            m->registerHook(getBase()+0x2214b0, extract((void(D::*)(floa)){&D::updateRotation}));

        if ((void($PlayerObject::*)(floa, floa)){&$PlayerObject::updateRotation} != (void(D::*)(floa, floa)){&D::updateRotation})
            m->registerHook(getBase()+0x221230, extract((void(D::*)(floa, floa)){&D::updateRotation}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateShipRotation} != (void(D::*)(floa)){&D::updateShipRotation})
            m->registerHook(getBase()+0x221310, extract((void(D::*)(floa)){&D::updateShipRotation}));

        if ((void($PlayerObject::*)(std::strin)){&$PlayerObject::updateShipSpriteExtra} != (void(D::*)(std::strin)){&D::updateShipSpriteExtra})
            m->registerHook(getBase()+0x218510, extract((void(D::*)(std::strin)){&D::updateShipSpriteExtra}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSlopeRotation} != (void(D::*)(floa)){&D::updateSlopeRotation})
            m->registerHook(getBase()+0x221030, extract((void(D::*)(floa)){&D::updateSlopeRotation}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSlopeYVelocity} != (void(D::*)(floa)){&D::updateSlopeYVelocity})
            m->registerHook(getBase()+0x22e920, extract((void(D::*)(floa)){&D::updateSlopeYVelocity}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateSpecial} != (void(D::*)(floa)){&D::updateSpecial})
            m->registerHook(getBase()+0x21a790, extract((void(D::*)(floa)){&D::updateSpecial}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateStateVariables} != (void(D::*)()){&D::updateStateVariables})
            m->registerHook(getBase()+0x21a770, extract((void(D::*)()){&D::updateStateVariables}));

        if ((void($PlayerObject::*)(floa)){&$PlayerObject::updateTimeMod} != (void(D::*)(floa)){&D::updateTimeMod})
            m->registerHook(getBase()+0x2185e0, extract((void(D::*)(floa)){&D::updateTimeMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode} != (void(D::*)()){&D::usingWallLimitedMode})
            m->registerHook(getBase()+0x22df00, extract((void(D::*)()){&D::usingWallLimitedMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartDown} != (void(D::*)()){&D::yStartDown})
            m->registerHook(getBase()+0x22e9b0, extract((void(D::*)()){&D::yStartDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartUp} != (void(D::*)()){&D::yStartUp})
            m->registerHook(getBase()+0x22e990, extract((void(D::*)()){&D::yStartUp}));

        if ((($PlayerObject::*)()){&$PlayerObject::~PlayerObject} != ((D::*)()){&D::~PlayerObject})
            m->registerHook(getBase()+0x217100, extract(((D::*)()){&D::~PlayerObject}));
    }
};


template<class D>
class $PulseEffectAction : public PulseEffectAction, public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PulseEffectAction() {}
    typedef PulseEffectAction* __thistype;

    static PulseEffectAction* createFromString(std::strin p0) {
        if ((PulseEffectAction*(*)(std::strin)){&$PulseEffectAction::createFromString} != (PulseEffectAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<PulseEffectAction*(*)(std::strin)>(m->getOriginal(getBase()+0x179e90))(p0);
        else return PulseEffectAction::createFromString(p0);
    }

    void getSaveString() {
        if ((void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17a850))(this);
        else return PulseEffectAction::getSaveString();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((PulseEffectAction*(*)(std::strin)){&$PulseEffectAction::createFromString} != (PulseEffectAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x179e90, (PulseEffectAction*(*)(std::strin)){&D::createFromString});

        if ((void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17a850, extract((void(D::*)()){&D::getSaveString}));
    }
};


template<class D>
class $RetryLevelLayer : public RetryLevelLayer, public $CacBase {
 public:
    $RetryLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$RetryLevelLayer() {}
    typedef RetryLevelLayer* __thistype;

    static RetryLevelLayer* create() {
        if ((RetryLevelLayer*(*)()){&$RetryLevelLayer::create} != (RetryLevelLayer*(*)()){&D::create})
            return reinterpret_cast<RetryLevelLayer*(*)()>(m->getOriginal(getBase()+0x28dd60))();
        else return RetryLevelLayer::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((RetryLevelLayer*(*)()){&$RetryLevelLayer::create} != (RetryLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x28dd60, (RetryLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $SetGroupIDLayer : public SetGroupIDLayer, public $CacBase {
 public:
    $SetGroupIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetGroupIDLayer() {}
    typedef SetGroupIDLayer* __thistype;

    void onNextGroupID1(cocos2d::CCObject p0) {
        if ((void($SetGroupIDLayer::*)(cocos2d::CCObject)){&$SetGroupIDLayer::onNextGroupID1} != (void(D::*)(cocos2d::CCObject)){&D::onNextGroupID1})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1967a0))(this, p0);
        else return SetGroupIDLayer::onNextGroupID1(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x197af0))(this, p0);
        else return SetGroupIDLayer::textChanged(p0);
    }

    void updateGroupIDLabel() {
        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel} != (void(D::*)()){&D::updateGroupIDLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x197260))(this);
        else return SetGroupIDLayer::updateGroupIDLabel();
    }

     ~SetGroupIDLayer() {
        if ((($SetGroupIDLayer::*)()){&$SetGroupIDLayer::~SetGroupIDLayer} != ((D::*)()){&D::~SetGroupIDLayer})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x194410))(this);
        else return SetGroupIDLayer::~SetGroupIDLayer();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($SetGroupIDLayer::*)(cocos2d::CCObject)){&$SetGroupIDLayer::onNextGroupID1} != (void(D::*)(cocos2d::CCObject)){&D::onNextGroupID1})
            m->registerHook(getBase()+0x1967a0, extract((void(D::*)(cocos2d::CCObject)){&D::onNextGroupID1}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x197af0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel} != (void(D::*)()){&D::updateGroupIDLabel})
            m->registerHook(getBase()+0x197260, extract((void(D::*)()){&D::updateGroupIDLabel}));

        if ((($SetGroupIDLayer::*)()){&$SetGroupIDLayer::~SetGroupIDLayer} != ((D::*)()){&D::~SetGroupIDLayer})
            m->registerHook(getBase()+0x194410, extract(((D::*)()){&D::~SetGroupIDLayer}));
    }
};


template<class D>
class $SetIDLayer : public SetIDLayer, public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetIDLayer() {}
    typedef SetIDLayer* __thistype;

    static SetIDLayer* create(GameObject p0) {
        if ((SetIDLayer*(*)(GameObject)){&$SetIDLayer::create} != (SetIDLayer*(*)(GameObject)){&D::create})
            return reinterpret_cast<SetIDLayer*(*)(GameObject)>(m->getOriginal(getBase()+0x168f20))(p0);
        else return SetIDLayer::create(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetIDLayer*(*)(GameObject)){&$SetIDLayer::create} != (SetIDLayer*(*)(GameObject)){&D::create})
            m->registerHook(getBase()+0x168f20, (SetIDLayer*(*)(GameObject)){&D::create});
    }
};


template<class D>
class $SetItemIDLayer : public SetItemIDLayer, public $CacBase {
 public:
    $SetItemIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetItemIDLayer() {}
    typedef SetItemIDLayer* __thistype;

    static SetItemIDLayer* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$SetItemIDLayer::create} != (SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x5a830))(p0, p1);
        else return SetItemIDLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)){&$SetItemIDLayer::create} != (SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x5a830, (SetItemIDLayer*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});
    }
};


template<class D>
class $SetTargetIDLayer : public SetTargetIDLayer, public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetTargetIDLayer() {}
    typedef SetTargetIDLayer* __thistype;

    static SetTargetIDLayer* create(EffectGameObject p0, cocos2d::CCArray p1, std::strin p2) {
        if ((SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)){&$SetTargetIDLayer::create} != (SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)){&D::create})
            return reinterpret_cast<SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)>(m->getOriginal(getBase()+0x159d20))(p0, p1, p2);
        else return SetTargetIDLayer::create(p0, p1, p2);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetTargetIDLayer::*)(cocos2d::CCObject)){&$SetTargetIDLayer::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x15aed0))(this, p0);
        else return SetTargetIDLayer::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x15b6c0))(this, p0);
        else return SetTargetIDLayer::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15b4a0))(this);
        else return SetTargetIDLayer::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)){&$SetTargetIDLayer::create} != (SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)){&D::create})
            m->registerHook(getBase()+0x159d20, (SetTargetIDLayer*(*)(EffectGameObject, cocos2d::CCArray, std::strin)){&D::create});

        if ((void($SetTargetIDLayer::*)(cocos2d::CCObject)){&$SetTargetIDLayer::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15aed0, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x15b6c0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15b4a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupAnimationPopup : public SetupAnimationPopup, public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupAnimationPopup() {}
    typedef SetupAnimationPopup* __thistype;

    static SetupAnimationPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupAnimationPopup::create} != (SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x208b70))(p0, p1);
        else return SetupAnimationPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupAnimationPopup::*)(cocos2d::CCObject)){&$SetupAnimationPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x209fc0))(this, p0);
        else return SetupAnimationPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x20ab30))(this, p0);
        else return SetupAnimationPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20a910))(this);
        else return SetupAnimationPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupAnimationPopup::create} != (SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x208b70, (SetupAnimationPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupAnimationPopup::*)(cocos2d::CCObject)){&$SetupAnimationPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x209fc0, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x20ab30, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x20a910, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCollisionTriggerPopup : public SetupCollisionTriggerPopup, public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupCollisionTriggerPopup() {}
    typedef SetupCollisionTriggerPopup* __thistype;

    static SetupCollisionTriggerPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupCollisionTriggerPopup::create} != (SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1d6120))(p0, p1);
        else return SetupCollisionTriggerPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject)){&$SetupCollisionTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1d77b0))(this, p0);
        else return SetupCollisionTriggerPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x1d84d0))(this, p0);
        else return SetupCollisionTriggerPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d82b0))(this);
        else return SetupCollisionTriggerPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupCollisionTriggerPopup::create} != (SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1d6120, (SetupCollisionTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject)){&$SetupCollisionTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1d77b0, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x1d84d0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1d82b0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCountTriggerPopup : public SetupCountTriggerPopup, public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupCountTriggerPopup() {}
    typedef SetupCountTriggerPopup* __thistype;

    static SetupCountTriggerPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupCountTriggerPopup::create} != (SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x15c6c0))(p0, p1);
        else return SetupCountTriggerPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupCountTriggerPopup::*)(cocos2d::CCObject)){&$SetupCountTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x15dd40))(this, p0);
        else return SetupCountTriggerPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x15e9a0))(this, p0);
        else return SetupCountTriggerPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15e8a0))(this);
        else return SetupCountTriggerPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupCountTriggerPopup::create} != (SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x15c6c0, (SetupCountTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupCountTriggerPopup::*)(cocos2d::CCObject)){&$SetupCountTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15dd40, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x15e9a0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15e8a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInstantCountPopup : public SetupInstantCountPopup, public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupInstantCountPopup() {}
    typedef SetupInstantCountPopup* __thistype;

    static SetupInstantCountPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupInstantCountPopup::create} != (SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x352c10))(p0, p1);
        else return SetupInstantCountPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupInstantCountPopup::*)(cocos2d::CCObject)){&$SetupInstantCountPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x354520))(this, p0);
        else return SetupInstantCountPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x355270))(this, p0);
        else return SetupInstantCountPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x355170))(this);
        else return SetupInstantCountPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupInstantCountPopup::create} != (SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x352c10, (SetupInstantCountPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupInstantCountPopup::*)(cocos2d::CCObject)){&$SetupInstantCountPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x354520, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x355270, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x355170, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInteractObjectPopup : public SetupInteractObjectPopup, public $CacBase {
 public:
    $SetupInteractObjectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupInteractObjectPopup() {}
    typedef SetupInteractObjectPopup* __thistype;

    static SetupInteractObjectPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupInteractObjectPopup::create} != (SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x29a400))(p0, p1);
        else return SetupInteractObjectPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupInteractObjectPopup::*)(cocos2d::CCObject)){&$SetupInteractObjectPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x29bbc0))(this, p0);
        else return SetupInteractObjectPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x29c2b0))(this, p0);
        else return SetupInteractObjectPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x29c120))(this);
        else return SetupInteractObjectPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupInteractObjectPopup::create} != (SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x29a400, (SetupInteractObjectPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupInteractObjectPopup::*)(cocos2d::CCObject)){&$SetupInteractObjectPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x29bbc0, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x29c2b0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x29c120, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupObjectTogglePopup : public SetupObjectTogglePopup, public $CacBase {
 public:
    $SetupObjectTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupObjectTogglePopup() {}
    typedef SetupObjectTogglePopup* __thistype;

    static SetupObjectTogglePopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupObjectTogglePopup::create} != (SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1c0860))(p0, p1);
        else return SetupObjectTogglePopup::create(p0, p1);
    }

    bool init(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((bool($SetupObjectTogglePopup::*)(EffectGameObject, cocos2d::CCArray)){&$SetupObjectTogglePopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1c0a40))(this, p0, p1);
        else return SetupObjectTogglePopup::init(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupObjectTogglePopup::*)(cocos2d::CCObject)){&$SetupObjectTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1c1c40))(this, p0);
        else return SetupObjectTogglePopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x1c2660))(this, p0);
        else return SetupObjectTogglePopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2440))(this);
        else return SetupObjectTogglePopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupObjectTogglePopup::create} != (SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1c0860, (SetupObjectTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((bool($SetupObjectTogglePopup::*)(EffectGameObject, cocos2d::CCArray)){&$SetupObjectTogglePopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            m->registerHook(getBase()+0x1c0a40, extract((bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init}));

        if ((void($SetupObjectTogglePopup::*)(cocos2d::CCObject)){&$SetupObjectTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1c1c40, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x1c2660, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1c2440, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupOpacityPopup : public SetupOpacityPopup, public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupOpacityPopup() {}
    typedef SetupOpacityPopup* __thistype;

    static SetupOpacityPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupOpacityPopup::create} != (SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x32b70))(p0, p1);
        else return SetupOpacityPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupOpacityPopup::*)(cocos2d::CCObject)){&$SetupOpacityPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x340a0))(this, p0);
        else return SetupOpacityPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x34a60))(this, p0);
        else return SetupOpacityPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34760))(this);
        else return SetupOpacityPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupOpacityPopup::create} != (SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x32b70, (SetupOpacityPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupOpacityPopup::*)(cocos2d::CCObject)){&$SetupOpacityPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x340a0, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x34a60, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x34760, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupPickupTriggerPopup : public SetupPickupTriggerPopup, public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupPickupTriggerPopup() {}
    typedef SetupPickupTriggerPopup* __thistype;

    static SetupPickupTriggerPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupPickupTriggerPopup::create} != (SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x35e70))(p0, p1);
        else return SetupPickupTriggerPopup::create(p0, p1);
    }

    void onItemIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject)){&$SetupPickupTriggerPopup::onItemIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onItemIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x37100))(this, p0);
        else return SetupPickupTriggerPopup::onItemIDArrow(p0);
    }

    void onNextItemID(cocos2d::CCObject p0) {
        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject)){&$SetupPickupTriggerPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject)){&D::onNextItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x37260))(this, p0);
        else return SetupPickupTriggerPopup::onNextItemID(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x37ca0))(this, p0);
        else return SetupPickupTriggerPopup::textChanged(p0);
    }

    void updateItemID() {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID} != (void(D::*)()){&D::updateItemID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x37ab0))(this);
        else return SetupPickupTriggerPopup::updateItemID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupPickupTriggerPopup::create} != (SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x35e70, (SetupPickupTriggerPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject)){&$SetupPickupTriggerPopup::onItemIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onItemIDArrow})
            m->registerHook(getBase()+0x37100, extract((void(D::*)(cocos2d::CCObject)){&D::onItemIDArrow}));

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject)){&$SetupPickupTriggerPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject)){&D::onNextItemID})
            m->registerHook(getBase()+0x37260, extract((void(D::*)(cocos2d::CCObject)){&D::onNextItemID}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x37ca0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID} != (void(D::*)()){&D::updateItemID})
            m->registerHook(getBase()+0x37ab0, extract((void(D::*)()){&D::updateItemID}));
    }
};


template<class D>
class $SetupPulsePopup : public SetupPulsePopup, public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupPulsePopup() {}
    typedef SetupPulsePopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3 p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
        else return SetupPulsePopup::colorValueChanged(p0);
    }

    static SetupPulsePopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupPulsePopup::create} != (SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1e6d40))(p0, p1);
        else return SetupPulsePopup::create(p0, p1);
    }

    bool init(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((bool($SetupPulsePopup::*)(EffectGameObject, cocos2d::CCArray)){&$SetupPulsePopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
        else return SetupPulsePopup::init(p0, p1);
    }

    void onSelectPulseMode(cocos2d::CCObject p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onSelectPulseMode} != (void(D::*)(cocos2d::CCObject)){&D::onSelectPulseMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
        else return SetupPulsePopup::onSelectPulseMode(p0);
    }

    void onSelectTargetMode(cocos2d::CCObject p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onSelectTargetMode} != (void(D::*)(cocos2d::CCObject)){&D::onSelectTargetMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1eac30))(this, p0);
        else return SetupPulsePopup::onSelectTargetMode(p0);
    }

    void onUpdateCustomColor(cocos2d::CCObject p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onUpdateCustomColor} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateCustomColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x1eaef0))(this, p0);
        else return SetupPulsePopup::onUpdateCustomColor(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x1ec960))(this, p0);
        else return SetupPulsePopup::textChanged(p0);
    }

    void updateCopyColorTextInputLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebf20))(this);
        else return SetupPulsePopup::updateCopyColorTextInputLabel();
    }

    void updateEditorLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ec310))(this);
        else return SetupPulsePopup::updateEditorLabel();
    }

    void updateFadeOutLabel(boo p0) {
        if ((void($SetupPulsePopup::*)(boo)){&$SetupPulsePopup::updateFadeOutLabel} != (void(D::*)(boo)){&D::updateFadeOutLabel})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
        else return SetupPulsePopup::updateFadeOutLabel(p0);
    }

    void updateTargetID() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebbe0))(this);
        else return SetupPulsePopup::updateTargetID();
    }

    void updateTextInputLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1eb8d0))(this);
        else return SetupPulsePopup::updateTextInputLabel();
    }

     ~SetupPulsePopup() {
        if ((($SetupPulsePopup::*)()){&$SetupPulsePopup::~SetupPulsePopup} != ((D::*)()){&D::~SetupPulsePopup})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0x1e6b40))(this);
        else return SetupPulsePopup::~SetupPulsePopup();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged})
            m->registerHook(getBase()+0x1ec680, extract((void(D::*)(cocos2d::_ccColor3)){&D::colorValueChanged}));

        if ((SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupPulsePopup::create} != (SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1e6d40, (SetupPulsePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((bool($SetupPulsePopup::*)(EffectGameObject, cocos2d::CCArray)){&$SetupPulsePopup::init} != (bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init})
            m->registerHook(getBase()+0x1e7010, extract((bool(D::*)(EffectGameObject, cocos2d::CCArray)){&D::init}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onSelectPulseMode} != (void(D::*)(cocos2d::CCObject)){&D::onSelectPulseMode})
            m->registerHook(getBase()+0x1eb020, extract((void(D::*)(cocos2d::CCObject)){&D::onSelectPulseMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onSelectTargetMode} != (void(D::*)(cocos2d::CCObject)){&D::onSelectTargetMode})
            m->registerHook(getBase()+0x1eac30, extract((void(D::*)(cocos2d::CCObject)){&D::onSelectTargetMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject)){&$SetupPulsePopup::onUpdateCustomColor} != (void(D::*)(cocos2d::CCObject)){&D::onUpdateCustomColor})
            m->registerHook(getBase()+0x1eaef0, extract((void(D::*)(cocos2d::CCObject)){&D::onUpdateCustomColor}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x1ec960, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x1ebf20, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x1ec310, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($SetupPulsePopup::*)(boo)){&$SetupPulsePopup::updateFadeOutLabel} != (void(D::*)(boo)){&D::updateFadeOutLabel})
            m->registerHook(getBase()+0x1eba20, extract((void(D::*)(boo)){&D::updateFadeOutLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1ebbe0, extract((void(D::*)()){&D::updateTargetID}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x1eb8d0, extract((void(D::*)()){&D::updateTextInputLabel}));

        if ((($SetupPulsePopup::*)()){&$SetupPulsePopup::~SetupPulsePopup} != ((D::*)()){&D::~SetupPulsePopup})
            m->registerHook(getBase()+0x1e6b40, extract(((D::*)()){&D::~SetupPulsePopup}));
    }
};


template<class D>
class $SetupShakePopup : public SetupShakePopup, public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupShakePopup() {}
    typedef SetupShakePopup* __thistype;

    static SetupShakePopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupShakePopup::create} != (SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x3adc00))(p0, p1);
        else return SetupShakePopup::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupShakePopup::create} != (SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x3adc00, (SetupShakePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});
    }
};


template<class D>
class $SetupSpawnPopup : public SetupSpawnPopup, public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupSpawnPopup() {}
    typedef SetupSpawnPopup* __thistype;

    static SetupSpawnPopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupSpawnPopup::create} != (SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x139790))(p0, p1);
        else return SetupSpawnPopup::create(p0, p1);
    }

    void createToggleButton(std::strin p0, cocos2d::SEL_CallFunc p1, boo p2, cocos2d::CCMenu p3, cocos2d::CCPoin p4, cocos2d::CCArray p5) {
        if ((void($SetupSpawnPopup::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)){&$SetupSpawnPopup::createToggleButton} != (void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)){&D::createToggleButton})
            return reinterpret_cast<void(*)(decltype(this), std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
        else return SetupSpawnPopup::createToggleButton(p0, p1, p2, p3, p4, p5);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupSpawnPopup::*)(cocos2d::CCObject)){&$SetupSpawnPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x13ad80))(this, p0);
        else return SetupSpawnPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x13b990))(this, p0);
        else return SetupSpawnPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13b770))(this);
        else return SetupSpawnPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupSpawnPopup::create} != (SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x139790, (SetupSpawnPopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupSpawnPopup::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)){&$SetupSpawnPopup::createToggleButton} != (void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)){&D::createToggleButton})
            m->registerHook(getBase()+0x13b0e0, extract((void(D::*)(std::strin, cocos2d::SEL_CallFunc, boo, cocos2d::CCMenu, cocos2d::CCPoin, cocos2d::CCArray)){&D::createToggleButton}));

        if ((void($SetupSpawnPopup::*)(cocos2d::CCObject)){&$SetupSpawnPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x13ad80, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x13b990, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x13b770, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupTouchTogglePopup : public SetupTouchTogglePopup, public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupTouchTogglePopup() {}
    typedef SetupTouchTogglePopup* __thistype;

    static SetupTouchTogglePopup* create(EffectGameObject p0, cocos2d::CCArray p1) {
        if ((SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupTouchTogglePopup::create} != (SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            return reinterpret_cast<SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)>(m->getOriginal(getBase()+0x1576a0))(p0, p1);
        else return SetupTouchTogglePopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject p0) {
        if ((void($SetupTouchTogglePopup::*)(cocos2d::CCObject)){&$SetupTouchTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject)>(m->getOriginal(getBase()+0x158b60))(this, p0);
        else return SetupTouchTogglePopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode p0) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x1596a0))(this, p0);
        else return SetupTouchTogglePopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x159480))(this);
        else return SetupTouchTogglePopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&$SetupTouchTogglePopup::create} != (SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create})
            m->registerHook(getBase()+0x1576a0, (SetupTouchTogglePopup*(*)(EffectGameObject, cocos2d::CCArray)){&D::create});

        if ((void($SetupTouchTogglePopup::*)(cocos2d::CCObject)){&$SetupTouchTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x158b60, extract((void(D::*)(cocos2d::CCObject)){&D::onTargetIDArrow}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode)){&D::textChanged})
            m->registerHook(getBase()+0x1596a0, extract((void(D::*)(CCTextInputNode)){&D::textChanged}));

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x159480, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SimplePlayer : public SimplePlayer, public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SimplePlayer() {}
    typedef SimplePlayer* __thistype;

    static SimplePlayer* create(in p0) {
        if ((SimplePlayer*(*)(in)){&$SimplePlayer::create} != (SimplePlayer*(*)(in)){&D::create})
            return reinterpret_cast<SimplePlayer*(*)(in)>(m->getOriginal(getBase()+0x1b6140))(p0);
        else return SimplePlayer::create(p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const p0) {
        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const)){&$SimplePlayer::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
        else return SimplePlayer::setSecondColor(p0);
    }

    void updateColors() {
        if ((void($SimplePlayer::*)()){&$SimplePlayer::updateColors} != (void(D::*)()){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ba1f0))(this);
        else return SimplePlayer::updateColors();
    }

    void updatePlayerFrame(in p0, IconTyp p1) {
        if ((void($SimplePlayer::*)(in, IconTyp)){&$SimplePlayer::updatePlayerFrame} != (void(D::*)(in, IconTyp)){&D::updatePlayerFrame})
            return reinterpret_cast<void(*)(decltype(this), in, IconTyp)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
        else return SimplePlayer::updatePlayerFrame(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SimplePlayer*(*)(in)){&$SimplePlayer::create} != (SimplePlayer*(*)(in)){&D::create})
            m->registerHook(getBase()+0x1b6140, (SimplePlayer*(*)(in)){&D::create});

        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const)){&$SimplePlayer::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor})
            m->registerHook(getBase()+0x1bace0, extract((void(D::*)(cocos2d::_ccColor3B const)){&D::setSecondColor}));

        if ((void($SimplePlayer::*)()){&$SimplePlayer::updateColors} != (void(D::*)()){&D::updateColors})
            m->registerHook(getBase()+0x1ba1f0, extract((void(D::*)()){&D::updateColors}));

        if ((void($SimplePlayer::*)(in, IconTyp)){&$SimplePlayer::updatePlayerFrame} != (void(D::*)(in, IconTyp)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x1b62f0, extract((void(D::*)(in, IconTyp)){&D::updatePlayerFrame}));
    }
};


template<class D>
class $Slider : public Slider, public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$Slider() {}
    typedef Slider* __thistype;

    static Slider* create(cocos2d::CCNode p0, cocos2d::SEL_CallFunc p1, char const p2, char const p3, char const p4, char const p5, floa p6) {
        if ((Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)){&D::create})
            return reinterpret_cast<Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)>(m->getOriginal(getBase()+0x18dd80))(p0, p1, p2, p3, p4, p5, p6);
        else return Slider::create(p0, p1, p2, p3, p4, p5, p6);
    }

    static Slider* create(cocos2d::CCNode p0, cocos2d::SEL_CallFunc p1, floa p2) {
        if ((Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)){&D::create})
            return reinterpret_cast<Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)>(m->getOriginal(getBase()+0x18dc40))(p0, p1, p2);
        else return Slider::create(p0, p1, p2);
    }

    void getValue() {
        if ((void($Slider::*)()){&$Slider::getValue} != (void(D::*)()){&D::getValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
        else return Slider::getValue();
    }

    void setBarVisibility(boo p0) {
        if ((void($Slider::*)(boo)){&$Slider::setBarVisibility} != (void(D::*)(boo)){&D::setBarVisibility})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x18e280))(this, p0);
        else return Slider::setBarVisibility(p0);
    }

    void setValue(floa p0) {
        if ((void($Slider::*)(floa)){&$Slider::setValue} != (void(D::*)(floa)){&D::setValue})
            return reinterpret_cast<void(*)(decltype(this), floa)>(m->getOriginal(getBase()+0x18e170))(this, p0);
        else return Slider::setValue(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)){&D::create})
            m->registerHook(getBase()+0x18dd80, (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, char const, char const, char const, char const, floa)){&D::create});

        if ((Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)){&D::create})
            m->registerHook(getBase()+0x18dc40, (Slider*(*)(cocos2d::CCNode, cocos2d::SEL_CallFunc, floa)){&D::create});

        if ((void($Slider::*)()){&$Slider::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18e0c0, extract((void(D::*)()){&D::getValue}));

        if ((void($Slider::*)(boo)){&$Slider::setBarVisibility} != (void(D::*)(boo)){&D::setBarVisibility})
            m->registerHook(getBase()+0x18e280, extract((void(D::*)(boo)){&D::setBarVisibility}));

        if ((void($Slider::*)(floa)){&$Slider::setValue} != (void(D::*)(floa)){&D::setValue})
            m->registerHook(getBase()+0x18e170, extract((void(D::*)(floa)){&D::setValue}));
    }
};


template<class D>
class $SliderThumb : public SliderThumb, public $CacBase {
 public:
    $SliderThumb() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SliderThumb() {}
    typedef SliderThumb* __thistype;

    void getValue() {
        if ((void($SliderThumb::*)()){&$SliderThumb::getValue} != (void(D::*)()){&D::getValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18ce80))(this);
        else return SliderThumb::getValue();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((void($SliderThumb::*)()){&$SliderThumb::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18ce80, extract((void(D::*)()){&D::getValue}));
    }
};


template<class D>
class $SpawnTriggerAction : public SpawnTriggerAction, public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SpawnTriggerAction() {}
    typedef SpawnTriggerAction* __thistype;

    static SpawnTriggerAction* createFromString(std::strin p0) {
        if ((SpawnTriggerAction*(*)(std::strin)){&$SpawnTriggerAction::createFromString} != (SpawnTriggerAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<SpawnTriggerAction*(*)(std::strin)>(m->getOriginal(getBase()+0x17bf50))(p0);
        else return SpawnTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SpawnTriggerAction*(*)(std::strin)){&$SpawnTriggerAction::createFromString} != (SpawnTriggerAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x17bf50, (SpawnTriggerAction*(*)(std::strin)){&D::createFromString});
    }
};


template<class D>
class $SpeedObject : public SpeedObject, public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SpeedObject() {}
    typedef SpeedObject* __thistype;

    static SpeedObject* create(GameObject p0, in p1, floa p2) {
        if ((SpeedObject*(*)(GameObject, in, floa)){&$SpeedObject::create} != (SpeedObject*(*)(GameObject, in, floa)){&D::create})
            return reinterpret_cast<SpeedObject*(*)(GameObject, in, floa)>(m->getOriginal(getBase()+0x77450))(p0, p1, p2);
        else return SpeedObject::create(p0, p1, p2);
    }

    bool init(GameObject p0, in p1, floa p2) {
        if ((bool($SpeedObject::*)(GameObject, in, floa)){&$SpeedObject::init} != (bool(D::*)(GameObject, in, floa)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GameObject, in, floa)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
        else return SpeedObject::init(p0, p1, p2);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((SpeedObject*(*)(GameObject, in, floa)){&$SpeedObject::create} != (SpeedObject*(*)(GameObject, in, floa)){&D::create})
            m->registerHook(getBase()+0x77450, (SpeedObject*(*)(GameObject, in, floa)){&D::create});

        if ((bool($SpeedObject::*)(GameObject, in, floa)){&$SpeedObject::init} != (bool(D::*)(GameObject, in, floa)){&D::init})
            m->registerHook(getBase()+0x77400, extract((bool(D::*)(GameObject, in, floa)){&D::init}));
    }
};


template<class D>
class $TeleportPortalObject : public TeleportPortalObject, public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TeleportPortalObject() {}
    typedef TeleportPortalObject* __thistype;

    static TeleportPortalObject* create(char const p0) {
        if ((TeleportPortalObject*(*)(char const)){&$TeleportPortalObject::create} != (TeleportPortalObject*(*)(char const)){&D::create})
            return reinterpret_cast<TeleportPortalObject*(*)(char const)>(m->getOriginal(getBase()+0xdaa50))(p0);
        else return TeleportPortalObject::create(p0);
    }

    void getTeleportXOff(cocos2d::CCNode p0) {
        if ((void($TeleportPortalObject::*)(cocos2d::CCNode)){&$TeleportPortalObject::getTeleportXOff} != (void(D::*)(cocos2d::CCNode)){&D::getTeleportXOff})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode)>(m->getOriginal(getBase()+0xdac20))(this, p0);
        else return TeleportPortalObject::getTeleportXOff(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((TeleportPortalObject*(*)(char const)){&$TeleportPortalObject::create} != (TeleportPortalObject*(*)(char const)){&D::create})
            m->registerHook(getBase()+0xdaa50, (TeleportPortalObject*(*)(char const)){&D::create});

        if ((void($TeleportPortalObject::*)(cocos2d::CCNode)){&$TeleportPortalObject::getTeleportXOff} != (void(D::*)(cocos2d::CCNode)){&D::getTeleportXOff})
            m->registerHook(getBase()+0xdac20, extract((void(D::*)(cocos2d::CCNode)){&D::getTeleportXOff}));
    }
};


template<class D>
class $TextArea : public TextArea, public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TextArea() {}
    typedef TextArea* __thistype;

    static TextArea* create(std::strin p0, char const p1, floa p2, floa p3, cocos2d::CCPoin p4, floa p5, boo p6) {
        if ((TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)){&$TextArea::create} != (TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)){&D::create})
            return reinterpret_cast<TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)>(m->getOriginal(getBase()+0x19eb40))(p0, p1, p2, p3, p4, p5, p6);
        else return TextArea::create(p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)){&$TextArea::create} != (TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)){&D::create})
            m->registerHook(getBase()+0x19eb40, (TextArea*(*)(std::strin, char const, floa, floa, cocos2d::CCPoin, floa, boo)){&D::create});
    }
};


template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TextInputDelegate() {}
    typedef TextInputDelegate* __thistype;

    bool allowTextInput(CCTextInputNode p0) {
        if ((bool($TextInputDelegate::*)(CCTextInputNode)){&$TextInputDelegate::allowTextInput} != (bool(D::*)(CCTextInputNode)){&D::allowTextInput})
            return reinterpret_cast<bool(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x6210))(this, p0);
        else return TextInputDelegate::allowTextInput(p0);
    }

    void textInputOpened(CCTextInputNode p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode)>(m->getOriginal(getBase()+0x6200))(this, p0);
        else return TextInputDelegate::textInputOpened(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((bool($TextInputDelegate::*)(CCTextInputNode)){&$TextInputDelegate::allowTextInput} != (bool(D::*)(CCTextInputNode)){&D::allowTextInput})
            m->registerHook(getBase()+0x6210, extract((bool(D::*)(CCTextInputNode)){&D::allowTextInput}));

        if ((void($TextInputDelegate::*)(CCTextInputNode)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode)){&D::textInputOpened})
            m->registerHook(getBase()+0x6200, extract((void(D::*)(CCTextInputNode)){&D::textInputOpened}));
    }
};


template<class D>
class $ToggleTriggerAction : public ToggleTriggerAction, public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ToggleTriggerAction() {}
    typedef ToggleTriggerAction* __thistype;

    static ToggleTriggerAction* createFromString(std::strin p0) {
        if ((ToggleTriggerAction*(*)(std::strin)){&$ToggleTriggerAction::createFromString} != (ToggleTriggerAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<ToggleTriggerAction*(*)(std::strin)>(m->getOriginal(getBase()+0x1765e0))(p0);
        else return ToggleTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((ToggleTriggerAction*(*)(std::strin)){&$ToggleTriggerAction::createFromString} != (ToggleTriggerAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x1765e0, (ToggleTriggerAction*(*)(std::strin)){&D::createFromString});
    }
};


template<class D>
class $TouchToggleAction : public TouchToggleAction, public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TouchToggleAction() {}
    typedef TouchToggleAction* __thistype;

    static TouchToggleAction* createFromString(std::strin p0) {
        if ((TouchToggleAction*(*)(std::strin)){&$TouchToggleAction::createFromString} != (TouchToggleAction*(*)(std::strin)){&D::createFromString})
            return reinterpret_cast<TouchToggleAction*(*)(std::strin)>(m->getOriginal(getBase()+0x177e10))(p0);
        else return TouchToggleAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((TouchToggleAction*(*)(std::strin)){&$TouchToggleAction::createFromString} != (TouchToggleAction*(*)(std::strin)){&D::createFromString})
            m->registerHook(getBase()+0x177e10, (TouchToggleAction*(*)(std::strin)){&D::createFromString});
    }
};


template<class D>
class $UILayer : public UILayer, public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$UILayer() {}
    typedef UILayer* __thistype;

    static UILayer* create() {
        if ((UILayer*(*)()){&$UILayer::create} != (UILayer*(*)()){&D::create})
            return reinterpret_cast<UILayer*(*)()>(m->getOriginal(getBase()+0x27fd10))();
        else return UILayer::create();
    }

    void disableMenu() {
        if ((void($UILayer::*)()){&$UILayer::disableMenu} != (void(D::*)()){&D::disableMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280960))(this);
        else return UILayer::disableMenu();
    }

    void enableMenu() {
        if ((void($UILayer::*)()){&$UILayer::enableMenu} != (void(D::*)()){&D::enableMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280940))(this);
        else return UILayer::enableMenu();
    }

    void pCommand(cocos2d::CCNode p0) {
        if ((void($UILayer::*)(cocos2d::CCNode)){&$UILayer::pCommand} != (void(D::*)(cocos2d::CCNode)){&D::pCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode)>(m->getOriginal(getBase()+0x280830))(this, p0);
        else return UILayer::pCommand(p0);
    }

    void toggleCheckpointsMenu(boo p0) {
        if ((void($UILayer::*)(boo)){&$UILayer::toggleCheckpointsMenu} != (void(D::*)(boo)){&D::toggleCheckpointsMenu})
            return reinterpret_cast<void(*)(decltype(this), boo)>(m->getOriginal(getBase()+0x280430))(this, p0);
        else return UILayer::toggleCheckpointsMenu(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((UILayer*(*)()){&$UILayer::create} != (UILayer*(*)()){&D::create})
            m->registerHook(getBase()+0x27fd10, (UILayer*(*)()){&D::create});

        if ((void($UILayer::*)()){&$UILayer::disableMenu} != (void(D::*)()){&D::disableMenu})
            m->registerHook(getBase()+0x280960, extract((void(D::*)()){&D::disableMenu}));

        if ((void($UILayer::*)()){&$UILayer::enableMenu} != (void(D::*)()){&D::enableMenu})
            m->registerHook(getBase()+0x280940, extract((void(D::*)()){&D::enableMenu}));

        if ((void($UILayer::*)(cocos2d::CCNode)){&$UILayer::pCommand} != (void(D::*)(cocos2d::CCNode)){&D::pCommand})
            m->registerHook(getBase()+0x280830, extract((void(D::*)(cocos2d::CCNode)){&D::pCommand}));

        if ((void($UILayer::*)(boo)){&$UILayer::toggleCheckpointsMenu} != (void(D::*)(boo)){&D::toggleCheckpointsMenu})
            m->registerHook(getBase()+0x280430, extract((void(D::*)(boo)){&D::toggleCheckpointsMenu}));
    }
};


template<class D>
class $UndoObject : public UndoObject, public $CacBase {
 public:
    $UndoObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$UndoObject() {}
    typedef UndoObject* __thistype;

    static UndoObject* create(GameObject p0, UndoComman p1) {
        if ((UndoObject*(*)(GameObject, UndoComman)){&$UndoObject::create} != (UndoObject*(*)(GameObject, UndoComman)){&D::create})
            return reinterpret_cast<UndoObject*(*)(GameObject, UndoComman)>(m->getOriginal(getBase()+0x94ea0))(p0, p1);
        else return UndoObject::create(p0, p1);
    }

    static UndoObject* createWithArray(cocos2d::CCArray p0, UndoComman p1) {
        if ((UndoObject*(*)(cocos2d::CCArray, UndoComman)){&$UndoObject::createWithArray} != (UndoObject*(*)(cocos2d::CCArray, UndoComman)){&D::createWithArray})
            return reinterpret_cast<UndoObject*(*)(cocos2d::CCArray, UndoComman)>(m->getOriginal(getBase()+0x96ee0))(p0, p1);
        else return UndoObject::createWithArray(p0, p1);
    }

     ~UndoObject() {
        if ((($UndoObject::*)()){&$UndoObject::~UndoObject} != ((D::*)()){&D::~UndoObject})
            return reinterpret_cast<(*)(decltype(this))>(m->getOriginal(getBase()+0xa2f70))(this);
        else return UndoObject::~UndoObject();
    }

    void apply_hooks() override {
    m->registerHook(extract_virtual(this), +[](){});

        if ((UndoObject*(*)(GameObject, UndoComman)){&$UndoObject::create} != (UndoObject*(*)(GameObject, UndoComman)){&D::create})
            m->registerHook(getBase()+0x94ea0, (UndoObject*(*)(GameObject, UndoComman)){&D::create});

        if ((UndoObject*(*)(cocos2d::CCArray, UndoComman)){&$UndoObject::createWithArray} != (UndoObject*(*)(cocos2d::CCArray, UndoComman)){&D::createWithArray})
            m->registerHook(getBase()+0x96ee0, (UndoObject*(*)(cocos2d::CCArray, UndoComman)){&D::createWithArray});

        if ((($UndoObject::*)()){&$UndoObject::~UndoObject} != ((D::*)()){&D::~UndoObject})
            m->registerHook(getBase()+0xa2f70, extract(((D::*)()){&D::~UndoObject}));
    }
};
