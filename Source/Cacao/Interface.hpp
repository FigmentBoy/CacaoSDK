// 
// Copyright camila314 & alk1m123 2021. 
// Autogenerated using a python script
//
#pragma once
#include <Base/InterfaceBase.hpp>

template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
public:
    inline ~$AppDelegate() {}

    inline void bgScale() {
        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aaab0))(this);
        return AppDelegate::bgScale();
    }

    inline bool applicationDidFinishLaunching() {
        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (bool(D::*)()){&D::applicationDidFinishLaunching})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3aa900))(this);
        return AppDelegate::applicationDidFinishLaunching();
    }

    inline void applicationDidEnterBackground() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aabe0))(this);
        return AppDelegate::applicationDidEnterBackground();
    }

    inline void applicationWillEnterForeground() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aac80))(this);
        return AppDelegate::applicationWillEnterForeground();
    }

    inline bool applicationWillBecomeActive() {
        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (bool(D::*)()){&D::applicationWillBecomeActive})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3aab30))(this);
        return AppDelegate::applicationWillBecomeActive();
    }

    inline bool applicationWillResignActive() {
        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (bool(D::*)()){&D::applicationWillResignActive})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3aab50))(this);
        return AppDelegate::applicationWillResignActive();
    }

    inline void trySaveGame() {
        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aaf10))(this);
        return AppDelegate::trySaveGame();
    }

    inline void willSwitchToScene(cocos2d::CCScene* p0) {
        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(base+0x3aaf40))(this, p0);
        return AppDelegate::willSwitchToScene(p0);
    }

    inline static AppDelegate* get() {
        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            return reinterpret_cast<AppDelegate*(*)()>(m->getOriginal(base+0x3aab10))();
        return AppDelegate::get();
    }

    inline $AppDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            m->registerHook(base+0x3aaab0, extract((void(D::*)()){&D::bgScale}));

        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (bool(D::*)()){&D::applicationDidFinishLaunching})
            m->registerHook(base+0x3aa900, extract_virtual(V, (bool(D::*)()){&D::applicationDidFinishLaunching}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            m->registerHook(base+0x3aabe0, extract_virtual(V, (void(D::*)()){&D::applicationDidEnterBackground}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            m->registerHook(base+0x3aac80, extract_virtual(V, (void(D::*)()){&D::applicationWillEnterForeground}));

        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (bool(D::*)()){&D::applicationWillBecomeActive})
            m->registerHook(base+0x3aab30, extract_virtual(V, (bool(D::*)()){&D::applicationWillBecomeActive}));

        if ((bool($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (bool(D::*)()){&D::applicationWillResignActive})
            m->registerHook(base+0x3aab50, extract_virtual(V, (bool(D::*)()){&D::applicationWillResignActive}));

        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            m->registerHook(base+0x3aaf10, extract_virtual(V, (void(D::*)()){&D::trySaveGame}));

        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            m->registerHook(base+0x3aaf40, extract_virtual(V, (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene}));

        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            m->registerHook(base+0x3aab10, (AppDelegate*(*)()){&D::get});
    }
};

template<class D>
class $CCCircleWaveDelegate : public CCCircleWaveDelegate, public $CacBase {
public:
    inline ~$CCCircleWaveDelegate() {}

    inline $CCCircleWaveDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TableViewDelegate : public TableViewDelegate, public $CacBase {
public:
    inline ~$TableViewDelegate() {}

    inline $TableViewDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TableViewDataSource : public TableViewDataSource, public $CacBase {
public:
    inline ~$TableViewDataSource() {}

    inline $TableViewDataSource() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $CCScrollLayerExtDelegate : public CCScrollLayerExtDelegate, public $CacBase {
public:
    inline ~$CCScrollLayerExtDelegate() {}

    inline $CCScrollLayerExtDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $GJSpecialColorSelectDelegate : public GJSpecialColorSelectDelegate, public $CacBase {
public:
    inline ~$GJSpecialColorSelectDelegate() {}

    inline $GJSpecialColorSelectDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
public:
    inline ~$TextInputDelegate() {}

    inline $TextInputDelegate() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $FLAlertLayerProtocol : public FLAlertLayerProtocol, public $CacBase {
public:
    inline ~$FLAlertLayerProtocol() {}

    inline $FLAlertLayerProtocol() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
public:
    inline ~$CCSpritePlus() {}

    inline bool initWithSpriteFrameName(char const* p0) {
        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(base+0x248670))(this, p0);
        return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    inline $CCSpritePlus() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            m->registerHook(base+0x248670, extract((bool(D::*)(char const*)){&D::initWithSpriteFrameName}));
    }
};

template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
public:
    inline ~$CCMoveCNode() {}

    inline static CCMoveCNode* create() {
        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            return reinterpret_cast<CCMoveCNode*(*)()>(m->getOriginal(base+0x1842a0))();
        return CCMoveCNode::create();
    }

    inline bool init() {
        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18b3d0))(this);
        return CCMoveCNode::init();
    }

    inline $CCMoveCNode() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            m->registerHook(base+0x1842a0, (CCMoveCNode*(*)()){&D::create});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18b3d0, extract((bool(D::*)()){&D::init}));
    }
};

template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
public:
    inline ~$CCNodeContainer() {}

    inline static CCNodeContainer* create() {
        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            return reinterpret_cast<CCNodeContainer*(*)()>(m->getOriginal(base+0xb1090))();
        return CCNodeContainer::create();
    }

    inline bool init() {
        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xba950))(this);
        return CCNodeContainer::init();
    }

    inline void visit() {
        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xba960))(this);
        return CCNodeContainer::visit();
    }

    inline $CCNodeContainer() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            m->registerHook(base+0xb1090, (CCNodeContainer*(*)()){&D::create});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xba950, extract((bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0xba960, extract((void(D::*)()){&D::visit}));
    }
};

template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
public:
    inline ~$CCAnimatedSprite() {}

    inline void runAnimation(gd::string p0) {
        if ((void($CCAnimatedSprite::*)(gd::string)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(gd::string)){&D::runAnimation})
            return reinterpret_cast<void(*)(decltype(this), gd::string)>(m->getOriginal(base+0x1a6430))(this, p0);
        return CCAnimatedSprite::runAnimation(p0);
    }

    inline void tweenToAnimation(gd::string p0, float p1) {
        if ((void($CCAnimatedSprite::*)(gd::string, float)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(gd::string, float)){&D::tweenToAnimation})
            return reinterpret_cast<void(*)(decltype(this), gd::string, float)>(m->getOriginal(base+0x1a65b0))(this, p0, p1);
        return CCAnimatedSprite::tweenToAnimation(p0, p1);
    }

    inline $CCAnimatedSprite() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCAnimatedSprite::*)(gd::string)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(gd::string)){&D::runAnimation})
            m->registerHook(base+0x1a6430, extract((void(D::*)(gd::string)){&D::runAnimation}));

        if ((void($CCAnimatedSprite::*)(gd::string, float)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(gd::string, float)){&D::tweenToAnimation})
            m->registerHook(base+0x1a65b0, extract((void(D::*)(gd::string, float)){&D::tweenToAnimation}));
    }
};

template<class D>
class $CCBlockLayer : public CCBlockLayer, public $CacBase {
public:
    inline ~$CCBlockLayer() {}

    inline void disableUI() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a80))(this);
        return CCBlockLayer::disableUI();
    }

    inline void draw() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5c20))(this);
        return CCBlockLayer::draw();
    }

    inline void enableUI() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a90))(this);
        return CCBlockLayer::enableUI();
    }

    inline void enterAnimFinished() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bb0))(this);
        return CCBlockLayer::enterAnimFinished();
    }

    inline void enterLayer() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5aa0))(this);
        return CCBlockLayer::enterLayer();
    }

    inline void exitLayer() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5b40))(this);
        return CCBlockLayer::exitLayer();
    }

    inline void hideLayer(bool p0) {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5ba0))(this, p0);
        return CCBlockLayer::hideLayer(p0);
    }

    inline bool init() {
        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2a59c0))(this);
        return CCBlockLayer::init();
    }

    inline void layerHidden() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5be0))(this);
        return CCBlockLayer::layerHidden();
    }

    inline void layerVisible() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bc0))(this);
        return CCBlockLayer::layerVisible();
    }

    inline void registerWithTouchDispatcher() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5ad0))(this);
        return CCBlockLayer::registerWithTouchDispatcher();
    }

    inline void showLayer(bool p0) {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5b90))(this, p0);
        return CCBlockLayer::showLayer(p0);
    }

    inline $CCBlockLayer() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x2a5a80, extract((void(D::*)()){&D::disableUI}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2a5c20, extract((void(D::*)()){&D::draw}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x2a5a90, extract((void(D::*)()){&D::enableUI}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x2a5bb0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x2a5aa0, extract((void(D::*)()){&D::enterLayer}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            m->registerHook(base+0x2a5b40, extract((void(D::*)()){&D::exitLayer}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x2a5ba0, extract((void(D::*)(bool)){&D::hideLayer}));

        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2a59c0, extract((bool(D::*)()){&D::init}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x2a5be0, extract((void(D::*)()){&D::layerHidden}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x2a5bc0, extract((void(D::*)()){&D::layerVisible}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2a5ad0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x2a5b90, extract((void(D::*)(bool)){&D::showLayer}));
    }
};

template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
public:
    inline ~$CCCircleWave() {}

    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool)>(m->getOriginal(base+0xbd270))(p0, p1, p2, p3);
        return CCCircleWave::create(p0, p1, p2, p3);
    }

    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool, bool)>(m->getOriginal(base+0xbd290))(p0, p1, p2, p3, p4);
        return CCCircleWave::create(p0, p1, p2, p3, p4);
    }

    inline bool init(float p0, float p1, float p2, bool p3, bool p4) {
        if ((bool($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::init} != (bool(D::*)(float, float, float, bool, bool)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), float, float, float, bool, bool)>(m->getOriginal(base+0xbd380))(this, p0, p1, p2, p3, p4);
        return CCCircleWave::init(p0, p1, p2, p3, p4);
    }

    inline void followObject(cocos2d::CCNode* p0, bool p1) {
        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(base+0xbd670))(this, p0, p1);
        return CCCircleWave::followObject(p0, p1);
    }

    inline void updatePosition(float p0) {
        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xbd630))(this, p0);
        return CCCircleWave::updatePosition(p0);
    }

    inline $CCCircleWave() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            m->registerHook(base+0xbd270, (CCCircleWave*(*)(float, float, float, bool)){&D::create});

        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            m->registerHook(base+0xbd290, (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create});

        if ((bool($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::init} != (bool(D::*)(float, float, float, bool, bool)){&D::init})
            m->registerHook(base+0xbd380, extract((bool(D::*)(float, float, float, bool, bool)){&D::init}));

        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            m->registerHook(base+0xbd670, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::followObject}));

        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            m->registerHook(base+0xbd630, extract((void(D::*)(float)){&D::updatePosition}));
    }
};

template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
public:
    inline ~$CCLightFlash() {}

    inline static CCLightFlash* create() {
        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            return reinterpret_cast<CCLightFlash*(*)()>(m->getOriginal(base+0x295870))();
        return CCLightFlash::create();
    }

    inline void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        if ((void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(base+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
        return CCLightFlash::playEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    inline $CCLightFlash() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            m->registerHook(base+0x295870, (CCLightFlash*(*)()){&D::create});

        if ((void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect})
            m->registerHook(base+0x295900, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect}));
    }
};

template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
public:
    inline ~$CCMenuItemSpriteExtra() {}

    inline static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x1253c0))(p0, p1, p2, p3);
        return CCMenuItemSpriteExtra::create(p0, p1, p2, p3);
    }

    inline void setSizeMult(float p0) {
        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1255e0))(this, p0);
        return CCMenuItemSpriteExtra::setSizeMult(p0);
    }

    inline bool init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::init} != (bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x125450))(this, p0, p1, p2, p3);
        return CCMenuItemSpriteExtra::init(p0, p1, p2, p3);
    }

    inline $CCMenuItemSpriteExtra() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            m->registerHook(base+0x1253c0, (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create});

        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(base+0x1255e0, extract((void(D::*)(float)){&D::setSizeMult}));

        if ((bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::init} != (bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init})
            m->registerHook(base+0x125450, extract((bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init}));
    }
};

template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
public:
    inline ~$CCMenuItemToggler() {}

    inline static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            return reinterpret_cast<CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x38400))(p0, p1, p2, p3);
        return CCMenuItemToggler::create(p0, p1, p2, p3);
    }

    inline void setSizeMult(float p0) {
        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x38a40))(this, p0);
        return CCMenuItemToggler::setSizeMult(p0);
    }

    inline $CCMenuItemToggler() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            m->registerHook(base+0x38400, (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create});

        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(base+0x38a40, extract((void(D::*)(float)){&D::setSizeMult}));
    }
};

template<class D>
class $CCScrollLayerExt : public CCScrollLayerExt, public $CacBase {
public:
    inline ~$CCScrollLayerExt() {}

    inline void visit() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236550))(this);
        return CCScrollLayerExt::visit();
    }

    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x235ef0))(this, p0, p1);
        return CCScrollLayerExt::ccTouchBegan(p0, p1);
    }

    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236300))(this, p0, p1);
        return CCScrollLayerExt::ccTouchMoved(p0, p1);
    }

    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236020))(this, p0, p1);
        return CCScrollLayerExt::ccTouchEnded(p0, p1);
    }

    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2362a0))(this, p0, p1);
        return CCScrollLayerExt::ccTouchCancelled(p0, p1);
    }

    inline void registerWithTouchDispatcher() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x235eb0))(this);
        return CCScrollLayerExt::registerWithTouchDispatcher();
    }

    inline void preVisitWithClippingRect(cocos2d::CCRect p0) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0x2366a0))(this, p0);
        return CCScrollLayerExt::preVisitWithClippingRect(p0);
    }

    inline void postVisit() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236720))(this);
        return CCScrollLayerExt::postVisit();
    }

    inline void moveToTop() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::moveToTop} != (void(D::*)()){&D::moveToTop})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x235870))(this);
        return CCScrollLayerExt::moveToTop();
    }

    inline void moveToTopWithOffset(float p0) {
        if ((void($CCScrollLayerExt::*)(float)){&$CCScrollLayerExt::moveToTopWithOffset} != (void(D::*)(float)){&D::moveToTopWithOffset})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2357d0))(this, p0);
        return CCScrollLayerExt::moveToTopWithOffset(p0);
    }

    inline $CCScrollLayerExt() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x236550, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x235ef0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x236300, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x236020, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2362a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x235eb0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            m->registerHook(base+0x2366a0, extract_virtual(V, (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            m->registerHook(base+0x236720, extract_virtual(V, (void(D::*)()){&D::postVisit}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::moveToTop} != (void(D::*)()){&D::moveToTop})
            m->registerHook(base+0x235870, extract((void(D::*)()){&D::moveToTop}));

        if ((void($CCScrollLayerExt::*)(float)){&$CCScrollLayerExt::moveToTopWithOffset} != (void(D::*)(float)){&D::moveToTopWithOffset})
            m->registerHook(base+0x2357d0, extract((void(D::*)(float)){&D::moveToTopWithOffset}));
    }
};

template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
public:
    inline ~$FLAlertLayer() {}

    inline void onEnter() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f350))(this);
        return FLAlertLayer::onEnter();
    }

    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ee40))(this, p0, p1);
        return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f0a0))(this, p0, p1);
        return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ef60))(this, p0, p1);
        return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f020))(this, p0, p1);
        return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    inline void registerWithTouchDispatcher() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f2e0))(this);
        return FLAlertLayer::registerWithTouchDispatcher();
    }

    inline void keyBackClicked() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25ed90))(this);
        return FLAlertLayer::keyBackClicked();
    }

    inline void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x25ece0))(this, p0);
        return FLAlertLayer::keyDown(p0);
    }

    inline void show() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f120))(this);
        return FLAlertLayer::show();
    }

    inline bool init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)>(m->getOriginal(base+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        return FLAlertLayer::init(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)>(m->getOriginal(base+0x25e0e0))(p0, p1, p2, p3, p4, p5);
        return FLAlertLayer::create(p0, p1, p2, p3, p4, p5);
    }

    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)>(m->getOriginal(base+0x25dec0))(p0, p1, p2, p3, p4, p5, p6, p7);
        return FLAlertLayer::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $FLAlertLayer() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x25f350, extract_virtual(V, (void(D::*)()){&D::onEnter}));

        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x25ee40, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x25f0a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x25ef60, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x25f020, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25f2e0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25ed90, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x25ece0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x25f120, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::init})
            m->registerHook(base+0x25e1b0, extract((bool(D::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::init}));

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)){&D::create})
            m->registerHook(base+0x25e0e0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float)){&D::create});

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::create})
            m->registerHook(base+0x25dec0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float)){&D::create});
    }
};

template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
public:
    inline ~$MenuLayer() {}

    inline bool init() {
        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1d14b0))(this);
        return MenuLayer::init();
    }

    inline void keyBackClicked() {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d3160))(this);
        return MenuLayer::keyBackClicked();
    }

    inline void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x1d33d0))(this, p0);
        return MenuLayer::keyDown(p0);
    }

    inline void googlePlaySignedIn() {
        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d2f30))(this);
        return MenuLayer::googlePlaySignedIn();
    }

    inline void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1d3190))(this, p0, p1);
        return MenuLayer::FLAlert_Clicked(p0, p1);
    }

    inline void onMoreGames(cocos2d::CCObject* p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1d2ad0))(this, p0);
        return MenuLayer::onMoreGames(p0);
    }

    inline void onQuit(cocos2d::CCObject* p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1d2b40))(this, p0);
        return MenuLayer::onQuit(p0);
    }

    inline void scene(bool p0) {
        if ((void($MenuLayer::*)(bool)){&$MenuLayer::scene} != (void(D::*)(bool)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1d12d0))(this, p0);
        return MenuLayer::scene(p0);
    }

    inline $MenuLayer() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1d14b0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d3160, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x1d33d0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            m->registerHook(base+0x1d2f30, extract_virtual(V, (void(D::*)()){&D::googlePlaySignedIn}));

        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1d3190, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            m->registerHook(base+0x1d2ad0, extract((void(D::*)(cocos2d::CCObject*)){&D::onMoreGames}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            m->registerHook(base+0x1d2b40, extract((void(D::*)(cocos2d::CCObject*)){&D::onQuit}));

        if ((void($MenuLayer::*)(bool)){&$MenuLayer::scene} != (void(D::*)(bool)){&D::scene})
            m->registerHook(base+0x1d12d0, extract((void(D::*)(bool)){&D::scene}));
    }
};

template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
public:
    inline ~$ButtonSprite() {}

    inline static ButtonSprite* create(char const* p0) {
        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*)>(m->getOriginal(base+0x4fa10))(p0);
        return ButtonSprite::create(p0);
    }

    inline static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*, int, int, float, bool)>(m->getOriginal(base+0x4fa40))(p0, p1, p2, p3, p4);
        return ButtonSprite::create(p0, p1, p2, p3, p4);
    }

    inline void updateBGImage(char const* p0) {
        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x502d0))(this, p0);
        return ButtonSprite::updateBGImage(p0);
    }

    inline static ButtonSprite* create(char const* p0, float p1) {
        if ((ButtonSprite*(*)(char const*, float)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, float)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*, float)>(m->getOriginal(base+0x4fa60))(p0, p1);
        return ButtonSprite::create(p0, p1);
    }

    inline static ButtonSprite* create(cocos2d::CCSprite* p0, int p1, int p2, float p3, float p4, bool p5, char const* p6, bool p7) {
        if ((ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)>(m->getOriginal(base+0x4fa90))(p0, p1, p2, p3, p4, p5, p6, p7);
        return ButtonSprite::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $ButtonSprite() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            m->registerHook(base+0x4fa10, (ButtonSprite*(*)(char const*)){&D::create});

        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            m->registerHook(base+0x4fa40, (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create});

        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            m->registerHook(base+0x502d0, extract((void(D::*)(char const*)){&D::updateBGImage}));

        if ((ButtonSprite*(*)(char const*, float)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, float)){&D::create})
            m->registerHook(base+0x4fa60, (ButtonSprite*(*)(char const*, float)){&D::create});

        if ((ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create})
            m->registerHook(base+0x4fa90, (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create});
    }
};

template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
public:
    inline ~$CCTextInputNode() {}

    inline static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            return reinterpret_cast<CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)>(m->getOriginal(base+0x5cfb0))(p0, p1, p2, p3, p4, p5);
        return CCTextInputNode::create(p0, p1, p2, p3, p4, p5);
    }

    inline gd::string getString() {
        if ((gd::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (gd::string(D::*)()){&D::getString})
            return reinterpret_cast<gd::string(*)(decltype(this))>(m->getOriginal(base+0x5d6f0))(this);
        return CCTextInputNode::getString();
    }

    inline void refreshLabel() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5d730))(this);
        return CCTextInputNode::refreshLabel();
    }

    inline void setAllowedChars(gd::string p0) {
        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(gd::string)){&D::setAllowedChars})
            return reinterpret_cast<void(*)(decltype(this), gd::string)>(m->getOriginal(base+0x5d360))(this, p0);
        return CCTextInputNode::setAllowedChars(p0);
    }

    inline void setLabelNormalColor(cocos2d::_ccColor3B p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelNormalColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x5dab0))(this, p0);
        return CCTextInputNode::setLabelNormalColor(p0);
    }

    inline void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x5da90))(this, p0);
        return CCTextInputNode::setLabelPlaceholderColor(p0);
    }

    inline void setLabelPlaceholderScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da70))(this, p0);
        return CCTextInputNode::setLabelPlaceholderScale(p0);
    }

    inline void setMaxLabelScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da30))(this, p0);
        return CCTextInputNode::setMaxLabelScale(p0);
    }

    inline void setMaxLabelWidth(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da50))(this, p0);
        return CCTextInputNode::setMaxLabelWidth(p0);
    }

    inline void setString(gd::string p0) {
        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::setString} != (void(D::*)(gd::string)){&D::setString})
            return reinterpret_cast<void(*)(decltype(this), gd::string)>(m->getOriginal(base+0x5d3e0))(this, p0);
        return CCTextInputNode::setString(p0);
    }

    inline void updateLabel(gd::string p0) {
        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(gd::string)){&D::updateLabel})
            return reinterpret_cast<void(*)(decltype(this), gd::string)>(m->getOriginal(base+0x5d4a0))(this, p0);
        return CCTextInputNode::updateLabel(p0);
    }

    inline void forceOffset() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::forceOffset} != (void(D::*)()){&D::forceOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5ec70))(this);
        return CCTextInputNode::forceOffset();
    }

    inline void registerWithTouchDispatcher() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5eec0))(this);
        return CCTextInputNode::registerWithTouchDispatcher();
    }

    inline bool init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((bool($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::init} != (bool(D::*)(float, float, char const*, char const*, int, char const*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), float, float, char const*, char const*, int, char const*)>(m->getOriginal(base+0x5d180))(this, p0, p1, p2, p3, p4, p5);
        return CCTextInputNode::init(p0, p1, p2, p3, p4, p5);
    }

    inline void visit() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5d380))(this);
        return CCTextInputNode::visit();
    }

    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ec80))(this, p0, p1);
        return CCTextInputNode::ccTouchBegan(p0, p1);
    }

    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee80))(this, p0, p1);
        return CCTextInputNode::ccTouchCancelled(p0, p1);
    }

    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee60))(this, p0, p1);
        return CCTextInputNode::ccTouchEnded(p0, p1);
    }

    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5eea0))(this, p0, p1);
        return CCTextInputNode::ccTouchMoved(p0, p1);
    }

    inline void textChanged() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5dd70))(this);
        return CCTextInputNode::textChanged();
    }

    inline void onClickTrackNode(bool p0) {
        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x5dd40))(this, p0);
        return CCTextInputNode::onClickTrackNode(p0);
    }

    inline void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dad0))(this, p0);
        return CCTextInputNode::keyboardWillShow(p0);
    }

    inline void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dc20))(this, p0);
        return CCTextInputNode::keyboardWillHide(p0);
    }

    inline bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2) {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*, char const*, int)>(m->getOriginal(base+0x5de50))(this, p0, p1, p2);
        return CCTextInputNode::onTextFieldInsertText(p0, p1, p2);
    }

    inline bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e2c0))(this, p0);
        return CCTextInputNode::onTextFieldAttachWithIME(p0);
    }

    inline bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e610))(this, p0);
        return CCTextInputNode::onTextFieldDetachWithIME(p0);
    }

    inline $CCTextInputNode() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            m->registerHook(base+0x5cfb0, (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create});

        if ((gd::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (gd::string(D::*)()){&D::getString})
            m->registerHook(base+0x5d6f0, extract((gd::string(D::*)()){&D::getString}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            m->registerHook(base+0x5d730, extract((void(D::*)()){&D::refreshLabel}));

        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(gd::string)){&D::setAllowedChars})
            m->registerHook(base+0x5d360, extract((void(D::*)(gd::string)){&D::setAllowedChars}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelNormalColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor})
            m->registerHook(base+0x5dab0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            m->registerHook(base+0x5da90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            m->registerHook(base+0x5da70, extract((void(D::*)(float)){&D::setLabelPlaceholderScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            m->registerHook(base+0x5da30, extract((void(D::*)(float)){&D::setMaxLabelScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            m->registerHook(base+0x5da50, extract((void(D::*)(float)){&D::setMaxLabelWidth}));

        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::setString} != (void(D::*)(gd::string)){&D::setString})
            m->registerHook(base+0x5d3e0, extract((void(D::*)(gd::string)){&D::setString}));

        if ((void($CCTextInputNode::*)(gd::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(gd::string)){&D::updateLabel})
            m->registerHook(base+0x5d4a0, extract((void(D::*)(gd::string)){&D::updateLabel}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::forceOffset} != (void(D::*)()){&D::forceOffset})
            m->registerHook(base+0x5ec70, extract((void(D::*)()){&D::forceOffset}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x5eec0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((bool($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::init} != (bool(D::*)(float, float, char const*, char const*, int, char const*)){&D::init})
            m->registerHook(base+0x5d180, extract((bool(D::*)(float, float, char const*, char const*, int, char const*)){&D::init}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x5d380, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x5ec80, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x5ee80, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x5ee60, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x5eea0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            m->registerHook(base+0x5dd70, extract_virtual(V, (void(D::*)()){&D::textChanged}));

        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            m->registerHook(base+0x5dd40, extract_virtual(V, (void(D::*)(bool)){&D::onClickTrackNode}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            m->registerHook(base+0x5dad0, extract_virtual(V, (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            m->registerHook(base+0x5dc20, extract_virtual(V, (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            m->registerHook(base+0x5de50, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            m->registerHook(base+0x5e2c0, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            m->registerHook(base+0x5e610, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME}));
    }
};

template<class D>
class $TableView : public TableView, public $CacBase {
public:
    inline ~$TableView() {}

    inline static TableView* create(TableViewDelegate* p0, TableViewDataSource* p1, cocos2d::CCRect p2) {
        if ((TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&$TableView::create} != (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create})
            return reinterpret_cast<TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)>(m->getOriginal(base+0x37eb30))(p0, p1, p2);
        return TableView::create(p0, p1, p2);
    }

    inline void reloadData() {
        if ((void($TableView::*)()){&$TableView::reloadData} != (void(D::*)()){&D::reloadData})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37f970))(this);
        return TableView::reloadData();
    }

    inline $TableView() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&$TableView::create} != (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create})
            m->registerHook(base+0x37eb30, (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create});

        if ((void($TableView::*)()){&$TableView::reloadData} != (void(D::*)()){&D::reloadData})
            m->registerHook(base+0x37f970, extract((void(D::*)()){&D::reloadData}));
    }
};

template<class D>
class $BoomListView : public BoomListView, public $CacBase {
public:
    inline ~$BoomListView() {}

    inline static BoomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::create} != (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            return reinterpret_cast<BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)>(m->getOriginal(base+0x18ecb0))(p0, p1, p2, p3, p4);
        return BoomListView::create(p0, p1, p2, p3, p4);
    }

    inline bool init(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::init} != (bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCArray*, float, float, int, BoomListType)>(m->getOriginal(base+0x18ee00))(this, p0, p1, p2, p3, p4);
        return BoomListView::init(p0, p1, p2, p3, p4);
    }

    inline void draw() {
        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18f790))(this);
        return BoomListView::draw();
    }

    inline void setupList() {
        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18ef90))(this);
        return BoomListView::setupList();
    }

    inline void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f030))(this, p0, p1, p2);
        return BoomListView::TableViewWillDisplayCellForRowAtIndexPath(p0, p1, p2);
    }

    inline void cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f070))(this, p0, p1);
        return BoomListView::cellHeightForRowAtIndexPath(p0, p1);
    }

    inline void didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f090))(this, p0, p1);
        return BoomListView::didSelectRowAtIndexPath(p0, p1);
    }

    inline int numberOfRowsInSection(unsigned int p0, TableView* p1) {
        if ((int($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            return reinterpret_cast<int(*)(decltype(this), unsigned int, TableView*)>(m->getOriginal(base+0x18f0b0))(this, p0, p1);
        return BoomListView::numberOfRowsInSection(p0, p1);
    }

    inline void numberOfSectionsInTableView(TableView* p0) {
        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            return reinterpret_cast<void(*)(decltype(this), TableView*)>(m->getOriginal(base+0x18f0e0))(this, p0);
        return BoomListView::numberOfSectionsInTableView(p0);
    }

    inline void cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f100))(this, p0, p1);
        return BoomListView::cellForRowAtIndexPath(p0, p1);
    }

    inline void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {
        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), TableView*, TableViewCellEditingStyle, CCIndexPath&)>(m->getOriginal(base+0x18f770))(this, p0, p1, p2);
        return BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2);
    }

    inline void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f050))(this, p0, p1, p2);
        return BoomListView::TableViewWillReloadCellForRowAtIndexPath(p0, p1, p2);
    }

    inline TableViewCell* getListCell(char const* p0) {
        if ((TableViewCell*($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (TableViewCell*(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<TableViewCell*(*)(decltype(this), char const*)>(m->getOriginal(base+0x18f200))(this, p0);
        return BoomListView::getListCell(p0);
    }

    inline void loadCell(TableViewCell* p0, int p1) {
        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x18f4a0))(this, p0, p1);
        return BoomListView::loadCell(p0, p1);
    }

    inline $BoomListView() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::create} != (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            m->registerHook(base+0x18ecb0, (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create});

        if ((bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::init} != (bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init})
            m->registerHook(base+0x18ee00, extract((bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init}));

        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18f790, extract((void(D::*)()){&D::draw}));

        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x18ef90, extract_virtual(V, (void(D::*)()){&D::setupList}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x18f030, extract_virtual(V, (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            m->registerHook(base+0x18f070, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            m->registerHook(base+0x18f090, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath}));

        if ((int($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            m->registerHook(base+0x18f0b0, extract_virtual(V, (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection}));

        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            m->registerHook(base+0x18f0e0, extract_virtual(V, (void(D::*)(TableView*)){&D::numberOfSectionsInTableView}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            m->registerHook(base+0x18f100, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath}));

        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            m->registerHook(base+0x18f770, extract_virtual(V, (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            m->registerHook(base+0x18f050, extract_virtual(V, (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath}));

        if ((TableViewCell*($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (TableViewCell*(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x18f200, extract_virtual(V, (TableViewCell*(D::*)(char const*)){&D::getListCell}));

        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x18f4a0, extract_virtual(V, (void(D::*)(TableViewCell*, int)){&D::loadCell}));
    }
};

template<class D>
class $CustomListView : public CustomListView, public $CacBase {
public:
    inline ~$CustomListView() {}

    inline static CustomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$CustomListView::create} != (CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            return reinterpret_cast<CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)>(m->getOriginal(base+0x10d410))(p0, p1, p2, p3, p4);
        return CustomListView::create(p0, p1, p2, p3, p4);
    }

    inline void getListCell(char const* p0) {
        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x10d560))(this, p0);
        return CustomListView::getListCell(p0);
    }

    inline void loadCell(TableViewCell* p0, int p1) {
        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x10e610))(this, p0, p1);
        return CustomListView::loadCell(p0, p1);
    }

    inline void setupList() {
        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x116e70))(this);
        return CustomListView::setupList();
    }

    inline $CustomListView() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$CustomListView::create} != (CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            m->registerHook(base+0x10d410, (CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create});

        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x10d560, extract((void(D::*)(char const*)){&D::getListCell}));

        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x10e610, extract((void(D::*)(TableViewCell*, int)){&D::loadCell}));

        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x116e70, extract((void(D::*)()){&D::setupList}));
    }
};

template<class D>
class $TableViewCell : public TableViewCell, public $CacBase {
public:
    inline ~$TableViewCell() {}

    inline $TableViewCell() {
        if (_lock) return;
        _lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        _lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};
