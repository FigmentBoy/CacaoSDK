// 
// Copyright camila314 & alk1m123 2022. 
// Autogenerated using a python script
//
#pragma once
#include <InterfaceBase.hpp>
#define dl decltype
#define dv std::declval
namespace Cacao::interfaces {
using namespace cocos2d;
using namespace cocos2d::extension;

template<class D>
struct $CCActionTween : CCActionTween, InterfaceBase {
	$CCActionTween(const $CCActionTween& c) : CCActionTween(c) {}
	$CCActionTween() = delete;
	setInterfaceStaticTypesOf(0, CCActionTween, create, , 4, float, char const*, float, float);
	static inline auto address0 = base+0x447590;

	dupable static getFunctionOf(CCActionTween, create, , 4, float, char const*, float, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	static getWrapperOf(CCActionTween, create, , 4, float, char const*, float, float) {
		return D::create(p0, p1, p2, p3);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCActionTween::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCAnimate : CCAnimate, InterfaceBase {
	$CCAnimate(const $CCAnimate& c) : CCAnimate(c) {}
	$CCAnimate() = delete;
	setInterfaceStaticTypesOf(0, CCAnimate, create, , 1, cocos2d::CCAnimation*);
	static inline auto address0 = base+0x1f8fc0;

	dupable static getFunctionOf(CCAnimate, create, , 1, cocos2d::CCAnimation*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCAnimate, create, , 1, cocos2d::CCAnimation*) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCAnimate::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCAnimation : CCAnimation, InterfaceBase {
	$CCAnimation(const $CCAnimation& c) : CCAnimation(c) {}
	$CCAnimation() = delete;
	setInterfaceStaticTypesOf(0, CCAnimation, createWithSpriteFrames, , 2, cocos2d::CCArray*, float);
	static inline auto address0 = base+0x140df0;

	dupable static getFunctionOf(CCAnimation, createWithSpriteFrames, , 2, cocos2d::CCArray*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCAnimation, createWithSpriteFrames, , 2, cocos2d::CCArray*, float) {
		return D::createWithSpriteFrames(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCAnimation::createWithSpriteFrames) != (der0)(&D::createWithSpriteFrames)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWithSpriteFramesWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCApplication : CCApplication, InterfaceBase {
	$CCApplication(const $CCApplication& c) : CCApplication(c) {}
	$CCApplication() = delete;
	setInterfaceTypesOf(0, CCApplication, getCurrentLanguage, , 0);
	setInterfaceTypesOf(1, CCApplication, getTargetPlatform, , 0);
	setInterfaceTypesOf(2, CCApplication, openURL, , 1, char const*);
	setInterfaceTypesOf(3, CCApplication, setAnimationInterval, , 1, double);
	static inline auto address0 = base+0x1a3f40;
	static inline auto address1 = base+0x1a3f20;
	static inline auto address2 = base+0x1a4550;
	static inline auto address3 = base+0x1a3ee0;

	dupable getFunctionOf(CCApplication, getCurrentLanguage, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCApplication, getTargetPlatform, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCApplication, openURL, , 1, char const*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCApplication, setAnimationInterval, , 1, double) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	getWrapperOf(CCApplication, getCurrentLanguage, , 0) {
		return reinterpret_cast<D*>(this)->D::getCurrentLanguage();
	}

	getWrapperOf(CCApplication, getTargetPlatform, , 0) {
		return reinterpret_cast<D*>(this)->D::getTargetPlatform();
	}

	getWrapperOf(CCApplication, openURL, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::openURL(p0);
	}

	getWrapperOf(CCApplication, setAnimationInterval, , 1, double) {
		return reinterpret_cast<D*>(this)->D::setAnimationInterval(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCApplication::getCurrentLanguage) != (der0)(&D::getCurrentLanguage)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::getCurrentLanguageWrapper)));
		}

		if constexpr((mem1)(&$CCApplication::getTargetPlatform) != (der1)(&D::getTargetPlatform)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getTargetPlatformWrapper)));
		}

		if constexpr((mem2)(&$CCApplication::openURL) != (der2)(&D::openURL)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::openURLWrapper)));
		}

		if constexpr((mem3)(&$CCApplication::setAnimationInterval) != (der3)(&D::setAnimationInterval)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::setAnimationIntervalWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCApplicationProtocol : CCApplicationProtocol, InterfaceBase {
	$CCApplicationProtocol(const $CCApplicationProtocol& c) : CCApplicationProtocol(c) {}
	$CCApplicationProtocol() = delete;
	setInterfaceTypesOf(0, CCApplicationProtocol, gameDidSave, , 0);
	static inline auto address0 = base+0x1a45f0;

	dupable getFunctionOf(CCApplicationProtocol, gameDidSave, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	getWrapperOf(CCApplicationProtocol, gameDidSave, , 0) {
		return reinterpret_cast<D*>(this)->D::gameDidSave();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCApplicationProtocol::gameDidSave) != (der0)(&D::gameDidSave)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::gameDidSaveWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCArray : CCArray, InterfaceBase {
	$CCArray(const $CCArray& c) : CCArray(c) {}
	$CCArray() = delete;
	setInterfaceTypesOf(0, CCArray, addObject, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(1, CCArray, addObjectNew, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, CCArray, addObjectsFromArray, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(3, CCArray, containsObject, const, 1, cocos2d::CCObject*);
	setInterfaceTypesOf(4, CCArray, count, const, 0);
	setInterfaceStaticTypesOf(5, CCArray, create, , 0);
	setInterfaceStaticTypesOf(6, CCArray, createWithObject, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(7, CCArray, fastRemoveObject, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(8, CCArray, fastRemoveObjectAtIndex, , 1, unsigned int);
	setInterfaceTypesOf(9, CCArray, fastRemoveObjectAtIndexNew, , 1, unsigned int);
	setInterfaceTypesOf(10, CCArray, lastObject, , 0);
	setInterfaceTypesOf(11, CCArray, objectAtIndex, , 1, unsigned int);
	setInterfaceTypesOf(12, CCArray, removeAllObjects, , 0);
	setInterfaceTypesOf(13, CCArray, removeLastObject, , 1, bool);
	setInterfaceTypesOf(14, CCArray, removeObject, , 2, cocos2d::CCObject*, bool);
	setInterfaceTypesOf(15, CCArray, removeObjectAtIndex, , 2, unsigned int, bool);
	setInterfaceTypesOf(16, CCArray, stringAtIndex, , 1, unsigned int);
	static inline auto address0 = base+0x419f90;
	static inline auto address1 = base+0x41a450;
	static inline auto address2 = base+0x41a2d0;
	static inline auto address3 = base+0x41a3e0;
	static inline auto address4 = base+0x41a2f0;
	static inline auto address5 = base+0x419cb0;
	static inline auto address6 = base+0x419d50;
	static inline auto address7 = base+0x41a520;
	static inline auto address8 = base+0x41a500;
	static inline auto address9 = base+0x41a510;
	static inline auto address10 = base+0x41a360;
	static inline auto address11 = base+0x41a340;
	static inline auto address12 = base+0x41a4f0;
	static inline auto address13 = base+0x41a470;
	static inline auto address14 = base+0x41a490;
	static inline auto address15 = base+0x41a4b0;
	static inline auto address16 = base+0x41a320;

	dupable getFunctionOf(CCArray, addObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CCArray, addObjectNew, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CCArray, addObjectsFromArray, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCArray, containsObject, const, 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCArray, count, const, 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable static getFunctionOf(CCArray, create, , 0) {
		return reinterpret_cast<fun5>(address5)();
	}

	dupable static getFunctionOf(CCArray, createWithObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun6>(address6)(p0);
	}

	dupable getFunctionOf(CCArray, fastRemoveObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCArray, fastRemoveObjectAtIndex, , 1, unsigned int) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCArray, fastRemoveObjectAtIndexNew, , 1, unsigned int) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCArray, lastObject, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCArray, objectAtIndex, , 1, unsigned int) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCArray, removeAllObjects, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCArray, removeLastObject, , 1, bool) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(CCArray, removeObject, , 2, cocos2d::CCObject*, bool) {
		return reinterpret_cast<fun14>(address14)(this, p0, p1);
	}

	dupable getFunctionOf(CCArray, removeObjectAtIndex, , 2, unsigned int, bool) {
		return reinterpret_cast<fun15>(address15)(this, p0, p1);
	}

	dupable getFunctionOf(CCArray, stringAtIndex, , 1, unsigned int) {
		return reinterpret_cast<fun16>(address16)(this, p0);
	}

	getWrapperOf(CCArray, addObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::addObject(p0);
	}

	getWrapperOf(CCArray, addObjectNew, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::addObjectNew(p0);
	}

	getWrapperOf(CCArray, addObjectsFromArray, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::addObjectsFromArray(p0);
	}

	getWrapperOf(CCArray, containsObject, const, 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::containsObject(p0);
	}

	getWrapperOf(CCArray, count, const, 0) {
		return reinterpret_cast<D*>(this)->D::count();
	}

	static getWrapperOf(CCArray, create, , 0) {
		return D::create();
	}

	static getWrapperOf(CCArray, createWithObject, , 1, cocos2d::CCObject*) {
		return D::createWithObject(p0);
	}

	getWrapperOf(CCArray, fastRemoveObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::fastRemoveObject(p0);
	}

	getWrapperOf(CCArray, fastRemoveObjectAtIndex, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::fastRemoveObjectAtIndex(p0);
	}

	getWrapperOf(CCArray, fastRemoveObjectAtIndexNew, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::fastRemoveObjectAtIndexNew(p0);
	}

	getWrapperOf(CCArray, lastObject, , 0) {
		return reinterpret_cast<D*>(this)->D::lastObject();
	}

	getWrapperOf(CCArray, objectAtIndex, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::objectAtIndex(p0);
	}

	getWrapperOf(CCArray, removeAllObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllObjects();
	}

	getWrapperOf(CCArray, removeLastObject, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::removeLastObject(p0);
	}

	getWrapperOf(CCArray, removeObject, , 2, cocos2d::CCObject*, bool) {
		return reinterpret_cast<D*>(this)->D::removeObject(p0, p1);
	}

	getWrapperOf(CCArray, removeObjectAtIndex, , 2, unsigned int, bool) {
		return reinterpret_cast<D*>(this)->D::removeObjectAtIndex(p0, p1);
	}

	getWrapperOf(CCArray, stringAtIndex, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::stringAtIndex(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCArray::addObject) != (der0)(&D::addObject)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::addObjectWrapper)));
		}

		if constexpr((mem1)(&$CCArray::addObjectNew) != (der1)(&D::addObjectNew)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::addObjectNewWrapper)));
		}

		if constexpr((mem2)(&$CCArray::addObjectsFromArray) != (der2)(&D::addObjectsFromArray)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::addObjectsFromArrayWrapper)));
		}

		if constexpr((mem3)(&$CCArray::containsObject) != (der3)(&D::containsObject)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::containsObjectWrapper)));
		}

		if constexpr((mem4)(&$CCArray::count) != (der4)(&D::count)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::countWrapper)));
		}

		if constexpr((mem5)(&$CCArray::create) != (der5)(&D::create)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::createWrapper)));
		}

		if constexpr((mem6)(&$CCArray::createWithObject) != (der6)(&D::createWithObject)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::createWithObjectWrapper)));
		}

		if constexpr((mem7)(&$CCArray::fastRemoveObject) != (der7)(&D::fastRemoveObject)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::fastRemoveObjectWrapper)));
		}

		if constexpr((mem8)(&$CCArray::fastRemoveObjectAtIndex) != (der8)(&D::fastRemoveObjectAtIndex)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::fastRemoveObjectAtIndexWrapper)));
		}

		if constexpr((mem9)(&$CCArray::fastRemoveObjectAtIndexNew) != (der9)(&D::fastRemoveObjectAtIndexNew)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::fastRemoveObjectAtIndexNewWrapper)));
		}

		if constexpr((mem10)(&$CCArray::lastObject) != (der10)(&D::lastObject)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::lastObjectWrapper)));
		}

		if constexpr((mem11)(&$CCArray::objectAtIndex) != (der11)(&D::objectAtIndex)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::objectAtIndexWrapper)));
		}

		if constexpr((mem12)(&$CCArray::removeAllObjects) != (der12)(&D::removeAllObjects)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::removeAllObjectsWrapper)));
		}

		if constexpr((mem13)(&$CCArray::removeLastObject) != (der13)(&D::removeLastObject)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::removeLastObjectWrapper)));
		}

		if constexpr((mem14)(&$CCArray::removeObject) != (der14)(&D::removeObject)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::removeObjectWrapper)));
		}

		if constexpr((mem15)(&$CCArray::removeObjectAtIndex) != (der15)(&D::removeObjectAtIndex)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::removeObjectAtIndexWrapper)));
		}

		if constexpr((mem16)(&$CCArray::stringAtIndex) != (der16)(&D::stringAtIndex)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::stringAtIndexWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCBezierTo : CCBezierTo, InterfaceBase {
	$CCBezierTo(const $CCBezierTo& c) : CCBezierTo(c) {}
	$CCBezierTo() = delete;
	setInterfaceStaticTypesOf(0, CCBezierTo, create, , 2, float, cocos2d::_ccBezierConfig const&);
	static inline auto address0 = base+0x1f6c10;

	dupable static getFunctionOf(CCBezierTo, create, , 2, float, cocos2d::_ccBezierConfig const&) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCBezierTo, create, , 2, float, cocos2d::_ccBezierConfig const&) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCBezierTo::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCCallFunc : CCCallFunc, InterfaceBase {
	$CCCallFunc(const $CCCallFunc& c) : CCCallFunc(c) {}
	$CCCallFunc() = delete;
	setInterfaceStaticTypesOf(0, CCCallFunc, create, , 1, int);
	static inline auto address0 = base+0x454d90;

	dupable static getFunctionOf(CCCallFunc, create, , 1, int) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCCallFunc, create, , 1, int) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCCallFunc::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCClippingNode : CCClippingNode, InterfaceBase {
	$CCClippingNode(const $CCClippingNode& c) : CCClippingNode(c) {}
	$CCClippingNode() = delete;
	setInterfaceStaticTypesOf(0, CCClippingNode, create, , 0);
	setInterfaceStaticTypesOf(1, CCClippingNode, create, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(2, CCClippingNode, getAlphaThreshold, const, 0);
	setInterfaceTypesOf(3, CCClippingNode, getStencil, const, 0);
	setInterfaceTypesOf(4, CCClippingNode, isInverted, const, 0);
	setInterfaceTypesOf(5, CCClippingNode, onEnter, , 0);
	setInterfaceTypesOf(6, CCClippingNode, onEnterTransitionDidFinish, , 0);
	setInterfaceTypesOf(7, CCClippingNode, onExit, , 0);
	setInterfaceTypesOf(8, CCClippingNode, onExitTransitionDidStart, , 0);
	setInterfaceTypesOf(9, CCClippingNode, setAlphaThreshold, , 1, float);
	setInterfaceTypesOf(10, CCClippingNode, setInverted, , 1, bool);
	setInterfaceTypesOf(11, CCClippingNode, setStencil, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(12, CCClippingNode, visit, , 0);
	static inline auto address0 = base+0x4192a0;
	static inline auto address1 = base+0x419330;
	static inline auto address2 = base+0x419a10;
	static inline auto address3 = base+0x4199c0;
	static inline auto address4 = base+0x419a30;
	static inline auto address5 = base+0x419470;
	static inline auto address6 = base+0x4194a0;
	static inline auto address7 = base+0x419500;
	static inline auto address8 = base+0x4194d0;
	static inline auto address9 = base+0x419a20;
	static inline auto address10 = base+0x419a40;
	static inline auto address11 = base+0x4199d0;
	static inline auto address12 = base+0x419530;

	dupable static getFunctionOf(CCClippingNode, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable static getFunctionOf(CCClippingNode, create, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	dupable getFunctionOf(CCClippingNode, getAlphaThreshold, const, 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCClippingNode, getStencil, const, 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCClippingNode, isInverted, const, 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCClippingNode, onEnter, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCClippingNode, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCClippingNode, onExit, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCClippingNode, onExitTransitionDidStart, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCClippingNode, setAlphaThreshold, , 1, float) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCClippingNode, setInverted, , 1, bool) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(CCClippingNode, setStencil, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCClippingNode, visit, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	static getWrapperOf(CCClippingNode, create, , 0) {
		return D::create();
	}

	static getWrapperOf(CCClippingNode, create, , 1, cocos2d::CCNode*) {
		return D::create(p0);
	}

	getWrapperOf(CCClippingNode, getAlphaThreshold, const, 0) {
		return reinterpret_cast<D*>(this)->D::getAlphaThreshold();
	}

	getWrapperOf(CCClippingNode, getStencil, const, 0) {
		return reinterpret_cast<D*>(this)->D::getStencil();
	}

	getWrapperOf(CCClippingNode, isInverted, const, 0) {
		return reinterpret_cast<D*>(this)->D::isInverted();
	}

	getWrapperOf(CCClippingNode, onEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnter();
	}

	getWrapperOf(CCClippingNode, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnterTransitionDidFinish();
	}

	getWrapperOf(CCClippingNode, onExit, , 0) {
		return reinterpret_cast<D*>(this)->D::onExit();
	}

	getWrapperOf(CCClippingNode, onExitTransitionDidStart, , 0) {
		return reinterpret_cast<D*>(this)->D::onExitTransitionDidStart();
	}

	getWrapperOf(CCClippingNode, setAlphaThreshold, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setAlphaThreshold(p0);
	}

	getWrapperOf(CCClippingNode, setInverted, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setInverted(p0);
	}

	getWrapperOf(CCClippingNode, setStencil, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setStencil(p0);
	}

	getWrapperOf(CCClippingNode, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCClippingNode::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCClippingNode::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$CCClippingNode::getAlphaThreshold) != (der2)(&D::getAlphaThreshold)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getAlphaThresholdWrapper)));
		}

		if constexpr((mem3)(&$CCClippingNode::getStencil) != (der3)(&D::getStencil)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getStencilWrapper)));
		}

		if constexpr((mem4)(&$CCClippingNode::isInverted) != (der4)(&D::isInverted)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::isInvertedWrapper)));
		}

		if constexpr((mem5)(&$CCClippingNode::onEnter) != (der5)(&D::onEnter)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::onEnterWrapper)));
		}

		if constexpr((mem6)(&$CCClippingNode::onEnterTransitionDidFinish) != (der6)(&D::onEnterTransitionDidFinish)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::onEnterTransitionDidFinishWrapper)));
		}

		if constexpr((mem7)(&$CCClippingNode::onExit) != (der7)(&D::onExit)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::onExitWrapper)));
		}

		if constexpr((mem8)(&$CCClippingNode::onExitTransitionDidStart) != (der8)(&D::onExitTransitionDidStart)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::onExitTransitionDidStartWrapper)));
		}

		if constexpr((mem9)(&$CCClippingNode::setAlphaThreshold) != (der9)(&D::setAlphaThreshold)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::setAlphaThresholdWrapper)));
		}

		if constexpr((mem10)(&$CCClippingNode::setInverted) != (der10)(&D::setInverted)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::setInvertedWrapper)));
		}

		if constexpr((mem11)(&$CCClippingNode::setStencil) != (der11)(&D::setStencil)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::setStencilWrapper)));
		}

		if constexpr((mem12)(&$CCClippingNode::visit) != (der12)(&D::visit)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::visitWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCCopying : CCCopying, InterfaceBase {
	$CCCopying(const $CCCopying& c) : CCCopying(c) {}
	$CCCopying() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCDelayTime : CCDelayTime, InterfaceBase {
	$CCDelayTime(const $CCDelayTime& c) : CCDelayTime(c) {}
	$CCDelayTime() = delete;
	setInterfaceStaticTypesOf(0, CCDelayTime, create, , 1, float);
	static inline auto address0 = base+0x1f4380;

	dupable static getFunctionOf(CCDelayTime, create, , 1, float) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCDelayTime, create, , 1, float) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCDelayTime::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCDictionary : CCDictionary, InterfaceBase {
	$CCDictionary(const $CCDictionary& c) : CCDictionary(c) {}
	$CCDictionary() = delete;
	setInterfaceTypesOf(0, CCDictionary, allKeys, , 0);
	setInterfaceTypesOf(1, CCDictionary, count, , 0);
	setInterfaceStaticTypesOf(2, CCDictionary, create, , 0);
	setInterfaceTypesOf(3, CCDictionary, objectForKey, , 1, intptr_t);
	setInterfaceTypesOf(4, CCDictionary, objectForKey, , 1, gd::string const&);
	setInterfaceTypesOf(5, CCDictionary, removeAllObjects, , 0);
	setInterfaceTypesOf(6, CCDictionary, removeObjectForKey, , 1, intptr_t);
	setInterfaceTypesOf(7, CCDictionary, setObject, , 2, cocos2d::CCObject*, intptr_t);
	setInterfaceTypesOf(8, CCDictionary, setObject, , 2, cocos2d::CCObject*, gd::string const&);
	setInterfaceTypesOf(9, CCDictionary, valueForKey, , 1, intptr_t);
	setInterfaceTypesOf(10, CCDictionary, valueForKey, , 1, gd::string const&);
	static inline auto address0 = base+0x190450;
	static inline auto address1 = base+0x190430;
	static inline auto address2 = base+0x192650;
	static inline auto address3 = base+0x190bb0;
	static inline auto address4 = base+0x190870;
	static inline auto address5 = base+0x190220;
	static inline auto address6 = base+0x1921d0;
	static inline auto address7 = base+0x191790;
	static inline auto address8 = base+0x190dc0;
	static inline auto address9 = base+0x190cf0;
	static inline auto address10 = base+0x1907a0;

	dupable getFunctionOf(CCDictionary, allKeys, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCDictionary, count, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable static getFunctionOf(CCDictionary, create, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	dupable getFunctionOf(CCDictionary, objectForKey, , 1, intptr_t) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCDictionary, objectForKey, , 1, gd::string const&) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCDictionary, removeAllObjects, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCDictionary, removeObjectForKey, , 1, intptr_t) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCDictionary, setObject, , 2, cocos2d::CCObject*, intptr_t) {
		return reinterpret_cast<fun7>(address7)(this, p0, p1);
	}

	dupable getFunctionOf(CCDictionary, setObject, , 2, cocos2d::CCObject*, gd::string const&) {
		return reinterpret_cast<fun8>(address8)(this, p0, p1);
	}

	dupable getFunctionOf(CCDictionary, valueForKey, , 1, intptr_t) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCDictionary, valueForKey, , 1, gd::string const&) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	getWrapperOf(CCDictionary, allKeys, , 0) {
		return reinterpret_cast<D*>(this)->D::allKeys();
	}

	getWrapperOf(CCDictionary, count, , 0) {
		return reinterpret_cast<D*>(this)->D::count();
	}

	static getWrapperOf(CCDictionary, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCDictionary, objectForKey, , 1, intptr_t) {
		return reinterpret_cast<D*>(this)->D::objectForKey(p0);
	}

	getWrapperOf(CCDictionary, objectForKey, , 1, gd::string const&) {
		return reinterpret_cast<D*>(this)->D::objectForKey(p0);
	}

	getWrapperOf(CCDictionary, removeAllObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllObjects();
	}

	getWrapperOf(CCDictionary, removeObjectForKey, , 1, intptr_t) {
		return reinterpret_cast<D*>(this)->D::removeObjectForKey(p0);
	}

	getWrapperOf(CCDictionary, setObject, , 2, cocos2d::CCObject*, intptr_t) {
		return reinterpret_cast<D*>(this)->D::setObject(p0, p1);
	}

	getWrapperOf(CCDictionary, setObject, , 2, cocos2d::CCObject*, gd::string const&) {
		return reinterpret_cast<D*>(this)->D::setObject(p0, p1);
	}

	getWrapperOf(CCDictionary, valueForKey, , 1, intptr_t) {
		return reinterpret_cast<D*>(this)->D::valueForKey(p0);
	}

	getWrapperOf(CCDictionary, valueForKey, , 1, gd::string const&) {
		return reinterpret_cast<D*>(this)->D::valueForKey(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCDictionary::allKeys) != (der0)(&D::allKeys)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::allKeysWrapper)));
		}

		if constexpr((mem1)(&$CCDictionary::count) != (der1)(&D::count)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::countWrapper)));
		}

		if constexpr((mem2)(&$CCDictionary::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		if constexpr((mem3)(&$CCDictionary::objectForKey) != (der3)(&D::objectForKey)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::objectForKeyWrapper)));
		}

		if constexpr((mem4)(&$CCDictionary::objectForKey) != (der4)(&D::objectForKey)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::objectForKeyWrapper)));
		}

		if constexpr((mem5)(&$CCDictionary::removeAllObjects) != (der5)(&D::removeAllObjects)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::removeAllObjectsWrapper)));
		}

		if constexpr((mem6)(&$CCDictionary::removeObjectForKey) != (der6)(&D::removeObjectForKey)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::removeObjectForKeyWrapper)));
		}

		if constexpr((mem7)(&$CCDictionary::setObject) != (der7)(&D::setObject)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::setObjectWrapper)));
		}

		if constexpr((mem8)(&$CCDictionary::setObject) != (der8)(&D::setObject)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::setObjectWrapper)));
		}

		if constexpr((mem9)(&$CCDictionary::valueForKey) != (der9)(&D::valueForKey)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::valueForKeyWrapper)));
		}

		if constexpr((mem10)(&$CCDictionary::valueForKey) != (der10)(&D::valueForKey)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::valueForKeyWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCDirector : CCDirector, InterfaceBase {
	$CCDirector(const $CCDirector& c) : CCDirector(c) {}
	$CCDirector() = delete;
	setInterfaceTypesOf(1, CCDirector, init, , 0);
	setInterfaceTypesOf(2, CCDirector, getScheduler, , 0);
	setInterfaceTypesOf(3, CCDirector, setScheduler, , 1, cocos2d::CCScheduler*);
	setInterfaceTypesOf(4, CCDirector, getActionManager, , 0);
	setInterfaceTypesOf(5, CCDirector, setActionManager, , 1, cocos2d::CCActionManager*);
	setInterfaceTypesOf(6, CCDirector, getTouchDispatcher, , 0);
	setInterfaceTypesOf(7, CCDirector, setTouchDispatcher, , 1, cocos2d::CCTouchDispatcher*);
	setInterfaceTypesOf(8, CCDirector, getKeypadDispatcher, , 0);
	setInterfaceTypesOf(9, CCDirector, setKeypadDispatcher, , 1, cocos2d::CCKeypadDispatcher*);
	setInterfaceTypesOf(10, CCDirector, getKeyboardDispatcher, , 0);
	setInterfaceTypesOf(11, CCDirector, setKeyboardDispatcher, , 1, cocos2d::CCKeyboardDispatcher*);
	setInterfaceTypesOf(12, CCDirector, getMouseDispatcher, , 0);
	setInterfaceTypesOf(13, CCDirector, setMouseDispatcher, , 1, cocos2d::CCMouseDispatcher*);
	setInterfaceTypesOf(14, CCDirector, getAccelerometer, , 0);
	setInterfaceTypesOf(15, CCDirector, setAccelerometer, , 1, cocos2d::CCAccelerometer*);
	setInterfaceTypesOf(16, CCDirector, getDeltaTime, , 0);
	setInterfaceTypesOf(17, CCDirector, getSceneDelegate, , 0);
	setInterfaceTypesOf(18, CCDirector, setSceneDelegate, , 1, cocos2d::CCSceneDelegate*);
	setInterfaceTypesOf(19, CCDirector, getWinSize, , 0);
	setInterfaceTypesOf(20, CCDirector, pushScene, , 1, cocos2d::CCScene*);
	setInterfaceTypesOf(21, CCDirector, replaceScene, , 1, cocos2d::CCScene*);
	setInterfaceTypesOf(22, CCDirector, resetSmoothFixCounter, , 0);
	setInterfaceStaticTypesOf(23, CCDirector, sharedDirector, , 0);
	setInterfaceTypesOf(26, CCDirector, convertToGL, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(27, CCDirector, drawScene, , 0);
	setInterfaceTypesOf(30, CCDirector, updateContentScale, , 1, cocos2d::TextureQuality);
	setInterfaceTypesOf(31, CCDirector, popSceneWithTransition, , 2, float, cocos2d::PopTransition);
	static inline auto address0 = base+0x2493a0;
	static inline auto address1 = base+0x248df0;
	static inline auto address2 = base+0x24af00;
	static inline auto address3 = base+0x24aec0;
	static inline auto address4 = base+0x24af50;
	static inline auto address5 = base+0x24af10;
	static inline auto address6 = base+0x24afa0;
	static inline auto address7 = base+0x24af60;
	static inline auto address8 = base+0x24b090;
	static inline auto address9 = base+0x24b050;
	static inline auto address10 = base+0x24aff0;
	static inline auto address11 = base+0x24afb0;
	static inline auto address12 = base+0x24b040;
	static inline auto address13 = base+0x24b000;
	static inline auto address14 = base+0x24b0e0;
	static inline auto address15 = base+0x24b0a0;
	static inline auto address16 = base+0x249bd0;
	static inline auto address17 = base+0x24b320;
	static inline auto address18 = base+0x24b330;
	static inline auto address19 = base+0x24a0f0;
	static inline auto address20 = base+0x24a620;
	static inline auto address21 = base+0x24a6d0;
	static inline auto address22 = base+0x249bc0;
	static inline auto address23 = base+0x248cb0;
	static inline auto address26 = base+0x24a210;
	static inline auto address27 = base+0x249690;
	static inline auto address30 = base+0x249ff0;
	static inline auto address31 = base+0x24a8b0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCDirector, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCDirector, getScheduler, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCDirector, setScheduler, , 1, cocos2d::CCScheduler*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getActionManager, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCDirector, setActionManager, , 1, cocos2d::CCActionManager*) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getTouchDispatcher, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCDirector, setTouchDispatcher, , 1, cocos2d::CCTouchDispatcher*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getKeypadDispatcher, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCDirector, setKeypadDispatcher, , 1, cocos2d::CCKeypadDispatcher*) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getKeyboardDispatcher, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCDirector, setKeyboardDispatcher, , 1, cocos2d::CCKeyboardDispatcher*) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getMouseDispatcher, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCDirector, setMouseDispatcher, , 1, cocos2d::CCMouseDispatcher*) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getAccelerometer, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(CCDirector, setAccelerometer, , 1, cocos2d::CCAccelerometer*) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getDeltaTime, , 0) {
		return reinterpret_cast<fun16>(address16)(this);
	}

	dupable getFunctionOf(CCDirector, getSceneDelegate, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(CCDirector, setSceneDelegate, , 1, cocos2d::CCSceneDelegate*) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	dupable getFunctionOf(CCDirector, getWinSize, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(CCDirector, pushScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(CCDirector, replaceScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<fun21>(address21)(this, p0);
	}

	dupable getFunctionOf(CCDirector, resetSmoothFixCounter, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable static getFunctionOf(CCDirector, sharedDirector, , 0) {
		return reinterpret_cast<fun23>(address23)();
	}

	dupable getFunctionOf(CCDirector, convertToGL, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	dupable getFunctionOf(CCDirector, drawScene, , 0) {
		return reinterpret_cast<fun27>(address27)(this);
	}

	dupable getFunctionOf(CCDirector, updateContentScale, , 1, cocos2d::TextureQuality) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(CCDirector, popSceneWithTransition, , 2, float, cocos2d::PopTransition) {
		return reinterpret_cast<fun31>(address31)(this, p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCDirector, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCDirector, getScheduler, , 0) {
		return reinterpret_cast<D*>(this)->D::getScheduler();
	}

	getWrapperOf(CCDirector, setScheduler, , 1, cocos2d::CCScheduler*) {
		return reinterpret_cast<D*>(this)->D::setScheduler(p0);
	}

	getWrapperOf(CCDirector, getActionManager, , 0) {
		return reinterpret_cast<D*>(this)->D::getActionManager();
	}

	getWrapperOf(CCDirector, setActionManager, , 1, cocos2d::CCActionManager*) {
		return reinterpret_cast<D*>(this)->D::setActionManager(p0);
	}

	getWrapperOf(CCDirector, getTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::getTouchDispatcher();
	}

	getWrapperOf(CCDirector, setTouchDispatcher, , 1, cocos2d::CCTouchDispatcher*) {
		return reinterpret_cast<D*>(this)->D::setTouchDispatcher(p0);
	}

	getWrapperOf(CCDirector, getKeypadDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::getKeypadDispatcher();
	}

	getWrapperOf(CCDirector, setKeypadDispatcher, , 1, cocos2d::CCKeypadDispatcher*) {
		return reinterpret_cast<D*>(this)->D::setKeypadDispatcher(p0);
	}

	getWrapperOf(CCDirector, getKeyboardDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::getKeyboardDispatcher();
	}

	getWrapperOf(CCDirector, setKeyboardDispatcher, , 1, cocos2d::CCKeyboardDispatcher*) {
		return reinterpret_cast<D*>(this)->D::setKeyboardDispatcher(p0);
	}

	getWrapperOf(CCDirector, getMouseDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::getMouseDispatcher();
	}

	getWrapperOf(CCDirector, setMouseDispatcher, , 1, cocos2d::CCMouseDispatcher*) {
		return reinterpret_cast<D*>(this)->D::setMouseDispatcher(p0);
	}

	getWrapperOf(CCDirector, getAccelerometer, , 0) {
		return reinterpret_cast<D*>(this)->D::getAccelerometer();
	}

	getWrapperOf(CCDirector, setAccelerometer, , 1, cocos2d::CCAccelerometer*) {
		return reinterpret_cast<D*>(this)->D::setAccelerometer(p0);
	}

	getWrapperOf(CCDirector, getDeltaTime, , 0) {
		return reinterpret_cast<D*>(this)->D::getDeltaTime();
	}

	getWrapperOf(CCDirector, getSceneDelegate, , 0) {
		return reinterpret_cast<D*>(this)->D::getSceneDelegate();
	}

	getWrapperOf(CCDirector, setSceneDelegate, , 1, cocos2d::CCSceneDelegate*) {
		return reinterpret_cast<D*>(this)->D::setSceneDelegate(p0);
	}

	getWrapperOf(CCDirector, getWinSize, , 0) {
		return reinterpret_cast<D*>(this)->D::getWinSize();
	}

	getWrapperOf(CCDirector, pushScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<D*>(this)->D::pushScene(p0);
	}

	getWrapperOf(CCDirector, replaceScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<D*>(this)->D::replaceScene(p0);
	}

	getWrapperOf(CCDirector, resetSmoothFixCounter, , 0) {
		return reinterpret_cast<D*>(this)->D::resetSmoothFixCounter();
	}

	static getWrapperOf(CCDirector, sharedDirector, , 0) {
		return D::sharedDirector();
	}

	getWrapperOf(CCDirector, convertToGL, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::convertToGL(p0);
	}

	getWrapperOf(CCDirector, drawScene, , 0) {
		return reinterpret_cast<D*>(this)->D::drawScene();
	}

	getWrapperOf(CCDirector, updateContentScale, , 1, cocos2d::TextureQuality) {
		return reinterpret_cast<D*>(this)->D::updateContentScale(p0);
	}

	getWrapperOf(CCDirector, popSceneWithTransition, , 2, float, cocos2d::PopTransition) {
		return reinterpret_cast<D*>(this)->D::popSceneWithTransition(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr(&$CCDirector::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCDirector::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if ((mem2)(&$CCDirector::getScheduler) != (der2)(&D::getScheduler)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::getSchedulerWrapper)));
		}

		if ((mem3)(&$CCDirector::setScheduler) != (der3)(&D::setScheduler)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setSchedulerWrapper)));
		}

		if ((mem4)(&$CCDirector::getActionManager) != (der4)(&D::getActionManager)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::getActionManagerWrapper)));
		}

		if ((mem5)(&$CCDirector::setActionManager) != (der5)(&D::setActionManager)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setActionManagerWrapper)));
		}

		if ((mem6)(&$CCDirector::getTouchDispatcher) != (der6)(&D::getTouchDispatcher)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::getTouchDispatcherWrapper)));
		}

		if ((mem7)(&$CCDirector::setTouchDispatcher) != (der7)(&D::setTouchDispatcher)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setTouchDispatcherWrapper)));
		}

		if ((mem8)(&$CCDirector::getKeypadDispatcher) != (der8)(&D::getKeypadDispatcher)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::getKeypadDispatcherWrapper)));
		}

		if ((mem9)(&$CCDirector::setKeypadDispatcher) != (der9)(&D::setKeypadDispatcher)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::setKeypadDispatcherWrapper)));
		}

		if ((mem10)(&$CCDirector::getKeyboardDispatcher) != (der10)(&D::getKeyboardDispatcher)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::getKeyboardDispatcherWrapper)));
		}

		if ((mem11)(&$CCDirector::setKeyboardDispatcher) != (der11)(&D::setKeyboardDispatcher)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setKeyboardDispatcherWrapper)));
		}

		if ((mem12)(&$CCDirector::getMouseDispatcher) != (der12)(&D::getMouseDispatcher)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::getMouseDispatcherWrapper)));
		}

		if ((mem13)(&$CCDirector::setMouseDispatcher) != (der13)(&D::setMouseDispatcher)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::setMouseDispatcherWrapper)));
		}

		if ((mem14)(&$CCDirector::getAccelerometer) != (der14)(&D::getAccelerometer)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::getAccelerometerWrapper)));
		}

		if ((mem15)(&$CCDirector::setAccelerometer) != (der15)(&D::setAccelerometer)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::setAccelerometerWrapper)));
		}

		if ((mem16)(&$CCDirector::getDeltaTime) != (der16)(&D::getDeltaTime)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfVirtual((der16)(&D::getDeltaTimeWrapper)));
		}

		if ((mem17)(&$CCDirector::getSceneDelegate) != (der17)(&D::getSceneDelegate)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfVirtual((der17)(&D::getSceneDelegateWrapper)));
		}

		if ((mem18)(&$CCDirector::setSceneDelegate) != (der18)(&D::setSceneDelegate)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfVirtual((der18)(&D::setSceneDelegateWrapper)));
		}

		if constexpr((mem19)(&$CCDirector::getWinSize) != (der19)(&D::getWinSize)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::getWinSizeWrapper)));
		}

		if constexpr((mem20)(&$CCDirector::pushScene) != (der20)(&D::pushScene)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::pushSceneWrapper)));
		}

		if constexpr((mem21)(&$CCDirector::replaceScene) != (der21)(&D::replaceScene)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::replaceSceneWrapper)));
		}

		if constexpr((mem22)(&$CCDirector::resetSmoothFixCounter) != (der22)(&D::resetSmoothFixCounter)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::resetSmoothFixCounterWrapper)));
		}

		if constexpr((mem23)(&$CCDirector::sharedDirector) != (der23)(&D::sharedDirector)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::sharedDirectorWrapper)));
		}

		if constexpr((mem26)(&$CCDirector::convertToGL) != (der26)(&D::convertToGL)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::convertToGLWrapper)));
		}

		if constexpr((mem27)(&$CCDirector::drawScene) != (der27)(&D::drawScene)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::drawSceneWrapper)));
		}

		if constexpr((mem30)(&$CCDirector::updateContentScale) != (der30)(&D::updateContentScale)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::updateContentScaleWrapper)));
		}

		if constexpr((mem31)(&$CCDirector::popSceneWithTransition) != (der31)(&D::popSceneWithTransition)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::popSceneWithTransitionWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCDrawNode : CCDrawNode, InterfaceBase {
	$CCDrawNode(const $CCDrawNode& c) : CCDrawNode(c) {}
	$CCDrawNode() = delete;
	setInterfaceTypesOf(0, CCDrawNode, clear, , 0);
	setInterfaceStaticTypesOf(1, CCDrawNode, create, , 0);
	setInterfaceTypesOf(2, CCDrawNode, drawPolygon, , 5, cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&);
	setInterfaceTypesOf(3, CCDrawNode, drawSegment, , 4, cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&);
	setInterfaceTypesOf(4, CCDrawNode, getBlendFunc, const, 0);
	setInterfaceTypesOf(5, CCDrawNode, init, , 0);
	setInterfaceTypesOf(6, CCDrawNode, setBlendFunc, , 1, cocos2d::_ccBlendFunc const&);
	setInterfaceTypesOf(7, CCDrawNode, draw, , 0);
	static inline auto address0 = base+0x379e80;
	static inline auto address1 = base+0x378d00;
	static inline auto address2 = base+0x3797f0;
	static inline auto address3 = base+0x3792d0;
	static inline auto address4 = base+0x379ea0;
	static inline auto address5 = base+0x378e00;
	static inline auto address6 = base+0x379eb0;
	static inline auto address7 = base+0x379020;
	static inline auto address8 = base+0x378cc0;

	dupable getFunctionOf(CCDrawNode, clear, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable static getFunctionOf(CCDrawNode, create, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	dupable getFunctionOf(CCDrawNode, drawPolygon, , 5, cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(CCDrawNode, drawSegment, , 4, cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCDrawNode, getBlendFunc, const, 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCDrawNode, init, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCDrawNode, setBlendFunc, , 1, cocos2d::_ccBlendFunc const&) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCDrawNode, draw, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address8)(this);
	}

	getWrapperOf(CCDrawNode, clear, , 0) {
		return reinterpret_cast<D*>(this)->D::clear();
	}

	static getWrapperOf(CCDrawNode, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCDrawNode, drawPolygon, , 5, cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&) {
		return reinterpret_cast<D*>(this)->D::drawPolygon(p0, p1, p2, p3, p4);
	}

	getWrapperOf(CCDrawNode, drawSegment, , 4, cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&) {
		return reinterpret_cast<D*>(this)->D::drawSegment(p0, p1, p2, p3);
	}

	getWrapperOf(CCDrawNode, getBlendFunc, const, 0) {
		return reinterpret_cast<D*>(this)->D::getBlendFunc();
	}

	getWrapperOf(CCDrawNode, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCDrawNode, setBlendFunc, , 1, cocos2d::_ccBlendFunc const&) {
		return reinterpret_cast<D*>(this)->D::setBlendFunc(p0);
	}

	getWrapperOf(CCDrawNode, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCDrawNode::clear) != (der0)(&D::clear)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::clearWrapper)));
		}

		if constexpr((mem1)(&$CCDrawNode::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$CCDrawNode::drawPolygon) != (der2)(&D::drawPolygon)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::drawPolygonWrapper)));
		}

		if constexpr((mem3)(&$CCDrawNode::drawSegment) != (der3)(&D::drawSegment)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::drawSegmentWrapper)));
		}

		if constexpr((mem4)(&$CCDrawNode::getBlendFunc) != (der4)(&D::getBlendFunc)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::getBlendFuncWrapper)));
		}

		if constexpr((mem5)(&$CCDrawNode::init) != (der5)(&D::init)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::initWrapper)));
		}

		if constexpr((mem6)(&$CCDrawNode::setBlendFunc) != (der6)(&D::setBlendFunc)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::setBlendFuncWrapper)));
		}

		if constexpr((mem7)(&$CCDrawNode::draw) != (der7)(&D::draw)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::drawWrapper)));
		}

		if constexpr(&$CCDrawNode::destructor != &D::destructor) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCEaseElasticOut : CCEaseElasticOut, InterfaceBase {
	$CCEaseElasticOut(const $CCEaseElasticOut& c) : CCEaseElasticOut(c) {}
	$CCEaseElasticOut() = delete;
	setInterfaceStaticTypesOf(0, CCEaseElasticOut, create, , 2, cocos2d::CCActionInterval*, float);
	static inline auto address0 = base+0x2a3080;

	dupable static getFunctionOf(CCEaseElasticOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCEaseElasticOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCEaseElasticOut::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCEaseIn : CCEaseIn, InterfaceBase {
	$CCEaseIn(const $CCEaseIn& c) : CCEaseIn(c) {}
	$CCEaseIn() = delete;
	setInterfaceStaticTypesOf(0, CCEaseIn, create, , 2, cocos2d::CCActionInterval*, float);
	static inline auto address0 = base+0x2a1960;

	dupable static getFunctionOf(CCEaseIn, create, , 2, cocos2d::CCActionInterval*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCEaseIn, create, , 2, cocos2d::CCActionInterval*, float) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCEaseIn::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCEaseInOut : CCEaseInOut, InterfaceBase {
	$CCEaseInOut(const $CCEaseInOut& c) : CCEaseInOut(c) {}
	$CCEaseInOut() = delete;
	setInterfaceStaticTypesOf(0, CCEaseInOut, create, , 2, cocos2d::CCActionInterval*, float);
	static inline auto address0 = base+0x2a1d80;

	dupable static getFunctionOf(CCEaseInOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCEaseInOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCEaseInOut::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCEaseOut : CCEaseOut, InterfaceBase {
	$CCEaseOut(const $CCEaseOut& c) : CCEaseOut(c) {}
	$CCEaseOut() = delete;
	setInterfaceStaticTypesOf(0, CCEaseOut, create, , 2, cocos2d::CCActionInterval*, float);
	static inline auto address0 = base+0x2a1b70;

	dupable static getFunctionOf(CCEaseOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCEaseOut, create, , 2, cocos2d::CCActionInterval*, float) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCEaseOut::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCFadeOut : CCFadeOut, InterfaceBase {
	$CCFadeOut(const $CCFadeOut& c) : CCFadeOut(c) {}
	$CCFadeOut() = delete;
	setInterfaceStaticTypesOf(0, CCFadeOut, create, , 1, float);
	static inline auto address0 = base+0x1f7d80;

	dupable static getFunctionOf(CCFadeOut, create, , 1, float) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCFadeOut, create, , 1, float) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCFadeOut::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCFadeTo : CCFadeTo, InterfaceBase {
	$CCFadeTo(const $CCFadeTo& c) : CCFadeTo(c) {}
	$CCFadeTo() = delete;
	setInterfaceStaticTypesOf(0, CCFadeTo, create, , 2, float, unsigned char);
	static inline auto address0 = base+0x1f7ff0;

	dupable static getFunctionOf(CCFadeTo, create, , 2, float, unsigned char) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCFadeTo, create, , 2, float, unsigned char) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCFadeTo::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCHide : CCHide, InterfaceBase {
	$CCHide(const $CCHide& c) : CCHide(c) {}
	$CCHide() = delete;
	setInterfaceStaticTypesOf(0, CCHide, create, , 0);
	static inline auto address0 = base+0x4543e0;

	dupable static getFunctionOf(CCHide, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	static getWrapperOf(CCHide, create, , 0) {
		return D::create();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCHide::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCIMEDelegate : CCIMEDelegate, InterfaceBase {
	$CCIMEDelegate(const $CCIMEDelegate& c) : CCIMEDelegate(c) {}
	$CCIMEDelegate() = delete;
	setInterfaceTypesOf(1, CCIMEDelegate, attachWithIME, , 0);
	setInterfaceTypesOf(2, CCIMEDelegate, detachWithIME, , 0);
	static inline auto address0 = base+0x277670;
	static inline auto address1 = base+0x2776a0;
	static inline auto address2 = base+0x277880;
	static inline auto address3 = base+0x277310;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCIMEDelegate, attachWithIME, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCIMEDelegate, detachWithIME, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address3)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCIMEDelegate, attachWithIME, , 0) {
		return reinterpret_cast<D*>(this)->D::attachWithIME();
	}

	getWrapperOf(CCIMEDelegate, detachWithIME, , 0) {
		return reinterpret_cast<D*>(this)->D::detachWithIME();
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

public:
	static bool _apply() {

		if constexpr(&$CCIMEDelegate::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCIMEDelegate::attachWithIME) != (der1)(&D::attachWithIME)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::attachWithIMEWrapper)));
		}

		if ((mem2)(&$CCIMEDelegate::detachWithIME) != (der2)(&D::detachWithIME)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::detachWithIMEWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCImage : CCImage, InterfaceBase {
	$CCImage(const $CCImage& c) : CCImage(c) {}
	$CCImage() = delete;
	setInterfaceTypesOf(2, CCImage, initWithImageData, , 6, void*, int, cocos2d::CCImage::EImageFormat, int, int, int);
	static inline auto address0 = base+0x24fa00;
	static inline auto address1 = base+0x24fa80;
	static inline auto address2 = base+0x24fcb0;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable getFunctionOf(CCImage, initWithImageData, , 6, void*, int, cocos2d::CCImage::EImageFormat, int, int, int) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1, p2, p3, p4, p5);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCImage, initWithImageData, , 6, void*, int, cocos2d::CCImage::EImageFormat, int, int, int) {
		return reinterpret_cast<D*>(this)->D::initWithImageData(p0, p1, p2, p3, p4, p5);
	}

public:
	static bool _apply() {

		if constexpr(&$CCImage::destructor != &D::destructor) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem2)(&$CCImage::initWithImageData) != (der2)(&D::initWithImageData)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::initWithImageDataWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCKeyboardDelegate : CCKeyboardDelegate, InterfaceBase {
	$CCKeyboardDelegate(const $CCKeyboardDelegate& c) : CCKeyboardDelegate(c) {}
	$CCKeyboardDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCKeyboardDispatcher : CCKeyboardDispatcher, InterfaceBase {
	$CCKeyboardDispatcher(const $CCKeyboardDispatcher& c) : CCKeyboardDispatcher(c) {}
	$CCKeyboardDispatcher() = delete;
	setInterfaceTypesOf(0, CCKeyboardDispatcher, dispatchKeyboardMSG, , 2, cocos2d::enumKeyCodes, bool);
	static inline auto address0 = base+0xe8190;

	dupable getFunctionOf(CCKeyboardDispatcher, dispatchKeyboardMSG, , 2, cocos2d::enumKeyCodes, bool) {
		return reinterpret_cast<fun0>(address0)(this, p0, p1);
	}

	getWrapperOf(CCKeyboardDispatcher, dispatchKeyboardMSG, , 2, cocos2d::enumKeyCodes, bool) {
		return reinterpret_cast<D*>(this)->D::dispatchKeyboardMSG(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCKeyboardDispatcher::dispatchKeyboardMSG) != (der0)(&D::dispatchKeyboardMSG)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::dispatchKeyboardMSGWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCKeyboardHandler : CCKeyboardHandler, InterfaceBase {
	$CCKeyboardHandler(const $CCKeyboardHandler& c) : CCKeyboardHandler(c) {}
	$CCKeyboardHandler() = delete;
	setInterfaceStaticTypesOf(0, CCKeyboardHandler, handlerWithDelegate, , 1, cocos2d::CCKeyboardDelegate*);
	setInterfaceTypesOf(1, CCKeyboardHandler, initWithDelegate, , 1, cocos2d::CCKeyboardDelegate*);
	static inline auto address0 = base+0x242030;
	static inline auto address1 = base+0x241ff0;
	static inline auto address2 = base+0x241e90;

	dupable static getFunctionOf(CCKeyboardHandler, handlerWithDelegate, , 1, cocos2d::CCKeyboardDelegate*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(CCKeyboardHandler, initWithDelegate, , 1, cocos2d::CCKeyboardDelegate*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	static getWrapperOf(CCKeyboardHandler, handlerWithDelegate, , 1, cocos2d::CCKeyboardDelegate*) {
		return D::handlerWithDelegate(p0);
	}

	getWrapperOf(CCKeyboardHandler, initWithDelegate, , 1, cocos2d::CCKeyboardDelegate*) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCKeyboardHandler::handlerWithDelegate) != (der0)(&D::handlerWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::handlerWithDelegateWrapper)));
		}

		if ((mem1)(&$CCKeyboardHandler::initWithDelegate) != (der1)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCKeyboardHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCKeypadHandler : CCKeypadHandler, InterfaceBase {
	$CCKeypadHandler(const $CCKeypadHandler& c) : CCKeypadHandler(c) {}
	$CCKeypadHandler() = delete;
	setInterfaceStaticTypesOf(0, CCKeypadHandler, handlerWithDelegate, , 1, cocos2d::CCKeypadDelegate*);
	setInterfaceTypesOf(1, CCKeypadHandler, initWithDelegate, , 1, cocos2d::CCKeypadDelegate*);
	setInterfaceTypesOf(3, CCKeypadHandler, getDelegate, , 0);
	static inline auto address0 = base+0x1ff2d0;
	static inline auto address1 = base+0x1ff290;
	static inline auto address2 = base+0x1ff130;
	static inline auto address3 = base+0x1ff0b0;

	dupable static getFunctionOf(CCKeypadHandler, handlerWithDelegate, , 1, cocos2d::CCKeypadDelegate*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(CCKeypadHandler, initWithDelegate, , 1, cocos2d::CCKeypadDelegate*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	dupable getFunctionOf(CCKeypadHandler, getDelegate, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(CCKeypadHandler, handlerWithDelegate, , 1, cocos2d::CCKeypadDelegate*) {
		return D::handlerWithDelegate(p0);
	}

	getWrapperOf(CCKeypadHandler, initWithDelegate, , 1, cocos2d::CCKeypadDelegate*) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCKeypadHandler, getDelegate, , 0) {
		return reinterpret_cast<D*>(this)->D::getDelegate();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCKeypadHandler::handlerWithDelegate) != (der0)(&D::handlerWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::handlerWithDelegateWrapper)));
		}

		if ((mem1)(&$CCKeypadHandler::initWithDelegate) != (der1)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCKeypadHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem3)(&$CCKeypadHandler::getDelegate) != (der3)(&D::getDelegate)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getDelegateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCLabelBMFont : CCLabelBMFont, InterfaceBase {
	$CCLabelBMFont(const $CCLabelBMFont& c) : CCLabelBMFont(c) {}
	$CCLabelBMFont() = delete;
	setInterfaceStaticTypesOf(0, CCLabelBMFont, create, , 2, char const*, char const*);
	setInterfaceTypesOf(1, CCLabelBMFont, limitLabelWidth, , 3, float, float, float);
	setInterfaceTypesOf(2, CCLabelBMFont, setScale, , 1, float);
	setInterfaceTypesOf(3, CCLabelBMFont, setString, , 2, char const*, bool);
	setInterfaceTypesOf(4, CCLabelBMFont, setAnchorPoint, , 1, cocos2d::CCPoint const&);
	static inline auto address0 = base+0x347660;
	static inline auto address1 = base+0x34a6e0;
	static inline auto address2 = base+0x34a5d0;
	static inline auto address3 = base+0x3489e0;
	static inline auto address4 = base+0x349440;

	dupable static getFunctionOf(CCLabelBMFont, create, , 2, char const*, char const*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(CCLabelBMFont, limitLabelWidth, , 3, float, float, float) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCLabelBMFont, setScale, , 1, float) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCLabelBMFont, setString, , 2, char const*, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(CCLabelBMFont, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	static getWrapperOf(CCLabelBMFont, create, , 2, char const*, char const*) {
		return D::create(p0, p1);
	}

	getWrapperOf(CCLabelBMFont, limitLabelWidth, , 3, float, float, float) {
		return reinterpret_cast<D*>(this)->D::limitLabelWidth(p0, p1, p2);
	}

	getWrapperOf(CCLabelBMFont, setScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0);
	}

	getWrapperOf(CCLabelBMFont, setString, , 2, char const*, bool) {
		return reinterpret_cast<D*>(this)->D::setString(p0, p1);
	}

	getWrapperOf(CCLabelBMFont, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setAnchorPoint(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCLabelBMFont::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCLabelBMFont::limitLabelWidth) != (der1)(&D::limitLabelWidth)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::limitLabelWidthWrapper)));
		}

		if constexpr((mem2)(&$CCLabelBMFont::setScale) != (der2)(&D::setScale)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::setScaleWrapper)));
		}

		if constexpr((mem3)(&$CCLabelBMFont::setString) != (der3)(&D::setString)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::setStringWrapper)));
		}

		if constexpr((mem4)(&$CCLabelBMFont::setAnchorPoint) != (der4)(&D::setAnchorPoint)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::setAnchorPointWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCLabelTTF : CCLabelTTF, InterfaceBase {
	$CCLabelTTF(const $CCLabelTTF& c) : CCLabelTTF(c) {}
	$CCLabelTTF() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCLayer : CCLayer, InterfaceBase {
	$CCLayer(const $CCLayer& c) : CCLayer(c) {}
	$CCLayer() = delete;
	setInterfaceTypesOf(1, CCLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(2, CCLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(3, CCLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(4, CCLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(5, CCLayer, ccTouchesBegan, , 2, cocos2d::CCSet*, cocos2d::CCEvent*);
	setInterfaceTypesOf(6, CCLayer, ccTouchesCancelled, , 2, cocos2d::CCSet*, cocos2d::CCEvent*);
	setInterfaceTypesOf(7, CCLayer, ccTouchesEnded, , 2, cocos2d::CCSet*, cocos2d::CCEvent*);
	setInterfaceTypesOf(8, CCLayer, ccTouchesMoved, , 2, cocos2d::CCSet*, cocos2d::CCEvent*);
	setInterfaceStaticTypesOf(9, CCLayer, create, , 0);
	setInterfaceTypesOf(10, CCLayer, didAccelerate, , 1, cocos2d::CCAcceleration*);
	setInterfaceTypesOf(11, CCLayer, getTouchMode, , 0);
	setInterfaceTypesOf(12, CCLayer, getTouchPriority, , 0);
	setInterfaceTypesOf(13, CCLayer, init, , 0);
	setInterfaceTypesOf(14, CCLayer, isAccelerometerEnabled, , 0);
	setInterfaceTypesOf(15, CCLayer, isKeyboardEnabled, , 0);
	setInterfaceTypesOf(16, CCLayer, isKeypadEnabled, , 0);
	setInterfaceTypesOf(17, CCLayer, isMouseEnabled, , 0);
	setInterfaceTypesOf(18, CCLayer, isTouchEnabled, , 0);
	setInterfaceTypesOf(19, CCLayer, keyBackClicked, , 0);
	setInterfaceTypesOf(20, CCLayer, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(21, CCLayer, keyMenuClicked, , 0);
	setInterfaceTypesOf(22, CCLayer, onEnter, , 0);
	setInterfaceTypesOf(23, CCLayer, onEnterTransitionDidFinish, , 0);
	setInterfaceTypesOf(24, CCLayer, onExit, , 0);
	setInterfaceTypesOf(25, CCLayer, registerScriptTouchHandler, , 4, int, bool, int, bool);
	setInterfaceTypesOf(26, CCLayer, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(27, CCLayer, setAccelerometerEnabled, , 1, bool);
	setInterfaceTypesOf(28, CCLayer, setAccelerometerInterval, , 1, double);
	setInterfaceTypesOf(29, CCLayer, setKeyboardEnabled, , 1, bool);
	setInterfaceTypesOf(30, CCLayer, setKeypadEnabled, , 1, bool);
	setInterfaceTypesOf(31, CCLayer, setMouseEnabled, , 1, bool);
	setInterfaceTypesOf(32, CCLayer, setTouchEnabled, , 1, bool);
	setInterfaceTypesOf(33, CCLayer, setTouchMode, , 1, cocos2d::ccTouchesMode);
	setInterfaceTypesOf(34, CCLayer, setTouchPriority, , 1, int);
	setInterfaceTypesOf(35, CCLayer, unregisterScriptTouchHandler, , 0);
	static inline auto address0 = base+0x2725b0;
	static inline auto address1 = base+0x2734d0;
	static inline auto address2 = base+0x273650;
	static inline auto address3 = base+0x2735d0;
	static inline auto address4 = base+0x273550;
	static inline auto address5 = base+0x2736d0;
	static inline auto address6 = base+0x273850;
	static inline auto address7 = base+0x2737d0;
	static inline auto address8 = base+0x273750;
	static inline auto address9 = base+0x272a00;
	static inline auto address10 = base+0x272ea0;
	static inline auto address11 = base+0x272e10;
	static inline auto address12 = base+0x272e00;
	static inline auto address13 = base+0x2729a0;
	static inline auto address14 = base+0x272e20;
	static inline auto address15 = base+0x273010;
	static inline auto address16 = base+0x272f70;
	static inline auto address17 = base+0x273090;
	static inline auto address18 = base+0x272ce0;
	static inline auto address19 = base+0x273160;
	static inline auto address20 = base+0x273280;
	static inline auto address21 = base+0x273200;
	static inline auto address22 = base+0x273300;
	static inline auto address23 = base+0x273490;
	static inline auto address24 = base+0x2733c0;
	static inline auto address25 = base+0x272bd0;
	static inline auto address26 = base+0x272b40;
	static inline auto address27 = base+0x272e30;
	static inline auto address28 = base+0x272e70;
	static inline auto address29 = base+0x273020;
	static inline auto address30 = base+0x272f80;
	static inline auto address31 = base+0x2730a0;
	static inline auto address32 = base+0x272cf0;
	static inline auto address33 = base+0x272d60;
	static inline auto address34 = base+0x272db0;
	static inline auto address35 = base+0x272c30;
	static inline auto address36 = base+0x2727b0;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchesBegan, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchesCancelled, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchesEnded, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun7>(address7)(this, p0, p1);
	}

	dupable getFunctionOf(CCLayer, ccTouchesMoved, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun8>(address8)(this, p0, p1);
	}

	dupable static getFunctionOf(CCLayer, create, , 0) {
		return reinterpret_cast<fun9>(address9)();
	}

	dupable getFunctionOf(CCLayer, didAccelerate, , 1, cocos2d::CCAcceleration*) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(CCLayer, getTouchMode, , 0) {
		return reinterpret_cast<fun11>(address11)(this);
	}

	dupable getFunctionOf(CCLayer, getTouchPriority, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCLayer, init, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(CCLayer, isAccelerometerEnabled, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(CCLayer, isKeyboardEnabled, , 0) {
		return reinterpret_cast<fun15>(address15)(this);
	}

	dupable getFunctionOf(CCLayer, isKeypadEnabled, , 0) {
		return reinterpret_cast<fun16>(address16)(this);
	}

	dupable getFunctionOf(CCLayer, isMouseEnabled, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(CCLayer, isTouchEnabled, , 0) {
		return reinterpret_cast<fun18>(address18)(this);
	}

	dupable getFunctionOf(CCLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(CCLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(CCLayer, keyMenuClicked, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(CCLayer, onEnter, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable getFunctionOf(CCLayer, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(CCLayer, onExit, , 0) {
		return reinterpret_cast<fun24>(address24)(this);
	}

	dupable getFunctionOf(CCLayer, registerScriptTouchHandler, , 4, int, bool, int, bool) {
		return reinterpret_cast<fun25>(address25)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(CCLayer, setAccelerometerEnabled, , 1, bool) {
		return reinterpret_cast<fun27>(address27)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setAccelerometerInterval, , 1, double) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setKeyboardEnabled, , 1, bool) {
		return reinterpret_cast<fun29>(address29)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setKeypadEnabled, , 1, bool) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setMouseEnabled, , 1, bool) {
		return reinterpret_cast<fun31>(address31)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setTouchEnabled, , 1, bool) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setTouchMode, , 1, cocos2d::ccTouchesMode) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(CCLayer, setTouchPriority, , 1, int) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(CCLayer, unregisterScriptTouchHandler, , 0) {
		return reinterpret_cast<fun35>(address35)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address36)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchesBegan, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchesBegan(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchesCancelled, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchesCancelled(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchesEnded, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchesEnded(p0, p1);
	}

	getWrapperOf(CCLayer, ccTouchesMoved, , 2, cocos2d::CCSet*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchesMoved(p0, p1);
	}

	static getWrapperOf(CCLayer, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCLayer, didAccelerate, , 1, cocos2d::CCAcceleration*) {
		return reinterpret_cast<D*>(this)->D::didAccelerate(p0);
	}

	getWrapperOf(CCLayer, getTouchMode, , 0) {
		return reinterpret_cast<D*>(this)->D::getTouchMode();
	}

	getWrapperOf(CCLayer, getTouchPriority, , 0) {
		return reinterpret_cast<D*>(this)->D::getTouchPriority();
	}

	getWrapperOf(CCLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCLayer, isAccelerometerEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isAccelerometerEnabled();
	}

	getWrapperOf(CCLayer, isKeyboardEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isKeyboardEnabled();
	}

	getWrapperOf(CCLayer, isKeypadEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isKeypadEnabled();
	}

	getWrapperOf(CCLayer, isMouseEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isMouseEnabled();
	}

	getWrapperOf(CCLayer, isTouchEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isTouchEnabled();
	}

	getWrapperOf(CCLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	getWrapperOf(CCLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(CCLayer, keyMenuClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyMenuClicked();
	}

	getWrapperOf(CCLayer, onEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnter();
	}

	getWrapperOf(CCLayer, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnterTransitionDidFinish();
	}

	getWrapperOf(CCLayer, onExit, , 0) {
		return reinterpret_cast<D*>(this)->D::onExit();
	}

	getWrapperOf(CCLayer, registerScriptTouchHandler, , 4, int, bool, int, bool) {
		return reinterpret_cast<D*>(this)->D::registerScriptTouchHandler(p0, p1, p2, p3);
	}

	getWrapperOf(CCLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(CCLayer, setAccelerometerEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setAccelerometerEnabled(p0);
	}

	getWrapperOf(CCLayer, setAccelerometerInterval, , 1, double) {
		return reinterpret_cast<D*>(this)->D::setAccelerometerInterval(p0);
	}

	getWrapperOf(CCLayer, setKeyboardEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setKeyboardEnabled(p0);
	}

	getWrapperOf(CCLayer, setKeypadEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setKeypadEnabled(p0);
	}

	getWrapperOf(CCLayer, setMouseEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setMouseEnabled(p0);
	}

	getWrapperOf(CCLayer, setTouchEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setTouchEnabled(p0);
	}

	getWrapperOf(CCLayer, setTouchMode, , 1, cocos2d::ccTouchesMode) {
		return reinterpret_cast<D*>(this)->D::setTouchMode(p0);
	}

	getWrapperOf(CCLayer, setTouchPriority, , 1, int) {
		return reinterpret_cast<D*>(this)->D::setTouchPriority(p0);
	}

	getWrapperOf(CCLayer, unregisterScriptTouchHandler, , 0) {
		return reinterpret_cast<D*>(this)->D::unregisterScriptTouchHandler();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCLayer::ccTouchBegan) != (der1)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::ccTouchBeganWrapper)));
		}

		if constexpr((mem2)(&$CCLayer::ccTouchCancelled) != (der2)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::ccTouchCancelledWrapper)));
		}

		if constexpr((mem3)(&$CCLayer::ccTouchEnded) != (der3)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::ccTouchEndedWrapper)));
		}

		if constexpr((mem4)(&$CCLayer::ccTouchMoved) != (der4)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::ccTouchMovedWrapper)));
		}

		if constexpr((mem5)(&$CCLayer::ccTouchesBegan) != (der5)(&D::ccTouchesBegan)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::ccTouchesBeganWrapper)));
		}

		if constexpr((mem6)(&$CCLayer::ccTouchesCancelled) != (der6)(&D::ccTouchesCancelled)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::ccTouchesCancelledWrapper)));
		}

		if constexpr((mem7)(&$CCLayer::ccTouchesEnded) != (der7)(&D::ccTouchesEnded)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::ccTouchesEndedWrapper)));
		}

		if constexpr((mem8)(&$CCLayer::ccTouchesMoved) != (der8)(&D::ccTouchesMoved)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::ccTouchesMovedWrapper)));
		}

		if constexpr((mem9)(&$CCLayer::create) != (der9)(&D::create)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::createWrapper)));
		}

		if constexpr((mem10)(&$CCLayer::didAccelerate) != (der10)(&D::didAccelerate)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::didAccelerateWrapper)));
		}

		if constexpr((mem11)(&$CCLayer::getTouchMode) != (der11)(&D::getTouchMode)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::getTouchModeWrapper)));
		}

		if constexpr((mem12)(&$CCLayer::getTouchPriority) != (der12)(&D::getTouchPriority)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::getTouchPriorityWrapper)));
		}

		if constexpr((mem13)(&$CCLayer::init) != (der13)(&D::init)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::initWrapper)));
		}

		if constexpr((mem14)(&$CCLayer::isAccelerometerEnabled) != (der14)(&D::isAccelerometerEnabled)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::isAccelerometerEnabledWrapper)));
		}

		if constexpr((mem15)(&$CCLayer::isKeyboardEnabled) != (der15)(&D::isKeyboardEnabled)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::isKeyboardEnabledWrapper)));
		}

		if constexpr((mem16)(&$CCLayer::isKeypadEnabled) != (der16)(&D::isKeypadEnabled)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::isKeypadEnabledWrapper)));
		}

		if constexpr((mem17)(&$CCLayer::isMouseEnabled) != (der17)(&D::isMouseEnabled)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::isMouseEnabledWrapper)));
		}

		if constexpr((mem18)(&$CCLayer::isTouchEnabled) != (der18)(&D::isTouchEnabled)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::isTouchEnabledWrapper)));
		}

		if constexpr((mem19)(&$CCLayer::keyBackClicked) != (der19)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::keyBackClickedWrapper)));
		}

		if constexpr((mem20)(&$CCLayer::keyDown) != (der20)(&D::keyDown)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::keyDownWrapper)));
		}

		if constexpr((mem21)(&$CCLayer::keyMenuClicked) != (der21)(&D::keyMenuClicked)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::keyMenuClickedWrapper)));
		}

		if constexpr((mem22)(&$CCLayer::onEnter) != (der22)(&D::onEnter)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::onEnterWrapper)));
		}

		if constexpr((mem23)(&$CCLayer::onEnterTransitionDidFinish) != (der23)(&D::onEnterTransitionDidFinish)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::onEnterTransitionDidFinishWrapper)));
		}

		if constexpr((mem24)(&$CCLayer::onExit) != (der24)(&D::onExit)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::onExitWrapper)));
		}

		if constexpr((mem25)(&$CCLayer::registerScriptTouchHandler) != (der25)(&D::registerScriptTouchHandler)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::registerScriptTouchHandlerWrapper)));
		}

		if constexpr((mem26)(&$CCLayer::registerWithTouchDispatcher) != (der26)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::registerWithTouchDispatcherWrapper)));
		}

		if constexpr((mem27)(&$CCLayer::setAccelerometerEnabled) != (der27)(&D::setAccelerometerEnabled)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::setAccelerometerEnabledWrapper)));
		}

		if constexpr((mem28)(&$CCLayer::setAccelerometerInterval) != (der28)(&D::setAccelerometerInterval)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::setAccelerometerIntervalWrapper)));
		}

		if constexpr((mem29)(&$CCLayer::setKeyboardEnabled) != (der29)(&D::setKeyboardEnabled)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::setKeyboardEnabledWrapper)));
		}

		if constexpr((mem30)(&$CCLayer::setKeypadEnabled) != (der30)(&D::setKeypadEnabled)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::setKeypadEnabledWrapper)));
		}

		if constexpr((mem31)(&$CCLayer::setMouseEnabled) != (der31)(&D::setMouseEnabled)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::setMouseEnabledWrapper)));
		}

		if constexpr((mem32)(&$CCLayer::setTouchEnabled) != (der32)(&D::setTouchEnabled)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::setTouchEnabledWrapper)));
		}

		if constexpr((mem33)(&$CCLayer::setTouchMode) != (der33)(&D::setTouchMode)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::setTouchModeWrapper)));
		}

		if constexpr((mem34)(&$CCLayer::setTouchPriority) != (der34)(&D::setTouchPriority)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::setTouchPriorityWrapper)));
		}

		if constexpr((mem35)(&$CCLayer::unregisterScriptTouchHandler) != (der35)(&D::unregisterScriptTouchHandler)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::unregisterScriptTouchHandlerWrapper)));
		}

		if constexpr(&$CCLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCLayerColor : CCLayerColor, InterfaceBase {
	$CCLayerColor(const $CCLayerColor& c) : CCLayerColor(c) {}
	$CCLayerColor() = delete;
	setInterfaceStaticTypesOf(1, CCLayerColor, create, , 3, cocos2d::_ccColor4B const&, float, float);
	setInterfaceTypesOf(2, CCLayerColor, draw, , 0);
	setInterfaceTypesOf(3, CCLayerColor, getBlendFunc, , 0);
	setInterfaceTypesOf(4, CCLayerColor, init, , 0);
	setInterfaceTypesOf(5, CCLayerColor, initWithColor, , 1, cocos2d::_ccColor4B const&);
	setInterfaceTypesOf(6, CCLayerColor, initWithColor, , 3, cocos2d::_ccColor4B const&, float, float);
	setInterfaceTypesOf(7, CCLayerColor, setBlendFunc, , 1, cocos2d::_ccBlendFunc);
	setInterfaceTypesOf(8, CCLayerColor, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(9, CCLayerColor, setContentSize, , 1, cocos2d::CCSize const&);
	setInterfaceTypesOf(10, CCLayerColor, setOpacity, , 1, unsigned char);
	static inline auto address0 = base+0x274320;
	static inline auto address1 = base+0x2745e0;
	static inline auto address2 = base+0x274b50;
	static inline auto address3 = base+0x274480;
	static inline auto address4 = base+0x274800;
	static inline auto address5 = base+0x2749a0;
	static inline auto address6 = base+0x274850;
	static inline auto address7 = base+0x2744a0;
	static inline auto address8 = base+0x274c20;
	static inline auto address9 = base+0x2749f0;
	static inline auto address10 = base+0x274db0;
	static inline auto address12 = base+0x2743d0;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable static getFunctionOf(CCLayerColor, create, , 3, cocos2d::_ccColor4B const&, float, float) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2);
	}

	dupable getFunctionOf(CCLayerColor, draw, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCLayerColor, getBlendFunc, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCLayerColor, init, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCLayerColor, initWithColor, , 1, cocos2d::_ccColor4B const&) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCLayerColor, initWithColor, , 3, cocos2d::_ccColor4B const&, float, float) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCLayerColor, setBlendFunc, , 1, cocos2d::_ccBlendFunc) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCLayerColor, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCLayerColor, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCLayerColor, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address12)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	static getWrapperOf(CCLayerColor, create, , 3, cocos2d::_ccColor4B const&, float, float) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(CCLayerColor, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(CCLayerColor, getBlendFunc, , 0) {
		return reinterpret_cast<D*>(this)->D::getBlendFunc();
	}

	getWrapperOf(CCLayerColor, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCLayerColor, initWithColor, , 1, cocos2d::_ccColor4B const&) {
		return reinterpret_cast<D*>(this)->D::initWithColor(p0);
	}

	getWrapperOf(CCLayerColor, initWithColor, , 3, cocos2d::_ccColor4B const&, float, float) {
		return reinterpret_cast<D*>(this)->D::initWithColor(p0, p1, p2);
	}

	getWrapperOf(CCLayerColor, setBlendFunc, , 1, cocos2d::_ccBlendFunc) {
		return reinterpret_cast<D*>(this)->D::setBlendFunc(p0);
	}

	getWrapperOf(CCLayerColor, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(CCLayerColor, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::setContentSize(p0);
	}

	getWrapperOf(CCLayerColor, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCLayerColor::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$CCLayerColor::draw) != (der2)(&D::draw)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::drawWrapper)));
		}

		if constexpr((mem3)(&$CCLayerColor::getBlendFunc) != (der3)(&D::getBlendFunc)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getBlendFuncWrapper)));
		}

		if constexpr((mem4)(&$CCLayerColor::init) != (der4)(&D::init)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::initWrapper)));
		}

		if constexpr((mem5)(&$CCLayerColor::initWithColor) != (der5)(&D::initWithColor)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::initWithColorWrapper)));
		}

		if constexpr((mem6)(&$CCLayerColor::initWithColor) != (der6)(&D::initWithColor)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::initWithColorWrapper)));
		}

		if constexpr((mem7)(&$CCLayerColor::setBlendFunc) != (der7)(&D::setBlendFunc)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::setBlendFuncWrapper)));
		}

		if constexpr((mem8)(&$CCLayerColor::setColor) != (der8)(&D::setColor)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::setColorWrapper)));
		}

		if constexpr((mem9)(&$CCLayerColor::setContentSize) != (der9)(&D::setContentSize)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::setContentSizeWrapper)));
		}

		if constexpr((mem10)(&$CCLayerColor::setOpacity) != (der10)(&D::setOpacity)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::setOpacityWrapper)));
		}

		if constexpr(&$CCLayerColor::destructor != &D::destructor) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCLayerRGBA : CCLayerRGBA, InterfaceBase {
	$CCLayerRGBA(const $CCLayerRGBA& c) : CCLayerRGBA(c) {}
	$CCLayerRGBA() = delete;
	setInterfaceTypesOf(1, CCLayerRGBA, init, , 0);
	setInterfaceTypesOf(2, CCLayerRGBA, getOpacity, , 0);
	setInterfaceTypesOf(3, CCLayerRGBA, getDisplayedOpacity, , 0);
	setInterfaceTypesOf(4, CCLayerRGBA, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(5, CCLayerRGBA, updateDisplayedOpacity, , 1, unsigned char);
	setInterfaceTypesOf(6, CCLayerRGBA, isCascadeOpacityEnabled, , 0);
	setInterfaceTypesOf(7, CCLayerRGBA, setCascadeOpacityEnabled, , 1, bool);
	setInterfaceTypesOf(8, CCLayerRGBA, getColor, , 0);
	setInterfaceTypesOf(9, CCLayerRGBA, getDisplayedColor, , 0);
	setInterfaceTypesOf(10, CCLayerRGBA, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(11, CCLayerRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(12, CCLayerRGBA, isCascadeColorEnabled, , 0);
	setInterfaceTypesOf(13, CCLayerRGBA, setCascadeColorEnabled, , 1, bool);
	static inline auto address0 = base+0x2738d0;
	static inline auto address1 = base+0x273b40;
	static inline auto address2 = base+0x273be0;
	static inline auto address3 = base+0x273c00;
	static inline auto address4 = base+0x273c20;
	static inline auto address5 = base+0x273f20;
	static inline auto address6 = base+0x2741f0;
	static inline auto address7 = base+0x274210;
	static inline auto address8 = base+0x273d60;
	static inline auto address9 = base+0x273d80;
	static inline auto address10 = base+0x273da0;
	static inline auto address11 = base+0x2740b0;
	static inline auto address12 = base+0x274230;
	static inline auto address13 = base+0x274250;
	static inline auto address14 = base+0x273aa0;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, getOpacity, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, getDisplayedOpacity, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCLayerRGBA, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCLayerRGBA, isCascadeOpacityEnabled, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, setCascadeOpacityEnabled, , 1, bool) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCLayerRGBA, getColor, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, getDisplayedColor, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(CCLayerRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCLayerRGBA, isCascadeColorEnabled, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCLayerRGBA, setCascadeColorEnabled, , 1, bool) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address14)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCLayerRGBA, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCLayerRGBA, getOpacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getOpacity();
	}

	getWrapperOf(CCLayerRGBA, getDisplayedOpacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisplayedOpacity();
	}

	getWrapperOf(CCLayerRGBA, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(CCLayerRGBA, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedOpacity(p0);
	}

	getWrapperOf(CCLayerRGBA, isCascadeOpacityEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isCascadeOpacityEnabled();
	}

	getWrapperOf(CCLayerRGBA, setCascadeOpacityEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setCascadeOpacityEnabled(p0);
	}

	getWrapperOf(CCLayerRGBA, getColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getColor();
	}

	getWrapperOf(CCLayerRGBA, getDisplayedColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisplayedColor();
	}

	getWrapperOf(CCLayerRGBA, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(CCLayerRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedColor(p0);
	}

	getWrapperOf(CCLayerRGBA, isCascadeColorEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isCascadeColorEnabled();
	}

	getWrapperOf(CCLayerRGBA, setCascadeColorEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setCascadeColorEnabled(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if ((mem1)(&$CCLayerRGBA::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if ((mem2)(&$CCLayerRGBA::getOpacity) != (der2)(&D::getOpacity)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::getOpacityWrapper)));
		}

		if ((mem3)(&$CCLayerRGBA::getDisplayedOpacity) != (der3)(&D::getDisplayedOpacity)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::getDisplayedOpacityWrapper)));
		}

		if ((mem4)(&$CCLayerRGBA::setOpacity) != (der4)(&D::setOpacity)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setOpacityWrapper)));
		}

		if ((mem5)(&$CCLayerRGBA::updateDisplayedOpacity) != (der5)(&D::updateDisplayedOpacity)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::updateDisplayedOpacityWrapper)));
		}

		if ((mem6)(&$CCLayerRGBA::isCascadeOpacityEnabled) != (der6)(&D::isCascadeOpacityEnabled)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::isCascadeOpacityEnabledWrapper)));
		}

		if ((mem7)(&$CCLayerRGBA::setCascadeOpacityEnabled) != (der7)(&D::setCascadeOpacityEnabled)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setCascadeOpacityEnabledWrapper)));
		}

		if ((mem8)(&$CCLayerRGBA::getColor) != (der8)(&D::getColor)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::getColorWrapper)));
		}

		if ((mem9)(&$CCLayerRGBA::getDisplayedColor) != (der9)(&D::getDisplayedColor)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::getDisplayedColorWrapper)));
		}

		if ((mem10)(&$CCLayerRGBA::setColor) != (der10)(&D::setColor)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::setColorWrapper)));
		}

		if ((mem11)(&$CCLayerRGBA::updateDisplayedColor) != (der11)(&D::updateDisplayedColor)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::updateDisplayedColorWrapper)));
		}

		if ((mem12)(&$CCLayerRGBA::isCascadeColorEnabled) != (der12)(&D::isCascadeColorEnabled)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::isCascadeColorEnabledWrapper)));
		}

		if ((mem13)(&$CCLayerRGBA::setCascadeColorEnabled) != (der13)(&D::setCascadeColorEnabled)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::setCascadeColorEnabledWrapper)));
		}

		if constexpr(&$CCLayerRGBA::destructor != &D::destructor) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCMenu : CCMenu, InterfaceBase {
	$CCMenu(const $CCMenu& c) : CCMenu(c) {}
	$CCMenu() = delete;
	setInterfaceTypesOf(0, CCMenu, alignItemsHorizontallyWithPadding, , 1, float);
	setInterfaceTypesOf(1, CCMenu, alignItemsVerticallyWithPadding, , 1, float);
	setInterfaceStaticTypesOf(2, CCMenu, create, , 0);
	setInterfaceStaticTypesOf(3, CCMenu, createWithArray, , 1, cocos2d::CCArray*);
	setInterfaceStaticTypesOf(4, CCMenu, createWithItem, , 1, cocos2d::CCMenuItem*);
	static inline auto address0 = base+0x4393e0;
	static inline auto address1 = base+0x439190;
	static inline auto address2 = base+0x438720;
	static inline auto address3 = base+0x4387e0;
	static inline auto address4 = base+0x438b80;

	dupable getFunctionOf(CCMenu, alignItemsHorizontallyWithPadding, , 1, float) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CCMenu, alignItemsVerticallyWithPadding, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable static getFunctionOf(CCMenu, create, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	dupable static getFunctionOf(CCMenu, createWithArray, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun3>(address3)(p0);
	}

	dupable static getFunctionOf(CCMenu, createWithItem, , 1, cocos2d::CCMenuItem*) {
		return reinterpret_cast<fun4>(address4)(p0);
	}

	getWrapperOf(CCMenu, alignItemsHorizontallyWithPadding, , 1, float) {
		return reinterpret_cast<D*>(this)->D::alignItemsHorizontallyWithPadding(p0);
	}

	getWrapperOf(CCMenu, alignItemsVerticallyWithPadding, , 1, float) {
		return reinterpret_cast<D*>(this)->D::alignItemsVerticallyWithPadding(p0);
	}

	static getWrapperOf(CCMenu, create, , 0) {
		return D::create();
	}

	static getWrapperOf(CCMenu, createWithArray, , 1, cocos2d::CCArray*) {
		return D::createWithArray(p0);
	}

	static getWrapperOf(CCMenu, createWithItem, , 1, cocos2d::CCMenuItem*) {
		return D::createWithItem(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMenu::alignItemsHorizontallyWithPadding) != (der0)(&D::alignItemsHorizontallyWithPadding)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::alignItemsHorizontallyWithPaddingWrapper)));
		}

		if constexpr((mem1)(&$CCMenu::alignItemsVerticallyWithPadding) != (der1)(&D::alignItemsVerticallyWithPadding)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::alignItemsVerticallyWithPaddingWrapper)));
		}

		if constexpr((mem2)(&$CCMenu::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		if constexpr((mem3)(&$CCMenu::createWithArray) != (der3)(&D::createWithArray)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::createWithArrayWrapper)));
		}

		if constexpr((mem4)(&$CCMenu::createWithItem) != (der4)(&D::createWithItem)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::createWithItemWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItem : CCMenuItem, InterfaceBase {
	$CCMenuItem(const $CCMenuItem& c) : CCMenuItem(c) {}
	$CCMenuItem() = delete;
	setInterfaceTypesOf(1, CCMenuItem, activate, , 0);
	setInterfaceTypesOf(2, CCMenuItem, selected, , 0);
	setInterfaceTypesOf(3, CCMenuItem, unselected, , 0);
	setInterfaceTypesOf(4, CCMenuItem, registerScriptTapHandler, , 1, int);
	setInterfaceTypesOf(5, CCMenuItem, unregisterScriptTapHandler, , 0);
	setInterfaceTypesOf(6, CCMenuItem, isEnabled, , 0);
	setInterfaceTypesOf(7, CCMenuItem, setEnabled, , 1, bool);
	setInterfaceTypesOf(8, CCMenuItem, isSelected, , 0);
	static inline auto address0 = base+0x1fb8e0;
	static inline auto address1 = base+0x1fba70;
	static inline auto address2 = base+0x1fb9e0;
	static inline auto address3 = base+0x1fb9f0;
	static inline auto address4 = base+0x1fba00;
	static inline auto address5 = base+0x1fba30;
	static inline auto address6 = base+0x1fbaf0;
	static inline auto address7 = base+0x1fbae0;
	static inline auto address8 = base+0x1fbb50;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCMenuItem, activate, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCMenuItem, selected, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCMenuItem, unselected, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCMenuItem, registerScriptTapHandler, , 1, int) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCMenuItem, unregisterScriptTapHandler, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCMenuItem, isEnabled, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCMenuItem, setEnabled, , 1, bool) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCMenuItem, isSelected, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCMenuItem, activate, , 0) {
		return reinterpret_cast<D*>(this)->D::activate();
	}

	getWrapperOf(CCMenuItem, selected, , 0) {
		return reinterpret_cast<D*>(this)->D::selected();
	}

	getWrapperOf(CCMenuItem, unselected, , 0) {
		return reinterpret_cast<D*>(this)->D::unselected();
	}

	getWrapperOf(CCMenuItem, registerScriptTapHandler, , 1, int) {
		return reinterpret_cast<D*>(this)->D::registerScriptTapHandler(p0);
	}

	getWrapperOf(CCMenuItem, unregisterScriptTapHandler, , 0) {
		return reinterpret_cast<D*>(this)->D::unregisterScriptTapHandler();
	}

	getWrapperOf(CCMenuItem, isEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isEnabled();
	}

	getWrapperOf(CCMenuItem, setEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setEnabled(p0);
	}

	getWrapperOf(CCMenuItem, isSelected, , 0) {
		return reinterpret_cast<D*>(this)->D::isSelected();
	}

public:
	static bool _apply() {

		if constexpr(&$CCMenuItem::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCMenuItem::activate) != (der1)(&D::activate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::activateWrapper)));
		}

		if ((mem2)(&$CCMenuItem::selected) != (der2)(&D::selected)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::selectedWrapper)));
		}

		if ((mem3)(&$CCMenuItem::unselected) != (der3)(&D::unselected)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::unselectedWrapper)));
		}

		if ((mem4)(&$CCMenuItem::registerScriptTapHandler) != (der4)(&D::registerScriptTapHandler)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::registerScriptTapHandlerWrapper)));
		}

		if ((mem5)(&$CCMenuItem::unregisterScriptTapHandler) != (der5)(&D::unregisterScriptTapHandler)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::unregisterScriptTapHandlerWrapper)));
		}

		if ((mem6)(&$CCMenuItem::isEnabled) != (der6)(&D::isEnabled)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::isEnabledWrapper)));
		}

		if ((mem7)(&$CCMenuItem::setEnabled) != (der7)(&D::setEnabled)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setEnabledWrapper)));
		}

		if ((mem8)(&$CCMenuItem::isSelected) != (der8)(&D::isSelected)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::isSelectedWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItemImage : CCMenuItemImage, InterfaceBase {
	$CCMenuItemImage(const $CCMenuItemImage& c) : CCMenuItemImage(c) {}
	$CCMenuItemImage() = delete;
	setInterfaceTypesOf(0, CCMenuItemImage, init, , 0);
	static inline auto address0 = base+0x1fd750;

	dupable getFunctionOf(CCMenuItemImage, init, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	getWrapperOf(CCMenuItemImage, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

public:
	static bool _apply() {

		if ((mem0)(&$CCMenuItemImage::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::initWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItemLabel : CCMenuItemLabel, InterfaceBase {
	$CCMenuItemLabel(const $CCMenuItemLabel& c) : CCMenuItemLabel(c) {}
	$CCMenuItemLabel() = delete;
	setInterfaceTypesOf(1, CCMenuItemLabel, activate, , 0);
	setInterfaceTypesOf(2, CCMenuItemLabel, selected, , 0);
	setInterfaceTypesOf(3, CCMenuItemLabel, unselected, , 0);
	setInterfaceTypesOf(4, CCMenuItemLabel, setEnabled, , 1, bool);
	setInterfaceTypesOf(5, CCMenuItemLabel, getDisabledColor, , 0);
	setInterfaceTypesOf(6, CCMenuItemLabel, setDisabledColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(7, CCMenuItemLabel, getLabel, , 0);
	setInterfaceTypesOf(8, CCMenuItemLabel, setLabel, , 1, cocos2d::CCNode*);
	static inline auto address0 = base+0x1fc0d0;
	static inline auto address1 = base+0x1fc240;
	static inline auto address2 = base+0x1fc2e0;
	static inline auto address3 = base+0x1fc380;
	static inline auto address4 = base+0x1fc3f0;
	static inline auto address5 = base+0x1fbb80;
	static inline auto address6 = base+0x1fbb90;
	static inline auto address7 = base+0x1fbbb0;
	static inline auto address8 = base+0x1fbbc0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, activate, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, selected, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, unselected, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, setEnabled, , 1, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemLabel, getDisabledColor, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, setDisabledColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemLabel, getLabel, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCMenuItemLabel, setLabel, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCMenuItemLabel, activate, , 0) {
		return reinterpret_cast<D*>(this)->D::activate();
	}

	getWrapperOf(CCMenuItemLabel, selected, , 0) {
		return reinterpret_cast<D*>(this)->D::selected();
	}

	getWrapperOf(CCMenuItemLabel, unselected, , 0) {
		return reinterpret_cast<D*>(this)->D::unselected();
	}

	getWrapperOf(CCMenuItemLabel, setEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setEnabled(p0);
	}

	getWrapperOf(CCMenuItemLabel, getDisabledColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisabledColor();
	}

	getWrapperOf(CCMenuItemLabel, setDisabledColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setDisabledColor(p0);
	}

	getWrapperOf(CCMenuItemLabel, getLabel, , 0) {
		return reinterpret_cast<D*>(this)->D::getLabel();
	}

	getWrapperOf(CCMenuItemLabel, setLabel, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setLabel(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCMenuItemLabel::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCMenuItemLabel::activate) != (der1)(&D::activate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::activateWrapper)));
		}

		if ((mem2)(&$CCMenuItemLabel::selected) != (der2)(&D::selected)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::selectedWrapper)));
		}

		if ((mem3)(&$CCMenuItemLabel::unselected) != (der3)(&D::unselected)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::unselectedWrapper)));
		}

		if ((mem4)(&$CCMenuItemLabel::setEnabled) != (der4)(&D::setEnabled)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setEnabledWrapper)));
		}

		if ((mem5)(&$CCMenuItemLabel::getDisabledColor) != (der5)(&D::getDisabledColor)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::getDisabledColorWrapper)));
		}

		if ((mem6)(&$CCMenuItemLabel::setDisabledColor) != (der6)(&D::setDisabledColor)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::setDisabledColorWrapper)));
		}

		if ((mem7)(&$CCMenuItemLabel::getLabel) != (der7)(&D::getLabel)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::getLabelWrapper)));
		}

		if ((mem8)(&$CCMenuItemLabel::setLabel) != (der8)(&D::setLabel)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setLabelWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItemSprite : CCMenuItemSprite, InterfaceBase {
	$CCMenuItemSprite(const $CCMenuItemSprite& c) : CCMenuItemSprite(c) {}
	$CCMenuItemSprite() = delete;
	setInterfaceTypesOf(0, CCMenuItemSprite, selected, , 0);
	setInterfaceTypesOf(1, CCMenuItemSprite, unselected, , 0);
	setInterfaceTypesOf(2, CCMenuItemSprite, setEnabled, , 1, bool);
	setInterfaceTypesOf(3, CCMenuItemSprite, getNormalImage, , 0);
	setInterfaceTypesOf(4, CCMenuItemSprite, setNormalImage, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(5, CCMenuItemSprite, getSelectedImage, , 0);
	setInterfaceTypesOf(6, CCMenuItemSprite, setSelectedImage, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(7, CCMenuItemSprite, getDisabledImage, , 0);
	setInterfaceTypesOf(8, CCMenuItemSprite, setDisabledImage, , 1, cocos2d::CCNode*);
	setInterfaceStaticTypesOf(10, CCMenuItemSprite, create, , 3, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*);
	setInterfaceStaticTypesOf(11, CCMenuItemSprite, create, , 5, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	setInterfaceStaticTypesOf(12, CCMenuItemSprite, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static inline auto address0 = base+0x1fd3f0;
	static inline auto address1 = base+0x1fd470;
	static inline auto address2 = base+0x1fd4e0;
	static inline auto address3 = base+0x1fcee0;
	static inline auto address4 = base+0x1fcef0;
	static inline auto address5 = base+0x1fcfc0;
	static inline auto address6 = base+0x1fcfd0;
	static inline auto address7 = base+0x1fd070;
	static inline auto address8 = base+0x1fd080;
	static inline auto address10 = base+0x1fd120;
	static inline auto address11 = base+0x1fd140;
	static inline auto address12 = base+0x1fd2d0;

	dupable getFunctionOf(CCMenuItemSprite, selected, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCMenuItemSprite, unselected, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCMenuItemSprite, setEnabled, , 1, bool) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemSprite, getNormalImage, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCMenuItemSprite, setNormalImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemSprite, getSelectedImage, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCMenuItemSprite, setSelectedImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemSprite, getDisabledImage, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCMenuItemSprite, setDisabledImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable static getFunctionOf(CCMenuItemSprite, create, , 3, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*) {
		return reinterpret_cast<fun10>(address10)(p0, p1, p2);
	}

	dupable static getFunctionOf(CCMenuItemSprite, create, , 5, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun11>(address11)(p0, p1, p2, p3, p4);
	}

	dupable static getFunctionOf(CCMenuItemSprite, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun12>(address12)(p0, p1, p2, p3);
	}

	getWrapperOf(CCMenuItemSprite, selected, , 0) {
		return reinterpret_cast<D*>(this)->D::selected();
	}

	getWrapperOf(CCMenuItemSprite, unselected, , 0) {
		return reinterpret_cast<D*>(this)->D::unselected();
	}

	getWrapperOf(CCMenuItemSprite, setEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setEnabled(p0);
	}

	getWrapperOf(CCMenuItemSprite, getNormalImage, , 0) {
		return reinterpret_cast<D*>(this)->D::getNormalImage();
	}

	getWrapperOf(CCMenuItemSprite, setNormalImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setNormalImage(p0);
	}

	getWrapperOf(CCMenuItemSprite, getSelectedImage, , 0) {
		return reinterpret_cast<D*>(this)->D::getSelectedImage();
	}

	getWrapperOf(CCMenuItemSprite, setSelectedImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setSelectedImage(p0);
	}

	getWrapperOf(CCMenuItemSprite, getDisabledImage, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisabledImage();
	}

	getWrapperOf(CCMenuItemSprite, setDisabledImage, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setDisabledImage(p0);
	}

	static getWrapperOf(CCMenuItemSprite, create, , 3, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*) {
		return D::create(p0, p1, p2);
	}

	static getWrapperOf(CCMenuItemSprite, create, , 5, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return D::create(p0, p1, p2, p3, p4);
	}

	static getWrapperOf(CCMenuItemSprite, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return D::create(p0, p1, p2, p3);
	}

public:
	static bool _apply() {

		if ((mem0)(&$CCMenuItemSprite::selected) != (der0)(&D::selected)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::selectedWrapper)));
		}

		if ((mem1)(&$CCMenuItemSprite::unselected) != (der1)(&D::unselected)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::unselectedWrapper)));
		}

		if ((mem2)(&$CCMenuItemSprite::setEnabled) != (der2)(&D::setEnabled)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setEnabledWrapper)));
		}

		if ((mem3)(&$CCMenuItemSprite::getNormalImage) != (der3)(&D::getNormalImage)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::getNormalImageWrapper)));
		}

		if ((mem4)(&$CCMenuItemSprite::setNormalImage) != (der4)(&D::setNormalImage)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setNormalImageWrapper)));
		}

		if ((mem5)(&$CCMenuItemSprite::getSelectedImage) != (der5)(&D::getSelectedImage)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::getSelectedImageWrapper)));
		}

		if ((mem6)(&$CCMenuItemSprite::setSelectedImage) != (der6)(&D::setSelectedImage)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::setSelectedImageWrapper)));
		}

		if ((mem7)(&$CCMenuItemSprite::getDisabledImage) != (der7)(&D::getDisabledImage)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::getDisabledImageWrapper)));
		}

		if ((mem8)(&$CCMenuItemSprite::setDisabledImage) != (der8)(&D::setDisabledImage)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setDisabledImageWrapper)));
		}

		if constexpr((mem10)(&$CCMenuItemSprite::create) != (der10)(&D::create)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::createWrapper)));
		}

		if constexpr((mem11)(&$CCMenuItemSprite::create) != (der11)(&D::create)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::createWrapper)));
		}

		if constexpr((mem12)(&$CCMenuItemSprite::create) != (der12)(&D::create)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMotionStreak : CCMotionStreak, InterfaceBase {
	$CCMotionStreak(const $CCMotionStreak& c) : CCMotionStreak(c) {}
	$CCMotionStreak() = delete;
	setInterfaceTypesOf(0, CCMotionStreak, reset, , 0);
	setInterfaceTypesOf(1, CCMotionStreak, resumeStroke, , 0);
	setInterfaceTypesOf(2, CCMotionStreak, stopStroke, , 0);
	static inline auto address0 = base+0x2ee190;
	static inline auto address1 = base+0x2edb30;
	static inline auto address2 = base+0x2edb20;

	dupable getFunctionOf(CCMotionStreak, reset, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCMotionStreak, resumeStroke, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCMotionStreak, stopStroke, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	getWrapperOf(CCMotionStreak, reset, , 0) {
		return reinterpret_cast<D*>(this)->D::reset();
	}

	getWrapperOf(CCMotionStreak, resumeStroke, , 0) {
		return reinterpret_cast<D*>(this)->D::resumeStroke();
	}

	getWrapperOf(CCMotionStreak, stopStroke, , 0) {
		return reinterpret_cast<D*>(this)->D::stopStroke();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMotionStreak::reset) != (der0)(&D::reset)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::resetWrapper)));
		}

		if constexpr((mem1)(&$CCMotionStreak::resumeStroke) != (der1)(&D::resumeStroke)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::resumeStrokeWrapper)));
		}

		if constexpr((mem2)(&$CCMotionStreak::stopStroke) != (der2)(&D::stopStroke)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::stopStrokeWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMouseDelegate : CCMouseDelegate, InterfaceBase {
	$CCMouseDelegate(const $CCMouseDelegate& c) : CCMouseDelegate(c) {}
	$CCMouseDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCMouseHandler : CCMouseHandler, InterfaceBase {
	$CCMouseHandler(const $CCMouseHandler& c) : CCMouseHandler(c) {}
	$CCMouseHandler() = delete;
	setInterfaceStaticTypesOf(0, CCMouseHandler, handlerWithDelegate, , 1, cocos2d::CCMouseDelegate*);
	setInterfaceTypesOf(1, CCMouseHandler, initWithDelegate, , 1, cocos2d::CCMouseDelegate*);
	static inline auto address0 = base+0x12ef80;
	static inline auto address1 = base+0x12ef40;
	static inline auto address2 = base+0x12ede0;

	dupable static getFunctionOf(CCMouseHandler, handlerWithDelegate, , 1, cocos2d::CCMouseDelegate*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(CCMouseHandler, initWithDelegate, , 1, cocos2d::CCMouseDelegate*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	static getWrapperOf(CCMouseHandler, handlerWithDelegate, , 1, cocos2d::CCMouseDelegate*) {
		return D::handlerWithDelegate(p0);
	}

	getWrapperOf(CCMouseHandler, initWithDelegate, , 1, cocos2d::CCMouseDelegate*) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMouseHandler::handlerWithDelegate) != (der0)(&D::handlerWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::handlerWithDelegateWrapper)));
		}

		if ((mem1)(&$CCMouseHandler::initWithDelegate) != (der1)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCMouseHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCMoveBy : CCMoveBy, InterfaceBase {
	$CCMoveBy(const $CCMoveBy& c) : CCMoveBy(c) {}
	$CCMoveBy() = delete;
	setInterfaceStaticTypesOf(0, CCMoveBy, create, , 2, float, cocos2d::CCPoint const&);
	static inline auto address0 = base+0x1f50e0;

	dupable static getFunctionOf(CCMoveBy, create, , 2, float, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCMoveBy, create, , 2, float, cocos2d::CCPoint const&) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMoveBy::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMoveTo : CCMoveTo, InterfaceBase {
	$CCMoveTo(const $CCMoveTo& c) : CCMoveTo(c) {}
	$CCMoveTo() = delete;
	setInterfaceStaticTypesOf(0, CCMoveTo, create, , 2, float, cocos2d::CCPoint const&);
	static inline auto address0 = base+0x1f54d0;

	dupable static getFunctionOf(CCMoveTo, create, , 2, float, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCMoveTo, create, , 2, float, cocos2d::CCPoint const&) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMoveTo::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCNode : CCNode, InterfaceBase {
	$CCNode(const $CCNode& c) : CCNode(c) {}
	$CCNode() = delete;
	setInterfaceTypesOf(1, CCNode, _setZOrder, , 1, int);
	setInterfaceTypesOf(2, CCNode, addChild, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(3, CCNode, addChild, , 2, cocos2d::CCNode*, int);
	setInterfaceTypesOf(4, CCNode, addChild, , 3, cocos2d::CCNode*, int, int);
	setInterfaceTypesOf(5, CCNode, addComponent, , 1, cocos2d::CCComponent*);
	setInterfaceTypesOf(6, CCNode, cleanup, , 0);
	setInterfaceTypesOf(7, CCNode, convertToNodeSpace, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(8, CCNode, convertToWorldSpace, , 1, cocos2d::CCPoint const&);
	setInterfaceStaticTypesOf(9, CCNode, create, , 0);
	setInterfaceTypesOf(10, CCNode, draw, , 0);
	setInterfaceTypesOf(11, CCNode, getActionByTag, , 1, int);
	setInterfaceTypesOf(12, CCNode, getActionManager, , 0);
	setInterfaceTypesOf(13, CCNode, getAnchorPoint, , 0);
	setInterfaceTypesOf(14, CCNode, getAnchorPointInPoints, , 0);
	setInterfaceTypesOf(15, CCNode, getCamera, , 0);
	setInterfaceTypesOf(16, CCNode, getChildByTag, , 1, int);
	setInterfaceTypesOf(17, CCNode, getChildren, , 0);
	setInterfaceTypesOf(18, CCNode, getChildrenCount, const, 0);
	setInterfaceTypesOf(19, CCNode, getContentSize, const, 0);
	setInterfaceTypesOf(20, CCNode, getGLServerState, , 0);
	setInterfaceTypesOf(21, CCNode, getGrid, , 0);
	setInterfaceTypesOf(22, CCNode, getOrderOfArrival, , 0);
	setInterfaceTypesOf(23, CCNode, getParent, , 0);
	setInterfaceTypesOf(24, CCNode, getPosition, , 0);
	setInterfaceTypesOf(25, CCNode, getPosition, , 2, float*, float*);
	setInterfaceTypesOf(26, CCNode, getPositionX, , 0);
	setInterfaceTypesOf(27, CCNode, getPositionY, , 0);
	setInterfaceTypesOf(28, CCNode, getRotation, , 0);
	setInterfaceTypesOf(29, CCNode, getRotationX, , 0);
	setInterfaceTypesOf(30, CCNode, getRotationY, , 0);
	setInterfaceTypesOf(31, CCNode, getScale, , 0);
	setInterfaceTypesOf(32, CCNode, getScaleX, , 0);
	setInterfaceTypesOf(33, CCNode, getScaleY, , 0);
	setInterfaceTypesOf(34, CCNode, getScaledContentSize, , 0);
	setInterfaceTypesOf(35, CCNode, getScheduler, , 0);
	setInterfaceTypesOf(36, CCNode, getShaderProgram, , 0);
	setInterfaceTypesOf(37, CCNode, getSkewX, , 0);
	setInterfaceTypesOf(38, CCNode, getSkewY, , 0);
	setInterfaceTypesOf(39, CCNode, getUserData, , 0);
	setInterfaceTypesOf(40, CCNode, getUserObject, , 0);
	setInterfaceTypesOf(41, CCNode, getVertexZ, , 0);
	setInterfaceTypesOf(42, CCNode, getZOrder, , 0);
	setInterfaceTypesOf(43, CCNode, ignoreAnchorPointForPosition, , 1, bool);
	setInterfaceTypesOf(44, CCNode, init, , 0);
	setInterfaceTypesOf(45, CCNode, isIgnoreAnchorPointForPosition, , 0);
	setInterfaceTypesOf(46, CCNode, isRunning, , 0);
	setInterfaceTypesOf(47, CCNode, isVisible, , 0);
	setInterfaceTypesOf(48, CCNode, nodeToParentTransform, , 0);
	setInterfaceTypesOf(49, CCNode, nodeToWorldTransform, , 0);
	setInterfaceTypesOf(50, CCNode, onEnter, , 0);
	setInterfaceTypesOf(51, CCNode, onEnterTransitionDidFinish, , 0);
	setInterfaceTypesOf(52, CCNode, onExit, , 0);
	setInterfaceTypesOf(53, CCNode, onExitTransitionDidStart, , 0);
	setInterfaceTypesOf(54, CCNode, parentToNodeTransform, , 0);
	setInterfaceTypesOf(55, CCNode, pauseSchedulerAndActions, , 0);
	setInterfaceTypesOf(56, CCNode, registerScriptHandler, , 1, int);
	setInterfaceTypesOf(57, CCNode, removeAllChildren, , 0);
	setInterfaceTypesOf(58, CCNode, removeAllChildrenWithCleanup, , 1, bool);
	setInterfaceTypesOf(59, CCNode, removeAllComponents, , 0);
	setInterfaceTypesOf(60, CCNode, removeChild, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(61, CCNode, removeChild, , 2, cocos2d::CCNode*, bool);
	setInterfaceTypesOf(62, CCNode, removeChildByTag, , 1, int);
	setInterfaceTypesOf(63, CCNode, removeChildByTag, , 2, int, bool);
	setInterfaceTypesOf(64, CCNode, removeComponent, , 1, char const*);
	setInterfaceTypesOf(65, CCNode, removeComponent, , 1, cocos2d::CCComponent*);
	setInterfaceTypesOf(66, CCNode, removeFromParent, , 0);
	setInterfaceTypesOf(67, CCNode, removeFromParentAndCleanup, , 1, bool);
	setInterfaceTypesOf(68, CCNode, removeMeAndCleanup, , 0);
	setInterfaceTypesOf(69, CCNode, reorderChild, , 2, cocos2d::CCNode*, int);
	setInterfaceTypesOf(70, CCNode, resumeSchedulerAndActions, , 0);
	setInterfaceTypesOf(71, CCNode, runAction, , 1, cocos2d::CCAction*);
	setInterfaceTypesOf(74, CCNode, scheduleUpdate, , 0);
	setInterfaceTypesOf(75, CCNode, setActionManager, , 1, cocos2d::CCActionManager*);
	setInterfaceTypesOf(76, CCNode, setAnchorPoint, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(77, CCNode, setContentSize, , 1, cocos2d::CCSize const&);
	setInterfaceTypesOf(78, CCNode, setGLServerState, , 1, cocos2d::ccGLServerState);
	setInterfaceTypesOf(79, CCNode, setGrid, , 1, cocos2d::CCGridBase*);
	setInterfaceTypesOf(80, CCNode, setOrderOfArrival, , 1, unsigned int);
	setInterfaceTypesOf(81, CCNode, setParent, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(82, CCNode, setPosition, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(83, CCNode, setPosition, , 2, float, float);
	setInterfaceTypesOf(84, CCNode, setPositionX, , 1, float);
	setInterfaceTypesOf(85, CCNode, setPositionY, , 1, float);
	setInterfaceTypesOf(86, CCNode, setRotation, , 1, float);
	setInterfaceTypesOf(87, CCNode, setRotationX, , 1, float);
	setInterfaceTypesOf(88, CCNode, setRotationY, , 1, float);
	setInterfaceTypesOf(89, CCNode, setScale, , 1, float);
	setInterfaceTypesOf(90, CCNode, setScale, , 2, float, float);
	setInterfaceTypesOf(91, CCNode, setScaleX, , 1, float);
	setInterfaceTypesOf(92, CCNode, setScaleY, , 1, float);
	setInterfaceTypesOf(93, CCNode, setScheduler, , 1, cocos2d::CCScheduler*);
	setInterfaceTypesOf(94, CCNode, setShaderProgram, , 1, cocos2d::CCGLProgram*);
	setInterfaceTypesOf(95, CCNode, setSkewX, , 1, float);
	setInterfaceTypesOf(96, CCNode, setSkewY, , 1, float);
	setInterfaceTypesOf(97, CCNode, setUserData, , 1, void*);
	setInterfaceTypesOf(98, CCNode, setUserObject, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(99, CCNode, setVertexZ, , 1, float);
	setInterfaceTypesOf(100, CCNode, setVisible, , 1, bool);
	setInterfaceTypesOf(101, CCNode, setZOrder, , 1, int);
	setInterfaceTypesOf(102, CCNode, sortAllChildren, , 0);
	setInterfaceTypesOf(103, CCNode, stopActionByTag, , 1, int);
	setInterfaceTypesOf(104, CCNode, stopAllActions, , 0);
	setInterfaceTypesOf(105, CCNode, unregisterScriptHandler, , 0);
	setInterfaceTypesOf(107, CCNode, unscheduleAllSelectors, , 0);
	setInterfaceTypesOf(108, CCNode, unscheduleUpdate, , 0);
	setInterfaceTypesOf(109, CCNode, update, , 1, float);
	setInterfaceTypesOf(110, CCNode, updateTransform, , 0);
	setInterfaceTypesOf(111, CCNode, updateTweenAction, , 2, float, char const*);
	setInterfaceTypesOf(112, CCNode, visit, , 0);
	setInterfaceTypesOf(113, CCNode, worldToNodeTransform, , 0);
	static inline auto address0 = base+0x122550;
	static inline auto address1 = base+0x122990;
	static inline auto address2 = base+0x1233d0;
	static inline auto address3 = base+0x1233b0;
	static inline auto address4 = base+0x1232a0;
	static inline auto address5 = base+0x124a40;
	static inline auto address6 = base+0x123100;
	static inline auto address7 = base+0x124750;
	static inline auto address8 = base+0x124790;
	static inline auto address9 = base+0x1230a0;
	static inline auto address10 = base+0x123840;
	static inline auto address11 = base+0x123ee0;
	static inline auto address12 = base+0x123e50;
	static inline auto address13 = base+0x122d80;
	static inline auto address14 = base+0x122d70;
	static inline auto address15 = base+0x122cb0;
	static inline auto address16 = base+0x123220;
	static inline auto address17 = base+0x122c80;
	static inline auto address18 = base+0x122c90;
	static inline auto address19 = base+0x122e00;
	static inline auto address20 = base+0x122f90;
	static inline auto address21 = base+0x122d00;
	static inline auto address22 = base+0x122f50;
	static inline auto address23 = base+0x122ed0;
	static inline auto address24 = base+0x122b60;
	static inline auto address25 = base+0x122b90;
	static inline auto address26 = base+0x122be0;
	static inline auto address27 = base+0x122bf0;
	static inline auto address28 = base+0x122a00;
	static inline auto address29 = base+0x122a50;
	static inline auto address30 = base+0x122a80;
	static inline auto address31 = base+0x122ab0;
	static inline auto address32 = base+0x122b00;
	static inline auto address33 = base+0x122b30;
	static inline auto address34 = base+0x122e10;
	static inline auto address35 = base+0x123f70;
	static inline auto address36 = base+0x122f70;
	static inline auto address37 = base+0x122920;
	static inline auto address38 = base+0x122950;
	static inline auto address39 = base+0x122f30;
	static inline auto address40 = base+0x122f80;
	static inline auto address41 = base+0x1229e0;
	static inline auto address42 = base+0x122980;
	static inline auto address43 = base+0x122f00;
	static inline auto address44 = base+0x122910;
	static inline auto address45 = base+0x122ef0;
	static inline auto address46 = base+0x122ec0;
	static inline auto address47 = base+0x122d50;
	static inline auto address48 = base+0x124210;
	static inline auto address49 = base+0x124670;
	static inline auto address50 = base+0x123a90;
	static inline auto address51 = base+0x123b90;
	static inline auto address52 = base+0x123ca0;
	static inline auto address53 = base+0x123c00;
	static inline auto address54 = base+0x1245d0;
	static inline auto address55 = base+0x123d60;
	static inline auto address56 = base+0x123d90;
	static inline auto address57 = base+0x123600;
	static inline auto address58 = base+0x123620;
	static inline auto address59 = base+0x124aa0;
	static inline auto address60 = base+0x123460;
	static inline auto address61 = base+0x123480;
	static inline auto address62 = base+0x1235a0;
	static inline auto address63 = base+0x1235c0;
	static inline auto address64 = base+0x124a60;
	static inline auto address65 = base+0x124a80;
	static inline auto address66 = base+0x1233f0;
	static inline auto address67 = base+0x123410;
	static inline auto address68 = base+0x123440;
	static inline auto address69 = base+0x123760;
	static inline auto address70 = base+0x123b60;
	static inline auto address71 = base+0x123e60;
	static inline auto address74 = base+0x123f80;
	static inline auto address75 = base+0x123e00;
	static inline auto address76 = base+0x122d90;
	static inline auto address77 = base+0x122e50;
	static inline auto address78 = base+0x122fa0;
	static inline auto address79 = base+0x122d10;
	static inline auto address80 = base+0x122f60;
	static inline auto address81 = base+0x122ee0;
	static inline auto address82 = base+0x122b70;
	static inline auto address83 = base+0x122ba0;
	static inline auto address84 = base+0x122c00;
	static inline auto address85 = base+0x122c40;
	static inline auto address86 = base+0x122a10;
	static inline auto address87 = base+0x122a60;
	static inline auto address88 = base+0x122a90;
	static inline auto address89 = base+0x122ac0;
	static inline auto address90 = base+0x122ae0;
	static inline auto address91 = base+0x122b10;
	static inline auto address92 = base+0x122b40;
	static inline auto address93 = base+0x123f20;
	static inline auto address94 = base+0x122ff0;
	static inline auto address95 = base+0x122930;
	static inline auto address96 = base+0x122960;
	static inline auto address97 = base+0x122f40;
	static inline auto address98 = base+0x122fb0;
	static inline auto address99 = base+0x1229f0;
	static inline auto address100 = base+0x122d60;
	static inline auto address101 = base+0x1229a0;
	static inline auto address102 = base+0x1237b0;
	static inline auto address103 = base+0x123ec0;
	static inline auto address104 = base+0x123190;
	static inline auto address105 = base+0x123dc0;
	static inline auto address107 = base+0x1231b0;
	static inline auto address108 = base+0x124060;
	static inline auto address109 = base+0x1241a0;
	static inline auto address110 = base+0x1249d0;
	static inline auto address111 = base+0x1249c0;
	static inline auto address112 = base+0x123850;
	static inline auto address113 = base+0x124710;
	static inline auto address114 = base+0x122750;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCNode, _setZOrder, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CCNode, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCNode, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCNode, addComponent, , 1, cocos2d::CCComponent*) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCNode, cleanup, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCNode, convertToNodeSpace, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCNode, convertToWorldSpace, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable static getFunctionOf(CCNode, create, , 0) {
		return reinterpret_cast<fun9>(address9)();
	}

	dupable getFunctionOf(CCNode, draw, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCNode, getActionByTag, , 1, int) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCNode, getActionManager, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCNode, getAnchorPoint, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(CCNode, getAnchorPointInPoints, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(CCNode, getCamera, , 0) {
		return reinterpret_cast<fun15>(address15)(this);
	}

	dupable getFunctionOf(CCNode, getChildByTag, , 1, int) {
		return reinterpret_cast<fun16>(address16)(this, p0);
	}

	dupable getFunctionOf(CCNode, getChildren, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(CCNode, getChildrenCount, const, 0) {
		return reinterpret_cast<fun18>(address18)(this);
	}

	dupable getFunctionOf(CCNode, getContentSize, const, 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(CCNode, getGLServerState, , 0) {
		return reinterpret_cast<fun20>(address20)(this);
	}

	dupable getFunctionOf(CCNode, getGrid, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(CCNode, getOrderOfArrival, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable getFunctionOf(CCNode, getParent, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(CCNode, getPosition, , 0) {
		return reinterpret_cast<fun24>(address24)(this);
	}

	dupable getFunctionOf(CCNode, getPosition, , 2, float*, float*) {
		return reinterpret_cast<fun25>(address25)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, getPositionX, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(CCNode, getPositionY, , 0) {
		return reinterpret_cast<fun27>(address27)(this);
	}

	dupable getFunctionOf(CCNode, getRotation, , 0) {
		return reinterpret_cast<fun28>(address28)(this);
	}

	dupable getFunctionOf(CCNode, getRotationX, , 0) {
		return reinterpret_cast<fun29>(address29)(this);
	}

	dupable getFunctionOf(CCNode, getRotationY, , 0) {
		return reinterpret_cast<fun30>(address30)(this);
	}

	dupable getFunctionOf(CCNode, getScale, , 0) {
		return reinterpret_cast<fun31>(address31)(this);
	}

	dupable getFunctionOf(CCNode, getScaleX, , 0) {
		return reinterpret_cast<fun32>(address32)(this);
	}

	dupable getFunctionOf(CCNode, getScaleY, , 0) {
		return reinterpret_cast<fun33>(address33)(this);
	}

	dupable getFunctionOf(CCNode, getScaledContentSize, , 0) {
		return reinterpret_cast<fun34>(address34)(this);
	}

	dupable getFunctionOf(CCNode, getScheduler, , 0) {
		return reinterpret_cast<fun35>(address35)(this);
	}

	dupable getFunctionOf(CCNode, getShaderProgram, , 0) {
		return reinterpret_cast<fun36>(address36)(this);
	}

	dupable getFunctionOf(CCNode, getSkewX, , 0) {
		return reinterpret_cast<fun37>(address37)(this);
	}

	dupable getFunctionOf(CCNode, getSkewY, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(CCNode, getUserData, , 0) {
		return reinterpret_cast<fun39>(address39)(this);
	}

	dupable getFunctionOf(CCNode, getUserObject, , 0) {
		return reinterpret_cast<fun40>(address40)(this);
	}

	dupable getFunctionOf(CCNode, getVertexZ, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(CCNode, getZOrder, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(CCNode, ignoreAnchorPointForPosition, , 1, bool) {
		return reinterpret_cast<fun43>(address43)(this, p0);
	}

	dupable getFunctionOf(CCNode, init, , 0) {
		return reinterpret_cast<fun44>(address44)(this);
	}

	dupable getFunctionOf(CCNode, isIgnoreAnchorPointForPosition, , 0) {
		return reinterpret_cast<fun45>(address45)(this);
	}

	dupable getFunctionOf(CCNode, isRunning, , 0) {
		return reinterpret_cast<fun46>(address46)(this);
	}

	dupable getFunctionOf(CCNode, isVisible, , 0) {
		return reinterpret_cast<fun47>(address47)(this);
	}

	dupable getFunctionOf(CCNode, nodeToParentTransform, , 0) {
		return reinterpret_cast<fun48>(address48)(this);
	}

	dupable getFunctionOf(CCNode, nodeToWorldTransform, , 0) {
		return reinterpret_cast<fun49>(address49)(this);
	}

	dupable getFunctionOf(CCNode, onEnter, , 0) {
		return reinterpret_cast<fun50>(address50)(this);
	}

	dupable getFunctionOf(CCNode, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<fun51>(address51)(this);
	}

	dupable getFunctionOf(CCNode, onExit, , 0) {
		return reinterpret_cast<fun52>(address52)(this);
	}

	dupable getFunctionOf(CCNode, onExitTransitionDidStart, , 0) {
		return reinterpret_cast<fun53>(address53)(this);
	}

	dupable getFunctionOf(CCNode, parentToNodeTransform, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(CCNode, pauseSchedulerAndActions, , 0) {
		return reinterpret_cast<fun55>(address55)(this);
	}

	dupable getFunctionOf(CCNode, registerScriptHandler, , 1, int) {
		return reinterpret_cast<fun56>(address56)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeAllChildren, , 0) {
		return reinterpret_cast<fun57>(address57)(this);
	}

	dupable getFunctionOf(CCNode, removeAllChildrenWithCleanup, , 1, bool) {
		return reinterpret_cast<fun58>(address58)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeAllComponents, , 0) {
		return reinterpret_cast<fun59>(address59)(this);
	}

	dupable getFunctionOf(CCNode, removeChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun60>(address60)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeChild, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<fun61>(address61)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, removeChildByTag, , 1, int) {
		return reinterpret_cast<fun62>(address62)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeChildByTag, , 2, int, bool) {
		return reinterpret_cast<fun63>(address63)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, removeComponent, , 1, char const*) {
		return reinterpret_cast<fun64>(address64)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeComponent, , 1, cocos2d::CCComponent*) {
		return reinterpret_cast<fun65>(address65)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeFromParent, , 0) {
		return reinterpret_cast<fun66>(address66)(this);
	}

	dupable getFunctionOf(CCNode, removeFromParentAndCleanup, , 1, bool) {
		return reinterpret_cast<fun67>(address67)(this, p0);
	}

	dupable getFunctionOf(CCNode, removeMeAndCleanup, , 0) {
		return reinterpret_cast<fun68>(address68)(this);
	}

	dupable getFunctionOf(CCNode, reorderChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<fun69>(address69)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, resumeSchedulerAndActions, , 0) {
		return reinterpret_cast<fun70>(address70)(this);
	}

	dupable getFunctionOf(CCNode, runAction, , 1, cocos2d::CCAction*) {
		return reinterpret_cast<fun71>(address71)(this, p0);
	}

	dupable getFunctionOf(CCNode, scheduleUpdate, , 0) {
		return reinterpret_cast<fun74>(address74)(this);
	}

	dupable getFunctionOf(CCNode, setActionManager, , 1, cocos2d::CCActionManager*) {
		return reinterpret_cast<fun75>(address75)(this, p0);
	}

	dupable getFunctionOf(CCNode, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun76>(address76)(this, p0);
	}

	dupable getFunctionOf(CCNode, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<fun77>(address77)(this, p0);
	}

	dupable getFunctionOf(CCNode, setGLServerState, , 1, cocos2d::ccGLServerState) {
		return reinterpret_cast<fun78>(address78)(this, p0);
	}

	dupable getFunctionOf(CCNode, setGrid, , 1, cocos2d::CCGridBase*) {
		return reinterpret_cast<fun79>(address79)(this, p0);
	}

	dupable getFunctionOf(CCNode, setOrderOfArrival, , 1, unsigned int) {
		return reinterpret_cast<fun80>(address80)(this, p0);
	}

	dupable getFunctionOf(CCNode, setParent, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun81>(address81)(this, p0);
	}

	dupable getFunctionOf(CCNode, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun82>(address82)(this, p0);
	}

	dupable getFunctionOf(CCNode, setPosition, , 2, float, float) {
		return reinterpret_cast<fun83>(address83)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, setPositionX, , 1, float) {
		return reinterpret_cast<fun84>(address84)(this, p0);
	}

	dupable getFunctionOf(CCNode, setPositionY, , 1, float) {
		return reinterpret_cast<fun85>(address85)(this, p0);
	}

	dupable getFunctionOf(CCNode, setRotation, , 1, float) {
		return reinterpret_cast<fun86>(address86)(this, p0);
	}

	dupable getFunctionOf(CCNode, setRotationX, , 1, float) {
		return reinterpret_cast<fun87>(address87)(this, p0);
	}

	dupable getFunctionOf(CCNode, setRotationY, , 1, float) {
		return reinterpret_cast<fun88>(address88)(this, p0);
	}

	dupable getFunctionOf(CCNode, setScale, , 1, float) {
		return reinterpret_cast<fun89>(address89)(this, p0);
	}

	dupable getFunctionOf(CCNode, setScale, , 2, float, float) {
		return reinterpret_cast<fun90>(address90)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, setScaleX, , 1, float) {
		return reinterpret_cast<fun91>(address91)(this, p0);
	}

	dupable getFunctionOf(CCNode, setScaleY, , 1, float) {
		return reinterpret_cast<fun92>(address92)(this, p0);
	}

	dupable getFunctionOf(CCNode, setScheduler, , 1, cocos2d::CCScheduler*) {
		return reinterpret_cast<fun93>(address93)(this, p0);
	}

	dupable getFunctionOf(CCNode, setShaderProgram, , 1, cocos2d::CCGLProgram*) {
		return reinterpret_cast<fun94>(address94)(this, p0);
	}

	dupable getFunctionOf(CCNode, setSkewX, , 1, float) {
		return reinterpret_cast<fun95>(address95)(this, p0);
	}

	dupable getFunctionOf(CCNode, setSkewY, , 1, float) {
		return reinterpret_cast<fun96>(address96)(this, p0);
	}

	dupable getFunctionOf(CCNode, setUserData, , 1, void*) {
		return reinterpret_cast<fun97>(address97)(this, p0);
	}

	dupable getFunctionOf(CCNode, setUserObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun98>(address98)(this, p0);
	}

	dupable getFunctionOf(CCNode, setVertexZ, , 1, float) {
		return reinterpret_cast<fun99>(address99)(this, p0);
	}

	dupable getFunctionOf(CCNode, setVisible, , 1, bool) {
		return reinterpret_cast<fun100>(address100)(this, p0);
	}

	dupable getFunctionOf(CCNode, setZOrder, , 1, int) {
		return reinterpret_cast<fun101>(address101)(this, p0);
	}

	dupable getFunctionOf(CCNode, sortAllChildren, , 0) {
		return reinterpret_cast<fun102>(address102)(this);
	}

	dupable getFunctionOf(CCNode, stopActionByTag, , 1, int) {
		return reinterpret_cast<fun103>(address103)(this, p0);
	}

	dupable getFunctionOf(CCNode, stopAllActions, , 0) {
		return reinterpret_cast<fun104>(address104)(this);
	}

	dupable getFunctionOf(CCNode, unregisterScriptHandler, , 0) {
		return reinterpret_cast<fun105>(address105)(this);
	}

	dupable getFunctionOf(CCNode, unscheduleAllSelectors, , 0) {
		return reinterpret_cast<fun107>(address107)(this);
	}

	dupable getFunctionOf(CCNode, unscheduleUpdate, , 0) {
		return reinterpret_cast<fun108>(address108)(this);
	}

	dupable getFunctionOf(CCNode, update, , 1, float) {
		return reinterpret_cast<fun109>(address109)(this, p0);
	}

	dupable getFunctionOf(CCNode, updateTransform, , 0) {
		return reinterpret_cast<fun110>(address110)(this);
	}

	dupable getFunctionOf(CCNode, updateTweenAction, , 2, float, char const*) {
		return reinterpret_cast<fun111>(address111)(this, p0, p1);
	}

	dupable getFunctionOf(CCNode, visit, , 0) {
		return reinterpret_cast<fun112>(address112)(this);
	}

	dupable getFunctionOf(CCNode, worldToNodeTransform, , 0) {
		return reinterpret_cast<fun113>(address113)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address114)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCNode, _setZOrder, , 1, int) {
		return reinterpret_cast<D*>(this)->D::_setZOrder(p0);
	}

	getWrapperOf(CCNode, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::addChild(p0);
	}

	getWrapperOf(CCNode, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1);
	}

	getWrapperOf(CCNode, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1, p2);
	}

	getWrapperOf(CCNode, addComponent, , 1, cocos2d::CCComponent*) {
		return reinterpret_cast<D*>(this)->D::addComponent(p0);
	}

	getWrapperOf(CCNode, cleanup, , 0) {
		return reinterpret_cast<D*>(this)->D::cleanup();
	}

	getWrapperOf(CCNode, convertToNodeSpace, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::convertToNodeSpace(p0);
	}

	getWrapperOf(CCNode, convertToWorldSpace, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::convertToWorldSpace(p0);
	}

	static getWrapperOf(CCNode, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCNode, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(CCNode, getActionByTag, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getActionByTag(p0);
	}

	getWrapperOf(CCNode, getActionManager, , 0) {
		return reinterpret_cast<D*>(this)->D::getActionManager();
	}

	getWrapperOf(CCNode, getAnchorPoint, , 0) {
		return reinterpret_cast<D*>(this)->D::getAnchorPoint();
	}

	getWrapperOf(CCNode, getAnchorPointInPoints, , 0) {
		return reinterpret_cast<D*>(this)->D::getAnchorPointInPoints();
	}

	getWrapperOf(CCNode, getCamera, , 0) {
		return reinterpret_cast<D*>(this)->D::getCamera();
	}

	getWrapperOf(CCNode, getChildByTag, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getChildByTag(p0);
	}

	getWrapperOf(CCNode, getChildren, , 0) {
		return reinterpret_cast<D*>(this)->D::getChildren();
	}

	getWrapperOf(CCNode, getChildrenCount, const, 0) {
		return reinterpret_cast<D*>(this)->D::getChildrenCount();
	}

	getWrapperOf(CCNode, getContentSize, const, 0) {
		return reinterpret_cast<D*>(this)->D::getContentSize();
	}

	getWrapperOf(CCNode, getGLServerState, , 0) {
		return reinterpret_cast<D*>(this)->D::getGLServerState();
	}

	getWrapperOf(CCNode, getGrid, , 0) {
		return reinterpret_cast<D*>(this)->D::getGrid();
	}

	getWrapperOf(CCNode, getOrderOfArrival, , 0) {
		return reinterpret_cast<D*>(this)->D::getOrderOfArrival();
	}

	getWrapperOf(CCNode, getParent, , 0) {
		return reinterpret_cast<D*>(this)->D::getParent();
	}

	getWrapperOf(CCNode, getPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::getPosition();
	}

	getWrapperOf(CCNode, getPosition, , 2, float*, float*) {
		return reinterpret_cast<D*>(this)->D::getPosition(p0, p1);
	}

	getWrapperOf(CCNode, getPositionX, , 0) {
		return reinterpret_cast<D*>(this)->D::getPositionX();
	}

	getWrapperOf(CCNode, getPositionY, , 0) {
		return reinterpret_cast<D*>(this)->D::getPositionY();
	}

	getWrapperOf(CCNode, getRotation, , 0) {
		return reinterpret_cast<D*>(this)->D::getRotation();
	}

	getWrapperOf(CCNode, getRotationX, , 0) {
		return reinterpret_cast<D*>(this)->D::getRotationX();
	}

	getWrapperOf(CCNode, getRotationY, , 0) {
		return reinterpret_cast<D*>(this)->D::getRotationY();
	}

	getWrapperOf(CCNode, getScale, , 0) {
		return reinterpret_cast<D*>(this)->D::getScale();
	}

	getWrapperOf(CCNode, getScaleX, , 0) {
		return reinterpret_cast<D*>(this)->D::getScaleX();
	}

	getWrapperOf(CCNode, getScaleY, , 0) {
		return reinterpret_cast<D*>(this)->D::getScaleY();
	}

	getWrapperOf(CCNode, getScaledContentSize, , 0) {
		return reinterpret_cast<D*>(this)->D::getScaledContentSize();
	}

	getWrapperOf(CCNode, getScheduler, , 0) {
		return reinterpret_cast<D*>(this)->D::getScheduler();
	}

	getWrapperOf(CCNode, getShaderProgram, , 0) {
		return reinterpret_cast<D*>(this)->D::getShaderProgram();
	}

	getWrapperOf(CCNode, getSkewX, , 0) {
		return reinterpret_cast<D*>(this)->D::getSkewX();
	}

	getWrapperOf(CCNode, getSkewY, , 0) {
		return reinterpret_cast<D*>(this)->D::getSkewY();
	}

	getWrapperOf(CCNode, getUserData, , 0) {
		return reinterpret_cast<D*>(this)->D::getUserData();
	}

	getWrapperOf(CCNode, getUserObject, , 0) {
		return reinterpret_cast<D*>(this)->D::getUserObject();
	}

	getWrapperOf(CCNode, getVertexZ, , 0) {
		return reinterpret_cast<D*>(this)->D::getVertexZ();
	}

	getWrapperOf(CCNode, getZOrder, , 0) {
		return reinterpret_cast<D*>(this)->D::getZOrder();
	}

	getWrapperOf(CCNode, ignoreAnchorPointForPosition, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::ignoreAnchorPointForPosition(p0);
	}

	getWrapperOf(CCNode, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCNode, isIgnoreAnchorPointForPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::isIgnoreAnchorPointForPosition();
	}

	getWrapperOf(CCNode, isRunning, , 0) {
		return reinterpret_cast<D*>(this)->D::isRunning();
	}

	getWrapperOf(CCNode, isVisible, , 0) {
		return reinterpret_cast<D*>(this)->D::isVisible();
	}

	getWrapperOf(CCNode, nodeToParentTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::nodeToParentTransform();
	}

	getWrapperOf(CCNode, nodeToWorldTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::nodeToWorldTransform();
	}

	getWrapperOf(CCNode, onEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnter();
	}

	getWrapperOf(CCNode, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnterTransitionDidFinish();
	}

	getWrapperOf(CCNode, onExit, , 0) {
		return reinterpret_cast<D*>(this)->D::onExit();
	}

	getWrapperOf(CCNode, onExitTransitionDidStart, , 0) {
		return reinterpret_cast<D*>(this)->D::onExitTransitionDidStart();
	}

	getWrapperOf(CCNode, parentToNodeTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::parentToNodeTransform();
	}

	getWrapperOf(CCNode, pauseSchedulerAndActions, , 0) {
		return reinterpret_cast<D*>(this)->D::pauseSchedulerAndActions();
	}

	getWrapperOf(CCNode, registerScriptHandler, , 1, int) {
		return reinterpret_cast<D*>(this)->D::registerScriptHandler(p0);
	}

	getWrapperOf(CCNode, removeAllChildren, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllChildren();
	}

	getWrapperOf(CCNode, removeAllChildrenWithCleanup, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::removeAllChildrenWithCleanup(p0);
	}

	getWrapperOf(CCNode, removeAllComponents, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllComponents();
	}

	getWrapperOf(CCNode, removeChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::removeChild(p0);
	}

	getWrapperOf(CCNode, removeChild, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<D*>(this)->D::removeChild(p0, p1);
	}

	getWrapperOf(CCNode, removeChildByTag, , 1, int) {
		return reinterpret_cast<D*>(this)->D::removeChildByTag(p0);
	}

	getWrapperOf(CCNode, removeChildByTag, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::removeChildByTag(p0, p1);
	}

	getWrapperOf(CCNode, removeComponent, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::removeComponent(p0);
	}

	getWrapperOf(CCNode, removeComponent, , 1, cocos2d::CCComponent*) {
		return reinterpret_cast<D*>(this)->D::removeComponent(p0);
	}

	getWrapperOf(CCNode, removeFromParent, , 0) {
		return reinterpret_cast<D*>(this)->D::removeFromParent();
	}

	getWrapperOf(CCNode, removeFromParentAndCleanup, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::removeFromParentAndCleanup(p0);
	}

	getWrapperOf(CCNode, removeMeAndCleanup, , 0) {
		return reinterpret_cast<D*>(this)->D::removeMeAndCleanup();
	}

	getWrapperOf(CCNode, reorderChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<D*>(this)->D::reorderChild(p0, p1);
	}

	getWrapperOf(CCNode, resumeSchedulerAndActions, , 0) {
		return reinterpret_cast<D*>(this)->D::resumeSchedulerAndActions();
	}

	getWrapperOf(CCNode, runAction, , 1, cocos2d::CCAction*) {
		return reinterpret_cast<D*>(this)->D::runAction(p0);
	}

	getWrapperOf(CCNode, scheduleUpdate, , 0) {
		return reinterpret_cast<D*>(this)->D::scheduleUpdate();
	}

	getWrapperOf(CCNode, setActionManager, , 1, cocos2d::CCActionManager*) {
		return reinterpret_cast<D*>(this)->D::setActionManager(p0);
	}

	getWrapperOf(CCNode, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setAnchorPoint(p0);
	}

	getWrapperOf(CCNode, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::setContentSize(p0);
	}

	getWrapperOf(CCNode, setGLServerState, , 1, cocos2d::ccGLServerState) {
		return reinterpret_cast<D*>(this)->D::setGLServerState(p0);
	}

	getWrapperOf(CCNode, setGrid, , 1, cocos2d::CCGridBase*) {
		return reinterpret_cast<D*>(this)->D::setGrid(p0);
	}

	getWrapperOf(CCNode, setOrderOfArrival, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::setOrderOfArrival(p0);
	}

	getWrapperOf(CCNode, setParent, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::setParent(p0);
	}

	getWrapperOf(CCNode, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setPosition(p0);
	}

	getWrapperOf(CCNode, setPosition, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::setPosition(p0, p1);
	}

	getWrapperOf(CCNode, setPositionX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setPositionX(p0);
	}

	getWrapperOf(CCNode, setPositionY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setPositionY(p0);
	}

	getWrapperOf(CCNode, setRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotation(p0);
	}

	getWrapperOf(CCNode, setRotationX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotationX(p0);
	}

	getWrapperOf(CCNode, setRotationY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotationY(p0);
	}

	getWrapperOf(CCNode, setScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0);
	}

	getWrapperOf(CCNode, setScale, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0, p1);
	}

	getWrapperOf(CCNode, setScaleX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleX(p0);
	}

	getWrapperOf(CCNode, setScaleY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleY(p0);
	}

	getWrapperOf(CCNode, setScheduler, , 1, cocos2d::CCScheduler*) {
		return reinterpret_cast<D*>(this)->D::setScheduler(p0);
	}

	getWrapperOf(CCNode, setShaderProgram, , 1, cocos2d::CCGLProgram*) {
		return reinterpret_cast<D*>(this)->D::setShaderProgram(p0);
	}

	getWrapperOf(CCNode, setSkewX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSkewX(p0);
	}

	getWrapperOf(CCNode, setSkewY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSkewY(p0);
	}

	getWrapperOf(CCNode, setUserData, , 1, void*) {
		return reinterpret_cast<D*>(this)->D::setUserData(p0);
	}

	getWrapperOf(CCNode, setUserObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::setUserObject(p0);
	}

	getWrapperOf(CCNode, setVertexZ, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setVertexZ(p0);
	}

	getWrapperOf(CCNode, setVisible, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setVisible(p0);
	}

	getWrapperOf(CCNode, setZOrder, , 1, int) {
		return reinterpret_cast<D*>(this)->D::setZOrder(p0);
	}

	getWrapperOf(CCNode, sortAllChildren, , 0) {
		return reinterpret_cast<D*>(this)->D::sortAllChildren();
	}

	getWrapperOf(CCNode, stopActionByTag, , 1, int) {
		return reinterpret_cast<D*>(this)->D::stopActionByTag(p0);
	}

	getWrapperOf(CCNode, stopAllActions, , 0) {
		return reinterpret_cast<D*>(this)->D::stopAllActions();
	}

	getWrapperOf(CCNode, unregisterScriptHandler, , 0) {
		return reinterpret_cast<D*>(this)->D::unregisterScriptHandler();
	}

	getWrapperOf(CCNode, unscheduleAllSelectors, , 0) {
		return reinterpret_cast<D*>(this)->D::unscheduleAllSelectors();
	}

	getWrapperOf(CCNode, unscheduleUpdate, , 0) {
		return reinterpret_cast<D*>(this)->D::unscheduleUpdate();
	}

	getWrapperOf(CCNode, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

	getWrapperOf(CCNode, updateTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTransform();
	}

	getWrapperOf(CCNode, updateTweenAction, , 2, float, char const*) {
		return reinterpret_cast<D*>(this)->D::updateTweenAction(p0, p1);
	}

	getWrapperOf(CCNode, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(CCNode, worldToNodeTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::worldToNodeTransform();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCNode::_setZOrder) != (der1)(&D::_setZOrder)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::_setZOrderWrapper)));
		}

		if constexpr((mem2)(&$CCNode::addChild) != (der2)(&D::addChild)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::addChildWrapper)));
		}

		if constexpr((mem3)(&$CCNode::addChild) != (der3)(&D::addChild)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::addChildWrapper)));
		}

		if constexpr((mem4)(&$CCNode::addChild) != (der4)(&D::addChild)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::addChildWrapper)));
		}

		if constexpr((mem5)(&$CCNode::addComponent) != (der5)(&D::addComponent)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::addComponentWrapper)));
		}

		if constexpr((mem6)(&$CCNode::cleanup) != (der6)(&D::cleanup)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::cleanupWrapper)));
		}

		if constexpr((mem7)(&$CCNode::convertToNodeSpace) != (der7)(&D::convertToNodeSpace)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::convertToNodeSpaceWrapper)));
		}

		if constexpr((mem8)(&$CCNode::convertToWorldSpace) != (der8)(&D::convertToWorldSpace)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::convertToWorldSpaceWrapper)));
		}

		if constexpr((mem9)(&$CCNode::create) != (der9)(&D::create)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::createWrapper)));
		}

		if constexpr((mem10)(&$CCNode::draw) != (der10)(&D::draw)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::drawWrapper)));
		}

		if constexpr((mem11)(&$CCNode::getActionByTag) != (der11)(&D::getActionByTag)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::getActionByTagWrapper)));
		}

		if constexpr((mem12)(&$CCNode::getActionManager) != (der12)(&D::getActionManager)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::getActionManagerWrapper)));
		}

		if constexpr((mem13)(&$CCNode::getAnchorPoint) != (der13)(&D::getAnchorPoint)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::getAnchorPointWrapper)));
		}

		if constexpr((mem14)(&$CCNode::getAnchorPointInPoints) != (der14)(&D::getAnchorPointInPoints)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::getAnchorPointInPointsWrapper)));
		}

		if constexpr((mem15)(&$CCNode::getCamera) != (der15)(&D::getCamera)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::getCameraWrapper)));
		}

		if constexpr((mem16)(&$CCNode::getChildByTag) != (der16)(&D::getChildByTag)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::getChildByTagWrapper)));
		}

		if constexpr((mem17)(&$CCNode::getChildren) != (der17)(&D::getChildren)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::getChildrenWrapper)));
		}

		if constexpr((mem18)(&$CCNode::getChildrenCount) != (der18)(&D::getChildrenCount)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::getChildrenCountWrapper)));
		}

		if constexpr((mem19)(&$CCNode::getContentSize) != (der19)(&D::getContentSize)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::getContentSizeWrapper)));
		}

		if constexpr((mem20)(&$CCNode::getGLServerState) != (der20)(&D::getGLServerState)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::getGLServerStateWrapper)));
		}

		if constexpr((mem21)(&$CCNode::getGrid) != (der21)(&D::getGrid)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::getGridWrapper)));
		}

		if constexpr((mem22)(&$CCNode::getOrderOfArrival) != (der22)(&D::getOrderOfArrival)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::getOrderOfArrivalWrapper)));
		}

		if constexpr((mem23)(&$CCNode::getParent) != (der23)(&D::getParent)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::getParentWrapper)));
		}

		if constexpr((mem24)(&$CCNode::getPosition) != (der24)(&D::getPosition)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::getPositionWrapper)));
		}

		if constexpr((mem25)(&$CCNode::getPosition) != (der25)(&D::getPosition)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::getPositionWrapper)));
		}

		if constexpr((mem26)(&$CCNode::getPositionX) != (der26)(&D::getPositionX)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::getPositionXWrapper)));
		}

		if constexpr((mem27)(&$CCNode::getPositionY) != (der27)(&D::getPositionY)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::getPositionYWrapper)));
		}

		if constexpr((mem28)(&$CCNode::getRotation) != (der28)(&D::getRotation)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::getRotationWrapper)));
		}

		if constexpr((mem29)(&$CCNode::getRotationX) != (der29)(&D::getRotationX)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::getRotationXWrapper)));
		}

		if constexpr((mem30)(&$CCNode::getRotationY) != (der30)(&D::getRotationY)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::getRotationYWrapper)));
		}

		if constexpr((mem31)(&$CCNode::getScale) != (der31)(&D::getScale)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::getScaleWrapper)));
		}

		if constexpr((mem32)(&$CCNode::getScaleX) != (der32)(&D::getScaleX)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::getScaleXWrapper)));
		}

		if constexpr((mem33)(&$CCNode::getScaleY) != (der33)(&D::getScaleY)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::getScaleYWrapper)));
		}

		if constexpr((mem34)(&$CCNode::getScaledContentSize) != (der34)(&D::getScaledContentSize)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::getScaledContentSizeWrapper)));
		}

		if constexpr((mem35)(&$CCNode::getScheduler) != (der35)(&D::getScheduler)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::getSchedulerWrapper)));
		}

		if constexpr((mem36)(&$CCNode::getShaderProgram) != (der36)(&D::getShaderProgram)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual((der36)(&D::getShaderProgramWrapper)));
		}

		if constexpr((mem37)(&$CCNode::getSkewX) != (der37)(&D::getSkewX)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::getSkewXWrapper)));
		}

		if constexpr((mem38)(&$CCNode::getSkewY) != (der38)(&D::getSkewY)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::getSkewYWrapper)));
		}

		if constexpr((mem39)(&$CCNode::getUserData) != (der39)(&D::getUserData)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::getUserDataWrapper)));
		}

		if constexpr((mem40)(&$CCNode::getUserObject) != (der40)(&D::getUserObject)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::getUserObjectWrapper)));
		}

		if constexpr((mem41)(&$CCNode::getVertexZ) != (der41)(&D::getVertexZ)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::getVertexZWrapper)));
		}

		if constexpr((mem42)(&$CCNode::getZOrder) != (der42)(&D::getZOrder)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::getZOrderWrapper)));
		}

		if constexpr((mem43)(&$CCNode::ignoreAnchorPointForPosition) != (der43)(&D::ignoreAnchorPointForPosition)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::ignoreAnchorPointForPositionWrapper)));
		}

		if constexpr((mem44)(&$CCNode::init) != (der44)(&D::init)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::initWrapper)));
		}

		if constexpr((mem45)(&$CCNode::isIgnoreAnchorPointForPosition) != (der45)(&D::isIgnoreAnchorPointForPosition)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::isIgnoreAnchorPointForPositionWrapper)));
		}

		if constexpr((mem46)(&$CCNode::isRunning) != (der46)(&D::isRunning)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::isRunningWrapper)));
		}

		if constexpr((mem47)(&$CCNode::isVisible) != (der47)(&D::isVisible)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::isVisibleWrapper)));
		}

		if constexpr((mem48)(&$CCNode::nodeToParentTransform) != (der48)(&D::nodeToParentTransform)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::nodeToParentTransformWrapper)));
		}

		if constexpr((mem49)(&$CCNode::nodeToWorldTransform) != (der49)(&D::nodeToWorldTransform)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::nodeToWorldTransformWrapper)));
		}

		if constexpr((mem50)(&$CCNode::onEnter) != (der50)(&D::onEnter)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::onEnterWrapper)));
		}

		if constexpr((mem51)(&$CCNode::onEnterTransitionDidFinish) != (der51)(&D::onEnterTransitionDidFinish)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::onEnterTransitionDidFinishWrapper)));
		}

		if constexpr((mem52)(&$CCNode::onExit) != (der52)(&D::onExit)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::onExitWrapper)));
		}

		if constexpr((mem53)(&$CCNode::onExitTransitionDidStart) != (der53)(&D::onExitTransitionDidStart)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::onExitTransitionDidStartWrapper)));
		}

		if constexpr((mem54)(&$CCNode::parentToNodeTransform) != (der54)(&D::parentToNodeTransform)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::parentToNodeTransformWrapper)));
		}

		if constexpr((mem55)(&$CCNode::pauseSchedulerAndActions) != (der55)(&D::pauseSchedulerAndActions)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::pauseSchedulerAndActionsWrapper)));
		}

		if constexpr((mem56)(&$CCNode::registerScriptHandler) != (der56)(&D::registerScriptHandler)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::registerScriptHandlerWrapper)));
		}

		if constexpr((mem57)(&$CCNode::removeAllChildren) != (der57)(&D::removeAllChildren)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::removeAllChildrenWrapper)));
		}

		if constexpr((mem58)(&$CCNode::removeAllChildrenWithCleanup) != (der58)(&D::removeAllChildrenWithCleanup)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::removeAllChildrenWithCleanupWrapper)));
		}

		if constexpr((mem59)(&$CCNode::removeAllComponents) != (der59)(&D::removeAllComponents)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::removeAllComponentsWrapper)));
		}

		if constexpr((mem60)(&$CCNode::removeChild) != (der60)(&D::removeChild)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::removeChildWrapper)));
		}

		if constexpr((mem61)(&$CCNode::removeChild) != (der61)(&D::removeChild)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::removeChildWrapper)));
		}

		if constexpr((mem62)(&$CCNode::removeChildByTag) != (der62)(&D::removeChildByTag)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::removeChildByTagWrapper)));
		}

		if constexpr((mem63)(&$CCNode::removeChildByTag) != (der63)(&D::removeChildByTag)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::removeChildByTagWrapper)));
		}

		if constexpr((mem64)(&$CCNode::removeComponent) != (der64)(&D::removeComponent)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::removeComponentWrapper)));
		}

		if constexpr((mem65)(&$CCNode::removeComponent) != (der65)(&D::removeComponent)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::removeComponentWrapper)));
		}

		if constexpr((mem66)(&$CCNode::removeFromParent) != (der66)(&D::removeFromParent)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::removeFromParentWrapper)));
		}

		if constexpr((mem67)(&$CCNode::removeFromParentAndCleanup) != (der67)(&D::removeFromParentAndCleanup)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::removeFromParentAndCleanupWrapper)));
		}

		if constexpr((mem68)(&$CCNode::removeMeAndCleanup) != (der68)(&D::removeMeAndCleanup)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::removeMeAndCleanupWrapper)));
		}

		if constexpr((mem69)(&$CCNode::reorderChild) != (der69)(&D::reorderChild)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::reorderChildWrapper)));
		}

		if constexpr((mem70)(&$CCNode::resumeSchedulerAndActions) != (der70)(&D::resumeSchedulerAndActions)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::resumeSchedulerAndActionsWrapper)));
		}

		if constexpr((mem71)(&$CCNode::runAction) != (der71)(&D::runAction)) {
			modContainer.registerHookEnable(address71, FunctionScrapper::addressOfNonVirtual((der71)(&D::runActionWrapper)));
		}

		if constexpr((mem74)(&$CCNode::scheduleUpdate) != (der74)(&D::scheduleUpdate)) {
			modContainer.registerHookEnable(address74, FunctionScrapper::addressOfNonVirtual((der74)(&D::scheduleUpdateWrapper)));
		}

		if constexpr((mem75)(&$CCNode::setActionManager) != (der75)(&D::setActionManager)) {
			modContainer.registerHookEnable(address75, FunctionScrapper::addressOfNonVirtual((der75)(&D::setActionManagerWrapper)));
		}

		if constexpr((mem76)(&$CCNode::setAnchorPoint) != (der76)(&D::setAnchorPoint)) {
			modContainer.registerHookEnable(address76, FunctionScrapper::addressOfNonVirtual((der76)(&D::setAnchorPointWrapper)));
		}

		if constexpr((mem77)(&$CCNode::setContentSize) != (der77)(&D::setContentSize)) {
			modContainer.registerHookEnable(address77, FunctionScrapper::addressOfNonVirtual((der77)(&D::setContentSizeWrapper)));
		}

		if constexpr((mem78)(&$CCNode::setGLServerState) != (der78)(&D::setGLServerState)) {
			modContainer.registerHookEnable(address78, FunctionScrapper::addressOfNonVirtual((der78)(&D::setGLServerStateWrapper)));
		}

		if constexpr((mem79)(&$CCNode::setGrid) != (der79)(&D::setGrid)) {
			modContainer.registerHookEnable(address79, FunctionScrapper::addressOfNonVirtual((der79)(&D::setGridWrapper)));
		}

		if constexpr((mem80)(&$CCNode::setOrderOfArrival) != (der80)(&D::setOrderOfArrival)) {
			modContainer.registerHookEnable(address80, FunctionScrapper::addressOfNonVirtual((der80)(&D::setOrderOfArrivalWrapper)));
		}

		if constexpr((mem81)(&$CCNode::setParent) != (der81)(&D::setParent)) {
			modContainer.registerHookEnable(address81, FunctionScrapper::addressOfNonVirtual((der81)(&D::setParentWrapper)));
		}

		if constexpr((mem82)(&$CCNode::setPosition) != (der82)(&D::setPosition)) {
			modContainer.registerHookEnable(address82, FunctionScrapper::addressOfNonVirtual((der82)(&D::setPositionWrapper)));
		}

		if constexpr((mem83)(&$CCNode::setPosition) != (der83)(&D::setPosition)) {
			modContainer.registerHookEnable(address83, FunctionScrapper::addressOfNonVirtual((der83)(&D::setPositionWrapper)));
		}

		if constexpr((mem84)(&$CCNode::setPositionX) != (der84)(&D::setPositionX)) {
			modContainer.registerHookEnable(address84, FunctionScrapper::addressOfNonVirtual((der84)(&D::setPositionXWrapper)));
		}

		if constexpr((mem85)(&$CCNode::setPositionY) != (der85)(&D::setPositionY)) {
			modContainer.registerHookEnable(address85, FunctionScrapper::addressOfNonVirtual((der85)(&D::setPositionYWrapper)));
		}

		if constexpr((mem86)(&$CCNode::setRotation) != (der86)(&D::setRotation)) {
			modContainer.registerHookEnable(address86, FunctionScrapper::addressOfNonVirtual((der86)(&D::setRotationWrapper)));
		}

		if constexpr((mem87)(&$CCNode::setRotationX) != (der87)(&D::setRotationX)) {
			modContainer.registerHookEnable(address87, FunctionScrapper::addressOfNonVirtual((der87)(&D::setRotationXWrapper)));
		}

		if constexpr((mem88)(&$CCNode::setRotationY) != (der88)(&D::setRotationY)) {
			modContainer.registerHookEnable(address88, FunctionScrapper::addressOfNonVirtual((der88)(&D::setRotationYWrapper)));
		}

		if constexpr((mem89)(&$CCNode::setScale) != (der89)(&D::setScale)) {
			modContainer.registerHookEnable(address89, FunctionScrapper::addressOfNonVirtual((der89)(&D::setScaleWrapper)));
		}

		if constexpr((mem90)(&$CCNode::setScale) != (der90)(&D::setScale)) {
			modContainer.registerHookEnable(address90, FunctionScrapper::addressOfNonVirtual((der90)(&D::setScaleWrapper)));
		}

		if constexpr((mem91)(&$CCNode::setScaleX) != (der91)(&D::setScaleX)) {
			modContainer.registerHookEnable(address91, FunctionScrapper::addressOfNonVirtual((der91)(&D::setScaleXWrapper)));
		}

		if constexpr((mem92)(&$CCNode::setScaleY) != (der92)(&D::setScaleY)) {
			modContainer.registerHookEnable(address92, FunctionScrapper::addressOfNonVirtual((der92)(&D::setScaleYWrapper)));
		}

		if constexpr((mem93)(&$CCNode::setScheduler) != (der93)(&D::setScheduler)) {
			modContainer.registerHookEnable(address93, FunctionScrapper::addressOfNonVirtual((der93)(&D::setSchedulerWrapper)));
		}

		if constexpr((mem94)(&$CCNode::setShaderProgram) != (der94)(&D::setShaderProgram)) {
			modContainer.registerHookEnable(address94, FunctionScrapper::addressOfNonVirtual((der94)(&D::setShaderProgramWrapper)));
		}

		if constexpr((mem95)(&$CCNode::setSkewX) != (der95)(&D::setSkewX)) {
			modContainer.registerHookEnable(address95, FunctionScrapper::addressOfNonVirtual((der95)(&D::setSkewXWrapper)));
		}

		if constexpr((mem96)(&$CCNode::setSkewY) != (der96)(&D::setSkewY)) {
			modContainer.registerHookEnable(address96, FunctionScrapper::addressOfNonVirtual((der96)(&D::setSkewYWrapper)));
		}

		if constexpr((mem97)(&$CCNode::setUserData) != (der97)(&D::setUserData)) {
			modContainer.registerHookEnable(address97, FunctionScrapper::addressOfNonVirtual((der97)(&D::setUserDataWrapper)));
		}

		if constexpr((mem98)(&$CCNode::setUserObject) != (der98)(&D::setUserObject)) {
			modContainer.registerHookEnable(address98, FunctionScrapper::addressOfNonVirtual((der98)(&D::setUserObjectWrapper)));
		}

		if constexpr((mem99)(&$CCNode::setVertexZ) != (der99)(&D::setVertexZ)) {
			modContainer.registerHookEnable(address99, FunctionScrapper::addressOfNonVirtual((der99)(&D::setVertexZWrapper)));
		}

		if constexpr((mem100)(&$CCNode::setVisible) != (der100)(&D::setVisible)) {
			modContainer.registerHookEnable(address100, FunctionScrapper::addressOfNonVirtual((der100)(&D::setVisibleWrapper)));
		}

		if constexpr((mem101)(&$CCNode::setZOrder) != (der101)(&D::setZOrder)) {
			modContainer.registerHookEnable(address101, FunctionScrapper::addressOfNonVirtual((der101)(&D::setZOrderWrapper)));
		}

		if constexpr((mem102)(&$CCNode::sortAllChildren) != (der102)(&D::sortAllChildren)) {
			modContainer.registerHookEnable(address102, FunctionScrapper::addressOfNonVirtual((der102)(&D::sortAllChildrenWrapper)));
		}

		if constexpr((mem103)(&$CCNode::stopActionByTag) != (der103)(&D::stopActionByTag)) {
			modContainer.registerHookEnable(address103, FunctionScrapper::addressOfNonVirtual((der103)(&D::stopActionByTagWrapper)));
		}

		if constexpr((mem104)(&$CCNode::stopAllActions) != (der104)(&D::stopAllActions)) {
			modContainer.registerHookEnable(address104, FunctionScrapper::addressOfNonVirtual((der104)(&D::stopAllActionsWrapper)));
		}

		if constexpr((mem105)(&$CCNode::unregisterScriptHandler) != (der105)(&D::unregisterScriptHandler)) {
			modContainer.registerHookEnable(address105, FunctionScrapper::addressOfNonVirtual((der105)(&D::unregisterScriptHandlerWrapper)));
		}

		if constexpr((mem107)(&$CCNode::unscheduleAllSelectors) != (der107)(&D::unscheduleAllSelectors)) {
			modContainer.registerHookEnable(address107, FunctionScrapper::addressOfNonVirtual((der107)(&D::unscheduleAllSelectorsWrapper)));
		}

		if constexpr((mem108)(&$CCNode::unscheduleUpdate) != (der108)(&D::unscheduleUpdate)) {
			modContainer.registerHookEnable(address108, FunctionScrapper::addressOfNonVirtual((der108)(&D::unscheduleUpdateWrapper)));
		}

		if constexpr((mem109)(&$CCNode::update) != (der109)(&D::update)) {
			modContainer.registerHookEnable(address109, FunctionScrapper::addressOfNonVirtual((der109)(&D::updateWrapper)));
		}

		if constexpr((mem110)(&$CCNode::updateTransform) != (der110)(&D::updateTransform)) {
			modContainer.registerHookEnable(address110, FunctionScrapper::addressOfNonVirtual((der110)(&D::updateTransformWrapper)));
		}

		if constexpr((mem111)(&$CCNode::updateTweenAction) != (der111)(&D::updateTweenAction)) {
			modContainer.registerHookEnable(address111, FunctionScrapper::addressOfNonVirtual((der111)(&D::updateTweenActionWrapper)));
		}

		if constexpr((mem112)(&$CCNode::visit) != (der112)(&D::visit)) {
			modContainer.registerHookEnable(address112, FunctionScrapper::addressOfNonVirtual((der112)(&D::visitWrapper)));
		}

		if constexpr((mem113)(&$CCNode::worldToNodeTransform) != (der113)(&D::worldToNodeTransform)) {
			modContainer.registerHookEnable(address113, FunctionScrapper::addressOfNonVirtual((der113)(&D::worldToNodeTransformWrapper)));
		}

		if constexpr(&$CCNode::destructor != &D::destructor) {
			modContainer.registerHookEnable(address114, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCNodeRGBA : CCNodeRGBA, InterfaceBase {
	$CCNodeRGBA(const $CCNodeRGBA& c) : CCNodeRGBA(c) {}
	$CCNodeRGBA() = delete;
	setInterfaceTypesOf(2, CCNodeRGBA, init, , 0);
	setInterfaceTypesOf(3, CCNodeRGBA, getOpacity, , 0);
	setInterfaceTypesOf(4, CCNodeRGBA, getDisplayedOpacity, , 0);
	setInterfaceTypesOf(5, CCNodeRGBA, setOpacity, , 1, GLubyte);
	setInterfaceTypesOf(6, CCNodeRGBA, updateDisplayedOpacity, , 1, GLubyte);
	setInterfaceTypesOf(7, CCNodeRGBA, isCascadeOpacityEnabled, , 0);
	setInterfaceTypesOf(8, CCNodeRGBA, setCascadeOpacityEnabled, , 1, bool);
	setInterfaceTypesOf(9, CCNodeRGBA, getColor, , 0);
	setInterfaceTypesOf(10, CCNodeRGBA, getDisplayedColor, , 0);
	setInterfaceTypesOf(11, CCNodeRGBA, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(12, CCNodeRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(13, CCNodeRGBA, isCascadeColorEnabled, , 0);
	setInterfaceTypesOf(14, CCNodeRGBA, setCascadeColorEnabled, , 1, bool);
	static inline auto address0 = base+0x124b30;
	static inline auto address1 = base+0x124bb0;
	static inline auto address2 = base+0x124bf0;
	static inline auto address3 = base+0x124cd0;
	static inline auto address4 = base+0x124cf0;
	static inline auto address5 = base+0x124d10;
	static inline auto address6 = base+0x124e50;
	static inline auto address7 = base+0x124fe0;
	static inline auto address8 = base+0x125000;
	static inline auto address9 = base+0x125020;
	static inline auto address10 = base+0x125040;
	static inline auto address11 = base+0x125060;
	static inline auto address12 = base+0x1251e0;
	static inline auto address13 = base+0x125320;
	static inline auto address14 = base+0x125340;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, init, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, getOpacity, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, getDisplayedOpacity, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, setOpacity, , 1, GLubyte) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCNodeRGBA, updateDisplayedOpacity, , 1, GLubyte) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCNodeRGBA, isCascadeOpacityEnabled, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, setCascadeOpacityEnabled, , 1, bool) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCNodeRGBA, getColor, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, getDisplayedColor, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCNodeRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(CCNodeRGBA, isCascadeColorEnabled, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(CCNodeRGBA, setCascadeColorEnabled, , 1, bool) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCNodeRGBA, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCNodeRGBA, getOpacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getOpacity();
	}

	getWrapperOf(CCNodeRGBA, getDisplayedOpacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisplayedOpacity();
	}

	getWrapperOf(CCNodeRGBA, setOpacity, , 1, GLubyte) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(CCNodeRGBA, updateDisplayedOpacity, , 1, GLubyte) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedOpacity(p0);
	}

	getWrapperOf(CCNodeRGBA, isCascadeOpacityEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isCascadeOpacityEnabled();
	}

	getWrapperOf(CCNodeRGBA, setCascadeOpacityEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setCascadeOpacityEnabled(p0);
	}

	getWrapperOf(CCNodeRGBA, getColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getColor();
	}

	getWrapperOf(CCNodeRGBA, getDisplayedColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getDisplayedColor();
	}

	getWrapperOf(CCNodeRGBA, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(CCNodeRGBA, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedColor(p0);
	}

	getWrapperOf(CCNodeRGBA, isCascadeColorEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::isCascadeColorEnabled();
	}

	getWrapperOf(CCNodeRGBA, setCascadeColorEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setCascadeColorEnabled(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCNodeRGBA::destructor != &D::destructor) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem2)(&$CCNodeRGBA::init) != (der2)(&D::init)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::initWrapper)));
		}

		if ((mem3)(&$CCNodeRGBA::getOpacity) != (der3)(&D::getOpacity)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::getOpacityWrapper)));
		}

		if ((mem4)(&$CCNodeRGBA::getDisplayedOpacity) != (der4)(&D::getDisplayedOpacity)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::getDisplayedOpacityWrapper)));
		}

		if ((mem5)(&$CCNodeRGBA::setOpacity) != (der5)(&D::setOpacity)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setOpacityWrapper)));
		}

		if ((mem6)(&$CCNodeRGBA::updateDisplayedOpacity) != (der6)(&D::updateDisplayedOpacity)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::updateDisplayedOpacityWrapper)));
		}

		if ((mem7)(&$CCNodeRGBA::isCascadeOpacityEnabled) != (der7)(&D::isCascadeOpacityEnabled)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::isCascadeOpacityEnabledWrapper)));
		}

		if ((mem8)(&$CCNodeRGBA::setCascadeOpacityEnabled) != (der8)(&D::setCascadeOpacityEnabled)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setCascadeOpacityEnabledWrapper)));
		}

		if ((mem9)(&$CCNodeRGBA::getColor) != (der9)(&D::getColor)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::getColorWrapper)));
		}

		if ((mem10)(&$CCNodeRGBA::getDisplayedColor) != (der10)(&D::getDisplayedColor)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::getDisplayedColorWrapper)));
		}

		if ((mem11)(&$CCNodeRGBA::setColor) != (der11)(&D::setColor)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setColorWrapper)));
		}

		if ((mem12)(&$CCNodeRGBA::updateDisplayedColor) != (der12)(&D::updateDisplayedColor)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::updateDisplayedColorWrapper)));
		}

		if ((mem13)(&$CCNodeRGBA::isCascadeColorEnabled) != (der13)(&D::isCascadeColorEnabled)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::isCascadeColorEnabledWrapper)));
		}

		if ((mem14)(&$CCNodeRGBA::setCascadeColorEnabled) != (der14)(&D::setCascadeColorEnabled)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::setCascadeColorEnabledWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCObject : CCObject, InterfaceBase {
	$CCObject(const $CCObject& c) : CCObject(c) {}
	$CCObject() = delete;
	setInterfaceTypesOf(1, CCObject, acceptVisitor, , 1, cocos2d::CCDataVisitor&);
	setInterfaceTypesOf(2, CCObject, autorelease, , 0);
	setInterfaceTypesOf(3, CCObject, canEncode, , 0);
	setInterfaceTypesOf(4, CCObject, encodeWithCoder, , 1, DS_Dictionary*);
	setInterfaceTypesOf(5, CCObject, getTag, const, 0);
	setInterfaceTypesOf(6, CCObject, isEqual, , 1, cocos2d::CCObject const*);
	setInterfaceTypesOf(7, CCObject, release, , 0);
	setInterfaceTypesOf(8, CCObject, retain, , 0);
	setInterfaceTypesOf(9, CCObject, setTag, , 1, int);
	static inline auto address0 = base+0x250ca0;
	static inline auto address1 = base+0x250f30;
	static inline auto address2 = base+0x250ed0;
	static inline auto address3 = base+0x250f90;
	static inline auto address4 = base+0x250f70;
	static inline auto address5 = base+0x250f50;
	static inline auto address6 = base+0x250f20;
	static inline auto address7 = base+0x250ea0;
	static inline auto address8 = base+0x250ec0;
	static inline auto address9 = base+0x250f60;
	static inline auto address10 = base+0x250d90;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCObject, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CCObject, autorelease, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCObject, canEncode, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCObject, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCObject, getTag, const, 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCObject, isEqual, , 1, cocos2d::CCObject const*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCObject, release, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCObject, retain, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCObject, setTag, , 1, int) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address10)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCObject, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<D*>(this)->D::acceptVisitor(p0);
	}

	getWrapperOf(CCObject, autorelease, , 0) {
		return reinterpret_cast<D*>(this)->D::autorelease();
	}

	getWrapperOf(CCObject, canEncode, , 0) {
		return reinterpret_cast<D*>(this)->D::canEncode();
	}

	getWrapperOf(CCObject, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<D*>(this)->D::encodeWithCoder(p0);
	}

	getWrapperOf(CCObject, getTag, const, 0) {
		return reinterpret_cast<D*>(this)->D::getTag();
	}

	getWrapperOf(CCObject, isEqual, , 1, cocos2d::CCObject const*) {
		return reinterpret_cast<D*>(this)->D::isEqual(p0);
	}

	getWrapperOf(CCObject, release, , 0) {
		return reinterpret_cast<D*>(this)->D::release();
	}

	getWrapperOf(CCObject, retain, , 0) {
		return reinterpret_cast<D*>(this)->D::retain();
	}

	getWrapperOf(CCObject, setTag, , 1, int) {
		return reinterpret_cast<D*>(this)->D::setTag(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCObject::acceptVisitor) != (der1)(&D::acceptVisitor)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::acceptVisitorWrapper)));
		}

		if constexpr((mem2)(&$CCObject::autorelease) != (der2)(&D::autorelease)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::autoreleaseWrapper)));
		}

		if constexpr((mem3)(&$CCObject::canEncode) != (der3)(&D::canEncode)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::canEncodeWrapper)));
		}

		if constexpr((mem4)(&$CCObject::encodeWithCoder) != (der4)(&D::encodeWithCoder)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::encodeWithCoderWrapper)));
		}

		if constexpr((mem5)(&$CCObject::getTag) != (der5)(&D::getTag)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::getTagWrapper)));
		}

		if constexpr((mem6)(&$CCObject::isEqual) != (der6)(&D::isEqual)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::isEqualWrapper)));
		}

		if constexpr((mem7)(&$CCObject::release) != (der7)(&D::release)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::releaseWrapper)));
		}

		if constexpr((mem8)(&$CCObject::retain) != (der8)(&D::retain)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::retainWrapper)));
		}

		if constexpr((mem9)(&$CCObject::setTag) != (der9)(&D::setTag)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::setTagWrapper)));
		}

		if constexpr(&$CCObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCParticleSystem : CCParticleSystem, InterfaceBase {
	$CCParticleSystem(const $CCParticleSystem& c) : CCParticleSystem(c) {}
	$CCParticleSystem() = delete;
	setInterfaceTypesOf(0, CCParticleSystem, resetSystem, , 0);
	setInterfaceTypesOf(1, CCParticleSystem, resumeSystem, , 0);
	setInterfaceTypesOf(2, CCParticleSystem, stopSystem, , 0);
	static inline auto address0 = base+0x46bd50;
	static inline auto address1 = base+0x46bd40;
	static inline auto address2 = base+0x46bd10;

	dupable getFunctionOf(CCParticleSystem, resetSystem, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCParticleSystem, resumeSystem, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCParticleSystem, stopSystem, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	getWrapperOf(CCParticleSystem, resetSystem, , 0) {
		return reinterpret_cast<D*>(this)->D::resetSystem();
	}

	getWrapperOf(CCParticleSystem, resumeSystem, , 0) {
		return reinterpret_cast<D*>(this)->D::resumeSystem();
	}

	getWrapperOf(CCParticleSystem, stopSystem, , 0) {
		return reinterpret_cast<D*>(this)->D::stopSystem();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCParticleSystem::resetSystem) != (der0)(&D::resetSystem)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::resetSystemWrapper)));
		}

		if constexpr((mem1)(&$CCParticleSystem::resumeSystem) != (der1)(&D::resumeSystem)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::resumeSystemWrapper)));
		}

		if constexpr((mem2)(&$CCParticleSystem::stopSystem) != (der2)(&D::stopSystem)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::stopSystemWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCParticleSystemQuad : CCParticleSystemQuad, InterfaceBase {
	$CCParticleSystemQuad(const $CCParticleSystemQuad& c) : CCParticleSystemQuad(c) {}
	$CCParticleSystemQuad() = delete;
	setInterfaceStaticTypesOf(0, CCParticleSystemQuad, create, , 1, char const*);
	static inline auto address0 = base+0x36b000;

	dupable static getFunctionOf(CCParticleSystemQuad, create, , 1, char const*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCParticleSystemQuad, create, , 1, char const*) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCParticleSystemQuad::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCPoolManager : CCPoolManager, InterfaceBase {
	$CCPoolManager(const $CCPoolManager& c) : CCPoolManager(c) {}
	$CCPoolManager() = delete;
	setInterfaceTypesOf(0, CCPoolManager, pop, , 0);
	setInterfaceStaticTypesOf(1, CCPoolManager, sharedPoolManager, , 0);
	static inline auto address0 = base+0x214620;
	static inline auto address1 = base+0x2142c0;

	dupable getFunctionOf(CCPoolManager, pop, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable static getFunctionOf(CCPoolManager, sharedPoolManager, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	getWrapperOf(CCPoolManager, pop, , 0) {
		return reinterpret_cast<D*>(this)->D::pop();
	}

	static getWrapperOf(CCPoolManager, sharedPoolManager, , 0) {
		return D::sharedPoolManager();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCPoolManager::pop) != (der0)(&D::pop)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::popWrapper)));
		}

		if constexpr((mem1)(&$CCPoolManager::sharedPoolManager) != (der1)(&D::sharedPoolManager)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedPoolManagerWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCRenderTexture : CCRenderTexture, InterfaceBase {
	$CCRenderTexture(const $CCRenderTexture& c) : CCRenderTexture(c) {}
	$CCRenderTexture() = delete;
	setInterfaceTypesOf(0, CCRenderTexture, begin, , 0);
	setInterfaceStaticTypesOf(2, CCRenderTexture, create, , 3, int, int, cocos2d::CCTexture2DPixelFormat);
	setInterfaceTypesOf(3, CCRenderTexture, newCCImage, , 1, bool);
	static inline auto address0 = base+0x35ce10;
	static inline auto address1 = base+0x35d2c0;
	static inline auto address2 = base+0x35c720;
	static inline auto address3 = base+0x35d7d0;

	dupable getFunctionOf(CCRenderTexture, begin, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable static getFunctionOf(CCRenderTexture, create, , 3, int, int, cocos2d::CCTexture2DPixelFormat) {
		return reinterpret_cast<fun2>(address2)(p0, p1, p2);
	}

	dupable getFunctionOf(CCRenderTexture, newCCImage, , 1, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	getWrapperOf(CCRenderTexture, begin, , 0) {
		return reinterpret_cast<D*>(this)->D::begin();
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	static getWrapperOf(CCRenderTexture, create, , 3, int, int, cocos2d::CCTexture2DPixelFormat) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(CCRenderTexture, newCCImage, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::newCCImage(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCRenderTexture::begin) != (der0)(&D::begin)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::beginWrapper)));
		}

		if constexpr((mem2)(&$CCRenderTexture::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		if constexpr((mem3)(&$CCRenderTexture::newCCImage) != (der3)(&D::newCCImage)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::newCCImageWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCRepeatForever : CCRepeatForever, InterfaceBase {
	$CCRepeatForever(const $CCRepeatForever& c) : CCRepeatForever(c) {}
	$CCRepeatForever() = delete;
	setInterfaceStaticTypesOf(0, CCRepeatForever, create, , 1, cocos2d::CCActionInterval*);
	static inline auto address0 = base+0x1f3920;

	dupable static getFunctionOf(CCRepeatForever, create, , 1, cocos2d::CCActionInterval*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CCRepeatForever, create, , 1, cocos2d::CCActionInterval*) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCRepeatForever::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCRotateBy : CCRotateBy, InterfaceBase {
	$CCRotateBy(const $CCRotateBy& c) : CCRotateBy(c) {}
	$CCRotateBy() = delete;
	setInterfaceStaticTypesOf(0, CCRotateBy, create, , 2, float, float);
	static inline auto address0 = base+0x1f4c50;

	dupable static getFunctionOf(CCRotateBy, create, , 2, float, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCRotateBy, create, , 2, float, float) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCRotateBy::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScaleTo : CCScaleTo, InterfaceBase {
	$CCScaleTo(const $CCScaleTo& c) : CCScaleTo(c) {}
	$CCScaleTo() = delete;
	setInterfaceStaticTypesOf(0, CCScaleTo, create, , 2, float, float);
	setInterfaceStaticTypesOf(1, CCScaleTo, create, , 3, float, float, float);
	static inline auto address0 = base+0x1f6ff0;
	static inline auto address1 = base+0x1f70f0;

	dupable static getFunctionOf(CCScaleTo, create, , 2, float, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable static getFunctionOf(CCScaleTo, create, , 3, float, float, float) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2);
	}

	static getWrapperOf(CCScaleTo, create, , 2, float, float) {
		return D::create(p0, p1);
	}

	static getWrapperOf(CCScaleTo, create, , 3, float, float, float) {
		return D::create(p0, p1, p2);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCScaleTo::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCScaleTo::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScene : CCScene, InterfaceBase {
	$CCScene(const $CCScene& c) : CCScene(c) {}
	$CCScene() = delete;
	setInterfaceStaticTypesOf(0, CCScene, create, , 0);
	setInterfaceTypesOf(1, CCScene, getHighestChildZ, , 0);
	static inline auto address0 = base+0x13c140;
	static inline auto address1 = base+0x13c200;

	dupable static getFunctionOf(CCScene, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(CCScene, getHighestChildZ, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	static getWrapperOf(CCScene, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCScene, getHighestChildZ, , 0) {
		return reinterpret_cast<D*>(this)->D::getHighestChildZ();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCScene::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCScene::getHighestChildZ) != (der1)(&D::getHighestChildZ)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getHighestChildZWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScheduler : CCScheduler, InterfaceBase {
	$CCScheduler(const $CCScheduler& c) : CCScheduler(c) {}
	$CCScheduler() = delete;
	setInterfaceTypesOf(1, CCScheduler, scheduleUpdateForTarget, , 3, cocos2d::CCObject*, int, bool);
	setInterfaceTypesOf(2, CCScheduler, unscheduleAllForTarget, , 1, cocos2d::CCObject*);
	static inline auto address1 = base+0x2438d0;
	static inline auto address2 = base+0x243e40;

	dupable getFunctionOf(CCScheduler, scheduleUpdateForTarget, , 3, cocos2d::CCObject*, int, bool) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCScheduler, unscheduleAllForTarget, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	getWrapperOf(CCScheduler, scheduleUpdateForTarget, , 3, cocos2d::CCObject*, int, bool) {
		return reinterpret_cast<D*>(this)->D::scheduleUpdateForTarget(p0, p1, p2);
	}

	getWrapperOf(CCScheduler, unscheduleAllForTarget, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::unscheduleAllForTarget(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCScheduler::scheduleUpdateForTarget) != (der1)(&D::scheduleUpdateForTarget)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::scheduleUpdateForTargetWrapper)));
		}

		if constexpr((mem2)(&$CCScheduler::unscheduleAllForTarget) != (der2)(&D::unscheduleAllForTarget)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::unscheduleAllForTargetWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCSequence : CCSequence, InterfaceBase {
	$CCSequence(const $CCSequence& c) : CCSequence(c) {}
	$CCSequence() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCSet : CCSet, InterfaceBase {
	$CCSet(const $CCSet& c) : CCSet(c) {}
	$CCSet() = delete;
	setInterfaceTypesOf(2, CCSet, acceptVisitor, , 1, cocos2d::CCDataVisitor&);
	static inline auto address0 = base+0x45ad80;
	static inline auto address1 = base+0x45b050;
	static inline auto address2 = base+0x45b090;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable getFunctionOf(CCSet, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCSet, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<D*>(this)->D::acceptVisitor(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCSet::destructor != &D::destructor) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem2)(&$CCSet::acceptVisitor) != (der2)(&D::acceptVisitor)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::acceptVisitorWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCSprite : CCSprite, InterfaceBase {
	$CCSprite(const $CCSprite& c) : CCSprite(c) {}
	$CCSprite() = delete;
	setInterfaceTypesOf(1, CCSprite, init, , 0);
	setInterfaceTypesOf(2, CCSprite, setVertexZ, , 1, float);
	setInterfaceTypesOf(3, CCSprite, setScaleX, , 1, float);
	setInterfaceTypesOf(4, CCSprite, setScaleY, , 1, float);
	setInterfaceTypesOf(5, CCSprite, setScale, , 1, float);
	setInterfaceTypesOf(6, CCSprite, setPosition, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(7, CCSprite, setSkewX, , 1, float);
	setInterfaceTypesOf(8, CCSprite, setSkewY, , 1, float);
	setInterfaceTypesOf(9, CCSprite, setAnchorPoint, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(10, CCSprite, setVisible, , 1, bool);
	setInterfaceTypesOf(11, CCSprite, setRotation, , 1, float);
	setInterfaceTypesOf(12, CCSprite, setRotationX, , 1, float);
	setInterfaceTypesOf(13, CCSprite, setRotationY, , 1, float);
	setInterfaceTypesOf(14, CCSprite, ignoreAnchorPointForPosition, , 1, bool);
	setInterfaceTypesOf(15, CCSprite, addChild, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(16, CCSprite, addChild, , 2, cocos2d::CCNode*, int);
	setInterfaceTypesOf(17, CCSprite, addChild, , 3, cocos2d::CCNode*, int, int);
	setInterfaceTypesOf(18, CCSprite, removeChild, , 2, cocos2d::CCNode*, bool);
	setInterfaceTypesOf(19, CCSprite, removeAllChildrenWithCleanup, , 1, bool);
	setInterfaceTypesOf(20, CCSprite, reorderChild, , 2, cocos2d::CCNode*, int);
	setInterfaceTypesOf(21, CCSprite, sortAllChildren, , 0);
	setInterfaceTypesOf(22, CCSprite, draw, , 0);
	setInterfaceTypesOf(23, CCSprite, updateTransform, , 0);
	setInterfaceTypesOf(24, CCSprite, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(25, CCSprite, updateDisplayedOpacity, , 1, unsigned char);
	setInterfaceTypesOf(26, CCSprite, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(27, CCSprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(28, CCSprite, setOpacityModifyRGB, , 1, bool);
	setInterfaceTypesOf(29, CCSprite, isOpacityModifyRGB, , 0);
	setInterfaceTypesOf(30, CCSprite, initWithTexture, , 1, cocos2d::CCTexture2D*);
	setInterfaceTypesOf(31, CCSprite, initWithTexture, , 2, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	setInterfaceTypesOf(32, CCSprite, initWithTexture, , 3, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	setInterfaceTypesOf(33, CCSprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*);
	setInterfaceTypesOf(34, CCSprite, initWithSpriteFrameName, , 1, char const*);
	setInterfaceTypesOf(35, CCSprite, initWithFile, , 1, char const*);
	setInterfaceTypesOf(36, CCSprite, initWithFile, , 2, char const*, cocos2d::CCRect const&);
	setInterfaceTypesOf(37, CCSprite, setTexture, , 1, cocos2d::CCTexture2D*);
	setInterfaceTypesOf(38, CCSprite, getTexture, , 0);
	setInterfaceTypesOf(39, CCSprite, setChildColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(40, CCSprite, setChildOpacity, , 1, unsigned char);
	setInterfaceTypesOf(41, CCSprite, getBatchNode, , 0);
	setInterfaceTypesOf(42, CCSprite, setBatchNode, , 1, cocos2d::CCSpriteBatchNode*);
	setInterfaceTypesOf(43, CCSprite, refreshTextureRect, , 0);
	setInterfaceTypesOf(44, CCSprite, setTextureRect, , 1, cocos2d::CCRect const&);
	setInterfaceTypesOf(45, CCSprite, setTextureRect, , 3, cocos2d::CCRect const&, bool, cocos2d::CCSize const&);
	setInterfaceTypesOf(46, CCSprite, setVertexRect, , 1, cocos2d::CCRect const&);
	setInterfaceTypesOf(47, CCSprite, setDisplayFrame, , 1, cocos2d::CCSpriteFrame*);
	setInterfaceTypesOf(48, CCSprite, isFrameDisplayed, , 1, cocos2d::CCSpriteFrame*);
	setInterfaceTypesOf(49, CCSprite, displayFrame, , 0);
	setInterfaceTypesOf(50, CCSprite, setDisplayFrameWithAnimationName, , 2, char const*, int);
	setInterfaceStaticTypesOf(56, CCSprite, create, , 0);
	setInterfaceStaticTypesOf(57, CCSprite, create, , 1, char const*);
	setInterfaceStaticTypesOf(58, CCSprite, createWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*);
	setInterfaceStaticTypesOf(59, CCSprite, createWithSpriteFrameName, , 1, char const*);
	setInterfaceStaticTypesOf(60, CCSprite, createWithTexture, , 1, cocos2d::CCTexture2D*);
	static inline auto address0 = base+0x133430;
	static inline auto address1 = base+0x132ef0;
	static inline auto address2 = base+0x134a80;
	static inline auto address3 = base+0x134900;
	static inline auto address4 = base+0x134980;
	static inline auto address5 = base+0x134a00;
	static inline auto address6 = base+0x134650;
	static inline auto address7 = base+0x134820;
	static inline auto address8 = base+0x134890;
	static inline auto address9 = base+0x134af0;
	static inline auto address10 = base+0x134b70;
	static inline auto address11 = base+0x1346d0;
	static inline auto address12 = base+0x134740;
	static inline auto address13 = base+0x1347b0;
	static inline auto address14 = base+0x134b60;
	static inline auto address15 = base+0x134190;
	static inline auto address16 = base+0x1341a0;
	static inline auto address17 = base+0x1341b0;
	static inline auto address18 = base+0x134300;
	static inline auto address19 = base+0x134340;
	static inline auto address20 = base+0x134270;
	static inline auto address21 = base+0x1343f0;
	static inline auto address22 = base+0x134070;
	static inline auto address23 = base+0x133b70;
	static inline auto address24 = base+0x134da0;
	static inline auto address25 = base+0x1354c0;
	static inline auto address26 = base+0x134ff0;
	static inline auto address27 = base+0x135370;
	static inline auto address28 = base+0x135200;
	static inline auto address29 = base+0x135350;
	static inline auto address30 = base+0x133110;
	static inline auto address31 = base+0x1330f0;
	static inline auto address32 = base+0x132f10;
	static inline auto address33 = base+0x133270;
	static inline auto address34 = base+0x1332c0;
	static inline auto address35 = base+0x133180;
	static inline auto address36 = base+0x133210;
	static inline auto address37 = base+0x135a90;
	static inline auto address38 = base+0x135c00;
	static inline auto address39 = base+0x135160;
	static inline auto address40 = base+0x134f50;
	static inline auto address41 = base+0x135910;
	static inline auto address42 = base+0x135920;
	static inline auto address43 = base+0x133520;
	static inline auto address44 = base+0x133560;
	static inline auto address45 = base+0x133580;
	static inline auto address46 = base+0x1338f0;
	static inline auto address47 = base+0x135610;
	static inline auto address48 = base+0x1356d0;
	static inline auto address49 = base+0x135760;
	static inline auto address50 = base+0x135680;
	static inline auto address55 = base+0x133300;
	static inline auto address56 = base+0x132df0;
	static inline auto address57 = base+0x132a80;
	static inline auto address58 = base+0x132cb0;
	static inline auto address59 = base+0x132dc0;
	static inline auto address60 = base+0x132790;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCSprite, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCSprite, setVertexZ, , 1, float) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setScaleX, , 1, float) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setScaleY, , 1, float) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setScale, , 1, float) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setSkewX, , 1, float) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setSkewY, , 1, float) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setVisible, , 1, bool) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setRotation, , 1, float) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setRotationX, , 1, float) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setRotationY, , 1, float) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(CCSprite, ignoreAnchorPointForPosition, , 1, bool) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(CCSprite, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(CCSprite, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1);
	}

	dupable getFunctionOf(CCSprite, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCSprite, removeChild, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<fun18>(address18)(this, p0, p1);
	}

	dupable getFunctionOf(CCSprite, removeAllChildrenWithCleanup, , 1, bool) {
		return reinterpret_cast<fun19>(address19)(this, p0);
	}

	dupable getFunctionOf(CCSprite, reorderChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<fun20>(address20)(this, p0, p1);
	}

	dupable getFunctionOf(CCSprite, sortAllChildren, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(CCSprite, draw, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable getFunctionOf(CCSprite, updateTransform, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(CCSprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	dupable getFunctionOf(CCSprite, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun25>(address25)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	dupable getFunctionOf(CCSprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun27>(address27)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setOpacityModifyRGB, , 1, bool) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	dupable getFunctionOf(CCSprite, isOpacityModifyRGB, , 0) {
		return reinterpret_cast<fun29>(address29)(this);
	}

	dupable getFunctionOf(CCSprite, initWithTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(CCSprite, initWithTexture, , 2, cocos2d::CCTexture2D*, cocos2d::CCRect const&) {
		return reinterpret_cast<fun31>(address31)(this, p0, p1);
	}

	dupable getFunctionOf(CCSprite, initWithTexture, , 3, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool) {
		return reinterpret_cast<fun32>(address32)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCSprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(CCSprite, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(CCSprite, initWithFile, , 1, char const*) {
		return reinterpret_cast<fun35>(address35)(this, p0);
	}

	dupable getFunctionOf(CCSprite, initWithFile, , 2, char const*, cocos2d::CCRect const&) {
		return reinterpret_cast<fun36>(address36)(this, p0, p1);
	}

	dupable getFunctionOf(CCSprite, setTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<fun37>(address37)(this, p0);
	}

	dupable getFunctionOf(CCSprite, getTexture, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(CCSprite, setChildColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun39>(address39)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setChildOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun40>(address40)(this, p0);
	}

	dupable getFunctionOf(CCSprite, getBatchNode, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(CCSprite, setBatchNode, , 1, cocos2d::CCSpriteBatchNode*) {
		return reinterpret_cast<fun42>(address42)(this, p0);
	}

	dupable getFunctionOf(CCSprite, refreshTextureRect, , 0) {
		return reinterpret_cast<fun43>(address43)(this);
	}

	dupable getFunctionOf(CCSprite, setTextureRect, , 1, cocos2d::CCRect const&) {
		return reinterpret_cast<fun44>(address44)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setTextureRect, , 3, cocos2d::CCRect const&, bool, cocos2d::CCSize const&) {
		return reinterpret_cast<fun45>(address45)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCSprite, setVertexRect, , 1, cocos2d::CCRect const&) {
		return reinterpret_cast<fun46>(address46)(this, p0);
	}

	dupable getFunctionOf(CCSprite, setDisplayFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun47>(address47)(this, p0);
	}

	dupable getFunctionOf(CCSprite, isFrameDisplayed, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun48>(address48)(this, p0);
	}

	dupable getFunctionOf(CCSprite, displayFrame, , 0) {
		return reinterpret_cast<fun49>(address49)(this);
	}

	dupable getFunctionOf(CCSprite, setDisplayFrameWithAnimationName, , 2, char const*, int) {
		return reinterpret_cast<fun50>(address50)(this, p0, p1);
	}

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address55)(this);
	}

	dupable static getFunctionOf(CCSprite, create, , 0) {
		return reinterpret_cast<fun56>(address56)();
	}

	dupable static getFunctionOf(CCSprite, create, , 1, char const*) {
		return reinterpret_cast<fun57>(address57)(p0);
	}

	dupable static getFunctionOf(CCSprite, createWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun58>(address58)(p0);
	}

	dupable static getFunctionOf(CCSprite, createWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<fun59>(address59)(p0);
	}

	dupable static getFunctionOf(CCSprite, createWithTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<fun60>(address60)(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCSprite, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCSprite, setVertexZ, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setVertexZ(p0);
	}

	getWrapperOf(CCSprite, setScaleX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleX(p0);
	}

	getWrapperOf(CCSprite, setScaleY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleY(p0);
	}

	getWrapperOf(CCSprite, setScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0);
	}

	getWrapperOf(CCSprite, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setPosition(p0);
	}

	getWrapperOf(CCSprite, setSkewX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSkewX(p0);
	}

	getWrapperOf(CCSprite, setSkewY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSkewY(p0);
	}

	getWrapperOf(CCSprite, setAnchorPoint, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setAnchorPoint(p0);
	}

	getWrapperOf(CCSprite, setVisible, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setVisible(p0);
	}

	getWrapperOf(CCSprite, setRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotation(p0);
	}

	getWrapperOf(CCSprite, setRotationX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotationX(p0);
	}

	getWrapperOf(CCSprite, setRotationY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotationY(p0);
	}

	getWrapperOf(CCSprite, ignoreAnchorPointForPosition, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::ignoreAnchorPointForPosition(p0);
	}

	getWrapperOf(CCSprite, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::addChild(p0);
	}

	getWrapperOf(CCSprite, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1);
	}

	getWrapperOf(CCSprite, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1, p2);
	}

	getWrapperOf(CCSprite, removeChild, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<D*>(this)->D::removeChild(p0, p1);
	}

	getWrapperOf(CCSprite, removeAllChildrenWithCleanup, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::removeAllChildrenWithCleanup(p0);
	}

	getWrapperOf(CCSprite, reorderChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<D*>(this)->D::reorderChild(p0, p1);
	}

	getWrapperOf(CCSprite, sortAllChildren, , 0) {
		return reinterpret_cast<D*>(this)->D::sortAllChildren();
	}

	getWrapperOf(CCSprite, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(CCSprite, updateTransform, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTransform();
	}

	getWrapperOf(CCSprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(CCSprite, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedOpacity(p0);
	}

	getWrapperOf(CCSprite, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(CCSprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedColor(p0);
	}

	getWrapperOf(CCSprite, setOpacityModifyRGB, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setOpacityModifyRGB(p0);
	}

	getWrapperOf(CCSprite, isOpacityModifyRGB, , 0) {
		return reinterpret_cast<D*>(this)->D::isOpacityModifyRGB();
	}

	getWrapperOf(CCSprite, initWithTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<D*>(this)->D::initWithTexture(p0);
	}

	getWrapperOf(CCSprite, initWithTexture, , 2, cocos2d::CCTexture2D*, cocos2d::CCRect const&) {
		return reinterpret_cast<D*>(this)->D::initWithTexture(p0, p1);
	}

	getWrapperOf(CCSprite, initWithTexture, , 3, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool) {
		return reinterpret_cast<D*>(this)->D::initWithTexture(p0, p1, p2);
	}

	getWrapperOf(CCSprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrame(p0);
	}

	getWrapperOf(CCSprite, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrameName(p0);
	}

	getWrapperOf(CCSprite, initWithFile, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0);
	}

	getWrapperOf(CCSprite, initWithFile, , 2, char const*, cocos2d::CCRect const&) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0, p1);
	}

	getWrapperOf(CCSprite, setTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<D*>(this)->D::setTexture(p0);
	}

	getWrapperOf(CCSprite, getTexture, , 0) {
		return reinterpret_cast<D*>(this)->D::getTexture();
	}

	getWrapperOf(CCSprite, setChildColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setChildColor(p0);
	}

	getWrapperOf(CCSprite, setChildOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setChildOpacity(p0);
	}

	getWrapperOf(CCSprite, getBatchNode, , 0) {
		return reinterpret_cast<D*>(this)->D::getBatchNode();
	}

	getWrapperOf(CCSprite, setBatchNode, , 1, cocos2d::CCSpriteBatchNode*) {
		return reinterpret_cast<D*>(this)->D::setBatchNode(p0);
	}

	getWrapperOf(CCSprite, refreshTextureRect, , 0) {
		return reinterpret_cast<D*>(this)->D::refreshTextureRect();
	}

	getWrapperOf(CCSprite, setTextureRect, , 1, cocos2d::CCRect const&) {
		return reinterpret_cast<D*>(this)->D::setTextureRect(p0);
	}

	getWrapperOf(CCSprite, setTextureRect, , 3, cocos2d::CCRect const&, bool, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::setTextureRect(p0, p1, p2);
	}

	getWrapperOf(CCSprite, setVertexRect, , 1, cocos2d::CCRect const&) {
		return reinterpret_cast<D*>(this)->D::setVertexRect(p0);
	}

	getWrapperOf(CCSprite, setDisplayFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<D*>(this)->D::setDisplayFrame(p0);
	}

	getWrapperOf(CCSprite, isFrameDisplayed, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<D*>(this)->D::isFrameDisplayed(p0);
	}

	getWrapperOf(CCSprite, displayFrame, , 0) {
		return reinterpret_cast<D*>(this)->D::displayFrame();
	}

	getWrapperOf(CCSprite, setDisplayFrameWithAnimationName, , 2, char const*, int) {
		return reinterpret_cast<D*>(this)->D::setDisplayFrameWithAnimationName(p0, p1);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	static getWrapperOf(CCSprite, create, , 0) {
		return D::create();
	}

	static getWrapperOf(CCSprite, create, , 1, char const*) {
		return D::create(p0);
	}

	static getWrapperOf(CCSprite, createWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return D::createWithSpriteFrame(p0);
	}

	static getWrapperOf(CCSprite, createWithSpriteFrameName, , 1, char const*) {
		return D::createWithSpriteFrameName(p0);
	}

	static getWrapperOf(CCSprite, createWithTexture, , 1, cocos2d::CCTexture2D*) {
		return D::createWithTexture(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCSprite::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCSprite::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if ((mem2)(&$CCSprite::setVertexZ) != (der2)(&D::setVertexZ)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setVertexZWrapper)));
		}

		if ((mem3)(&$CCSprite::setScaleX) != (der3)(&D::setScaleX)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setScaleXWrapper)));
		}

		if ((mem4)(&$CCSprite::setScaleY) != (der4)(&D::setScaleY)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setScaleYWrapper)));
		}

		if ((mem5)(&$CCSprite::setScale) != (der5)(&D::setScale)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setScaleWrapper)));
		}

		if ((mem6)(&$CCSprite::setPosition) != (der6)(&D::setPosition)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::setPositionWrapper)));
		}

		if ((mem7)(&$CCSprite::setSkewX) != (der7)(&D::setSkewX)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setSkewXWrapper)));
		}

		if ((mem8)(&$CCSprite::setSkewY) != (der8)(&D::setSkewY)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setSkewYWrapper)));
		}

		if ((mem9)(&$CCSprite::setAnchorPoint) != (der9)(&D::setAnchorPoint)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::setAnchorPointWrapper)));
		}

		if ((mem10)(&$CCSprite::setVisible) != (der10)(&D::setVisible)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::setVisibleWrapper)));
		}

		if ((mem11)(&$CCSprite::setRotation) != (der11)(&D::setRotation)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setRotationWrapper)));
		}

		if ((mem12)(&$CCSprite::setRotationX) != (der12)(&D::setRotationX)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::setRotationXWrapper)));
		}

		if ((mem13)(&$CCSprite::setRotationY) != (der13)(&D::setRotationY)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::setRotationYWrapper)));
		}

		if ((mem14)(&$CCSprite::ignoreAnchorPointForPosition) != (der14)(&D::ignoreAnchorPointForPosition)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::ignoreAnchorPointForPositionWrapper)));
		}

		if ((mem15)(&$CCSprite::addChild) != (der15)(&D::addChild)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::addChildWrapper)));
		}

		if ((mem16)(&$CCSprite::addChild) != (der16)(&D::addChild)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfVirtual((der16)(&D::addChildWrapper)));
		}

		if ((mem17)(&$CCSprite::addChild) != (der17)(&D::addChild)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfVirtual((der17)(&D::addChildWrapper)));
		}

		if ((mem18)(&$CCSprite::removeChild) != (der18)(&D::removeChild)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfVirtual((der18)(&D::removeChildWrapper)));
		}

		if ((mem19)(&$CCSprite::removeAllChildrenWithCleanup) != (der19)(&D::removeAllChildrenWithCleanup)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfVirtual((der19)(&D::removeAllChildrenWithCleanupWrapper)));
		}

		if ((mem20)(&$CCSprite::reorderChild) != (der20)(&D::reorderChild)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfVirtual((der20)(&D::reorderChildWrapper)));
		}

		if ((mem21)(&$CCSprite::sortAllChildren) != (der21)(&D::sortAllChildren)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfVirtual((der21)(&D::sortAllChildrenWrapper)));
		}

		if ((mem22)(&$CCSprite::draw) != (der22)(&D::draw)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfVirtual((der22)(&D::drawWrapper)));
		}

		if ((mem23)(&$CCSprite::updateTransform) != (der23)(&D::updateTransform)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfVirtual((der23)(&D::updateTransformWrapper)));
		}

		if ((mem24)(&$CCSprite::setOpacity) != (der24)(&D::setOpacity)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfVirtual((der24)(&D::setOpacityWrapper)));
		}

		if ((mem25)(&$CCSprite::updateDisplayedOpacity) != (der25)(&D::updateDisplayedOpacity)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfVirtual((der25)(&D::updateDisplayedOpacityWrapper)));
		}

		if ((mem26)(&$CCSprite::setColor) != (der26)(&D::setColor)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfVirtual((der26)(&D::setColorWrapper)));
		}

		if ((mem27)(&$CCSprite::updateDisplayedColor) != (der27)(&D::updateDisplayedColor)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfVirtual((der27)(&D::updateDisplayedColorWrapper)));
		}

		if ((mem28)(&$CCSprite::setOpacityModifyRGB) != (der28)(&D::setOpacityModifyRGB)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfVirtual((der28)(&D::setOpacityModifyRGBWrapper)));
		}

		if ((mem29)(&$CCSprite::isOpacityModifyRGB) != (der29)(&D::isOpacityModifyRGB)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfVirtual((der29)(&D::isOpacityModifyRGBWrapper)));
		}

		if ((mem30)(&$CCSprite::initWithTexture) != (der30)(&D::initWithTexture)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfVirtual((der30)(&D::initWithTextureWrapper)));
		}

		if ((mem31)(&$CCSprite::initWithTexture) != (der31)(&D::initWithTexture)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfVirtual((der31)(&D::initWithTextureWrapper)));
		}

		if ((mem32)(&$CCSprite::initWithTexture) != (der32)(&D::initWithTexture)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfVirtual((der32)(&D::initWithTextureWrapper)));
		}

		if ((mem33)(&$CCSprite::initWithSpriteFrame) != (der33)(&D::initWithSpriteFrame)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfVirtual((der33)(&D::initWithSpriteFrameWrapper)));
		}

		if ((mem34)(&$CCSprite::initWithSpriteFrameName) != (der34)(&D::initWithSpriteFrameName)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfVirtual((der34)(&D::initWithSpriteFrameNameWrapper)));
		}

		if ((mem35)(&$CCSprite::initWithFile) != (der35)(&D::initWithFile)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfVirtual((der35)(&D::initWithFileWrapper)));
		}

		if ((mem36)(&$CCSprite::initWithFile) != (der36)(&D::initWithFile)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfVirtual((der36)(&D::initWithFileWrapper)));
		}

		if ((mem37)(&$CCSprite::setTexture) != (der37)(&D::setTexture)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfVirtual((der37)(&D::setTextureWrapper)));
		}

		if ((mem38)(&$CCSprite::getTexture) != (der38)(&D::getTexture)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfVirtual((der38)(&D::getTextureWrapper)));
		}

		if ((mem39)(&$CCSprite::setChildColor) != (der39)(&D::setChildColor)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfVirtual((der39)(&D::setChildColorWrapper)));
		}

		if ((mem40)(&$CCSprite::setChildOpacity) != (der40)(&D::setChildOpacity)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfVirtual((der40)(&D::setChildOpacityWrapper)));
		}

		if ((mem41)(&$CCSprite::getBatchNode) != (der41)(&D::getBatchNode)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfVirtual((der41)(&D::getBatchNodeWrapper)));
		}

		if ((mem42)(&$CCSprite::setBatchNode) != (der42)(&D::setBatchNode)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfVirtual((der42)(&D::setBatchNodeWrapper)));
		}

		if ((mem43)(&$CCSprite::refreshTextureRect) != (der43)(&D::refreshTextureRect)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfVirtual((der43)(&D::refreshTextureRectWrapper)));
		}

		if ((mem44)(&$CCSprite::setTextureRect) != (der44)(&D::setTextureRect)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfVirtual((der44)(&D::setTextureRectWrapper)));
		}

		if ((mem45)(&$CCSprite::setTextureRect) != (der45)(&D::setTextureRect)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfVirtual((der45)(&D::setTextureRectWrapper)));
		}

		if ((mem46)(&$CCSprite::setVertexRect) != (der46)(&D::setVertexRect)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfVirtual((der46)(&D::setVertexRectWrapper)));
		}

		if ((mem47)(&$CCSprite::setDisplayFrame) != (der47)(&D::setDisplayFrame)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfVirtual((der47)(&D::setDisplayFrameWrapper)));
		}

		if ((mem48)(&$CCSprite::isFrameDisplayed) != (der48)(&D::isFrameDisplayed)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfVirtual((der48)(&D::isFrameDisplayedWrapper)));
		}

		if ((mem49)(&$CCSprite::displayFrame) != (der49)(&D::displayFrame)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfVirtual((der49)(&D::displayFrameWrapper)));
		}

		if ((mem50)(&$CCSprite::setDisplayFrameWithAnimationName) != (der50)(&D::setDisplayFrameWithAnimationName)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfVirtual((der50)(&D::setDisplayFrameWithAnimationNameWrapper)));
		}

		if constexpr((mem56)(&$CCSprite::create) != (der56)(&D::create)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::createWrapper)));
		}

		if constexpr((mem57)(&$CCSprite::create) != (der57)(&D::create)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::createWrapper)));
		}

		if constexpr((mem58)(&$CCSprite::createWithSpriteFrame) != (der58)(&D::createWithSpriteFrame)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::createWithSpriteFrameWrapper)));
		}

		if constexpr((mem59)(&$CCSprite::createWithSpriteFrameName) != (der59)(&D::createWithSpriteFrameName)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::createWithSpriteFrameNameWrapper)));
		}

		if constexpr((mem60)(&$CCSprite::createWithTexture) != (der60)(&D::createWithTexture)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::createWithTextureWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCSpriteBatchNode : CCSpriteBatchNode, InterfaceBase {
	$CCSpriteBatchNode(const $CCSpriteBatchNode& c) : CCSpriteBatchNode(c) {}
	$CCSpriteBatchNode() = delete;
	setInterfaceStaticTypesOf(0, CCSpriteBatchNode, create, , 2, char const*, unsigned int);
	setInterfaceStaticTypesOf(1, CCSpriteBatchNode, createWithTexture, , 2, cocos2d::CCTexture2D*, unsigned int);
	setInterfaceTypesOf(2, CCSpriteBatchNode, getUsedAtlasCapacity, , 0);
	setInterfaceTypesOf(3, CCSpriteBatchNode, increaseAtlasCapacity, , 1, unsigned int);
	static inline auto address0 = base+0xbb540;
	static inline auto address1 = base+0xbb310;
	static inline auto address2 = base+0xbc6b0;
	static inline auto address3 = base+0xbc670;

	dupable static getFunctionOf(CCSpriteBatchNode, create, , 2, char const*, unsigned int) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable static getFunctionOf(CCSpriteBatchNode, createWithTexture, , 2, cocos2d::CCTexture2D*, unsigned int) {
		return reinterpret_cast<fun1>(address1)(p0, p1);
	}

	dupable getFunctionOf(CCSpriteBatchNode, getUsedAtlasCapacity, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCSpriteBatchNode, increaseAtlasCapacity, , 1, unsigned int) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	static getWrapperOf(CCSpriteBatchNode, create, , 2, char const*, unsigned int) {
		return D::create(p0, p1);
	}

	static getWrapperOf(CCSpriteBatchNode, createWithTexture, , 2, cocos2d::CCTexture2D*, unsigned int) {
		return D::createWithTexture(p0, p1);
	}

	getWrapperOf(CCSpriteBatchNode, getUsedAtlasCapacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getUsedAtlasCapacity();
	}

	getWrapperOf(CCSpriteBatchNode, increaseAtlasCapacity, , 1, unsigned int) {
		return reinterpret_cast<D*>(this)->D::increaseAtlasCapacity(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCSpriteBatchNode::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCSpriteBatchNode::createWithTexture) != (der1)(&D::createWithTexture)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWithTextureWrapper)));
		}

		if constexpr((mem2)(&$CCSpriteBatchNode::getUsedAtlasCapacity) != (der2)(&D::getUsedAtlasCapacity)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getUsedAtlasCapacityWrapper)));
		}

		if constexpr((mem3)(&$CCSpriteBatchNode::increaseAtlasCapacity) != (der3)(&D::increaseAtlasCapacity)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::increaseAtlasCapacityWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCSpriteFrameCache : CCSpriteFrameCache, InterfaceBase {
	$CCSpriteFrameCache(const $CCSpriteFrameCache& c) : CCSpriteFrameCache(c) {}
	$CCSpriteFrameCache() = delete;
	setInterfaceTypesOf(0, CCSpriteFrameCache, addSpriteFramesWithFile, , 1, char const*);
	setInterfaceStaticTypesOf(1, CCSpriteFrameCache, sharedSpriteFrameCache, , 0);
	setInterfaceTypesOf(2, CCSpriteFrameCache, spriteFrameByName, , 1, char const*);
	static inline auto address0 = base+0x199a10;
	static inline auto address1 = base+0x198970;
	static inline auto address2 = base+0x19a7e0;

	dupable getFunctionOf(CCSpriteFrameCache, addSpriteFramesWithFile, , 1, char const*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable static getFunctionOf(CCSpriteFrameCache, sharedSpriteFrameCache, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	dupable getFunctionOf(CCSpriteFrameCache, spriteFrameByName, , 1, char const*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	getWrapperOf(CCSpriteFrameCache, addSpriteFramesWithFile, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::addSpriteFramesWithFile(p0);
	}

	static getWrapperOf(CCSpriteFrameCache, sharedSpriteFrameCache, , 0) {
		return D::sharedSpriteFrameCache();
	}

	getWrapperOf(CCSpriteFrameCache, spriteFrameByName, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::spriteFrameByName(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCSpriteFrameCache::addSpriteFramesWithFile) != (der0)(&D::addSpriteFramesWithFile)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::addSpriteFramesWithFileWrapper)));
		}

		if constexpr((mem1)(&$CCSpriteFrameCache::sharedSpriteFrameCache) != (der1)(&D::sharedSpriteFrameCache)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedSpriteFrameCacheWrapper)));
		}

		if constexpr((mem2)(&$CCSpriteFrameCache::spriteFrameByName) != (der2)(&D::spriteFrameByName)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::spriteFrameByNameWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCStandardTouchHandler : CCStandardTouchHandler, InterfaceBase {
	$CCStandardTouchHandler(const $CCStandardTouchHandler& c) : CCStandardTouchHandler(c) {}
	$CCStandardTouchHandler() = delete;
	setInterfaceStaticTypesOf(0, CCStandardTouchHandler, handlerWithDelegate, , 2, cocos2d::CCTouchDelegate*, int);
	setInterfaceTypesOf(1, CCStandardTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int);
	static inline auto address0 = base+0x247f30;
	static inline auto address1 = base+0x247ed0;
	static inline auto address2 = base+0x2482a0;

	dupable static getFunctionOf(CCStandardTouchHandler, handlerWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(CCStandardTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	static getWrapperOf(CCStandardTouchHandler, handlerWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return D::handlerWithDelegate(p0, p1);
	}

	getWrapperOf(CCStandardTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCStandardTouchHandler::handlerWithDelegate) != (der0)(&D::handlerWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::handlerWithDelegateWrapper)));
		}

		if ((mem1)(&$CCStandardTouchHandler::initWithDelegate) != (der1)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCStandardTouchHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCString : CCString, InterfaceBase {
	$CCString(const $CCString& c) : CCString(c) {}
	$CCString() = delete;
	setInterfaceTypesOf(1, CCString, isEqual, , 1, cocos2d::CCObject const*);
	setInterfaceTypesOf(2, CCString, acceptVisitor, , 1, cocos2d::CCDataVisitor&);
	setInterfaceTypesOf(3, CCString, copyWithZone, , 1, cocos2d::CCZone*);
	setInterfaceTypesOf(4, CCString, boolValue, const, 0);
	setInterfaceTypesOf(5, CCString, doubleValue, const, 0);
	setInterfaceTypesOf(6, CCString, floatValue, const, 0);
	setInterfaceTypesOf(7, CCString, getCString, const, 0);
	setInterfaceTypesOf(8, CCString, intValue, const, 0);
	static inline auto address0 = base+0x44c590;
	static inline auto address1 = base+0x44c8f0;
	static inline auto address2 = base+0x44ccb0;
	static inline auto address3 = base+0x44c870;
	static inline auto address4 = base+0x44c810;
	static inline auto address5 = base+0x44c7f0;
	static inline auto address6 = base+0x44c7d0;
	static inline auto address7 = base+0x44c470;
	static inline auto address8 = base+0x44c780;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCString, isEqual, , 1, cocos2d::CCObject const*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CCString, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(CCString, copyWithZone, , 1, cocos2d::CCZone*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCString, boolValue, const, 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCString, doubleValue, const, 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCString, floatValue, const, 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCString, getCString, const, 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCString, intValue, const, 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCString, isEqual, , 1, cocos2d::CCObject const*) {
		return reinterpret_cast<D*>(this)->D::isEqual(p0);
	}

	getWrapperOf(CCString, acceptVisitor, , 1, cocos2d::CCDataVisitor&) {
		return reinterpret_cast<D*>(this)->D::acceptVisitor(p0);
	}

	getWrapperOf(CCString, copyWithZone, , 1, cocos2d::CCZone*) {
		return reinterpret_cast<D*>(this)->D::copyWithZone(p0);
	}

	getWrapperOf(CCString, boolValue, const, 0) {
		return reinterpret_cast<D*>(this)->D::boolValue();
	}

	getWrapperOf(CCString, doubleValue, const, 0) {
		return reinterpret_cast<D*>(this)->D::doubleValue();
	}

	getWrapperOf(CCString, floatValue, const, 0) {
		return reinterpret_cast<D*>(this)->D::floatValue();
	}

	getWrapperOf(CCString, getCString, const, 0) {
		return reinterpret_cast<D*>(this)->D::getCString();
	}

	getWrapperOf(CCString, intValue, const, 0) {
		return reinterpret_cast<D*>(this)->D::intValue();
	}

public:
	static bool _apply() {

		if constexpr(&$CCString::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCString::isEqual) != (der1)(&D::isEqual)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::isEqualWrapper)));
		}

		if ((mem2)(&$CCString::acceptVisitor) != (der2)(&D::acceptVisitor)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::acceptVisitorWrapper)));
		}

		if ((mem3)(&$CCString::copyWithZone) != (der3)(&D::copyWithZone)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::copyWithZoneWrapper)));
		}

		if constexpr((mem4)(&$CCString::boolValue) != (der4)(&D::boolValue)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::boolValueWrapper)));
		}

		if constexpr((mem5)(&$CCString::doubleValue) != (der5)(&D::doubleValue)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::doubleValueWrapper)));
		}

		if constexpr((mem6)(&$CCString::floatValue) != (der6)(&D::floatValue)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::floatValueWrapper)));
		}

		if constexpr((mem7)(&$CCString::getCString) != (der7)(&D::getCString)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::getCStringWrapper)));
		}

		if constexpr((mem8)(&$CCString::intValue) != (der8)(&D::intValue)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::intValueWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTargetedTouchHandler : CCTargetedTouchHandler, InterfaceBase {
	$CCTargetedTouchHandler(const $CCTargetedTouchHandler& c) : CCTargetedTouchHandler(c) {}
	$CCTargetedTouchHandler() = delete;
	setInterfaceStaticTypesOf(0, CCTargetedTouchHandler, handlerWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool);
	setInterfaceTypesOf(1, CCTargetedTouchHandler, initWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool);
	static inline auto address0 = base+0x248010;
	static inline auto address1 = base+0x2480f0;
	static inline auto address2 = base+0x248180;

	dupable static getFunctionOf(CCTargetedTouchHandler, handlerWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2);
	}

	dupable getFunctionOf(CCTargetedTouchHandler, initWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	static getWrapperOf(CCTargetedTouchHandler, handlerWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool) {
		return D::handlerWithDelegate(p0, p1, p2);
	}

	getWrapperOf(CCTargetedTouchHandler, initWithDelegate, , 3, cocos2d::CCTouchDelegate*, int, bool) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0, p1, p2);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTargetedTouchHandler::handlerWithDelegate) != (der0)(&D::handlerWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::handlerWithDelegateWrapper)));
		}

		if ((mem1)(&$CCTargetedTouchHandler::initWithDelegate) != (der1)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCTargetedTouchHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCTexture2D : CCTexture2D, InterfaceBase {
	$CCTexture2D(const $CCTexture2D& c) : CCTexture2D(c) {}
	$CCTexture2D() = delete;
	setInterfaceTypesOf(2, CCTexture2D, getContentSize, , 0);
	setInterfaceTypesOf(3, CCTexture2D, getMaxS, , 0);
	setInterfaceTypesOf(4, CCTexture2D, getMaxT, , 0);
	setInterfaceTypesOf(5, CCTexture2D, getName, , 0);
	setInterfaceTypesOf(6, CCTexture2D, getPixelFormat, , 0);
	setInterfaceTypesOf(7, CCTexture2D, getPixelsHigh, , 0);
	setInterfaceTypesOf(8, CCTexture2D, getPixelsWide, , 0);
	setInterfaceTypesOf(9, CCTexture2D, getShaderProgram, , 0);
	setInterfaceTypesOf(11, CCTexture2D, initWithData, , 5, void const*, cocos2d::CCTexture2DPixelFormat, unsigned int, unsigned int, cocos2d::CCSize const&);
	setInterfaceTypesOf(12, CCTexture2D, setAliasTexParameters, , 0);
	setInterfaceTypesOf(13, CCTexture2D, setAntiAliasTexParameters, , 0);
	setInterfaceTypesOf(14, CCTexture2D, setMaxS, , 1, float);
	setInterfaceTypesOf(15, CCTexture2D, setMaxT, , 1, float);
	setInterfaceTypesOf(16, CCTexture2D, setShaderProgram, , 1, cocos2d::CCGLProgram*);
	setInterfaceTypesOf(17, CCTexture2D, initWithImage, , 1, cocos2d::CCImage*);
	setInterfaceTypesOf(18, CCTexture2D, setTexParameters, , 1, cocos2d::_ccTexParams*);
	static inline auto address0 = base+0x246350;
	static inline auto address1 = base+0x246280;
	static inline auto address2 = base+0x246460;
	static inline auto address3 = base+0x2464e0;
	static inline auto address4 = base+0x246500;
	static inline auto address5 = base+0x246450;
	static inline auto address6 = base+0x246420;
	static inline auto address7 = base+0x246440;
	static inline auto address8 = base+0x246430;
	static inline auto address9 = base+0x246520;
	static inline auto address11 = base+0x2465d0;
	static inline auto address12 = base+0x247a20;
	static inline auto address13 = base+0x247a80;
	static inline auto address14 = base+0x2464f0;
	static inline auto address15 = base+0x246510;
	static inline auto address16 = base+0x246530;
	static inline auto address17 = base+0x246940;
	static inline auto address18 = base+0x247980;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable getFunctionOf(CCTexture2D, getContentSize, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCTexture2D, getMaxS, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCTexture2D, getMaxT, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCTexture2D, getName, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCTexture2D, getPixelFormat, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCTexture2D, getPixelsHigh, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCTexture2D, getPixelsWide, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCTexture2D, getShaderProgram, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(CCTexture2D, initWithData, , 5, void const*, cocos2d::CCTexture2DPixelFormat, unsigned int, unsigned int, cocos2d::CCSize const&) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(CCTexture2D, setAliasTexParameters, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCTexture2D, setAntiAliasTexParameters, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(CCTexture2D, setMaxS, , 1, float) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(CCTexture2D, setMaxT, , 1, float) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(CCTexture2D, setShaderProgram, , 1, cocos2d::CCGLProgram*) {
		return reinterpret_cast<fun16>(address16)(this, p0);
	}

	dupable getFunctionOf(CCTexture2D, initWithImage, , 1, cocos2d::CCImage*) {
		return reinterpret_cast<fun17>(address17)(this, p0);
	}

	dupable getFunctionOf(CCTexture2D, setTexParameters, , 1, cocos2d::_ccTexParams*) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCTexture2D, getContentSize, , 0) {
		return reinterpret_cast<D*>(this)->D::getContentSize();
	}

	getWrapperOf(CCTexture2D, getMaxS, , 0) {
		return reinterpret_cast<D*>(this)->D::getMaxS();
	}

	getWrapperOf(CCTexture2D, getMaxT, , 0) {
		return reinterpret_cast<D*>(this)->D::getMaxT();
	}

	getWrapperOf(CCTexture2D, getName, , 0) {
		return reinterpret_cast<D*>(this)->D::getName();
	}

	getWrapperOf(CCTexture2D, getPixelFormat, , 0) {
		return reinterpret_cast<D*>(this)->D::getPixelFormat();
	}

	getWrapperOf(CCTexture2D, getPixelsHigh, , 0) {
		return reinterpret_cast<D*>(this)->D::getPixelsHigh();
	}

	getWrapperOf(CCTexture2D, getPixelsWide, , 0) {
		return reinterpret_cast<D*>(this)->D::getPixelsWide();
	}

	getWrapperOf(CCTexture2D, getShaderProgram, , 0) {
		return reinterpret_cast<D*>(this)->D::getShaderProgram();
	}

	getWrapperOf(CCTexture2D, initWithData, , 5, void const*, cocos2d::CCTexture2DPixelFormat, unsigned int, unsigned int, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::initWithData(p0, p1, p2, p3, p4);
	}

	getWrapperOf(CCTexture2D, setAliasTexParameters, , 0) {
		return reinterpret_cast<D*>(this)->D::setAliasTexParameters();
	}

	getWrapperOf(CCTexture2D, setAntiAliasTexParameters, , 0) {
		return reinterpret_cast<D*>(this)->D::setAntiAliasTexParameters();
	}

	getWrapperOf(CCTexture2D, setMaxS, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setMaxS(p0);
	}

	getWrapperOf(CCTexture2D, setMaxT, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setMaxT(p0);
	}

	getWrapperOf(CCTexture2D, setShaderProgram, , 1, cocos2d::CCGLProgram*) {
		return reinterpret_cast<D*>(this)->D::setShaderProgram(p0);
	}

	getWrapperOf(CCTexture2D, initWithImage, , 1, cocos2d::CCImage*) {
		return reinterpret_cast<D*>(this)->D::initWithImage(p0);
	}

	getWrapperOf(CCTexture2D, setTexParameters, , 1, cocos2d::_ccTexParams*) {
		return reinterpret_cast<D*>(this)->D::setTexParameters(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCTexture2D::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem2)(&$CCTexture2D::getContentSize) != (der2)(&D::getContentSize)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getContentSizeWrapper)));
		}

		if constexpr((mem3)(&$CCTexture2D::getMaxS) != (der3)(&D::getMaxS)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getMaxSWrapper)));
		}

		if constexpr((mem4)(&$CCTexture2D::getMaxT) != (der4)(&D::getMaxT)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::getMaxTWrapper)));
		}

		if constexpr((mem5)(&$CCTexture2D::getName) != (der5)(&D::getName)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::getNameWrapper)));
		}

		if constexpr((mem6)(&$CCTexture2D::getPixelFormat) != (der6)(&D::getPixelFormat)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::getPixelFormatWrapper)));
		}

		if constexpr((mem7)(&$CCTexture2D::getPixelsHigh) != (der7)(&D::getPixelsHigh)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::getPixelsHighWrapper)));
		}

		if constexpr((mem8)(&$CCTexture2D::getPixelsWide) != (der8)(&D::getPixelsWide)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::getPixelsWideWrapper)));
		}

		if constexpr((mem9)(&$CCTexture2D::getShaderProgram) != (der9)(&D::getShaderProgram)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::getShaderProgramWrapper)));
		}

		if constexpr((mem11)(&$CCTexture2D::initWithData) != (der11)(&D::initWithData)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::initWithDataWrapper)));
		}

		if constexpr((mem12)(&$CCTexture2D::setAliasTexParameters) != (der12)(&D::setAliasTexParameters)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::setAliasTexParametersWrapper)));
		}

		if constexpr((mem13)(&$CCTexture2D::setAntiAliasTexParameters) != (der13)(&D::setAntiAliasTexParameters)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::setAntiAliasTexParametersWrapper)));
		}

		if constexpr((mem14)(&$CCTexture2D::setMaxS) != (der14)(&D::setMaxS)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::setMaxSWrapper)));
		}

		if constexpr((mem15)(&$CCTexture2D::setMaxT) != (der15)(&D::setMaxT)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::setMaxTWrapper)));
		}

		if constexpr((mem16)(&$CCTexture2D::setShaderProgram) != (der16)(&D::setShaderProgram)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::setShaderProgramWrapper)));
		}

		if constexpr((mem17)(&$CCTexture2D::initWithImage) != (der17)(&D::initWithImage)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::initWithImageWrapper)));
		}

		if constexpr((mem18)(&$CCTexture2D::setTexParameters) != (der18)(&D::setTexParameters)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::setTexParametersWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTextureCache : CCTextureCache, InterfaceBase {
	$CCTextureCache(const $CCTextureCache& c) : CCTextureCache(c) {}
	$CCTextureCache() = delete;
	setInterfaceTypesOf(0, CCTextureCache, addImage, , 2, char const*, bool);
	setInterfaceStaticTypesOf(1, CCTextureCache, sharedTextureCache, , 0);
	static inline auto address0 = base+0x358120;
	static inline auto address1 = base+0x356e00;

	dupable getFunctionOf(CCTextureCache, addImage, , 2, char const*, bool) {
		return reinterpret_cast<fun0>(address0)(this, p0, p1);
	}

	dupable static getFunctionOf(CCTextureCache, sharedTextureCache, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	getWrapperOf(CCTextureCache, addImage, , 2, char const*, bool) {
		return reinterpret_cast<D*>(this)->D::addImage(p0, p1);
	}

	static getWrapperOf(CCTextureCache, sharedTextureCache, , 0) {
		return D::sharedTextureCache();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTextureCache::addImage) != (der0)(&D::addImage)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::addImageWrapper)));
		}

		if constexpr((mem1)(&$CCTextureCache::sharedTextureCache) != (der1)(&D::sharedTextureCache)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedTextureCacheWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTintTo : CCTintTo, InterfaceBase {
	$CCTintTo(const $CCTintTo& c) : CCTintTo(c) {}
	$CCTintTo() = delete;
	setInterfaceStaticTypesOf(0, CCTintTo, create, , 4, float, unsigned char, unsigned char, unsigned char);
	static inline auto address0 = base+0x1f82a0;

	dupable static getFunctionOf(CCTintTo, create, , 4, float, unsigned char, unsigned char, unsigned char) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	static getWrapperOf(CCTintTo, create, , 4, float, unsigned char, unsigned char, unsigned char) {
		return D::create(p0, p1, p2, p3);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTintTo::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTouch : CCTouch, InterfaceBase {
	$CCTouch(const $CCTouch& c) : CCTouch(c) {}
	$CCTouch() = delete;
	setInterfaceTypesOf(0, CCTouch, getDelta, const, 0);
	setInterfaceTypesOf(1, CCTouch, getLocationInView, const, 0);
	static inline auto address0 = base+0x38340;
	static inline auto address1 = base+0x38250;

	dupable getFunctionOf(CCTouch, getDelta, const, 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCTouch, getLocationInView, const, 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	getWrapperOf(CCTouch, getDelta, const, 0) {
		return reinterpret_cast<D*>(this)->D::getDelta();
	}

	getWrapperOf(CCTouch, getLocationInView, const, 0) {
		return reinterpret_cast<D*>(this)->D::getLocationInView();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTouch::getDelta) != (der0)(&D::getDelta)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::getDeltaWrapper)));
		}

		if constexpr((mem1)(&$CCTouch::getLocationInView) != (der1)(&D::getLocationInView)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getLocationInViewWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTouchDispatcher : CCTouchDispatcher, InterfaceBase {
	$CCTouchDispatcher(const $CCTouchDispatcher& c) : CCTouchDispatcher(c) {}
	$CCTouchDispatcher() = delete;
	setInterfaceTypesOf(0, CCTouchDispatcher, decrementForcePrio, , 1, int);
	setInterfaceTypesOf(1, CCTouchDispatcher, incrementForcePrio, , 1, int);
	static inline auto address0 = base+0x280f70;
	static inline auto address1 = base+0x280f60;

	dupable getFunctionOf(CCTouchDispatcher, decrementForcePrio, , 1, int) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CCTouchDispatcher, incrementForcePrio, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(CCTouchDispatcher, decrementForcePrio, , 1, int) {
		return reinterpret_cast<D*>(this)->D::decrementForcePrio(p0);
	}

	getWrapperOf(CCTouchDispatcher, incrementForcePrio, , 1, int) {
		return reinterpret_cast<D*>(this)->D::incrementForcePrio(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTouchDispatcher::decrementForcePrio) != (der0)(&D::decrementForcePrio)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::decrementForcePrioWrapper)));
		}

		if constexpr((mem1)(&$CCTouchDispatcher::incrementForcePrio) != (der1)(&D::incrementForcePrio)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::incrementForcePrioWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTouchHandler : CCTouchHandler, InterfaceBase {
	$CCTouchHandler(const $CCTouchHandler& c) : CCTouchHandler(c) {}
	$CCTouchHandler() = delete;
	setInterfaceTypesOf(0, CCTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int);
	static inline auto address0 = base+0x247d10;
	static inline auto address1 = base+0x247de0;

	dupable getFunctionOf(CCTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return reinterpret_cast<fun0>(address0)(this, p0, p1);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	getWrapperOf(CCTouchHandler, initWithDelegate, , 2, cocos2d::CCTouchDelegate*, int) {
		return reinterpret_cast<D*>(this)->D::initWithDelegate(p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if ((mem0)(&$CCTouchHandler::initWithDelegate) != (der0)(&D::initWithDelegate)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::initWithDelegateWrapper)));
		}

		if constexpr(&$CCTouchHandler::destructor != &D::destructor) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCTransitionFade : CCTransitionFade, InterfaceBase {
	$CCTransitionFade(const $CCTransitionFade& c) : CCTransitionFade(c) {}
	$CCTransitionFade() = delete;
	setInterfaceStaticTypesOf(0, CCTransitionFade, create, , 2, float, cocos2d::CCScene*);
	static inline auto address0 = base+0x8ea30;

	dupable static getFunctionOf(CCTransitionFade, create, , 2, float, cocos2d::CCScene*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(CCTransitionFade, create, , 2, float, cocos2d::CCScene*) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTransitionFade::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ZipUtils : ZipUtils, InterfaceBase {
	$ZipUtils(const $ZipUtils& c) : ZipUtils(c) {}
	$ZipUtils() = delete;
	setInterfaceStaticTypesOf(0, ZipUtils, compressString, , 3, gd::string, bool, int);
	setInterfaceStaticTypesOf(1, ZipUtils, decompressString, , 3, gd::string, bool, int);
	static inline auto address0 = base+0xe9a50;
	static inline auto address1 = base+0xea380;

	dupable static getFunctionOf(ZipUtils, compressString, , 3, gd::string, bool, int) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2);
	}

	dupable static getFunctionOf(ZipUtils, decompressString, , 3, gd::string, bool, int) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2);
	}

	static getWrapperOf(ZipUtils, compressString, , 3, gd::string, bool, int) {
		return D::compressString(p0, p1, p2);
	}

	static getWrapperOf(ZipUtils, decompressString, , 3, gd::string, bool, int) {
		return D::decompressString(p0, p1, p2);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ZipUtils::compressString) != (der0)(&D::compressString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::compressStringWrapper)));
		}

		if constexpr((mem1)(&$ZipUtils::decompressString) != (der1)(&D::decompressString)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::decompressStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCControlColourPicker : CCControlColourPicker, InterfaceBase {
	$CCControlColourPicker(const $CCControlColourPicker& c) : CCControlColourPicker(c) {}
	$CCControlColourPicker() = delete;
	setInterfaceTypesOf(0, CCControlColourPicker, setColorValue, , 1, cocos2d::_ccColor3B const&);
	static inline auto address0 = base+0x1aac10;

	dupable getFunctionOf(CCControlColourPicker, setColorValue, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(CCControlColourPicker, setColorValue, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColorValue(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCControlColourPicker::setColorValue) != (der0)(&D::setColorValue)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::setColorValueWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCControlUtils : CCControlUtils, InterfaceBase {
	$CCControlUtils(const $CCControlUtils& c) : CCControlUtils(c) {}
	$CCControlUtils() = delete;
	setInterfaceStaticTypesOf(0, CCControlUtils, HSVfromRGB, , 1, cocos2d::extension::RGBA);
	setInterfaceStaticTypesOf(1, CCControlUtils, RGBfromHSV, , 1, cocos2d::extension::HSV);
	static inline auto address0 = base+0x1e6750;
	static inline auto address1 = base+0x1e6850;

	dupable static getFunctionOf(CCControlUtils, HSVfromRGB, , 1, cocos2d::extension::RGBA) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable static getFunctionOf(CCControlUtils, RGBfromHSV, , 1, cocos2d::extension::HSV) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	static getWrapperOf(CCControlUtils, HSVfromRGB, , 1, cocos2d::extension::RGBA) {
		return D::HSVfromRGB(p0);
	}

	static getWrapperOf(CCControlUtils, RGBfromHSV, , 1, cocos2d::extension::HSV) {
		return D::RGBfromHSV(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCControlUtils::HSVfromRGB) != (der0)(&D::HSVfromRGB)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::HSVfromRGBWrapper)));
		}

		if constexpr((mem1)(&$CCControlUtils::RGBfromHSV) != (der1)(&D::RGBfromHSV)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::RGBfromHSVWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScale9Sprite : CCScale9Sprite, InterfaceBase {
	$CCScale9Sprite(const $CCScale9Sprite& c) : CCScale9Sprite(c) {}
	$CCScale9Sprite() = delete;
	setInterfaceStaticTypesOf(1, CCScale9Sprite, create, , 1, char const*);
	setInterfaceStaticTypesOf(2, CCScale9Sprite, create, , 2, char const*, cocos2d::CCRect);
	setInterfaceTypesOf(4, CCScale9Sprite, init, , 0);
	setInterfaceTypesOf(5, CCScale9Sprite, setContentSize, , 1, cocos2d::CCSize const&);
	setInterfaceTypesOf(6, CCScale9Sprite, visit, , 0);
	setInterfaceTypesOf(7, CCScale9Sprite, getOpacity, , 0);
	setInterfaceTypesOf(8, CCScale9Sprite, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(9, CCScale9Sprite, updateDisplayedOpacity, , 1, unsigned char);
	setInterfaceTypesOf(10, CCScale9Sprite, getColor, , 0);
	setInterfaceTypesOf(11, CCScale9Sprite, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(12, CCScale9Sprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(13, CCScale9Sprite, setOpacityModifyRGB, , 1, bool);
	setInterfaceTypesOf(14, CCScale9Sprite, isOpacityModifyRGB, , 0);
	setInterfaceTypesOf(15, CCScale9Sprite, getPreferredSize, , 0);
	setInterfaceTypesOf(16, CCScale9Sprite, setPreferredSize, , 1, cocos2d::CCSize);
	setInterfaceTypesOf(17, CCScale9Sprite, getCapInsets, , 0);
	setInterfaceTypesOf(18, CCScale9Sprite, setCapInsets, , 1, cocos2d::CCRect);
	setInterfaceTypesOf(19, CCScale9Sprite, getInsetLeft, , 0);
	setInterfaceTypesOf(20, CCScale9Sprite, setInsetLeft, , 1, float);
	setInterfaceTypesOf(21, CCScale9Sprite, getInsetTop, , 0);
	setInterfaceTypesOf(22, CCScale9Sprite, setInsetTop, , 1, float);
	setInterfaceTypesOf(23, CCScale9Sprite, getInsetRight, , 0);
	setInterfaceTypesOf(24, CCScale9Sprite, setInsetRight, , 1, float);
	setInterfaceTypesOf(25, CCScale9Sprite, getInsetBottom, , 0);
	setInterfaceTypesOf(26, CCScale9Sprite, setInsetBottom, , 1, float);
	setInterfaceTypesOf(27, CCScale9Sprite, initWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect);
	setInterfaceTypesOf(28, CCScale9Sprite, initWithBatchNode, , 3, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, cocos2d::CCRect);
	setInterfaceTypesOf(29, CCScale9Sprite, initWithFile, , 3, char const*, cocos2d::CCRect, cocos2d::CCRect);
	setInterfaceTypesOf(30, CCScale9Sprite, initWithFile, , 2, char const*, cocos2d::CCRect);
	setInterfaceTypesOf(31, CCScale9Sprite, initWithFile, , 2, cocos2d::CCRect, char const*);
	setInterfaceTypesOf(32, CCScale9Sprite, initWithFile, , 1, char const*);
	setInterfaceTypesOf(33, CCScale9Sprite, initWithSpriteFrame, , 2, cocos2d::CCSpriteFrame*, cocos2d::CCRect);
	setInterfaceTypesOf(34, CCScale9Sprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*);
	setInterfaceTypesOf(35, CCScale9Sprite, initWithSpriteFrameName, , 2, char const*, cocos2d::CCRect);
	setInterfaceTypesOf(36, CCScale9Sprite, initWithSpriteFrameName, , 1, char const*);
	setInterfaceTypesOf(37, CCScale9Sprite, updateWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect);
	setInterfaceTypesOf(38, CCScale9Sprite, setSpriteFrame, , 1, cocos2d::CCSpriteFrame*);
	static inline auto address0 = base+0x211330;
	static inline auto address1 = base+0x2130d0;
	static inline auto address2 = base+0x212ef0;
	static inline auto address3 = base+0x211590;
	static inline auto address4 = base+0x2115d0;
	static inline auto address5 = base+0x2127c0;
	static inline auto address6 = base+0x213bf0;
	static inline auto address7 = base+0x213f30;
	static inline auto address8 = base+0x213dd0;
	static inline auto address9 = base+0x2139b0;
	static inline auto address10 = base+0x213db0;
	static inline auto address11 = base+0x213c20;
	static inline auto address12 = base+0x213a20;
	static inline auto address13 = base+0x213830;
	static inline auto address14 = base+0x213990;
	static inline auto address15 = base+0x213620;
	static inline auto address16 = base+0x2135f0;
	static inline auto address17 = base+0x2136e0;
	static inline auto address18 = base+0x213640;
	static inline auto address19 = base+0x213b30;
	static inline auto address20 = base+0x213b70;
	static inline auto address21 = base+0x213b40;
	static inline auto address22 = base+0x213b90;
	static inline auto address23 = base+0x213b50;
	static inline auto address24 = base+0x213bb0;
	static inline auto address25 = base+0x213b60;
	static inline auto address26 = base+0x213bd0;
	static inline auto address27 = base+0x211690;
	static inline auto address28 = base+0x211630;
	static inline auto address29 = base+0x212d50;
	static inline auto address30 = base+0x212e80;
	static inline auto address31 = base+0x212f80;
	static inline auto address32 = base+0x213080;
	static inline auto address33 = base+0x213140;
	static inline auto address34 = base+0x213250;
	static inline auto address35 = base+0x213310;
	static inline auto address36 = base+0x213410;
	static inline auto address37 = base+0x211730;
	static inline auto address38 = base+0x213a90;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable static getFunctionOf(CCScale9Sprite, create, , 1, char const*) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	dupable static getFunctionOf(CCScale9Sprite, create, , 2, char const*, cocos2d::CCRect) {
		return reinterpret_cast<fun2>(address2)(p0, p1);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address3)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, init, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, visit, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, getOpacity, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getColor, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, setOpacityModifyRGB, , 1, bool) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, isOpacityModifyRGB, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, getPreferredSize, , 0) {
		return reinterpret_cast<fun15>(address15)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setPreferredSize, , 1, cocos2d::CCSize) {
		return reinterpret_cast<fun16>(address16)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getCapInsets, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setCapInsets, , 1, cocos2d::CCRect) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getInsetLeft, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setInsetLeft, , 1, float) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getInsetTop, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setInsetTop, , 1, float) {
		return reinterpret_cast<fun22>(address22)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getInsetRight, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setInsetRight, , 1, float) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, getInsetBottom, , 0) {
		return reinterpret_cast<fun25>(address25)(this);
	}

	dupable getFunctionOf(CCScale9Sprite, setInsetBottom, , 1, float) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect) {
		return reinterpret_cast<fun27>(address27)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithBatchNode, , 3, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, cocos2d::CCRect) {
		return reinterpret_cast<fun28>(address28)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithFile, , 3, char const*, cocos2d::CCRect, cocos2d::CCRect) {
		return reinterpret_cast<fun29>(address29)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithFile, , 2, char const*, cocos2d::CCRect) {
		return reinterpret_cast<fun30>(address30)(this, p0, p1);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithFile, , 2, cocos2d::CCRect, char const*) {
		return reinterpret_cast<fun31>(address31)(this, p0, p1);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithFile, , 1, char const*) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithSpriteFrame, , 2, cocos2d::CCSpriteFrame*, cocos2d::CCRect) {
		return reinterpret_cast<fun33>(address33)(this, p0, p1);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithSpriteFrameName, , 2, char const*, cocos2d::CCRect) {
		return reinterpret_cast<fun35>(address35)(this, p0, p1);
	}

	dupable getFunctionOf(CCScale9Sprite, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<fun36>(address36)(this, p0);
	}

	dupable getFunctionOf(CCScale9Sprite, updateWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect) {
		return reinterpret_cast<fun37>(address37)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCScale9Sprite, setSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<fun38>(address38)(this, p0);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	static getWrapperOf(CCScale9Sprite, create, , 1, char const*) {
		return D::create(p0);
	}

	static getWrapperOf(CCScale9Sprite, create, , 2, char const*, cocos2d::CCRect) {
		return D::create(p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCScale9Sprite, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCScale9Sprite, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::setContentSize(p0);
	}

	getWrapperOf(CCScale9Sprite, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(CCScale9Sprite, getOpacity, , 0) {
		return reinterpret_cast<D*>(this)->D::getOpacity();
	}

	getWrapperOf(CCScale9Sprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(CCScale9Sprite, updateDisplayedOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedOpacity(p0);
	}

	getWrapperOf(CCScale9Sprite, getColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getColor();
	}

	getWrapperOf(CCScale9Sprite, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(CCScale9Sprite, updateDisplayedColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::updateDisplayedColor(p0);
	}

	getWrapperOf(CCScale9Sprite, setOpacityModifyRGB, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setOpacityModifyRGB(p0);
	}

	getWrapperOf(CCScale9Sprite, isOpacityModifyRGB, , 0) {
		return reinterpret_cast<D*>(this)->D::isOpacityModifyRGB();
	}

	getWrapperOf(CCScale9Sprite, getPreferredSize, , 0) {
		return reinterpret_cast<D*>(this)->D::getPreferredSize();
	}

	getWrapperOf(CCScale9Sprite, setPreferredSize, , 1, cocos2d::CCSize) {
		return reinterpret_cast<D*>(this)->D::setPreferredSize(p0);
	}

	getWrapperOf(CCScale9Sprite, getCapInsets, , 0) {
		return reinterpret_cast<D*>(this)->D::getCapInsets();
	}

	getWrapperOf(CCScale9Sprite, setCapInsets, , 1, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::setCapInsets(p0);
	}

	getWrapperOf(CCScale9Sprite, getInsetLeft, , 0) {
		return reinterpret_cast<D*>(this)->D::getInsetLeft();
	}

	getWrapperOf(CCScale9Sprite, setInsetLeft, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setInsetLeft(p0);
	}

	getWrapperOf(CCScale9Sprite, getInsetTop, , 0) {
		return reinterpret_cast<D*>(this)->D::getInsetTop();
	}

	getWrapperOf(CCScale9Sprite, setInsetTop, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setInsetTop(p0);
	}

	getWrapperOf(CCScale9Sprite, getInsetRight, , 0) {
		return reinterpret_cast<D*>(this)->D::getInsetRight();
	}

	getWrapperOf(CCScale9Sprite, setInsetRight, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setInsetRight(p0);
	}

	getWrapperOf(CCScale9Sprite, getInsetBottom, , 0) {
		return reinterpret_cast<D*>(this)->D::getInsetBottom();
	}

	getWrapperOf(CCScale9Sprite, setInsetBottom, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setInsetBottom(p0);
	}

	getWrapperOf(CCScale9Sprite, initWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithBatchNode(p0, p1, p2, p3);
	}

	getWrapperOf(CCScale9Sprite, initWithBatchNode, , 3, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithBatchNode(p0, p1, p2);
	}

	getWrapperOf(CCScale9Sprite, initWithFile, , 3, char const*, cocos2d::CCRect, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0, p1, p2);
	}

	getWrapperOf(CCScale9Sprite, initWithFile, , 2, char const*, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0, p1);
	}

	getWrapperOf(CCScale9Sprite, initWithFile, , 2, cocos2d::CCRect, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0, p1);
	}

	getWrapperOf(CCScale9Sprite, initWithFile, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithFile(p0);
	}

	getWrapperOf(CCScale9Sprite, initWithSpriteFrame, , 2, cocos2d::CCSpriteFrame*, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrame(p0, p1);
	}

	getWrapperOf(CCScale9Sprite, initWithSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrame(p0);
	}

	getWrapperOf(CCScale9Sprite, initWithSpriteFrameName, , 2, char const*, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrameName(p0, p1);
	}

	getWrapperOf(CCScale9Sprite, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrameName(p0);
	}

	getWrapperOf(CCScale9Sprite, updateWithBatchNode, , 4, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::updateWithBatchNode(p0, p1, p2, p3);
	}

	getWrapperOf(CCScale9Sprite, setSpriteFrame, , 1, cocos2d::CCSpriteFrame*) {
		return reinterpret_cast<D*>(this)->D::setSpriteFrame(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$CCScale9Sprite::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$CCScale9Sprite::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		if constexpr(&$CCScale9Sprite::destructor != &D::destructor) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem4)(&$CCScale9Sprite::init) != (der4)(&D::init)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::initWrapper)));
		}

		if ((mem5)(&$CCScale9Sprite::setContentSize) != (der5)(&D::setContentSize)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setContentSizeWrapper)));
		}

		if ((mem6)(&$CCScale9Sprite::visit) != (der6)(&D::visit)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::visitWrapper)));
		}

		if ((mem7)(&$CCScale9Sprite::getOpacity) != (der7)(&D::getOpacity)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::getOpacityWrapper)));
		}

		if ((mem8)(&$CCScale9Sprite::setOpacity) != (der8)(&D::setOpacity)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setOpacityWrapper)));
		}

		if ((mem9)(&$CCScale9Sprite::updateDisplayedOpacity) != (der9)(&D::updateDisplayedOpacity)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::updateDisplayedOpacityWrapper)));
		}

		if ((mem10)(&$CCScale9Sprite::getColor) != (der10)(&D::getColor)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::getColorWrapper)));
		}

		if ((mem11)(&$CCScale9Sprite::setColor) != (der11)(&D::setColor)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setColorWrapper)));
		}

		if ((mem12)(&$CCScale9Sprite::updateDisplayedColor) != (der12)(&D::updateDisplayedColor)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::updateDisplayedColorWrapper)));
		}

		if ((mem13)(&$CCScale9Sprite::setOpacityModifyRGB) != (der13)(&D::setOpacityModifyRGB)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::setOpacityModifyRGBWrapper)));
		}

		if ((mem14)(&$CCScale9Sprite::isOpacityModifyRGB) != (der14)(&D::isOpacityModifyRGB)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::isOpacityModifyRGBWrapper)));
		}

		if ((mem15)(&$CCScale9Sprite::getPreferredSize) != (der15)(&D::getPreferredSize)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::getPreferredSizeWrapper)));
		}

		if ((mem16)(&$CCScale9Sprite::setPreferredSize) != (der16)(&D::setPreferredSize)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfVirtual((der16)(&D::setPreferredSizeWrapper)));
		}

		if ((mem17)(&$CCScale9Sprite::getCapInsets) != (der17)(&D::getCapInsets)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfVirtual((der17)(&D::getCapInsetsWrapper)));
		}

		if ((mem18)(&$CCScale9Sprite::setCapInsets) != (der18)(&D::setCapInsets)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfVirtual((der18)(&D::setCapInsetsWrapper)));
		}

		if ((mem19)(&$CCScale9Sprite::getInsetLeft) != (der19)(&D::getInsetLeft)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfVirtual((der19)(&D::getInsetLeftWrapper)));
		}

		if ((mem20)(&$CCScale9Sprite::setInsetLeft) != (der20)(&D::setInsetLeft)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfVirtual((der20)(&D::setInsetLeftWrapper)));
		}

		if ((mem21)(&$CCScale9Sprite::getInsetTop) != (der21)(&D::getInsetTop)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfVirtual((der21)(&D::getInsetTopWrapper)));
		}

		if ((mem22)(&$CCScale9Sprite::setInsetTop) != (der22)(&D::setInsetTop)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfVirtual((der22)(&D::setInsetTopWrapper)));
		}

		if ((mem23)(&$CCScale9Sprite::getInsetRight) != (der23)(&D::getInsetRight)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfVirtual((der23)(&D::getInsetRightWrapper)));
		}

		if ((mem24)(&$CCScale9Sprite::setInsetRight) != (der24)(&D::setInsetRight)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfVirtual((der24)(&D::setInsetRightWrapper)));
		}

		if ((mem25)(&$CCScale9Sprite::getInsetBottom) != (der25)(&D::getInsetBottom)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfVirtual((der25)(&D::getInsetBottomWrapper)));
		}

		if ((mem26)(&$CCScale9Sprite::setInsetBottom) != (der26)(&D::setInsetBottom)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfVirtual((der26)(&D::setInsetBottomWrapper)));
		}

		if ((mem27)(&$CCScale9Sprite::initWithBatchNode) != (der27)(&D::initWithBatchNode)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfVirtual((der27)(&D::initWithBatchNodeWrapper)));
		}

		if ((mem28)(&$CCScale9Sprite::initWithBatchNode) != (der28)(&D::initWithBatchNode)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfVirtual((der28)(&D::initWithBatchNodeWrapper)));
		}

		if ((mem29)(&$CCScale9Sprite::initWithFile) != (der29)(&D::initWithFile)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfVirtual((der29)(&D::initWithFileWrapper)));
		}

		if ((mem30)(&$CCScale9Sprite::initWithFile) != (der30)(&D::initWithFile)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfVirtual((der30)(&D::initWithFileWrapper)));
		}

		if ((mem31)(&$CCScale9Sprite::initWithFile) != (der31)(&D::initWithFile)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfVirtual((der31)(&D::initWithFileWrapper)));
		}

		if ((mem32)(&$CCScale9Sprite::initWithFile) != (der32)(&D::initWithFile)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfVirtual((der32)(&D::initWithFileWrapper)));
		}

		if ((mem33)(&$CCScale9Sprite::initWithSpriteFrame) != (der33)(&D::initWithSpriteFrame)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfVirtual((der33)(&D::initWithSpriteFrameWrapper)));
		}

		if ((mem34)(&$CCScale9Sprite::initWithSpriteFrame) != (der34)(&D::initWithSpriteFrame)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfVirtual((der34)(&D::initWithSpriteFrameWrapper)));
		}

		if ((mem35)(&$CCScale9Sprite::initWithSpriteFrameName) != (der35)(&D::initWithSpriteFrameName)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfVirtual((der35)(&D::initWithSpriteFrameNameWrapper)));
		}

		if ((mem36)(&$CCScale9Sprite::initWithSpriteFrameName) != (der36)(&D::initWithSpriteFrameName)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfVirtual((der36)(&D::initWithSpriteFrameNameWrapper)));
		}

		if ((mem37)(&$CCScale9Sprite::updateWithBatchNode) != (der37)(&D::updateWithBatchNode)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfVirtual((der37)(&D::updateWithBatchNodeWrapper)));
		}

		if ((mem38)(&$CCScale9Sprite::setSpriteFrame) != (der38)(&D::setSpriteFrame)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfVirtual((der38)(&D::setSpriteFrameWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScrollView : CCScrollView, InterfaceBase {
	$CCScrollView(const $CCScrollView& c) : CCScrollView(c) {}
	$CCScrollView() = delete;
	setInterfaceTypesOf(2, CCScrollView, init, , 0);
	setInterfaceTypesOf(3, CCScrollView, setContentSize, , 1, cocos2d::CCSize const&);
	setInterfaceTypesOf(4, CCScrollView, getContentSize, const, 0);
	setInterfaceTypesOf(5, CCScrollView, addChild, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(6, CCScrollView, addChild, , 2, cocos2d::CCNode*, int);
	setInterfaceTypesOf(7, CCScrollView, addChild, , 3, cocos2d::CCNode*, int, int);
	setInterfaceTypesOf(8, CCScrollView, visit, , 0);
	setInterfaceTypesOf(9, CCScrollView, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(10, CCScrollView, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(11, CCScrollView, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(12, CCScrollView, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(13, CCScrollView, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(14, CCScrollView, setTouchEnabled, , 1, bool);
	static inline auto address0 = base+0x214800;
	static inline auto address1 = base+0x214c30;
	static inline auto address2 = base+0x214fb0;
	static inline auto address3 = base+0x215eb0;
	static inline auto address4 = base+0x215e90;
	static inline auto address5 = base+0x216160;
	static inline auto address6 = base+0x216120;
	static inline auto address7 = base+0x216080;
	static inline auto address8 = base+0x2164a0;
	static inline auto address9 = base+0x216620;
	static inline auto address10 = base+0x216890;
	static inline auto address11 = base+0x216c70;
	static inline auto address12 = base+0x216d30;
	static inline auto address13 = base+0x214ff0;
	static inline auto address14 = base+0x215250;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address1)(this);
	}

	dupable getFunctionOf(CCScrollView, init, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCScrollView, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCScrollView, getContentSize, const, 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCScrollView, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCScrollView, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollView, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<fun7>(address7)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCScrollView, visit, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCScrollView, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollView, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollView, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollView, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun12>(address12)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollView, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(CCScrollView, setTouchEnabled, , 1, bool) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCScrollView, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCScrollView, setContentSize, , 1, cocos2d::CCSize const&) {
		return reinterpret_cast<D*>(this)->D::setContentSize(p0);
	}

	getWrapperOf(CCScrollView, getContentSize, const, 0) {
		return reinterpret_cast<D*>(this)->D::getContentSize();
	}

	getWrapperOf(CCScrollView, addChild, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::addChild(p0);
	}

	getWrapperOf(CCScrollView, addChild, , 2, cocos2d::CCNode*, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1);
	}

	getWrapperOf(CCScrollView, addChild, , 3, cocos2d::CCNode*, int, int) {
		return reinterpret_cast<D*>(this)->D::addChild(p0, p1, p2);
	}

	getWrapperOf(CCScrollView, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(CCScrollView, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(CCScrollView, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(CCScrollView, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(CCScrollView, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(CCScrollView, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(CCScrollView, setTouchEnabled, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setTouchEnabled(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCScrollView::destructor != &D::destructor) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem2)(&$CCScrollView::init) != (der2)(&D::init)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::initWrapper)));
		}

		if ((mem3)(&$CCScrollView::setContentSize) != (der3)(&D::setContentSize)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setContentSizeWrapper)));
		}

		if ((mem4)(&$CCScrollView::getContentSize) != (der4)(&D::getContentSize)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::getContentSizeWrapper)));
		}

		if ((mem5)(&$CCScrollView::addChild) != (der5)(&D::addChild)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::addChildWrapper)));
		}

		if ((mem6)(&$CCScrollView::addChild) != (der6)(&D::addChild)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::addChildWrapper)));
		}

		if ((mem7)(&$CCScrollView::addChild) != (der7)(&D::addChild)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::addChildWrapper)));
		}

		if ((mem8)(&$CCScrollView::visit) != (der8)(&D::visit)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::visitWrapper)));
		}

		if ((mem9)(&$CCScrollView::ccTouchBegan) != (der9)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::ccTouchBeganWrapper)));
		}

		if ((mem10)(&$CCScrollView::ccTouchMoved) != (der10)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::ccTouchMovedWrapper)));
		}

		if ((mem11)(&$CCScrollView::ccTouchEnded) != (der11)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::ccTouchEndedWrapper)));
		}

		if ((mem12)(&$CCScrollView::ccTouchCancelled) != (der12)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::ccTouchCancelledWrapper)));
		}

		if ((mem13)(&$CCScrollView::registerWithTouchDispatcher) != (der13)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::registerWithTouchDispatcherWrapper)));
		}

		if ((mem14)(&$CCScrollView::setTouchEnabled) != (der14)(&D::setTouchEnabled)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::setTouchEnabledWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AchievementCell : AchievementCell, InterfaceBase {
	$AchievementCell(const $AchievementCell& c) : AchievementCell(c) {}
	$AchievementCell() = delete;
	setInterfaceTypesOf(0, AchievementCell, loadFromDict, , 1, cocos2d::CCDictionary*);
	static inline auto address0 = base+0x10eaa0;

	dupable getFunctionOf(AchievementCell, loadFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(AchievementCell, loadFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<D*>(this)->D::loadFromDict(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AchievementCell::loadFromDict) != (der0)(&D::loadFromDict)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::loadFromDictWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AchievementManager : AchievementManager, InterfaceBase {
	$AchievementManager(const $AchievementManager& c) : AchievementManager(c) {}
	$AchievementManager() = delete;
	setInterfaceTypesOf(0, AchievementManager, getAllAchievements, , 0);
	setInterfaceTypesOf(1, AchievementManager, sharedState, , 0);
	static inline auto address0 = base+0x434d60;
	static inline auto address1 = base+0x424420;

	dupable getFunctionOf(AchievementManager, getAllAchievements, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(AchievementManager, sharedState, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	getWrapperOf(AchievementManager, getAllAchievements, , 0) {
		return reinterpret_cast<D*>(this)->D::getAllAchievements();
	}

	getWrapperOf(AchievementManager, sharedState, , 0) {
		return reinterpret_cast<D*>(this)->D::sharedState();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AchievementManager::getAllAchievements) != (der0)(&D::getAllAchievements)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::getAllAchievementsWrapper)));
		}

		if constexpr((mem1)(&$AchievementManager::sharedState) != (der1)(&D::sharedState)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedStateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AchievementNotifier : AchievementNotifier, InterfaceBase {
	$AchievementNotifier(const $AchievementNotifier& c) : AchievementNotifier(c) {}
	$AchievementNotifier() = delete;
	setInterfaceTypesOf(0, AchievementNotifier, sharedState, , 0);
	setInterfaceTypesOf(1, AchievementNotifier, willSwitchToScene, , 1, cocos2d::CCScene*);
	static inline auto address0 = base+0x464e00;
	static inline auto address1 = base+0x4650b0;

	dupable getFunctionOf(AchievementNotifier, sharedState, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(AchievementNotifier, willSwitchToScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(AchievementNotifier, sharedState, , 0) {
		return reinterpret_cast<D*>(this)->D::sharedState();
	}

	getWrapperOf(AchievementNotifier, willSwitchToScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<D*>(this)->D::willSwitchToScene(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AchievementNotifier::sharedState) != (der0)(&D::sharedState)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::sharedStateWrapper)));
		}

		if constexpr((mem1)(&$AchievementNotifier::willSwitchToScene) != (der1)(&D::willSwitchToScene)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::willSwitchToSceneWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AchievementsLayer : AchievementsLayer, InterfaceBase {
	$AchievementsLayer(const $AchievementsLayer& c) : AchievementsLayer(c) {}
	$AchievementsLayer() = delete;
	setInterfaceTypesOf(0, AchievementsLayer, customSetup, , 0);
	setInterfaceTypesOf(1, AchievementsLayer, loadPage, , 1, int);
	static inline auto address0 = base+0x1bdea0;
	static inline auto address1 = base+0x1be190;

	dupable getFunctionOf(AchievementsLayer, customSetup, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(AchievementsLayer, loadPage, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(AchievementsLayer, customSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::customSetup();
	}

	getWrapperOf(AchievementsLayer, loadPage, , 1, int) {
		return reinterpret_cast<D*>(this)->D::loadPage(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AchievementsLayer::customSetup) != (der0)(&D::customSetup)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::customSetupWrapper)));
		}

		if constexpr((mem1)(&$AchievementsLayer::loadPage) != (der1)(&D::loadPage)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::loadPageWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AnimatedGameObject : AnimatedGameObject, InterfaceBase {
	$AnimatedGameObject(const $AnimatedGameObject& c) : AnimatedGameObject(c) {}
	$AnimatedGameObject() = delete;
	setInterfaceTypesOf(0, AnimatedGameObject, playAnimation, , 1, int);
	setInterfaceTypesOf(1, AnimatedGameObject, updateChildSpriteColor, , 1, cocos2d::_ccColor3B);
	static inline auto address0 = base+0xc93d0;
	static inline auto address1 = base+0xc8450;

	dupable getFunctionOf(AnimatedGameObject, playAnimation, , 1, int) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(AnimatedGameObject, updateChildSpriteColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(AnimatedGameObject, playAnimation, , 1, int) {
		return reinterpret_cast<D*>(this)->D::playAnimation(p0);
	}

	getWrapperOf(AnimatedGameObject, updateChildSpriteColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::updateChildSpriteColor(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AnimatedGameObject::playAnimation) != (der0)(&D::playAnimation)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::playAnimationWrapper)));
		}

		if constexpr((mem1)(&$AnimatedGameObject::updateChildSpriteColor) != (der1)(&D::updateChildSpriteColor)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::updateChildSpriteColorWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AppDelegate : AppDelegate, InterfaceBase {
	$AppDelegate(const $AppDelegate& c) : AppDelegate(c) {}
	$AppDelegate() = delete;
	setInterfaceTypesOf(0, AppDelegate, bgScale, , 0);
	setInterfaceTypesOf(1, AppDelegate, applicationDidFinishLaunching, , 0);
	setInterfaceTypesOf(2, AppDelegate, applicationDidEnterBackground, , 0);
	setInterfaceTypesOf(3, AppDelegate, applicationWillEnterForeground, , 0);
	setInterfaceTypesOf(4, AppDelegate, applicationWillBecomeActive, , 0);
	setInterfaceTypesOf(5, AppDelegate, applicationWillResignActive, , 0);
	setInterfaceTypesOf(6, AppDelegate, trySaveGame, , 0);
	setInterfaceTypesOf(7, AppDelegate, willSwitchToScene, , 1, cocos2d::CCScene*);
	setInterfaceStaticTypesOf(8, AppDelegate, get, , 0);
	static inline auto address0 = base+0x3aaab0;
	static inline auto address1 = base+0x3aa900;
	static inline auto address2 = base+0x3aabe0;
	static inline auto address3 = base+0x3aac80;
	static inline auto address4 = base+0x3aab30;
	static inline auto address5 = base+0x3aab50;
	static inline auto address6 = base+0x3aaf10;
	static inline auto address7 = base+0x3aaf40;
	static inline auto address8 = base+0x3aab10;

	dupable getFunctionOf(AppDelegate, bgScale, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(AppDelegate, applicationDidFinishLaunching, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(AppDelegate, applicationDidEnterBackground, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(AppDelegate, applicationWillEnterForeground, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(AppDelegate, applicationWillBecomeActive, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(AppDelegate, applicationWillResignActive, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(AppDelegate, trySaveGame, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(AppDelegate, willSwitchToScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable static getFunctionOf(AppDelegate, get, , 0) {
		return reinterpret_cast<fun8>(address8)();
	}

	getWrapperOf(AppDelegate, bgScale, , 0) {
		return reinterpret_cast<D*>(this)->D::bgScale();
	}

	getWrapperOf(AppDelegate, applicationDidFinishLaunching, , 0) {
		return reinterpret_cast<D*>(this)->D::applicationDidFinishLaunching();
	}

	getWrapperOf(AppDelegate, applicationDidEnterBackground, , 0) {
		return reinterpret_cast<D*>(this)->D::applicationDidEnterBackground();
	}

	getWrapperOf(AppDelegate, applicationWillEnterForeground, , 0) {
		return reinterpret_cast<D*>(this)->D::applicationWillEnterForeground();
	}

	getWrapperOf(AppDelegate, applicationWillBecomeActive, , 0) {
		return reinterpret_cast<D*>(this)->D::applicationWillBecomeActive();
	}

	getWrapperOf(AppDelegate, applicationWillResignActive, , 0) {
		return reinterpret_cast<D*>(this)->D::applicationWillResignActive();
	}

	getWrapperOf(AppDelegate, trySaveGame, , 0) {
		return reinterpret_cast<D*>(this)->D::trySaveGame();
	}

	getWrapperOf(AppDelegate, willSwitchToScene, , 1, cocos2d::CCScene*) {
		return reinterpret_cast<D*>(this)->D::willSwitchToScene(p0);
	}

	static getWrapperOf(AppDelegate, get, , 0) {
		return D::get();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AppDelegate::bgScale) != (der0)(&D::bgScale)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::bgScaleWrapper)));
		}

		if ((mem1)(&$AppDelegate::applicationDidFinishLaunching) != (der1)(&D::applicationDidFinishLaunching)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::applicationDidFinishLaunchingWrapper)));
		}

		if ((mem2)(&$AppDelegate::applicationDidEnterBackground) != (der2)(&D::applicationDidEnterBackground)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::applicationDidEnterBackgroundWrapper)));
		}

		if ((mem3)(&$AppDelegate::applicationWillEnterForeground) != (der3)(&D::applicationWillEnterForeground)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::applicationWillEnterForegroundWrapper)));
		}

		if ((mem4)(&$AppDelegate::applicationWillBecomeActive) != (der4)(&D::applicationWillBecomeActive)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::applicationWillBecomeActiveWrapper)));
		}

		if ((mem5)(&$AppDelegate::applicationWillResignActive) != (der5)(&D::applicationWillResignActive)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::applicationWillResignActiveWrapper)));
		}

		if ((mem6)(&$AppDelegate::trySaveGame) != (der6)(&D::trySaveGame)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::trySaveGameWrapper)));
		}

		if ((mem7)(&$AppDelegate::willSwitchToScene) != (der7)(&D::willSwitchToScene)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::willSwitchToSceneWrapper)));
		}

		if constexpr((mem8)(&$AppDelegate::get) != (der8)(&D::get)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::getWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ArtistCell : ArtistCell, InterfaceBase {
	$ArtistCell(const $ArtistCell& c) : ArtistCell(c) {}
	$ArtistCell() = delete;
	setInterfaceTypesOf(0, ArtistCell, draw, , 0);
	setInterfaceTypesOf(1, ArtistCell, init, , 0);
	setInterfaceTypesOf(2, ArtistCell, loadFromObject, , 1, SongInfoObject*);
	setInterfaceTypesOf(3, ArtistCell, onNewgrounds, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(4, ArtistCell, updateBGColor, , 1, int);
	static inline auto address0 = base+0x11c980;
	static inline auto address1 = base+0x11c7c0;
	static inline auto address2 = base+0x1118b0;
	static inline auto address3 = base+0x11c7e0;
	static inline auto address4 = base+0x110460;

	dupable getFunctionOf(ArtistCell, draw, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(ArtistCell, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(ArtistCell, loadFromObject, , 1, SongInfoObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(ArtistCell, onNewgrounds, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(ArtistCell, updateBGColor, , 1, int) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	getWrapperOf(ArtistCell, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(ArtistCell, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(ArtistCell, loadFromObject, , 1, SongInfoObject*) {
		return reinterpret_cast<D*>(this)->D::loadFromObject(p0);
	}

	getWrapperOf(ArtistCell, onNewgrounds, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onNewgrounds(p0);
	}

	getWrapperOf(ArtistCell, updateBGColor, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updateBGColor(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ArtistCell::draw) != (der0)(&D::draw)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::drawWrapper)));
		}

		if constexpr((mem1)(&$ArtistCell::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$ArtistCell::loadFromObject) != (der2)(&D::loadFromObject)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::loadFromObjectWrapper)));
		}

		if constexpr((mem3)(&$ArtistCell::onNewgrounds) != (der3)(&D::onNewgrounds)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::onNewgroundsWrapper)));
		}

		if constexpr((mem4)(&$ArtistCell::updateBGColor) != (der4)(&D::updateBGColor)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::updateBGColorWrapper)));
		}

		return true;
	}
};

template<class D>
struct $AudioEffectsLayer : AudioEffectsLayer, InterfaceBase {
	$AudioEffectsLayer(const $AudioEffectsLayer& c) : AudioEffectsLayer(c) {}
	$AudioEffectsLayer() = delete;
	setInterfaceTypesOf(0, AudioEffectsLayer, audioStep, , 1, float);
	setInterfaceStaticTypesOf(1, AudioEffectsLayer, create, , 1, gd::string);
	setInterfaceTypesOf(2, AudioEffectsLayer, resetAudioVars, , 0);
	static inline auto address0 = base+0x271f40;
	static inline auto address1 = base+0x271a00;
	static inline auto address2 = base+0x271ee0;

	dupable getFunctionOf(AudioEffectsLayer, audioStep, , 1, float) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable static getFunctionOf(AudioEffectsLayer, create, , 1, gd::string) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	dupable getFunctionOf(AudioEffectsLayer, resetAudioVars, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	getWrapperOf(AudioEffectsLayer, audioStep, , 1, float) {
		return reinterpret_cast<D*>(this)->D::audioStep(p0);
	}

	static getWrapperOf(AudioEffectsLayer, create, , 1, gd::string) {
		return D::create(p0);
	}

	getWrapperOf(AudioEffectsLayer, resetAudioVars, , 0) {
		return reinterpret_cast<D*>(this)->D::resetAudioVars();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$AudioEffectsLayer::audioStep) != (der0)(&D::audioStep)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::audioStepWrapper)));
		}

		if constexpr((mem1)(&$AudioEffectsLayer::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$AudioEffectsLayer::resetAudioVars) != (der2)(&D::resetAudioVars)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::resetAudioVarsWrapper)));
		}

		return true;
	}
};

template<class D>
struct $BoomListView : BoomListView, InterfaceBase {
	$BoomListView(const $BoomListView& c) : BoomListView(c) {}
	$BoomListView() = delete;
	setInterfaceStaticTypesOf(0, BoomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType);
	setInterfaceTypesOf(1, BoomListView, init, , 5, cocos2d::CCArray*, float, float, int, BoomListType);
	setInterfaceTypesOf(2, BoomListView, draw, , 0);
	setInterfaceTypesOf(3, BoomListView, setupList, , 0);
	setInterfaceTypesOf(4, BoomListView, TableViewWillDisplayCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*);
	setInterfaceTypesOf(5, BoomListView, cellHeightForRowAtIndexPath, , 2, CCIndexPath&, TableView*);
	setInterfaceTypesOf(6, BoomListView, didSelectRowAtIndexPath, , 2, CCIndexPath&, TableView*);
	setInterfaceTypesOf(7, BoomListView, numberOfRowsInSection, , 2, unsigned int, TableView*);
	setInterfaceTypesOf(8, BoomListView, numberOfSectionsInTableView, , 1, TableView*);
	setInterfaceTypesOf(9, BoomListView, cellForRowAtIndexPath, , 2, CCIndexPath&, TableView*);
	setInterfaceTypesOf(10, BoomListView, TableViewCommitCellEditingStyleForRowAtIndexPath, , 3, TableView*, TableViewCellEditingStyle, CCIndexPath&);
	setInterfaceTypesOf(11, BoomListView, TableViewWillReloadCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*);
	setInterfaceTypesOf(12, BoomListView, getListCell, , 1, char const*);
	setInterfaceTypesOf(13, BoomListView, loadCell, , 2, TableViewCell*, int);
	static inline auto address0 = base+0x18ecb0;
	static inline auto address1 = base+0x18ee00;
	static inline auto address2 = base+0x18f790;
	static inline auto address3 = base+0x18ef90;
	static inline auto address4 = base+0x18f030;
	static inline auto address5 = base+0x18f070;
	static inline auto address6 = base+0x18f090;
	static inline auto address7 = base+0x18f0b0;
	static inline auto address8 = base+0x18f0e0;
	static inline auto address9 = base+0x18f100;
	static inline auto address10 = base+0x18f770;
	static inline auto address11 = base+0x18f050;
	static inline auto address12 = base+0x18f200;
	static inline auto address13 = base+0x18f4a0;

	dupable static getFunctionOf(BoomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(BoomListView, init, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(BoomListView, draw, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(BoomListView, setupList, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(BoomListView, TableViewWillDisplayCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2);
	}

	dupable getFunctionOf(BoomListView, cellHeightForRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(BoomListView, didSelectRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1);
	}

	dupable getFunctionOf(BoomListView, numberOfRowsInSection, , 2, unsigned int, TableView*) {
		return reinterpret_cast<fun7>(address7)(this, p0, p1);
	}

	dupable getFunctionOf(BoomListView, numberOfSectionsInTableView, , 1, TableView*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(BoomListView, cellForRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1);
	}

	dupable getFunctionOf(BoomListView, TableViewCommitCellEditingStyleForRowAtIndexPath, , 3, TableView*, TableViewCellEditingStyle, CCIndexPath&) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1, p2);
	}

	dupable getFunctionOf(BoomListView, TableViewWillReloadCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1, p2);
	}

	dupable getFunctionOf(BoomListView, getListCell, , 1, char const*) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(BoomListView, loadCell, , 2, TableViewCell*, int) {
		return reinterpret_cast<fun13>(address13)(this, p0, p1);
	}

	static getWrapperOf(BoomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return D::create(p0, p1, p2, p3, p4);
	}

	getWrapperOf(BoomListView, init, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3, p4);
	}

	getWrapperOf(BoomListView, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(BoomListView, setupList, , 0) {
		return reinterpret_cast<D*>(this)->D::setupList();
	}

	getWrapperOf(BoomListView, TableViewWillDisplayCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*) {
		return reinterpret_cast<D*>(this)->D::TableViewWillDisplayCellForRowAtIndexPath(p0, p1, p2);
	}

	getWrapperOf(BoomListView, cellHeightForRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<D*>(this)->D::cellHeightForRowAtIndexPath(p0, p1);
	}

	getWrapperOf(BoomListView, didSelectRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<D*>(this)->D::didSelectRowAtIndexPath(p0, p1);
	}

	getWrapperOf(BoomListView, numberOfRowsInSection, , 2, unsigned int, TableView*) {
		return reinterpret_cast<D*>(this)->D::numberOfRowsInSection(p0, p1);
	}

	getWrapperOf(BoomListView, numberOfSectionsInTableView, , 1, TableView*) {
		return reinterpret_cast<D*>(this)->D::numberOfSectionsInTableView(p0);
	}

	getWrapperOf(BoomListView, cellForRowAtIndexPath, , 2, CCIndexPath&, TableView*) {
		return reinterpret_cast<D*>(this)->D::cellForRowAtIndexPath(p0, p1);
	}

	getWrapperOf(BoomListView, TableViewCommitCellEditingStyleForRowAtIndexPath, , 3, TableView*, TableViewCellEditingStyle, CCIndexPath&) {
		return reinterpret_cast<D*>(this)->D::TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2);
	}

	getWrapperOf(BoomListView, TableViewWillReloadCellForRowAtIndexPath, , 3, CCIndexPath&, TableViewCell*, TableView*) {
		return reinterpret_cast<D*>(this)->D::TableViewWillReloadCellForRowAtIndexPath(p0, p1, p2);
	}

	getWrapperOf(BoomListView, getListCell, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getListCell(p0);
	}

	getWrapperOf(BoomListView, loadCell, , 2, TableViewCell*, int) {
		return reinterpret_cast<D*>(this)->D::loadCell(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$BoomListView::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$BoomListView::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$BoomListView::draw) != (der2)(&D::draw)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::drawWrapper)));
		}

		if ((mem3)(&$BoomListView::setupList) != (der3)(&D::setupList)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setupListWrapper)));
		}

		if ((mem4)(&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath) != (der4)(&D::TableViewWillDisplayCellForRowAtIndexPath)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::TableViewWillDisplayCellForRowAtIndexPathWrapper)));
		}

		if ((mem5)(&$BoomListView::cellHeightForRowAtIndexPath) != (der5)(&D::cellHeightForRowAtIndexPath)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::cellHeightForRowAtIndexPathWrapper)));
		}

		if ((mem6)(&$BoomListView::didSelectRowAtIndexPath) != (der6)(&D::didSelectRowAtIndexPath)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::didSelectRowAtIndexPathWrapper)));
		}

		if ((mem7)(&$BoomListView::numberOfRowsInSection) != (der7)(&D::numberOfRowsInSection)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::numberOfRowsInSectionWrapper)));
		}

		if ((mem8)(&$BoomListView::numberOfSectionsInTableView) != (der8)(&D::numberOfSectionsInTableView)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::numberOfSectionsInTableViewWrapper)));
		}

		if ((mem9)(&$BoomListView::cellForRowAtIndexPath) != (der9)(&D::cellForRowAtIndexPath)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::cellForRowAtIndexPathWrapper)));
		}

		if ((mem10)(&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath) != (der10)(&D::TableViewCommitCellEditingStyleForRowAtIndexPath)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::TableViewCommitCellEditingStyleForRowAtIndexPathWrapper)));
		}

		if ((mem11)(&$BoomListView::TableViewWillReloadCellForRowAtIndexPath) != (der11)(&D::TableViewWillReloadCellForRowAtIndexPath)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::TableViewWillReloadCellForRowAtIndexPathWrapper)));
		}

		if ((mem12)(&$BoomListView::getListCell) != (der12)(&D::getListCell)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::getListCellWrapper)));
		}

		if ((mem13)(&$BoomListView::loadCell) != (der13)(&D::loadCell)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::loadCellWrapper)));
		}

		return true;
	}
};

template<class D>
struct $BoomScrollLayer : BoomScrollLayer, InterfaceBase {
	$BoomScrollLayer(const $BoomScrollLayer& c) : BoomScrollLayer(c) {}
	$BoomScrollLayer() = delete;
	static inline auto address0 = base+0x1e42f0;

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $ButtonSprite : ButtonSprite, InterfaceBase {
	$ButtonSprite(const $ButtonSprite& c) : ButtonSprite(c) {}
	$ButtonSprite() = delete;
	setInterfaceStaticTypesOf(0, ButtonSprite, create, , 1, char const*);
	setInterfaceStaticTypesOf(1, ButtonSprite, create, , 5, char const*, int, int, float, bool);
	setInterfaceTypesOf(2, ButtonSprite, updateBGImage, , 1, char const*);
	setInterfaceStaticTypesOf(3, ButtonSprite, create, , 2, char const*, float);
	setInterfaceStaticTypesOf(4, ButtonSprite, create, , 8, cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static inline auto address0 = base+0x4fa10;
	static inline auto address1 = base+0x4fa40;
	static inline auto address2 = base+0x502d0;
	static inline auto address3 = base+0x4fa60;
	static inline auto address4 = base+0x4fa90;

	dupable static getFunctionOf(ButtonSprite, create, , 1, char const*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable static getFunctionOf(ButtonSprite, create, , 5, char const*, int, int, float, bool) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(ButtonSprite, updateBGImage, , 1, char const*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable static getFunctionOf(ButtonSprite, create, , 2, char const*, float) {
		return reinterpret_cast<fun3>(address3)(p0, p1);
	}

	dupable static getFunctionOf(ButtonSprite, create, , 8, cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool) {
		return reinterpret_cast<fun4>(address4)(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	static getWrapperOf(ButtonSprite, create, , 1, char const*) {
		return D::create(p0);
	}

	static getWrapperOf(ButtonSprite, create, , 5, char const*, int, int, float, bool) {
		return D::create(p0, p1, p2, p3, p4);
	}

	getWrapperOf(ButtonSprite, updateBGImage, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::updateBGImage(p0);
	}

	static getWrapperOf(ButtonSprite, create, , 2, char const*, float) {
		return D::create(p0, p1);
	}

	static getWrapperOf(ButtonSprite, create, , 8, cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool) {
		return D::create(p0, p1, p2, p3, p4, p5, p6, p7);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ButtonSprite::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$ButtonSprite::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$ButtonSprite::updateBGImage) != (der2)(&D::updateBGImage)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::updateBGImageWrapper)));
		}

		if constexpr((mem3)(&$ButtonSprite::create) != (der3)(&D::create)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::createWrapper)));
		}

		if constexpr((mem4)(&$ButtonSprite::create) != (der4)(&D::create)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCAnimatedSprite : CCAnimatedSprite, InterfaceBase {
	$CCAnimatedSprite(const $CCAnimatedSprite& c) : CCAnimatedSprite(c) {}
	$CCAnimatedSprite() = delete;
	setInterfaceTypesOf(0, CCAnimatedSprite, runAnimation, , 1, gd::string);
	setInterfaceTypesOf(1, CCAnimatedSprite, tweenToAnimation, , 2, gd::string, float);
	static inline auto address0 = base+0x1a6430;
	static inline auto address1 = base+0x1a65b0;

	dupable getFunctionOf(CCAnimatedSprite, runAnimation, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CCAnimatedSprite, tweenToAnimation, , 2, gd::string, float) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1);
	}

	getWrapperOf(CCAnimatedSprite, runAnimation, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::runAnimation(p0);
	}

	getWrapperOf(CCAnimatedSprite, tweenToAnimation, , 2, gd::string, float) {
		return reinterpret_cast<D*>(this)->D::tweenToAnimation(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCAnimatedSprite::runAnimation) != (der0)(&D::runAnimation)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::runAnimationWrapper)));
		}

		if constexpr((mem1)(&$CCAnimatedSprite::tweenToAnimation) != (der1)(&D::tweenToAnimation)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::tweenToAnimationWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCBlockLayer : CCBlockLayer, InterfaceBase {
	$CCBlockLayer(const $CCBlockLayer& c) : CCBlockLayer(c) {}
	$CCBlockLayer() = delete;
	setInterfaceTypesOf(0, CCBlockLayer, disableUI, , 0);
	setInterfaceTypesOf(1, CCBlockLayer, draw, , 0);
	setInterfaceTypesOf(2, CCBlockLayer, enableUI, , 0);
	setInterfaceTypesOf(3, CCBlockLayer, enterAnimFinished, , 0);
	setInterfaceTypesOf(4, CCBlockLayer, enterLayer, , 0);
	setInterfaceTypesOf(5, CCBlockLayer, exitLayer, , 0);
	setInterfaceTypesOf(6, CCBlockLayer, hideLayer, , 1, bool);
	setInterfaceTypesOf(7, CCBlockLayer, init, , 0);
	setInterfaceTypesOf(8, CCBlockLayer, layerHidden, , 0);
	setInterfaceTypesOf(9, CCBlockLayer, layerVisible, , 0);
	setInterfaceTypesOf(10, CCBlockLayer, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(11, CCBlockLayer, showLayer, , 1, bool);
	static inline auto address0 = base+0x2a5a80;
	static inline auto address1 = base+0x2a5c20;
	static inline auto address2 = base+0x2a5a90;
	static inline auto address3 = base+0x2a5bb0;
	static inline auto address4 = base+0x2a5aa0;
	static inline auto address5 = base+0x2a5b40;
	static inline auto address6 = base+0x2a5ba0;
	static inline auto address7 = base+0x2a59c0;
	static inline auto address8 = base+0x2a5be0;
	static inline auto address9 = base+0x2a5bc0;
	static inline auto address10 = base+0x2a5ad0;
	static inline auto address11 = base+0x2a5b90;

	dupable getFunctionOf(CCBlockLayer, disableUI, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(CCBlockLayer, draw, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCBlockLayer, enableUI, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCBlockLayer, enterAnimFinished, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(CCBlockLayer, enterLayer, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(CCBlockLayer, exitLayer, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(CCBlockLayer, hideLayer, , 1, bool) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCBlockLayer, init, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(CCBlockLayer, layerHidden, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCBlockLayer, layerVisible, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(CCBlockLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(CCBlockLayer, showLayer, , 1, bool) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	getWrapperOf(CCBlockLayer, disableUI, , 0) {
		return reinterpret_cast<D*>(this)->D::disableUI();
	}

	getWrapperOf(CCBlockLayer, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(CCBlockLayer, enableUI, , 0) {
		return reinterpret_cast<D*>(this)->D::enableUI();
	}

	getWrapperOf(CCBlockLayer, enterAnimFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::enterAnimFinished();
	}

	getWrapperOf(CCBlockLayer, enterLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::enterLayer();
	}

	getWrapperOf(CCBlockLayer, exitLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::exitLayer();
	}

	getWrapperOf(CCBlockLayer, hideLayer, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::hideLayer(p0);
	}

	getWrapperOf(CCBlockLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCBlockLayer, layerHidden, , 0) {
		return reinterpret_cast<D*>(this)->D::layerHidden();
	}

	getWrapperOf(CCBlockLayer, layerVisible, , 0) {
		return reinterpret_cast<D*>(this)->D::layerVisible();
	}

	getWrapperOf(CCBlockLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(CCBlockLayer, showLayer, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::showLayer(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCBlockLayer::disableUI) != (der0)(&D::disableUI)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::disableUIWrapper)));
		}

		if constexpr((mem1)(&$CCBlockLayer::draw) != (der1)(&D::draw)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::drawWrapper)));
		}

		if constexpr((mem2)(&$CCBlockLayer::enableUI) != (der2)(&D::enableUI)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::enableUIWrapper)));
		}

		if constexpr((mem3)(&$CCBlockLayer::enterAnimFinished) != (der3)(&D::enterAnimFinished)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::enterAnimFinishedWrapper)));
		}

		if constexpr((mem4)(&$CCBlockLayer::enterLayer) != (der4)(&D::enterLayer)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::enterLayerWrapper)));
		}

		if constexpr((mem5)(&$CCBlockLayer::exitLayer) != (der5)(&D::exitLayer)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::exitLayerWrapper)));
		}

		if constexpr((mem6)(&$CCBlockLayer::hideLayer) != (der6)(&D::hideLayer)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::hideLayerWrapper)));
		}

		if constexpr((mem7)(&$CCBlockLayer::init) != (der7)(&D::init)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::initWrapper)));
		}

		if constexpr((mem8)(&$CCBlockLayer::layerHidden) != (der8)(&D::layerHidden)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::layerHiddenWrapper)));
		}

		if constexpr((mem9)(&$CCBlockLayer::layerVisible) != (der9)(&D::layerVisible)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::layerVisibleWrapper)));
		}

		if constexpr((mem10)(&$CCBlockLayer::registerWithTouchDispatcher) != (der10)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::registerWithTouchDispatcherWrapper)));
		}

		if constexpr((mem11)(&$CCBlockLayer::showLayer) != (der11)(&D::showLayer)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::showLayerWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCCircleWave : CCCircleWave, InterfaceBase {
	$CCCircleWave(const $CCCircleWave& c) : CCCircleWave(c) {}
	$CCCircleWave() = delete;
	setInterfaceStaticTypesOf(0, CCCircleWave, create, , 4, float, float, float, bool);
	setInterfaceStaticTypesOf(1, CCCircleWave, create, , 5, float, float, float, bool, bool);
	setInterfaceTypesOf(2, CCCircleWave, init, , 5, float, float, float, bool, bool);
	setInterfaceTypesOf(3, CCCircleWave, followObject, , 2, cocos2d::CCNode*, bool);
	setInterfaceTypesOf(4, CCCircleWave, updatePosition, , 1, float);
	static inline auto address0 = base+0xbd270;
	static inline auto address1 = base+0xbd290;
	static inline auto address2 = base+0xbd380;
	static inline auto address3 = base+0xbd670;
	static inline auto address4 = base+0xbd630;

	dupable static getFunctionOf(CCCircleWave, create, , 4, float, float, float, bool) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	dupable static getFunctionOf(CCCircleWave, create, , 5, float, float, float, bool, bool) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(CCCircleWave, init, , 5, float, float, float, bool, bool) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(CCCircleWave, followObject, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(CCCircleWave, updatePosition, , 1, float) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	static getWrapperOf(CCCircleWave, create, , 4, float, float, float, bool) {
		return D::create(p0, p1, p2, p3);
	}

	static getWrapperOf(CCCircleWave, create, , 5, float, float, float, bool, bool) {
		return D::create(p0, p1, p2, p3, p4);
	}

	getWrapperOf(CCCircleWave, init, , 5, float, float, float, bool, bool) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3, p4);
	}

	getWrapperOf(CCCircleWave, followObject, , 2, cocos2d::CCNode*, bool) {
		return reinterpret_cast<D*>(this)->D::followObject(p0, p1);
	}

	getWrapperOf(CCCircleWave, updatePosition, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updatePosition(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCCircleWave::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCCircleWave::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$CCCircleWave::init) != (der2)(&D::init)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::initWrapper)));
		}

		if constexpr((mem3)(&$CCCircleWave::followObject) != (der3)(&D::followObject)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::followObjectWrapper)));
		}

		if constexpr((mem4)(&$CCCircleWave::updatePosition) != (der4)(&D::updatePosition)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::updatePositionWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCCircleWaveDelegate : CCCircleWaveDelegate, InterfaceBase {
	$CCCircleWaveDelegate(const $CCCircleWaveDelegate& c) : CCCircleWaveDelegate(c) {}
	$CCCircleWaveDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCLightFlash : CCLightFlash, InterfaceBase {
	$CCLightFlash(const $CCLightFlash& c) : CCLightFlash(c) {}
	$CCLightFlash() = delete;
	setInterfaceStaticTypesOf(0, CCLightFlash, create, , 0);
	setInterfaceTypesOf(1, CCLightFlash, playEffect, , 20, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
	static inline auto address0 = base+0x295870;
	static inline auto address1 = base+0x295900;

	dupable static getFunctionOf(CCLightFlash, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(CCLightFlash, playEffect, , 20, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
	}

	static getWrapperOf(CCLightFlash, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCLightFlash, playEffect, , 20, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float) {
		return reinterpret_cast<D*>(this)->D::playEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCLightFlash::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCLightFlash::playEffect) != (der1)(&D::playEffect)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::playEffectWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItemSpriteExtra : CCMenuItemSpriteExtra, InterfaceBase {
	$CCMenuItemSpriteExtra(const $CCMenuItemSpriteExtra& c) : CCMenuItemSpriteExtra(c) {}
	$CCMenuItemSpriteExtra() = delete;
	setInterfaceStaticTypesOf(0, CCMenuItemSpriteExtra, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	setInterfaceTypesOf(1, CCMenuItemSpriteExtra, setSizeMult, , 1, float);
	setInterfaceTypesOf(3, CCMenuItemSpriteExtra, init, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static inline auto address0 = base+0x1253c0;
	static inline auto address1 = base+0x1255e0;
	static inline auto address2 = base+0x32670;
	static inline auto address3 = base+0x125450;

	dupable static getFunctionOf(CCMenuItemSpriteExtra, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCMenuItemSpriteExtra, setSizeMult, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable void constructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	dupable getFunctionOf(CCMenuItemSpriteExtra, init, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1, p2, p3);
	}

	static getWrapperOf(CCMenuItemSpriteExtra, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return D::create(p0, p1, p2, p3);
	}

	getWrapperOf(CCMenuItemSpriteExtra, setSizeMult, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSizeMult(p0);
	}

	void constructorWrapper() {
		reinterpret_cast<D*>(this)->D::constructor();
	}

	getWrapperOf(CCMenuItemSpriteExtra, init, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMenuItemSpriteExtra::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCMenuItemSpriteExtra::setSizeMult) != (der1)(&D::setSizeMult)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setSizeMultWrapper)));
		}

		if constexpr((mem3)(&$CCMenuItemSpriteExtra::init) != (der3)(&D::init)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::initWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMenuItemToggler : CCMenuItemToggler, InterfaceBase {
	$CCMenuItemToggler(const $CCMenuItemToggler& c) : CCMenuItemToggler(c) {}
	$CCMenuItemToggler() = delete;
	setInterfaceStaticTypesOf(0, CCMenuItemToggler, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	setInterfaceTypesOf(1, CCMenuItemToggler, setSizeMult, , 1, float);
	setInterfaceTypesOf(2, CCMenuItemToggler, toggle, , 1, bool);
	static inline auto address0 = base+0x38400;
	static inline auto address1 = base+0x38a40;
	static inline auto address2 = base+0x38950;

	dupable static getFunctionOf(CCMenuItemToggler, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	dupable getFunctionOf(CCMenuItemToggler, setSizeMult, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CCMenuItemToggler, toggle, , 1, bool) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	static getWrapperOf(CCMenuItemToggler, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return D::create(p0, p1, p2, p3);
	}

	getWrapperOf(CCMenuItemToggler, setSizeMult, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setSizeMult(p0);
	}

	getWrapperOf(CCMenuItemToggler, toggle, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggle(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMenuItemToggler::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCMenuItemToggler::setSizeMult) != (der1)(&D::setSizeMult)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setSizeMultWrapper)));
		}

		if constexpr((mem2)(&$CCMenuItemToggler::toggle) != (der2)(&D::toggle)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::toggleWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCMoveCNode : CCMoveCNode, InterfaceBase {
	$CCMoveCNode(const $CCMoveCNode& c) : CCMoveCNode(c) {}
	$CCMoveCNode() = delete;
	setInterfaceStaticTypesOf(0, CCMoveCNode, create, , 0);
	setInterfaceTypesOf(1, CCMoveCNode, init, , 0);
	static inline auto address0 = base+0x1842a0;
	static inline auto address1 = base+0x18b3d0;
	static inline auto address2 = base+0x18b2c0;

	dupable static getFunctionOf(CCMoveCNode, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(CCMoveCNode, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address2)(this);
	}

	static getWrapperOf(CCMoveCNode, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCMoveCNode, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCMoveCNode::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCMoveCNode::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		if constexpr(&$CCMoveCNode::destructor != &D::destructor) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $CCNodeContainer : CCNodeContainer, InterfaceBase {
	$CCNodeContainer(const $CCNodeContainer& c) : CCNodeContainer(c) {}
	$CCNodeContainer() = delete;
	setInterfaceStaticTypesOf(0, CCNodeContainer, create, , 0);
	setInterfaceTypesOf(1, CCNodeContainer, init, , 0);
	setInterfaceTypesOf(2, CCNodeContainer, visit, , 0);
	static inline auto address0 = base+0xb1090;
	static inline auto address1 = base+0xba950;
	static inline auto address2 = base+0xba960;

	dupable static getFunctionOf(CCNodeContainer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(CCNodeContainer, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCNodeContainer, visit, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	static getWrapperOf(CCNodeContainer, create, , 0) {
		return D::create();
	}

	getWrapperOf(CCNodeContainer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(CCNodeContainer, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCNodeContainer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCNodeContainer::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$CCNodeContainer::visit) != (der2)(&D::visit)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::visitWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScrollLayerExt : CCScrollLayerExt, InterfaceBase {
	$CCScrollLayerExt(const $CCScrollLayerExt& c) : CCScrollLayerExt(c) {}
	$CCScrollLayerExt() = delete;
	setInterfaceTypesOf(1, CCScrollLayerExt, visit, , 0);
	setInterfaceTypesOf(2, CCScrollLayerExt, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(3, CCScrollLayerExt, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(4, CCScrollLayerExt, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(5, CCScrollLayerExt, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(6, CCScrollLayerExt, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(7, CCScrollLayerExt, preVisitWithClippingRect, , 1, cocos2d::CCRect);
	setInterfaceTypesOf(8, CCScrollLayerExt, postVisit, , 0);
	setInterfaceTypesOf(9, CCScrollLayerExt, moveToTop, , 0);
	setInterfaceTypesOf(10, CCScrollLayerExt, moveToTopWithOffset, , 1, float);
	static inline auto address0 = base+0x2359b0;
	static inline auto address1 = base+0x236550;
	static inline auto address2 = base+0x235ef0;
	static inline auto address3 = base+0x236300;
	static inline auto address4 = base+0x236020;
	static inline auto address5 = base+0x2362a0;
	static inline auto address6 = base+0x235eb0;
	static inline auto address7 = base+0x2366a0;
	static inline auto address8 = base+0x236720;
	static inline auto address9 = base+0x235870;
	static inline auto address10 = base+0x2357d0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CCScrollLayerExt, visit, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCScrollLayerExt, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollLayerExt, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollLayerExt, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollLayerExt, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(CCScrollLayerExt, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(CCScrollLayerExt, preVisitWithClippingRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCScrollLayerExt, postVisit, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(CCScrollLayerExt, moveToTop, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(CCScrollLayerExt, moveToTopWithOffset, , 1, float) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCScrollLayerExt, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(CCScrollLayerExt, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(CCScrollLayerExt, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(CCScrollLayerExt, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(CCScrollLayerExt, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(CCScrollLayerExt, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(CCScrollLayerExt, preVisitWithClippingRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::preVisitWithClippingRect(p0);
	}

	getWrapperOf(CCScrollLayerExt, postVisit, , 0) {
		return reinterpret_cast<D*>(this)->D::postVisit();
	}

	getWrapperOf(CCScrollLayerExt, moveToTop, , 0) {
		return reinterpret_cast<D*>(this)->D::moveToTop();
	}

	getWrapperOf(CCScrollLayerExt, moveToTopWithOffset, , 1, float) {
		return reinterpret_cast<D*>(this)->D::moveToTopWithOffset(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CCScrollLayerExt::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CCScrollLayerExt::visit) != (der1)(&D::visit)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::visitWrapper)));
		}

		if ((mem2)(&$CCScrollLayerExt::ccTouchBegan) != (der2)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::ccTouchBeganWrapper)));
		}

		if ((mem3)(&$CCScrollLayerExt::ccTouchMoved) != (der3)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::ccTouchMovedWrapper)));
		}

		if ((mem4)(&$CCScrollLayerExt::ccTouchEnded) != (der4)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::ccTouchEndedWrapper)));
		}

		if ((mem5)(&$CCScrollLayerExt::ccTouchCancelled) != (der5)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::ccTouchCancelledWrapper)));
		}

		if ((mem6)(&$CCScrollLayerExt::registerWithTouchDispatcher) != (der6)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::registerWithTouchDispatcherWrapper)));
		}

		if ((mem7)(&$CCScrollLayerExt::preVisitWithClippingRect) != (der7)(&D::preVisitWithClippingRect)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::preVisitWithClippingRectWrapper)));
		}

		if ((mem8)(&$CCScrollLayerExt::postVisit) != (der8)(&D::postVisit)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::postVisitWrapper)));
		}

		if constexpr((mem9)(&$CCScrollLayerExt::moveToTop) != (der9)(&D::moveToTop)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::moveToTopWrapper)));
		}

		if constexpr((mem10)(&$CCScrollLayerExt::moveToTopWithOffset) != (der10)(&D::moveToTopWithOffset)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::moveToTopWithOffsetWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCScrollLayerExtDelegate : CCScrollLayerExtDelegate, InterfaceBase {
	$CCScrollLayerExtDelegate(const $CCScrollLayerExtDelegate& c) : CCScrollLayerExtDelegate(c) {}
	$CCScrollLayerExtDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $CCSpritePlus : CCSpritePlus, InterfaceBase {
	$CCSpritePlus(const $CCSpritePlus& c) : CCSpritePlus(c) {}
	$CCSpritePlus() = delete;
	setInterfaceTypesOf(0, CCSpritePlus, initWithSpriteFrameName, , 1, char const*);
	static inline auto address0 = base+0x248670;

	dupable getFunctionOf(CCSpritePlus, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(CCSpritePlus, initWithSpriteFrameName, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::initWithSpriteFrameName(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCSpritePlus::initWithSpriteFrameName) != (der0)(&D::initWithSpriteFrameName)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::initWithSpriteFrameNameWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CCTextInputNode : CCTextInputNode, InterfaceBase {
	$CCTextInputNode(const $CCTextInputNode& c) : CCTextInputNode(c) {}
	$CCTextInputNode() = delete;
	setInterfaceStaticTypesOf(0, CCTextInputNode, create, , 6, float, float, char const*, char const*, int, char const*);
	setInterfaceTypesOf(1, CCTextInputNode, getString, , 0);
	setInterfaceTypesOf(2, CCTextInputNode, refreshLabel, , 0);
	setInterfaceTypesOf(3, CCTextInputNode, setAllowedChars, , 1, gd::string);
	setInterfaceTypesOf(4, CCTextInputNode, setLabelNormalColor, , 1, cocos2d::_ccColor3B);
	setInterfaceTypesOf(5, CCTextInputNode, setLabelPlaceholderColor, , 1, cocos2d::_ccColor3B);
	setInterfaceTypesOf(6, CCTextInputNode, setLabelPlaceholderScale, , 1, float);
	setInterfaceTypesOf(7, CCTextInputNode, setMaxLabelScale, , 1, float);
	setInterfaceTypesOf(8, CCTextInputNode, setMaxLabelWidth, , 1, float);
	setInterfaceTypesOf(9, CCTextInputNode, setString, , 1, gd::string);
	setInterfaceTypesOf(10, CCTextInputNode, updateLabel, , 1, gd::string);
	setInterfaceTypesOf(11, CCTextInputNode, forceOffset, , 0);
	setInterfaceTypesOf(12, CCTextInputNode, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(13, CCTextInputNode, init, , 6, float, float, char const*, char const*, int, char const*);
	setInterfaceTypesOf(15, CCTextInputNode, visit, , 0);
	setInterfaceTypesOf(16, CCTextInputNode, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(17, CCTextInputNode, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(18, CCTextInputNode, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(19, CCTextInputNode, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(20, CCTextInputNode, textChanged, , 0);
	setInterfaceTypesOf(21, CCTextInputNode, onClickTrackNode, , 1, bool);
	setInterfaceTypesOf(22, CCTextInputNode, keyboardWillShow, , 1, cocos2d::CCIMEKeyboardNotificationInfo&);
	setInterfaceTypesOf(23, CCTextInputNode, keyboardWillHide, , 1, cocos2d::CCIMEKeyboardNotificationInfo&);
	setInterfaceTypesOf(24, CCTextInputNode, onTextFieldInsertText, , 3, cocos2d::CCTextFieldTTF*, char const*, int);
	setInterfaceTypesOf(25, CCTextInputNode, onTextFieldAttachWithIME, , 1, cocos2d::CCTextFieldTTF*);
	setInterfaceTypesOf(26, CCTextInputNode, onTextFieldDetachWithIME, , 1, cocos2d::CCTextFieldTTF*);
	static inline auto address0 = base+0x5cfb0;
	static inline auto address1 = base+0x5d6f0;
	static inline auto address2 = base+0x5d730;
	static inline auto address3 = base+0x5d360;
	static inline auto address4 = base+0x5dab0;
	static inline auto address5 = base+0x5da90;
	static inline auto address6 = base+0x5da70;
	static inline auto address7 = base+0x5da30;
	static inline auto address8 = base+0x5da50;
	static inline auto address9 = base+0x5d3e0;
	static inline auto address10 = base+0x5d4a0;
	static inline auto address11 = base+0x5ec70;
	static inline auto address12 = base+0x5eec0;
	static inline auto address13 = base+0x5d180;
	static inline auto address14 = base+0x5ceb0;
	static inline auto address15 = base+0x5d380;
	static inline auto address16 = base+0x5ec80;
	static inline auto address17 = base+0x5ee80;
	static inline auto address18 = base+0x5ee60;
	static inline auto address19 = base+0x5eea0;
	static inline auto address20 = base+0x5dd70;
	static inline auto address21 = base+0x5dd40;
	static inline auto address22 = base+0x5dad0;
	static inline auto address23 = base+0x5dc20;
	static inline auto address24 = base+0x5de50;
	static inline auto address25 = base+0x5e2c0;
	static inline auto address26 = base+0x5e610;

	dupable static getFunctionOf(CCTextInputNode, create, , 6, float, float, char const*, char const*, int, char const*) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(CCTextInputNode, getString, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(CCTextInputNode, refreshLabel, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(CCTextInputNode, setAllowedChars, , 1, gd::string) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setLabelNormalColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setLabelPlaceholderColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setLabelPlaceholderScale, , 1, float) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setMaxLabelScale, , 1, float) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setMaxLabelWidth, , 1, float) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, setString, , 1, gd::string) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, updateLabel, , 1, gd::string) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, forceOffset, , 0) {
		return reinterpret_cast<fun11>(address11)(this);
	}

	dupable getFunctionOf(CCTextInputNode, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(CCTextInputNode, init, , 6, float, float, char const*, char const*, int, char const*) {
		return reinterpret_cast<fun13>(address13)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address14)(this);
	}

	dupable getFunctionOf(CCTextInputNode, visit, , 0) {
		return reinterpret_cast<fun15>(address15)(this);
	}

	dupable getFunctionOf(CCTextInputNode, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1);
	}

	dupable getFunctionOf(CCTextInputNode, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1);
	}

	dupable getFunctionOf(CCTextInputNode, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun18>(address18)(this, p0, p1);
	}

	dupable getFunctionOf(CCTextInputNode, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun19>(address19)(this, p0, p1);
	}

	dupable getFunctionOf(CCTextInputNode, textChanged, , 0) {
		return reinterpret_cast<fun20>(address20)(this);
	}

	dupable getFunctionOf(CCTextInputNode, onClickTrackNode, , 1, bool) {
		return reinterpret_cast<fun21>(address21)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, keyboardWillShow, , 1, cocos2d::CCIMEKeyboardNotificationInfo&) {
		return reinterpret_cast<fun22>(address22)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, keyboardWillHide, , 1, cocos2d::CCIMEKeyboardNotificationInfo&) {
		return reinterpret_cast<fun23>(address23)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, onTextFieldInsertText, , 3, cocos2d::CCTextFieldTTF*, char const*, int) {
		return reinterpret_cast<fun24>(address24)(this, p0, p1, p2);
	}

	dupable getFunctionOf(CCTextInputNode, onTextFieldAttachWithIME, , 1, cocos2d::CCTextFieldTTF*) {
		return reinterpret_cast<fun25>(address25)(this, p0);
	}

	dupable getFunctionOf(CCTextInputNode, onTextFieldDetachWithIME, , 1, cocos2d::CCTextFieldTTF*) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	static getWrapperOf(CCTextInputNode, create, , 6, float, float, char const*, char const*, int, char const*) {
		return D::create(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(CCTextInputNode, getString, , 0) {
		return reinterpret_cast<D*>(this)->D::getString();
	}

	getWrapperOf(CCTextInputNode, refreshLabel, , 0) {
		return reinterpret_cast<D*>(this)->D::refreshLabel();
	}

	getWrapperOf(CCTextInputNode, setAllowedChars, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::setAllowedChars(p0);
	}

	getWrapperOf(CCTextInputNode, setLabelNormalColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::setLabelNormalColor(p0);
	}

	getWrapperOf(CCTextInputNode, setLabelPlaceholderColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::setLabelPlaceholderColor(p0);
	}

	getWrapperOf(CCTextInputNode, setLabelPlaceholderScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setLabelPlaceholderScale(p0);
	}

	getWrapperOf(CCTextInputNode, setMaxLabelScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setMaxLabelScale(p0);
	}

	getWrapperOf(CCTextInputNode, setMaxLabelWidth, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setMaxLabelWidth(p0);
	}

	getWrapperOf(CCTextInputNode, setString, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::setString(p0);
	}

	getWrapperOf(CCTextInputNode, updateLabel, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::updateLabel(p0);
	}

	getWrapperOf(CCTextInputNode, forceOffset, , 0) {
		return reinterpret_cast<D*>(this)->D::forceOffset();
	}

	getWrapperOf(CCTextInputNode, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(CCTextInputNode, init, , 6, float, float, char const*, char const*, int, char const*) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3, p4, p5);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CCTextInputNode, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(CCTextInputNode, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(CCTextInputNode, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(CCTextInputNode, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(CCTextInputNode, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(CCTextInputNode, textChanged, , 0) {
		return reinterpret_cast<D*>(this)->D::textChanged();
	}

	getWrapperOf(CCTextInputNode, onClickTrackNode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::onClickTrackNode(p0);
	}

	getWrapperOf(CCTextInputNode, keyboardWillShow, , 1, cocos2d::CCIMEKeyboardNotificationInfo&) {
		return reinterpret_cast<D*>(this)->D::keyboardWillShow(p0);
	}

	getWrapperOf(CCTextInputNode, keyboardWillHide, , 1, cocos2d::CCIMEKeyboardNotificationInfo&) {
		return reinterpret_cast<D*>(this)->D::keyboardWillHide(p0);
	}

	getWrapperOf(CCTextInputNode, onTextFieldInsertText, , 3, cocos2d::CCTextFieldTTF*, char const*, int) {
		return reinterpret_cast<D*>(this)->D::onTextFieldInsertText(p0, p1, p2);
	}

	getWrapperOf(CCTextInputNode, onTextFieldAttachWithIME, , 1, cocos2d::CCTextFieldTTF*) {
		return reinterpret_cast<D*>(this)->D::onTextFieldAttachWithIME(p0);
	}

	getWrapperOf(CCTextInputNode, onTextFieldDetachWithIME, , 1, cocos2d::CCTextFieldTTF*) {
		return reinterpret_cast<D*>(this)->D::onTextFieldDetachWithIME(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CCTextInputNode::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CCTextInputNode::getString) != (der1)(&D::getString)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getStringWrapper)));
		}

		if constexpr((mem2)(&$CCTextInputNode::refreshLabel) != (der2)(&D::refreshLabel)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::refreshLabelWrapper)));
		}

		if constexpr((mem3)(&$CCTextInputNode::setAllowedChars) != (der3)(&D::setAllowedChars)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::setAllowedCharsWrapper)));
		}

		if constexpr((mem4)(&$CCTextInputNode::setLabelNormalColor) != (der4)(&D::setLabelNormalColor)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::setLabelNormalColorWrapper)));
		}

		if constexpr((mem5)(&$CCTextInputNode::setLabelPlaceholderColor) != (der5)(&D::setLabelPlaceholderColor)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::setLabelPlaceholderColorWrapper)));
		}

		if constexpr((mem6)(&$CCTextInputNode::setLabelPlaceholderScale) != (der6)(&D::setLabelPlaceholderScale)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::setLabelPlaceholderScaleWrapper)));
		}

		if constexpr((mem7)(&$CCTextInputNode::setMaxLabelScale) != (der7)(&D::setMaxLabelScale)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::setMaxLabelScaleWrapper)));
		}

		if constexpr((mem8)(&$CCTextInputNode::setMaxLabelWidth) != (der8)(&D::setMaxLabelWidth)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::setMaxLabelWidthWrapper)));
		}

		if constexpr((mem9)(&$CCTextInputNode::setString) != (der9)(&D::setString)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::setStringWrapper)));
		}

		if constexpr((mem10)(&$CCTextInputNode::updateLabel) != (der10)(&D::updateLabel)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::updateLabelWrapper)));
		}

		if constexpr((mem11)(&$CCTextInputNode::forceOffset) != (der11)(&D::forceOffset)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::forceOffsetWrapper)));
		}

		if ((mem12)(&$CCTextInputNode::registerWithTouchDispatcher) != (der12)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::registerWithTouchDispatcherWrapper)));
		}

		if constexpr((mem13)(&$CCTextInputNode::init) != (der13)(&D::init)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::initWrapper)));
		}

		if constexpr(&$CCTextInputNode::destructor != &D::destructor) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem15)(&$CCTextInputNode::visit) != (der15)(&D::visit)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::visitWrapper)));
		}

		if ((mem16)(&$CCTextInputNode::ccTouchBegan) != (der16)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfVirtual((der16)(&D::ccTouchBeganWrapper)));
		}

		if ((mem17)(&$CCTextInputNode::ccTouchCancelled) != (der17)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfVirtual((der17)(&D::ccTouchCancelledWrapper)));
		}

		if ((mem18)(&$CCTextInputNode::ccTouchEnded) != (der18)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfVirtual((der18)(&D::ccTouchEndedWrapper)));
		}

		if ((mem19)(&$CCTextInputNode::ccTouchMoved) != (der19)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfVirtual((der19)(&D::ccTouchMovedWrapper)));
		}

		if ((mem20)(&$CCTextInputNode::textChanged) != (der20)(&D::textChanged)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfVirtual((der20)(&D::textChangedWrapper)));
		}

		if ((mem21)(&$CCTextInputNode::onClickTrackNode) != (der21)(&D::onClickTrackNode)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfVirtual((der21)(&D::onClickTrackNodeWrapper)));
		}

		if ((mem22)(&$CCTextInputNode::keyboardWillShow) != (der22)(&D::keyboardWillShow)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfVirtual((der22)(&D::keyboardWillShowWrapper)));
		}

		if ((mem23)(&$CCTextInputNode::keyboardWillHide) != (der23)(&D::keyboardWillHide)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfVirtual((der23)(&D::keyboardWillHideWrapper)));
		}

		if ((mem24)(&$CCTextInputNode::onTextFieldInsertText) != (der24)(&D::onTextFieldInsertText)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfVirtual((der24)(&D::onTextFieldInsertTextWrapper)));
		}

		if ((mem25)(&$CCTextInputNode::onTextFieldAttachWithIME) != (der25)(&D::onTextFieldAttachWithIME)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfVirtual((der25)(&D::onTextFieldAttachWithIMEWrapper)));
		}

		if ((mem26)(&$CCTextInputNode::onTextFieldDetachWithIME) != (der26)(&D::onTextFieldDetachWithIME)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfVirtual((der26)(&D::onTextFieldDetachWithIMEWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CheckpointObject : CheckpointObject, InterfaceBase {
	$CheckpointObject(const $CheckpointObject& c) : CheckpointObject(c) {}
	$CheckpointObject() = delete;
	setInterfaceStaticTypesOf(0, CheckpointObject, create, , 0);
	setInterfaceTypesOf(1, CheckpointObject, getObject, , 0);
	static inline auto address0 = base+0x7e7d0;
	static inline auto address1 = base+0x7ef50;

	dupable static getFunctionOf(CheckpointObject, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(CheckpointObject, getObject, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	static getWrapperOf(CheckpointObject, create, , 0) {
		return D::create();
	}

	getWrapperOf(CheckpointObject, getObject, , 0) {
		return reinterpret_cast<D*>(this)->D::getObject();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CheckpointObject::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CheckpointObject::getObject) != (der1)(&D::getObject)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getObjectWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CollisionBlockPopup : CollisionBlockPopup, InterfaceBase {
	$CollisionBlockPopup(const $CollisionBlockPopup& c) : CollisionBlockPopup(c) {}
	$CollisionBlockPopup() = delete;
	setInterfaceStaticTypesOf(0, CollisionBlockPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, CollisionBlockPopup, onNextItemID, , 1, cocos2d::CCObject*);
	static inline auto address0 = base+0x130010;
	static inline auto address1 = base+0x130e60;

	dupable static getFunctionOf(CollisionBlockPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(CollisionBlockPopup, onNextItemID, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	static getWrapperOf(CollisionBlockPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(CollisionBlockPopup, onNextItemID, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onNextItemID(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CollisionBlockPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CollisionBlockPopup::onNextItemID) != (der1)(&D::onNextItemID)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onNextItemIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CollisionTriggerAction : CollisionTriggerAction, InterfaceBase {
	$CollisionTriggerAction(const $CollisionTriggerAction& c) : CollisionTriggerAction(c) {}
	$CollisionTriggerAction() = delete;
	setInterfaceStaticTypesOf(0, CollisionTriggerAction, createFromString, , 1, gd::string);
	static inline auto address0 = base+0x176ee0;

	dupable static getFunctionOf(CollisionTriggerAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CollisionTriggerAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CollisionTriggerAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ColorAction : ColorAction, InterfaceBase {
	$ColorAction(const $ColorAction& c) : ColorAction(c) {}
	$ColorAction() = delete;
	setInterfaceTypesOf(0, ColorAction, getSaveString, , 0);
	setInterfaceTypesOf(1, ColorAction, setupFromDict, , 1, cocos2d::CCDictionary*);
	setInterfaceTypesOf(2, ColorAction, setupFromString, , 1, gd::string);
	static inline auto address0 = base+0x17d080;
	static inline auto address1 = base+0x17f310;
	static inline auto address2 = base+0x17f270;

	dupable getFunctionOf(ColorAction, getSaveString, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(ColorAction, setupFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(ColorAction, setupFromString, , 1, gd::string) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	getWrapperOf(ColorAction, getSaveString, , 0) {
		return reinterpret_cast<D*>(this)->D::getSaveString();
	}

	getWrapperOf(ColorAction, setupFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<D*>(this)->D::setupFromDict(p0);
	}

	getWrapperOf(ColorAction, setupFromString, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::setupFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ColorAction::getSaveString) != (der0)(&D::getSaveString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::getSaveStringWrapper)));
		}

		if constexpr((mem1)(&$ColorAction::setupFromDict) != (der1)(&D::setupFromDict)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setupFromDictWrapper)));
		}

		if constexpr((mem2)(&$ColorAction::setupFromString) != (der2)(&D::setupFromString)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::setupFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ColorActionSprite : ColorActionSprite, InterfaceBase {
	$ColorActionSprite(const $ColorActionSprite& c) : ColorActionSprite(c) {}
	$ColorActionSprite() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $ColorChannelSprite : ColorChannelSprite, InterfaceBase {
	$ColorChannelSprite(const $ColorChannelSprite& c) : ColorChannelSprite(c) {}
	$ColorChannelSprite() = delete;
	setInterfaceTypesOf(0, ColorChannelSprite, updateBlending, , 1, bool);
	setInterfaceTypesOf(1, ColorChannelSprite, updateCopyLabel, , 2, int, bool);
	setInterfaceTypesOf(2, ColorChannelSprite, updateOpacity, , 1, float);
	setInterfaceTypesOf(3, ColorChannelSprite, updateValues, , 1, ColorAction*);
	static inline auto address0 = base+0x16e1d0;
	static inline auto address1 = base+0x16ded0;
	static inline auto address2 = base+0x16e080;
	static inline auto address3 = base+0x16e2e0;

	dupable getFunctionOf(ColorChannelSprite, updateBlending, , 1, bool) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(ColorChannelSprite, updateCopyLabel, , 2, int, bool) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1);
	}

	dupable getFunctionOf(ColorChannelSprite, updateOpacity, , 1, float) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(ColorChannelSprite, updateValues, , 1, ColorAction*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	getWrapperOf(ColorChannelSprite, updateBlending, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::updateBlending(p0);
	}

	getWrapperOf(ColorChannelSprite, updateCopyLabel, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::updateCopyLabel(p0, p1);
	}

	getWrapperOf(ColorChannelSprite, updateOpacity, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateOpacity(p0);
	}

	getWrapperOf(ColorChannelSprite, updateValues, , 1, ColorAction*) {
		return reinterpret_cast<D*>(this)->D::updateValues(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ColorChannelSprite::updateBlending) != (der0)(&D::updateBlending)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::updateBlendingWrapper)));
		}

		if constexpr((mem1)(&$ColorChannelSprite::updateCopyLabel) != (der1)(&D::updateCopyLabel)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::updateCopyLabelWrapper)));
		}

		if constexpr((mem2)(&$ColorChannelSprite::updateOpacity) != (der2)(&D::updateOpacity)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::updateOpacityWrapper)));
		}

		if constexpr((mem3)(&$ColorChannelSprite::updateValues) != (der3)(&D::updateValues)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateValuesWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CommentCell : CommentCell, InterfaceBase {
	$CommentCell(const $CommentCell& c) : CommentCell(c) {}
	$CommentCell() = delete;
	setInterfaceTypesOf(0, CommentCell, loadFromComment, , 1, GJComment*);
	static inline auto address0 = base+0x111c70;

	dupable getFunctionOf(CommentCell, loadFromComment, , 1, GJComment*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(CommentCell, loadFromComment, , 1, GJComment*) {
		return reinterpret_cast<D*>(this)->D::loadFromComment(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CommentCell::loadFromComment) != (der0)(&D::loadFromComment)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::loadFromCommentWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CountTriggerAction : CountTriggerAction, InterfaceBase {
	$CountTriggerAction(const $CountTriggerAction& c) : CountTriggerAction(c) {}
	$CountTriggerAction() = delete;
	setInterfaceStaticTypesOf(0, CountTriggerAction, createFromString, , 1, gd::string);
	static inline auto address0 = base+0x1754f0;

	dupable static getFunctionOf(CountTriggerAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(CountTriggerAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CountTriggerAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CreateMenuItem : CreateMenuItem, InterfaceBase {
	$CreateMenuItem(const $CreateMenuItem& c) : CreateMenuItem(c) {}
	$CreateMenuItem() = delete;
	setInterfaceStaticTypesOf(0, CreateMenuItem, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static inline auto address0 = base+0x1c580;

	dupable static getFunctionOf(CreateMenuItem, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	static getWrapperOf(CreateMenuItem, create, , 4, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler) {
		return D::create(p0, p1, p2, p3);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CreateMenuItem::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CreatorLayer : CreatorLayer, InterfaceBase {
	$CreatorLayer(const $CreatorLayer& c) : CreatorLayer(c) {}
	$CreatorLayer() = delete;
	setInterfaceTypesOf(0, CreatorLayer, onMyLevels, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(1, CreatorLayer, onSavedLevels, , 1, cocos2d::CCObject*);
	static inline auto address0 = base+0x142b70;
	static inline auto address1 = base+0x142860;

	dupable getFunctionOf(CreatorLayer, onMyLevels, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CreatorLayer, onSavedLevels, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(CreatorLayer, onMyLevels, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onMyLevels(p0);
	}

	getWrapperOf(CreatorLayer, onSavedLevels, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onSavedLevels(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CreatorLayer::onMyLevels) != (der0)(&D::onMyLevels)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::onMyLevelsWrapper)));
		}

		if constexpr((mem1)(&$CreatorLayer::onSavedLevels) != (der1)(&D::onSavedLevels)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onSavedLevelsWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CurrencyRewardLayer : CurrencyRewardLayer, InterfaceBase {
	$CurrencyRewardLayer(const $CurrencyRewardLayer& c) : CurrencyRewardLayer(c) {}
	$CurrencyRewardLayer() = delete;
	setInterfaceTypesOf(1, CurrencyRewardLayer, update, , 1, float);
	static inline auto address0 = base+0x447950;
	static inline auto address1 = base+0x44a5c0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(CurrencyRewardLayer, update, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(CurrencyRewardLayer, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$CurrencyRewardLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$CurrencyRewardLayer::update) != (der1)(&D::update)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::updateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CustomListView : CustomListView, InterfaceBase {
	$CustomListView(const $CustomListView& c) : CustomListView(c) {}
	$CustomListView() = delete;
	setInterfaceStaticTypesOf(0, CustomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType);
	setInterfaceTypesOf(1, CustomListView, getListCell, , 1, char const*);
	setInterfaceTypesOf(2, CustomListView, loadCell, , 2, TableViewCell*, int);
	setInterfaceTypesOf(3, CustomListView, setupList, , 0);
	static inline auto address0 = base+0x10d410;
	static inline auto address1 = base+0x10d560;
	static inline auto address2 = base+0x10e610;
	static inline auto address3 = base+0x116e70;

	dupable static getFunctionOf(CustomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(CustomListView, getListCell, , 1, char const*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CustomListView, loadCell, , 2, TableViewCell*, int) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(CustomListView, setupList, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(CustomListView, create, , 5, cocos2d::CCArray*, float, float, int, BoomListType) {
		return D::create(p0, p1, p2, p3, p4);
	}

	getWrapperOf(CustomListView, getListCell, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getListCell(p0);
	}

	getWrapperOf(CustomListView, loadCell, , 2, TableViewCell*, int) {
		return reinterpret_cast<D*>(this)->D::loadCell(p0, p1);
	}

	getWrapperOf(CustomListView, setupList, , 0) {
		return reinterpret_cast<D*>(this)->D::setupList();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CustomListView::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$CustomListView::getListCell) != (der1)(&D::getListCell)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getListCellWrapper)));
		}

		if constexpr((mem2)(&$CustomListView::loadCell) != (der2)(&D::loadCell)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::loadCellWrapper)));
		}

		if constexpr((mem3)(&$CustomListView::setupList) != (der3)(&D::setupList)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::setupListWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CustomSongCell : CustomSongCell, InterfaceBase {
	$CustomSongCell(const $CustomSongCell& c) : CustomSongCell(c) {}
	$CustomSongCell() = delete;
	setInterfaceTypesOf(0, CustomSongCell, loadFromObject, , 1, SongInfoObject*);
	static inline auto address0 = base+0x110220;

	dupable getFunctionOf(CustomSongCell, loadFromObject, , 1, SongInfoObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(CustomSongCell, loadFromObject, , 1, SongInfoObject*) {
		return reinterpret_cast<D*>(this)->D::loadFromObject(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CustomSongCell::loadFromObject) != (der0)(&D::loadFromObject)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::loadFromObjectWrapper)));
		}

		return true;
	}
};

template<class D>
struct $CustomSongLayer : CustomSongLayer, InterfaceBase {
	$CustomSongLayer(const $CustomSongLayer& c) : CustomSongLayer(c) {}
	$CustomSongLayer() = delete;
	setInterfaceTypesOf(0, CustomSongLayer, init, , 1, LevelSettingsObject*);
	setInterfaceTypesOf(1, CustomSongLayer, onArtists, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, CustomSongLayer, onSongBrowser, , 1, cocos2d::CCObject*);
	static inline auto address0 = base+0xf06f0;
	static inline auto address1 = base+0xf1950;
	static inline auto address2 = base+0xf18a0;

	dupable getFunctionOf(CustomSongLayer, init, , 1, LevelSettingsObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(CustomSongLayer, onArtists, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(CustomSongLayer, onSongBrowser, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	getWrapperOf(CustomSongLayer, init, , 1, LevelSettingsObject*) {
		return reinterpret_cast<D*>(this)->D::init(p0);
	}

	getWrapperOf(CustomSongLayer, onArtists, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onArtists(p0);
	}

	getWrapperOf(CustomSongLayer, onSongBrowser, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onSongBrowser(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$CustomSongLayer::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::initWrapper)));
		}

		if constexpr((mem1)(&$CustomSongLayer::onArtists) != (der1)(&D::onArtists)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onArtistsWrapper)));
		}

		if constexpr((mem2)(&$CustomSongLayer::onSongBrowser) != (der2)(&D::onSongBrowser)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::onSongBrowserWrapper)));
		}

		return true;
	}
};

template<class D>
struct $DialogLayer : DialogLayer, InterfaceBase {
	$DialogLayer(const $DialogLayer& c) : DialogLayer(c) {}
	$DialogLayer() = delete;
	setInterfaceTypesOf(1, DialogLayer, onEnter, , 0);
	setInterfaceTypesOf(2, DialogLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(3, DialogLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(4, DialogLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(5, DialogLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(6, DialogLayer, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(7, DialogLayer, keyBackClicked, , 0);
	setInterfaceTypesOf(8, DialogLayer, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(9, DialogLayer, fadeInTextFinished, , 1, TextArea*);
	static inline auto address0 = base+0x204720;
	static inline auto address1 = base+0x205900;
	static inline auto address2 = base+0x205790;
	static inline auto address3 = base+0x205820;
	static inline auto address4 = base+0x2057e0;
	static inline auto address5 = base+0x205840;
	static inline auto address6 = base+0x205890;
	static inline auto address7 = base+0x2056a0;
	static inline auto address8 = base+0x205ce0;
	static inline auto address9 = base+0x205930;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(DialogLayer, onEnter, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(DialogLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(DialogLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(DialogLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable getFunctionOf(DialogLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(DialogLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(DialogLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(DialogLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(DialogLayer, fadeInTextFinished, , 1, TextArea*) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(DialogLayer, onEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnter();
	}

	getWrapperOf(DialogLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(DialogLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(DialogLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(DialogLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(DialogLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(DialogLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	getWrapperOf(DialogLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(DialogLayer, fadeInTextFinished, , 1, TextArea*) {
		return reinterpret_cast<D*>(this)->D::fadeInTextFinished(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$DialogLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$DialogLayer::onEnter) != (der1)(&D::onEnter)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::onEnterWrapper)));
		}

		if ((mem2)(&$DialogLayer::ccTouchBegan) != (der2)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::ccTouchBeganWrapper)));
		}

		if ((mem3)(&$DialogLayer::ccTouchMoved) != (der3)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::ccTouchMovedWrapper)));
		}

		if ((mem4)(&$DialogLayer::ccTouchEnded) != (der4)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::ccTouchEndedWrapper)));
		}

		if ((mem5)(&$DialogLayer::ccTouchCancelled) != (der5)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::ccTouchCancelledWrapper)));
		}

		if ((mem6)(&$DialogLayer::registerWithTouchDispatcher) != (der6)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::registerWithTouchDispatcherWrapper)));
		}

		if ((mem7)(&$DialogLayer::keyBackClicked) != (der7)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::keyBackClickedWrapper)));
		}

		if ((mem8)(&$DialogLayer::keyDown) != (der8)(&D::keyDown)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::keyDownWrapper)));
		}

		if ((mem9)(&$DialogLayer::fadeInTextFinished) != (der9)(&D::fadeInTextFinished)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::fadeInTextFinishedWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EditorOptionsLayer : EditorOptionsLayer, InterfaceBase {
	$EditorOptionsLayer(const $EditorOptionsLayer& c) : EditorOptionsLayer(c) {}
	$EditorOptionsLayer() = delete;
	setInterfaceTypesOf(0, EditorOptionsLayer, onButtonsPerRow, , 1, cocos2d::CCObject*);
	static inline auto address0 = base+0x147b30;

	dupable getFunctionOf(EditorOptionsLayer, onButtonsPerRow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	getWrapperOf(EditorOptionsLayer, onButtonsPerRow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onButtonsPerRow(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$EditorOptionsLayer::onButtonsPerRow) != (der0)(&D::onButtonsPerRow)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::onButtonsPerRowWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EditorPauseLayer : EditorPauseLayer, InterfaceBase {
	$EditorPauseLayer(const $EditorPauseLayer& c) : EditorPauseLayer(c) {}
	$EditorPauseLayer() = delete;
	setInterfaceTypesOf(1, EditorPauseLayer, keyBackClicked, , 0);
	setInterfaceTypesOf(2, EditorPauseLayer, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(3, EditorPauseLayer, customSetup, , 0);
	setInterfaceTypesOf(4, EditorPauseLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool);
	setInterfaceStaticTypesOf(5, EditorPauseLayer, create, , 1, LevelEditorLayer*);
	setInterfaceTypesOf(6, EditorPauseLayer, saveLevel, , 0);
	setInterfaceTypesOf(7, EditorPauseLayer, init, , 1, LevelEditorLayer*);
	static inline auto address0 = base+0x13c3b0;
	static inline auto address1 = base+0x13f320;
	static inline auto address2 = base+0x13f3a0;
	static inline auto address3 = base+0x13cc00;
	static inline auto address4 = base+0x13f1b0;
	static inline auto address5 = base+0x13c680;
	static inline auto address6 = base+0x13ebd0;
	static inline auto address7 = base+0x13c7a0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(EditorPauseLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(EditorPauseLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(EditorPauseLayer, customSetup, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(EditorPauseLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable static getFunctionOf(EditorPauseLayer, create, , 1, LevelEditorLayer*) {
		return reinterpret_cast<fun5>(address5)(p0);
	}

	dupable getFunctionOf(EditorPauseLayer, saveLevel, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(EditorPauseLayer, init, , 1, LevelEditorLayer*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(EditorPauseLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	getWrapperOf(EditorPauseLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(EditorPauseLayer, customSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::customSetup();
	}

	getWrapperOf(EditorPauseLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool) {
		return reinterpret_cast<D*>(this)->D::FLAlert_Clicked(p0, p1);
	}

	static getWrapperOf(EditorPauseLayer, create, , 1, LevelEditorLayer*) {
		return D::create(p0);
	}

	getWrapperOf(EditorPauseLayer, saveLevel, , 0) {
		return reinterpret_cast<D*>(this)->D::saveLevel();
	}

	getWrapperOf(EditorPauseLayer, init, , 1, LevelEditorLayer*) {
		return reinterpret_cast<D*>(this)->D::init(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$EditorPauseLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$EditorPauseLayer::keyBackClicked) != (der1)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::keyBackClickedWrapper)));
		}

		if ((mem2)(&$EditorPauseLayer::keyDown) != (der2)(&D::keyDown)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::keyDownWrapper)));
		}

		if ((mem3)(&$EditorPauseLayer::customSetup) != (der3)(&D::customSetup)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::customSetupWrapper)));
		}

		if ((mem4)(&$EditorPauseLayer::FLAlert_Clicked) != (der4)(&D::FLAlert_Clicked)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::FLAlert_ClickedWrapper)));
		}

		if constexpr((mem5)(&$EditorPauseLayer::create) != (der5)(&D::create)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::createWrapper)));
		}

		if constexpr((mem6)(&$EditorPauseLayer::saveLevel) != (der6)(&D::saveLevel)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::saveLevelWrapper)));
		}

		if constexpr((mem7)(&$EditorPauseLayer::init) != (der7)(&D::init)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::initWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EditorUI : EditorUI, InterfaceBase {
	$EditorUI(const $EditorUI& c) : EditorUI(c) {}
	$EditorUI() = delete;
	setInterfaceTypesOf(0, EditorUI, constrainGameLayerPosition, , 0);
	setInterfaceTypesOf(1, EditorUI, create, , 1, LevelEditorLayer*);
	setInterfaceTypesOf(2, EditorUI, deselectAll, , 0);
	setInterfaceTypesOf(3, EditorUI, onDeselectAll, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(4, EditorUI, disableButton, , 1, CreateMenuItem*);
	setInterfaceTypesOf(5, EditorUI, editButtonUsable, , 0);
	setInterfaceTypesOf(6, EditorUI, editObject, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(7, EditorUI, enableButton, , 1, CreateMenuItem*);
	setInterfaceTypesOf(8, EditorUI, getCreateBtn, , 2, int, int);
	setInterfaceTypesOf(9, EditorUI, getGroupCenter, , 2, cocos2d::CCArray*, bool);
	setInterfaceTypesOf(10, EditorUI, getSelectedObjects, , 0);
	setInterfaceTypesOf(11, EditorUI, init, , 1, LevelEditorLayer*);
	setInterfaceTypesOf(12, EditorUI, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(13, EditorUI, moveObject, , 2, GameObject*, cocos2d::CCPoint);
	setInterfaceTypesOf(14, EditorUI, onDuplicate, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(15, EditorUI, pasteObjects, , 1, gd::string);
	setInterfaceTypesOf(16, EditorUI, playerTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(17, EditorUI, playtestStopped, , 0);
	setInterfaceTypesOf(18, EditorUI, redoLastAction, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(19, EditorUI, replaceGroupID, , 3, GameObject*, int, int);
	setInterfaceTypesOf(20, EditorUI, scaleChanged, , 1, float);
	setInterfaceTypesOf(21, EditorUI, scaleObjects, , 3, cocos2d::CCArray*, float, cocos2d::CCPoint);
	setInterfaceTypesOf(22, EditorUI, selectObjects, , 2, cocos2d::CCArray*, bool);
	setInterfaceTypesOf(23, EditorUI, setupCreateMenu, , 0);
	setInterfaceTypesOf(24, EditorUI, undoLastAction, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(25, EditorUI, updateButtons, , 0);
	setInterfaceTypesOf(26, EditorUI, updateObjectInfoLabel, , 0);
	setInterfaceTypesOf(27, EditorUI, updateSlider, , 0);
	setInterfaceTypesOf(28, EditorUI, updateZoom, , 1, float);
	static inline auto address0 = base+0x1c6d0;
	static inline auto address1 = base+0x8a80;
	static inline auto address2 = base+0x1f300;
	static inline auto address3 = base+0x19cd0;
	static inline auto address4 = base+0x1c0f0;
	static inline auto address5 = base+0x28f30;
	static inline auto address6 = base+0x195a0;
	static inline auto address7 = base+0x1bff0;
	static inline auto address8 = base+0x1f6c0;
	static inline auto address9 = base+0x23470;
	static inline auto address10 = base+0x23f30;
	static inline auto address11 = base+0x8ae0;
	static inline auto address12 = base+0x30790;
	static inline auto address13 = base+0x24b10;
	static inline auto address14 = base+0x18ba0;
	static inline auto address15 = base+0x232d0;
	static inline auto address16 = base+0x2ebf0;
	static inline auto address17 = base+0x24790;
	static inline auto address18 = base+0xb8e0;
	static inline auto address19 = base+0x27470;
	static inline auto address20 = base+0x25490;
	static inline auto address21 = base+0x252e0;
	static inline auto address22 = base+0x23940;
	static inline auto address23 = base+0xcb50;
	static inline auto address24 = base+0xb830;
	static inline auto address25 = base+0x1a300;
	static inline auto address26 = base+0x1cb10;
	static inline auto address27 = base+0x18a90;
	static inline auto address28 = base+0x248c0;

	dupable getFunctionOf(EditorUI, constrainGameLayerPosition, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(EditorUI, create, , 1, LevelEditorLayer*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(EditorUI, deselectAll, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(EditorUI, onDeselectAll, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(EditorUI, disableButton, , 1, CreateMenuItem*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(EditorUI, editButtonUsable, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(EditorUI, editObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(EditorUI, enableButton, , 1, CreateMenuItem*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(EditorUI, getCreateBtn, , 2, int, int) {
		return reinterpret_cast<fun8>(address8)(this, p0, p1);
	}

	dupable getFunctionOf(EditorUI, getGroupCenter, , 2, cocos2d::CCArray*, bool) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1);
	}

	dupable getFunctionOf(EditorUI, getSelectedObjects, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(EditorUI, init, , 1, LevelEditorLayer*) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(EditorUI, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(EditorUI, moveObject, , 2, GameObject*, cocos2d::CCPoint) {
		return reinterpret_cast<fun13>(address13)(this, p0, p1);
	}

	dupable getFunctionOf(EditorUI, onDuplicate, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(EditorUI, pasteObjects, , 1, gd::string) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(EditorUI, playerTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1);
	}

	dupable getFunctionOf(EditorUI, playtestStopped, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(EditorUI, redoLastAction, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	dupable getFunctionOf(EditorUI, replaceGroupID, , 3, GameObject*, int, int) {
		return reinterpret_cast<fun19>(address19)(this, p0, p1, p2);
	}

	dupable getFunctionOf(EditorUI, scaleChanged, , 1, float) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(EditorUI, scaleObjects, , 3, cocos2d::CCArray*, float, cocos2d::CCPoint) {
		return reinterpret_cast<fun21>(address21)(this, p0, p1, p2);
	}

	dupable getFunctionOf(EditorUI, selectObjects, , 2, cocos2d::CCArray*, bool) {
		return reinterpret_cast<fun22>(address22)(this, p0, p1);
	}

	dupable getFunctionOf(EditorUI, setupCreateMenu, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(EditorUI, undoLastAction, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	dupable getFunctionOf(EditorUI, updateButtons, , 0) {
		return reinterpret_cast<fun25>(address25)(this);
	}

	dupable getFunctionOf(EditorUI, updateObjectInfoLabel, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(EditorUI, updateSlider, , 0) {
		return reinterpret_cast<fun27>(address27)(this);
	}

	dupable getFunctionOf(EditorUI, updateZoom, , 1, float) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	getWrapperOf(EditorUI, constrainGameLayerPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::constrainGameLayerPosition();
	}

	getWrapperOf(EditorUI, create, , 1, LevelEditorLayer*) {
		return reinterpret_cast<D*>(this)->D::create(p0);
	}

	getWrapperOf(EditorUI, deselectAll, , 0) {
		return reinterpret_cast<D*>(this)->D::deselectAll();
	}

	getWrapperOf(EditorUI, onDeselectAll, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onDeselectAll(p0);
	}

	getWrapperOf(EditorUI, disableButton, , 1, CreateMenuItem*) {
		return reinterpret_cast<D*>(this)->D::disableButton(p0);
	}

	getWrapperOf(EditorUI, editButtonUsable, , 0) {
		return reinterpret_cast<D*>(this)->D::editButtonUsable();
	}

	getWrapperOf(EditorUI, editObject, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::editObject(p0);
	}

	getWrapperOf(EditorUI, enableButton, , 1, CreateMenuItem*) {
		return reinterpret_cast<D*>(this)->D::enableButton(p0);
	}

	getWrapperOf(EditorUI, getCreateBtn, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::getCreateBtn(p0, p1);
	}

	getWrapperOf(EditorUI, getGroupCenter, , 2, cocos2d::CCArray*, bool) {
		return reinterpret_cast<D*>(this)->D::getGroupCenter(p0, p1);
	}

	getWrapperOf(EditorUI, getSelectedObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::getSelectedObjects();
	}

	getWrapperOf(EditorUI, init, , 1, LevelEditorLayer*) {
		return reinterpret_cast<D*>(this)->D::init(p0);
	}

	getWrapperOf(EditorUI, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(EditorUI, moveObject, , 2, GameObject*, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::moveObject(p0, p1);
	}

	getWrapperOf(EditorUI, onDuplicate, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onDuplicate(p0);
	}

	getWrapperOf(EditorUI, pasteObjects, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::pasteObjects(p0);
	}

	getWrapperOf(EditorUI, playerTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::playerTouchBegan(p0, p1);
	}

	getWrapperOf(EditorUI, playtestStopped, , 0) {
		return reinterpret_cast<D*>(this)->D::playtestStopped();
	}

	getWrapperOf(EditorUI, redoLastAction, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::redoLastAction(p0);
	}

	getWrapperOf(EditorUI, replaceGroupID, , 3, GameObject*, int, int) {
		return reinterpret_cast<D*>(this)->D::replaceGroupID(p0, p1, p2);
	}

	getWrapperOf(EditorUI, scaleChanged, , 1, float) {
		return reinterpret_cast<D*>(this)->D::scaleChanged(p0);
	}

	getWrapperOf(EditorUI, scaleObjects, , 3, cocos2d::CCArray*, float, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::scaleObjects(p0, p1, p2);
	}

	getWrapperOf(EditorUI, selectObjects, , 2, cocos2d::CCArray*, bool) {
		return reinterpret_cast<D*>(this)->D::selectObjects(p0, p1);
	}

	getWrapperOf(EditorUI, setupCreateMenu, , 0) {
		return reinterpret_cast<D*>(this)->D::setupCreateMenu();
	}

	getWrapperOf(EditorUI, undoLastAction, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::undoLastAction(p0);
	}

	getWrapperOf(EditorUI, updateButtons, , 0) {
		return reinterpret_cast<D*>(this)->D::updateButtons();
	}

	getWrapperOf(EditorUI, updateObjectInfoLabel, , 0) {
		return reinterpret_cast<D*>(this)->D::updateObjectInfoLabel();
	}

	getWrapperOf(EditorUI, updateSlider, , 0) {
		return reinterpret_cast<D*>(this)->D::updateSlider();
	}

	getWrapperOf(EditorUI, updateZoom, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateZoom(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$EditorUI::constrainGameLayerPosition) != (der0)(&D::constrainGameLayerPosition)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::constrainGameLayerPositionWrapper)));
		}

		if constexpr((mem1)(&$EditorUI::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$EditorUI::deselectAll) != (der2)(&D::deselectAll)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::deselectAllWrapper)));
		}

		if constexpr((mem3)(&$EditorUI::onDeselectAll) != (der3)(&D::onDeselectAll)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::onDeselectAllWrapper)));
		}

		if constexpr((mem4)(&$EditorUI::disableButton) != (der4)(&D::disableButton)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::disableButtonWrapper)));
		}

		if constexpr((mem5)(&$EditorUI::editButtonUsable) != (der5)(&D::editButtonUsable)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::editButtonUsableWrapper)));
		}

		if constexpr((mem6)(&$EditorUI::editObject) != (der6)(&D::editObject)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::editObjectWrapper)));
		}

		if constexpr((mem7)(&$EditorUI::enableButton) != (der7)(&D::enableButton)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::enableButtonWrapper)));
		}

		if constexpr((mem8)(&$EditorUI::getCreateBtn) != (der8)(&D::getCreateBtn)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::getCreateBtnWrapper)));
		}

		if constexpr((mem9)(&$EditorUI::getGroupCenter) != (der9)(&D::getGroupCenter)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::getGroupCenterWrapper)));
		}

		if constexpr((mem10)(&$EditorUI::getSelectedObjects) != (der10)(&D::getSelectedObjects)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::getSelectedObjectsWrapper)));
		}

		if constexpr((mem11)(&$EditorUI::init) != (der11)(&D::init)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::initWrapper)));
		}

		if ((mem12)(&$EditorUI::keyDown) != (der12)(&D::keyDown)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::keyDownWrapper)));
		}

		if constexpr((mem13)(&$EditorUI::moveObject) != (der13)(&D::moveObject)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::moveObjectWrapper)));
		}

		if constexpr((mem14)(&$EditorUI::onDuplicate) != (der14)(&D::onDuplicate)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::onDuplicateWrapper)));
		}

		if constexpr((mem15)(&$EditorUI::pasteObjects) != (der15)(&D::pasteObjects)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::pasteObjectsWrapper)));
		}

		if constexpr((mem16)(&$EditorUI::playerTouchBegan) != (der16)(&D::playerTouchBegan)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::playerTouchBeganWrapper)));
		}

		if constexpr((mem17)(&$EditorUI::playtestStopped) != (der17)(&D::playtestStopped)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::playtestStoppedWrapper)));
		}

		if constexpr((mem18)(&$EditorUI::redoLastAction) != (der18)(&D::redoLastAction)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::redoLastActionWrapper)));
		}

		if constexpr((mem19)(&$EditorUI::replaceGroupID) != (der19)(&D::replaceGroupID)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::replaceGroupIDWrapper)));
		}

		if constexpr((mem20)(&$EditorUI::scaleChanged) != (der20)(&D::scaleChanged)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::scaleChangedWrapper)));
		}

		if constexpr((mem21)(&$EditorUI::scaleObjects) != (der21)(&D::scaleObjects)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::scaleObjectsWrapper)));
		}

		if constexpr((mem22)(&$EditorUI::selectObjects) != (der22)(&D::selectObjects)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::selectObjectsWrapper)));
		}

		if constexpr((mem23)(&$EditorUI::setupCreateMenu) != (der23)(&D::setupCreateMenu)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::setupCreateMenuWrapper)));
		}

		if constexpr((mem24)(&$EditorUI::undoLastAction) != (der24)(&D::undoLastAction)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::undoLastActionWrapper)));
		}

		if constexpr((mem25)(&$EditorUI::updateButtons) != (der25)(&D::updateButtons)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::updateButtonsWrapper)));
		}

		if constexpr((mem26)(&$EditorUI::updateObjectInfoLabel) != (der26)(&D::updateObjectInfoLabel)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::updateObjectInfoLabelWrapper)));
		}

		if constexpr((mem27)(&$EditorUI::updateSlider) != (der27)(&D::updateSlider)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::updateSliderWrapper)));
		}

		if constexpr((mem28)(&$EditorUI::updateZoom) != (der28)(&D::updateZoom)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::updateZoomWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EffectGameObject : EffectGameObject, InterfaceBase {
	$EffectGameObject(const $EffectGameObject& c) : EffectGameObject(c) {}
	$EffectGameObject() = delete;
	setInterfaceStaticTypesOf(0, EffectGameObject, create, , 1, char const*);
	setInterfaceTypesOf(1, EffectGameObject, getTargetColorIndex, , 0);
	setInterfaceTypesOf(2, EffectGameObject, triggerObject, , 1, GJBaseGameLayer*);
	static inline auto address0 = base+0xc9790;
	static inline auto address1 = base+0xca1f0;
	static inline auto address2 = base+0xc9870;

	dupable static getFunctionOf(EffectGameObject, create, , 1, char const*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(EffectGameObject, getTargetColorIndex, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(EffectGameObject, triggerObject, , 1, GJBaseGameLayer*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	static getWrapperOf(EffectGameObject, create, , 1, char const*) {
		return D::create(p0);
	}

	getWrapperOf(EffectGameObject, getTargetColorIndex, , 0) {
		return reinterpret_cast<D*>(this)->D::getTargetColorIndex();
	}

	getWrapperOf(EffectGameObject, triggerObject, , 1, GJBaseGameLayer*) {
		return reinterpret_cast<D*>(this)->D::triggerObject(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$EffectGameObject::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$EffectGameObject::getTargetColorIndex) != (der1)(&D::getTargetColorIndex)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getTargetColorIndexWrapper)));
		}

		if ((mem2)(&$EffectGameObject::triggerObject) != (der2)(&D::triggerObject)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::triggerObjectWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EndLevelLayer : EndLevelLayer, InterfaceBase {
	$EndLevelLayer(const $EndLevelLayer& c) : EndLevelLayer(c) {}
	$EndLevelLayer() = delete;
	setInterfaceStaticTypesOf(0, EndLevelLayer, create, , 0);
	static inline auto address0 = base+0x2787d0;

	dupable static getFunctionOf(EndLevelLayer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	static getWrapperOf(EndLevelLayer, create, , 0) {
		return D::create();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$EndLevelLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $EndPortalObject : EndPortalObject, InterfaceBase {
	$EndPortalObject(const $EndPortalObject& c) : EndPortalObject(c) {}
	$EndPortalObject() = delete;
	setInterfaceStaticTypesOf(0, EndPortalObject, create, , 0);
	setInterfaceTypesOf(1, EndPortalObject, updateColors, , 1, cocos2d::_ccColor3B);
	static inline auto address0 = base+0x1da8f0;
	static inline auto address1 = base+0x1dacb0;

	dupable static getFunctionOf(EndPortalObject, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(EndPortalObject, updateColors, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	static getWrapperOf(EndPortalObject, create, , 0) {
		return D::create();
	}

	getWrapperOf(EndPortalObject, updateColors, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::updateColors(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$EndPortalObject::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$EndPortalObject::updateColors) != (der1)(&D::updateColors)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::updateColorsWrapper)));
		}

		return true;
	}
};

template<class D>
struct $FLAlertLayer : FLAlertLayer, InterfaceBase {
	$FLAlertLayer(const $FLAlertLayer& c) : FLAlertLayer(c) {}
	$FLAlertLayer() = delete;
	setInterfaceTypesOf(1, FLAlertLayer, onEnter, , 0);
	setInterfaceTypesOf(2, FLAlertLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(3, FLAlertLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(4, FLAlertLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(5, FLAlertLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*);
	setInterfaceTypesOf(6, FLAlertLayer, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(7, FLAlertLayer, keyBackClicked, , 0);
	setInterfaceTypesOf(8, FLAlertLayer, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(9, FLAlertLayer, show, , 0);
	setInterfaceTypesOf(10, FLAlertLayer, init, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
	setInterfaceStaticTypesOf(12, FLAlertLayer, create, , 6, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
	setInterfaceStaticTypesOf(13, FLAlertLayer, create, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
	static inline auto address0 = base+0x25db60;
	static inline auto address1 = base+0x25f350;
	static inline auto address2 = base+0x25ee40;
	static inline auto address3 = base+0x25f0a0;
	static inline auto address4 = base+0x25ef60;
	static inline auto address5 = base+0x25f020;
	static inline auto address6 = base+0x25f2e0;
	static inline auto address7 = base+0x25ed90;
	static inline auto address8 = base+0x25ece0;
	static inline auto address9 = base+0x25f120;
	static inline auto address10 = base+0x25e1b0;
	static inline auto address12 = base+0x25e0e0;
	static inline auto address13 = base+0x25dec0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(FLAlertLayer, onEnter, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(FLAlertLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(FLAlertLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	dupable getFunctionOf(FLAlertLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable getFunctionOf(FLAlertLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(FLAlertLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(FLAlertLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(FLAlertLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(FLAlertLayer, show, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(FLAlertLayer, init, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable static getFunctionOf(FLAlertLayer, create, , 6, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float) {
		return reinterpret_cast<fun12>(address12)(p0, p1, p2, p3, p4, p5);
	}

	dupable static getFunctionOf(FLAlertLayer, create, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float) {
		return reinterpret_cast<fun13>(address13)(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(FLAlertLayer, onEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnter();
	}

	getWrapperOf(FLAlertLayer, ccTouchBegan, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchBegan(p0, p1);
	}

	getWrapperOf(FLAlertLayer, ccTouchMoved, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchMoved(p0, p1);
	}

	getWrapperOf(FLAlertLayer, ccTouchEnded, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchEnded(p0, p1);
	}

	getWrapperOf(FLAlertLayer, ccTouchCancelled, , 2, cocos2d::CCTouch*, cocos2d::CCEvent*) {
		return reinterpret_cast<D*>(this)->D::ccTouchCancelled(p0, p1);
	}

	getWrapperOf(FLAlertLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(FLAlertLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	getWrapperOf(FLAlertLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(FLAlertLayer, show, , 0) {
		return reinterpret_cast<D*>(this)->D::show();
	}

	getWrapperOf(FLAlertLayer, init, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	static getWrapperOf(FLAlertLayer, create, , 6, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float) {
		return D::create(p0, p1, p2, p3, p4, p5);
	}

	static getWrapperOf(FLAlertLayer, create, , 8, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float) {
		return D::create(p0, p1, p2, p3, p4, p5, p6, p7);
	}

public:
	static bool _apply() {

		if constexpr(&$FLAlertLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$FLAlertLayer::onEnter) != (der1)(&D::onEnter)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::onEnterWrapper)));
		}

		if ((mem2)(&$FLAlertLayer::ccTouchBegan) != (der2)(&D::ccTouchBegan)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::ccTouchBeganWrapper)));
		}

		if ((mem3)(&$FLAlertLayer::ccTouchMoved) != (der3)(&D::ccTouchMoved)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::ccTouchMovedWrapper)));
		}

		if ((mem4)(&$FLAlertLayer::ccTouchEnded) != (der4)(&D::ccTouchEnded)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::ccTouchEndedWrapper)));
		}

		if ((mem5)(&$FLAlertLayer::ccTouchCancelled) != (der5)(&D::ccTouchCancelled)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::ccTouchCancelledWrapper)));
		}

		if ((mem6)(&$FLAlertLayer::registerWithTouchDispatcher) != (der6)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::registerWithTouchDispatcherWrapper)));
		}

		if ((mem7)(&$FLAlertLayer::keyBackClicked) != (der7)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::keyBackClickedWrapper)));
		}

		if ((mem8)(&$FLAlertLayer::keyDown) != (der8)(&D::keyDown)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::keyDownWrapper)));
		}

		if ((mem9)(&$FLAlertLayer::show) != (der9)(&D::show)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::showWrapper)));
		}

		if constexpr((mem10)(&$FLAlertLayer::init) != (der10)(&D::init)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::initWrapper)));
		}

		if constexpr((mem12)(&$FLAlertLayer::create) != (der12)(&D::create)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::createWrapper)));
		}

		if constexpr((mem13)(&$FLAlertLayer::create) != (der13)(&D::create)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $FLAlertLayerProtocol : FLAlertLayerProtocol, InterfaceBase {
	$FLAlertLayerProtocol(const $FLAlertLayerProtocol& c) : FLAlertLayerProtocol(c) {}
	$FLAlertLayerProtocol() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $GameToolbox : GameToolbox, InterfaceBase {
	$GameToolbox(const $GameToolbox& c) : GameToolbox(c) {}
	$GameToolbox() = delete;
	setInterfaceStaticTypesOf(0, GameToolbox, createToggleButton, , 8, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCArray*);
	setInterfaceStaticTypesOf(1, GameToolbox, createToggleButton, , 15, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
	static inline auto address0 = base+0x0;
	static inline auto address1 = base+0x0;

	dupable static getFunctionOf(GameToolbox, createToggleButton, , 8, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable static getFunctionOf(GameToolbox, createToggleButton, , 15, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
	}

	static getWrapperOf(GameToolbox, createToggleButton, , 8, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCArray*) {
		return D::createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	static getWrapperOf(GameToolbox, createToggleButton, , 15, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*) {
		return D::createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$GameToolbox::createToggleButton) != (der0)(&D::createToggleButton)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createToggleButtonWrapper)));
		}

		if constexpr((mem1)(&$GameToolbox::createToggleButton) != (der1)(&D::createToggleButton)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createToggleButtonWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJRotationControl : GJRotationControl, InterfaceBase {
	$GJRotationControl(const $GJRotationControl& c) : GJRotationControl(c) {}
	$GJRotationControl() = delete;
	setInterfaceTypesOf(0, GJRotationControl, init, , 0);
	setInterfaceTypesOf(1, GJRotationControl, updateSliderPosition, , 1, cocos2d::CCPoint);
	static inline auto address0 = base+0x31510;
	static inline auto address1 = base+0x316a0;

	dupable getFunctionOf(GJRotationControl, init, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(GJRotationControl, updateSliderPosition, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(GJRotationControl, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(GJRotationControl, updateSliderPosition, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::updateSliderPosition(p0);
	}

public:
	static bool _apply() {

		if ((mem0)(&$GJRotationControl::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::initWrapper)));
		}

		if constexpr((mem1)(&$GJRotationControl::updateSliderPosition) != (der1)(&D::updateSliderPosition)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::updateSliderPositionWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJBaseGameLayer : GJBaseGameLayer, InterfaceBase {
	$GJBaseGameLayer(const $GJBaseGameLayer& c) : GJBaseGameLayer(c) {}
	$GJBaseGameLayer() = delete;
	setInterfaceTypesOf(0, GJBaseGameLayer, objectsCollided, , 2, int, int);
	setInterfaceTypesOf(1, GJBaseGameLayer, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int);
	setInterfaceTypesOf(2, GJBaseGameLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*);
	setInterfaceTypesOf(3, GJBaseGameLayer, flipGravity, , 3, PlayerObject*, bool, bool);
	setInterfaceTypesOf(4, GJBaseGameLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*);
	setInterfaceTypesOf(5, GJBaseGameLayer, toggleGroupTriggered, , 2, int, bool);
	setInterfaceTypesOf(6, GJBaseGameLayer, spawnGroup, , 1, int);
	setInterfaceTypesOf(7, GJBaseGameLayer, addToSection, , 1, GameObject*);
	setInterfaceTypesOf(8, GJBaseGameLayer, addToGroup, , 3, GameObject*, int, bool);
	setInterfaceTypesOf(9, GJBaseGameLayer, removeFromGroup, , 2, GameObject*, int);
	setInterfaceTypesOf(10, GJBaseGameLayer, init, , 0);
	setInterfaceTypesOf(11, GJBaseGameLayer, addObjectCounter, , 2, LabelGameObject*, int);
	setInterfaceTypesOf(12, GJBaseGameLayer, addToGroups, , 2, GameObject*, bool);
	setInterfaceTypesOf(13, GJBaseGameLayer, atlasValue, , 1, int);
	setInterfaceTypesOf(14, GJBaseGameLayer, bumpPlayer, , 2, PlayerObject*, GameObject*);
	setInterfaceTypesOf(15, GJBaseGameLayer, calculateOpacityValues, , 4, EffectGameObject*, EffectGameObject*, float, GJEffectManager*);
	setInterfaceTypesOf(16, GJBaseGameLayer, checkSpawnObjects, , 0);
	setInterfaceTypesOf(17, GJBaseGameLayer, collectItem, , 2, int, int);
	setInterfaceTypesOf(18, GJBaseGameLayer, collectedObject, , 1, EffectGameObject*);
	setInterfaceTypesOf(19, GJBaseGameLayer, createTextLayers, , 0);
	setInterfaceTypesOf(20, GJBaseGameLayer, damagingObjectsInRect, , 1, cocos2d::CCRect);
	setInterfaceTypesOf(21, GJBaseGameLayer, enableHighCapacityMode, , 0);
	setInterfaceTypesOf(22, GJBaseGameLayer, getCapacityString, , 0);
	setInterfaceTypesOf(23, GJBaseGameLayer, getGroundHeightForMode, , 1, int);
	setInterfaceTypesOf(24, GJBaseGameLayer, getGroup, , 1, int);
	setInterfaceTypesOf(25, GJBaseGameLayer, getMoveDeltaForObjects, , 2, int, int);
	setInterfaceTypesOf(26, GJBaseGameLayer, getOptimizedGroup, , 1, int);
	setInterfaceTypesOf(27, GJBaseGameLayer, getStaticGroup, , 1, int);
	setInterfaceTypesOf(28, GJBaseGameLayer, isGroupDisabledForObject, , 1, GameObject*);
	setInterfaceTypesOf(29, GJBaseGameLayer, isGroupDisabledForObjectFull, , 2, GameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(30, GJBaseGameLayer, loadUpToPosition, , 1, float);
	setInterfaceTypesOf(31, GJBaseGameLayer, objectIntersectsCircle, , 2, GameObject*, GameObject*);
	setInterfaceTypesOf(32, GJBaseGameLayer, objectTriggered, , 1, EffectGameObject*);
	setInterfaceTypesOf(33, GJBaseGameLayer, optimizeMoveGroups, , 0);
	setInterfaceTypesOf(34, GJBaseGameLayer, parentForZLayer, , 3, int, bool, int);
	setInterfaceTypesOf(35, GJBaseGameLayer, playerTouchedRing, , 2, PlayerObject*, GameObject*);
	setInterfaceTypesOf(36, GJBaseGameLayer, processColorObject, , 5, EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*);
	setInterfaceTypesOf(37, GJBaseGameLayer, processFollowActions, , 0);
	setInterfaceTypesOf(38, GJBaseGameLayer, processMoveActions, , 0);
	setInterfaceTypesOf(39, GJBaseGameLayer, processMoveActionsStep, , 1, float);
	setInterfaceTypesOf(40, GJBaseGameLayer, processOpacityObject, , 4, EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*);
	setInterfaceTypesOf(41, GJBaseGameLayer, processPlayerFollowActions, , 1, float);
	setInterfaceTypesOf(42, GJBaseGameLayer, processRotationActions, , 0);
	setInterfaceTypesOf(43, GJBaseGameLayer, pushButton, , 2, int, bool);
	setInterfaceTypesOf(44, GJBaseGameLayer, rectIntersectsCircle, , 3, cocos2d::CCRect, cocos2d::CCPoint, float);
	setInterfaceTypesOf(45, GJBaseGameLayer, refreshCounterLabels, , 0);
	setInterfaceTypesOf(46, GJBaseGameLayer, releaseButton, , 2, int, bool);
	setInterfaceTypesOf(47, GJBaseGameLayer, removeFromGroups, , 1, GameObject*);
	setInterfaceTypesOf(48, GJBaseGameLayer, removeObjectFromSection, , 1, GameObject*);
	setInterfaceTypesOf(49, GJBaseGameLayer, reorderObjectSection, , 1, GameObject*);
	setInterfaceTypesOf(50, GJBaseGameLayer, resetGroupCounters, , 1, bool);
	setInterfaceTypesOf(51, GJBaseGameLayer, resetMoveOptimizedValue, , 0);
	setInterfaceTypesOf(52, GJBaseGameLayer, sectionForPos, , 1, float);
	setInterfaceTypesOf(53, GJBaseGameLayer, setupLayers, , 0);
	setInterfaceTypesOf(54, GJBaseGameLayer, shouldExitHackedLevel, , 0);
	setInterfaceTypesOf(55, GJBaseGameLayer, spawnGroupTriggered, , 3, int, float, int);
	setInterfaceTypesOf(56, GJBaseGameLayer, staticObjectsInRect, , 1, cocos2d::CCRect);
	setInterfaceTypesOf(57, GJBaseGameLayer, testInstantCountTrigger, , 5, int, int, int, bool, int);
	setInterfaceTypesOf(58, GJBaseGameLayer, toggleGroup, , 2, int, bool);
	setInterfaceTypesOf(59, GJBaseGameLayer, togglePlayerVisibility, , 1, bool);
	setInterfaceTypesOf(60, GJBaseGameLayer, triggerMoveCommand, , 1, EffectGameObject*);
	setInterfaceTypesOf(61, GJBaseGameLayer, updateCollisionBlocks, , 0);
	setInterfaceTypesOf(62, GJBaseGameLayer, updateCounters, , 2, int, int);
	setInterfaceTypesOf(63, GJBaseGameLayer, updateDisabledObjectsLastPos, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(64, GJBaseGameLayer, updateLayerCapacity, , 1, gd::string);
	setInterfaceTypesOf(65, GJBaseGameLayer, updateLegacyLayerCapacity, , 4, int, int, int, int);
	setInterfaceTypesOf(66, GJBaseGameLayer, updateOBB2, , 1, cocos2d::CCRect);
	setInterfaceTypesOf(67, GJBaseGameLayer, updateQueuedLabels, , 0);
	static inline auto address0 = base+0xb6d90;
	static inline auto address1 = base+0xb73a0;
	static inline auto address2 = base+0xb7420;
	static inline auto address3 = base+0xba990;
	static inline auto address4 = base+0xba9a0;
	static inline auto address5 = base+0xb75a0;
	static inline auto address6 = base+0xb7050;
	static inline auto address7 = base+0xb7b70;
	static inline auto address8 = base+0xb77f0;
	static inline auto address9 = base+0xb7a60;
	static inline auto address10 = base+0xafc90;
	static inline auto address11 = base+0xb9eb0;
	static inline auto address12 = base+0xb7780;
	static inline auto address13 = base+0xb21e0;
	static inline auto address14 = base+0xb6860;
	static inline auto address15 = base+0xb5be0;
	static inline auto address16 = base+0xb6f90;
	static inline auto address17 = base+0xb9e20;
	static inline auto address18 = base+0xb9b60;
	static inline auto address19 = base+0xb5260;
	static inline auto address20 = base+0xb6140;
	static inline auto address21 = base+0xb11e0;
	static inline auto address22 = base+0xb2210;
	static inline auto address23 = base+0xb6630;
	static inline auto address24 = base+0xb6f20;
	static inline auto address25 = base+0xb6db0;
	static inline auto address26 = base+0xb7940;
	static inline auto address27 = base+0xb79a0;
	static inline auto address28 = base+0xb5cc0;
	static inline auto address29 = base+0xb5de0;
	static inline auto address30 = base+0xba680;
	static inline auto address31 = base+0xb66e0;
	static inline auto address32 = base+0xb71b0;
	static inline auto address33 = base+0xb96c0;
	static inline auto address34 = base+0xb55d0;
	static inline auto address35 = base+0xb69e0;
	static inline auto address36 = base+0xb5a90;
	static inline auto address37 = base+0xb8fd0;
	static inline auto address38 = base+0xb86c0;
	static inline auto address39 = base+0xb7ea0;
	static inline auto address40 = base+0xb5ae0;
	static inline auto address41 = base+0xb8b50;
	static inline auto address42 = base+0xb7fd0;
	static inline auto address43 = base+0xb9920;
	static inline auto address44 = base+0xb6470;
	static inline auto address45 = base+0xb9fc0;
	static inline auto address46 = base+0xb9a00;
	static inline auto address47 = base+0xb7a00;
	static inline auto address48 = base+0xb7e00;
	static inline auto address49 = base+0xb7cb0;
	static inline auto address50 = base+0xba300;
	static inline auto address51 = base+0xb9670;
	static inline auto address52 = base+0xb6120;
	static inline auto address53 = base+0xaffe0;
	static inline auto address54 = base+0xb1100;
	static inline auto address55 = base+0xb7020;
	static inline auto address56 = base+0xb5f90;
	static inline auto address57 = base+0xb9ae0;
	static inline auto address58 = base+0xb75f0;
	static inline auto address59 = base+0xba910;
	static inline auto address60 = base+0xb7290;
	static inline auto address61 = base+0xb6a30;
	static inline auto address62 = base+0xb9bc0;
	static inline auto address63 = base+0xb95b0;
	static inline auto address64 = base+0xb1680;
	static inline auto address65 = base+0xb1590;
	static inline auto address66 = base+0xb63f0;
	static inline auto address67 = base+0xb9f30;
	static inline auto address68 = base+0xaf990;

	dupable getFunctionOf(GJBaseGameLayer, objectsCollided, , 2, int, int) {
		return reinterpret_cast<fun0>(address0)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	dupable getFunctionOf(GJBaseGameLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJBaseGameLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(GJBaseGameLayer, toggleGroupTriggered, , 2, int, bool) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, spawnGroup, , 1, int) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, addToSection, , 1, GameObject*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, addToGroup, , 3, GameObject*, int, bool) {
		return reinterpret_cast<fun8>(address8)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJBaseGameLayer, removeFromGroup, , 2, GameObject*, int) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, init, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, addObjectCounter, , 2, LabelGameObject*, int) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, addToGroups, , 2, GameObject*, bool) {
		return reinterpret_cast<fun12>(address12)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, atlasValue, , 1, int) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, bumpPlayer, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<fun14>(address14)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, calculateOpacityValues, , 4, EffectGameObject*, EffectGameObject*, float, GJEffectManager*) {
		return reinterpret_cast<fun15>(address15)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(GJBaseGameLayer, checkSpawnObjects, , 0) {
		return reinterpret_cast<fun16>(address16)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, collectItem, , 2, int, int) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, collectedObject, , 1, EffectGameObject*) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, createTextLayers, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, damagingObjectsInRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, enableHighCapacityMode, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, getCapacityString, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, getGroundHeightForMode, , 1, int) {
		return reinterpret_cast<fun23>(address23)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, getGroup, , 1, int) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, getMoveDeltaForObjects, , 2, int, int) {
		return reinterpret_cast<fun25>(address25)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, getOptimizedGroup, , 1, int) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, getStaticGroup, , 1, int) {
		return reinterpret_cast<fun27>(address27)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, isGroupDisabledForObject, , 1, GameObject*) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, isGroupDisabledForObjectFull, , 2, GameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun29>(address29)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, loadUpToPosition, , 1, float) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, objectIntersectsCircle, , 2, GameObject*, GameObject*) {
		return reinterpret_cast<fun31>(address31)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, objectTriggered, , 1, EffectGameObject*) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, optimizeMoveGroups, , 0) {
		return reinterpret_cast<fun33>(address33)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, parentForZLayer, , 3, int, bool, int) {
		return reinterpret_cast<fun34>(address34)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJBaseGameLayer, playerTouchedRing, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<fun35>(address35)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, processColorObject, , 5, EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*) {
		return reinterpret_cast<fun36>(address36)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(GJBaseGameLayer, processFollowActions, , 0) {
		return reinterpret_cast<fun37>(address37)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, processMoveActions, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, processMoveActionsStep, , 1, float) {
		return reinterpret_cast<fun39>(address39)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, processOpacityObject, , 4, EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*) {
		return reinterpret_cast<fun40>(address40)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(GJBaseGameLayer, processPlayerFollowActions, , 1, float) {
		return reinterpret_cast<fun41>(address41)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, processRotationActions, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, pushButton, , 2, int, bool) {
		return reinterpret_cast<fun43>(address43)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, rectIntersectsCircle, , 3, cocos2d::CCRect, cocos2d::CCPoint, float) {
		return reinterpret_cast<fun44>(address44)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJBaseGameLayer, refreshCounterLabels, , 0) {
		return reinterpret_cast<fun45>(address45)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, releaseButton, , 2, int, bool) {
		return reinterpret_cast<fun46>(address46)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, removeFromGroups, , 1, GameObject*) {
		return reinterpret_cast<fun47>(address47)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, removeObjectFromSection, , 1, GameObject*) {
		return reinterpret_cast<fun48>(address48)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, reorderObjectSection, , 1, GameObject*) {
		return reinterpret_cast<fun49>(address49)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, resetGroupCounters, , 1, bool) {
		return reinterpret_cast<fun50>(address50)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, resetMoveOptimizedValue, , 0) {
		return reinterpret_cast<fun51>(address51)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, sectionForPos, , 1, float) {
		return reinterpret_cast<fun52>(address52)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, setupLayers, , 0) {
		return reinterpret_cast<fun53>(address53)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, shouldExitHackedLevel, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, spawnGroupTriggered, , 3, int, float, int) {
		return reinterpret_cast<fun55>(address55)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJBaseGameLayer, staticObjectsInRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<fun56>(address56)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, testInstantCountTrigger, , 5, int, int, int, bool, int) {
		return reinterpret_cast<fun57>(address57)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(GJBaseGameLayer, toggleGroup, , 2, int, bool) {
		return reinterpret_cast<fun58>(address58)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, togglePlayerVisibility, , 1, bool) {
		return reinterpret_cast<fun59>(address59)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, triggerMoveCommand, , 1, EffectGameObject*) {
		return reinterpret_cast<fun60>(address60)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateCollisionBlocks, , 0) {
		return reinterpret_cast<fun61>(address61)(this);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateCounters, , 2, int, int) {
		return reinterpret_cast<fun62>(address62)(this, p0, p1);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateDisabledObjectsLastPos, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun63>(address63)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateLayerCapacity, , 1, gd::string) {
		return reinterpret_cast<fun64>(address64)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateLegacyLayerCapacity, , 4, int, int, int, int) {
		return reinterpret_cast<fun65>(address65)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateOBB2, , 1, cocos2d::CCRect) {
		return reinterpret_cast<fun66>(address66)(this, p0);
	}

	dupable getFunctionOf(GJBaseGameLayer, updateQueuedLabels, , 0) {
		return reinterpret_cast<fun67>(address67)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address68)(this);
	}

	getWrapperOf(GJBaseGameLayer, objectsCollided, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::objectsCollided(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int) {
		return reinterpret_cast<D*>(this)->D::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	getWrapperOf(GJBaseGameLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	getWrapperOf(GJBaseGameLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<D*>(this)->D::flipGravity(p0, p1, p2);
	}

	getWrapperOf(GJBaseGameLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::calculateColorValues(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(GJBaseGameLayer, toggleGroupTriggered, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::toggleGroupTriggered(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, spawnGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::spawnGroup(p0);
	}

	getWrapperOf(GJBaseGameLayer, addToSection, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addToSection(p0);
	}

	getWrapperOf(GJBaseGameLayer, addToGroup, , 3, GameObject*, int, bool) {
		return reinterpret_cast<D*>(this)->D::addToGroup(p0, p1, p2);
	}

	getWrapperOf(GJBaseGameLayer, removeFromGroup, , 2, GameObject*, int) {
		return reinterpret_cast<D*>(this)->D::removeFromGroup(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(GJBaseGameLayer, addObjectCounter, , 2, LabelGameObject*, int) {
		return reinterpret_cast<D*>(this)->D::addObjectCounter(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, addToGroups, , 2, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::addToGroups(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, atlasValue, , 1, int) {
		return reinterpret_cast<D*>(this)->D::atlasValue(p0);
	}

	getWrapperOf(GJBaseGameLayer, bumpPlayer, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<D*>(this)->D::bumpPlayer(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, calculateOpacityValues, , 4, EffectGameObject*, EffectGameObject*, float, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::calculateOpacityValues(p0, p1, p2, p3);
	}

	getWrapperOf(GJBaseGameLayer, checkSpawnObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::checkSpawnObjects();
	}

	getWrapperOf(GJBaseGameLayer, collectItem, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::collectItem(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, collectedObject, , 1, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::collectedObject(p0);
	}

	getWrapperOf(GJBaseGameLayer, createTextLayers, , 0) {
		return reinterpret_cast<D*>(this)->D::createTextLayers();
	}

	getWrapperOf(GJBaseGameLayer, damagingObjectsInRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::damagingObjectsInRect(p0);
	}

	getWrapperOf(GJBaseGameLayer, enableHighCapacityMode, , 0) {
		return reinterpret_cast<D*>(this)->D::enableHighCapacityMode();
	}

	getWrapperOf(GJBaseGameLayer, getCapacityString, , 0) {
		return reinterpret_cast<D*>(this)->D::getCapacityString();
	}

	getWrapperOf(GJBaseGameLayer, getGroundHeightForMode, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getGroundHeightForMode(p0);
	}

	getWrapperOf(GJBaseGameLayer, getGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getGroup(p0);
	}

	getWrapperOf(GJBaseGameLayer, getMoveDeltaForObjects, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::getMoveDeltaForObjects(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, getOptimizedGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getOptimizedGroup(p0);
	}

	getWrapperOf(GJBaseGameLayer, getStaticGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getStaticGroup(p0);
	}

	getWrapperOf(GJBaseGameLayer, isGroupDisabledForObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::isGroupDisabledForObject(p0);
	}

	getWrapperOf(GJBaseGameLayer, isGroupDisabledForObjectFull, , 2, GameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::isGroupDisabledForObjectFull(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, loadUpToPosition, , 1, float) {
		return reinterpret_cast<D*>(this)->D::loadUpToPosition(p0);
	}

	getWrapperOf(GJBaseGameLayer, objectIntersectsCircle, , 2, GameObject*, GameObject*) {
		return reinterpret_cast<D*>(this)->D::objectIntersectsCircle(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, objectTriggered, , 1, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::objectTriggered(p0);
	}

	getWrapperOf(GJBaseGameLayer, optimizeMoveGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::optimizeMoveGroups();
	}

	getWrapperOf(GJBaseGameLayer, parentForZLayer, , 3, int, bool, int) {
		return reinterpret_cast<D*>(this)->D::parentForZLayer(p0, p1, p2);
	}

	getWrapperOf(GJBaseGameLayer, playerTouchedRing, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<D*>(this)->D::playerTouchedRing(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, processColorObject, , 5, EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::processColorObject(p0, p1, p2, p3, p4);
	}

	getWrapperOf(GJBaseGameLayer, processFollowActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processFollowActions();
	}

	getWrapperOf(GJBaseGameLayer, processMoveActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processMoveActions();
	}

	getWrapperOf(GJBaseGameLayer, processMoveActionsStep, , 1, float) {
		return reinterpret_cast<D*>(this)->D::processMoveActionsStep(p0);
	}

	getWrapperOf(GJBaseGameLayer, processOpacityObject, , 4, EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::processOpacityObject(p0, p1, p2, p3);
	}

	getWrapperOf(GJBaseGameLayer, processPlayerFollowActions, , 1, float) {
		return reinterpret_cast<D*>(this)->D::processPlayerFollowActions(p0);
	}

	getWrapperOf(GJBaseGameLayer, processRotationActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processRotationActions();
	}

	getWrapperOf(GJBaseGameLayer, pushButton, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::pushButton(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, rectIntersectsCircle, , 3, cocos2d::CCRect, cocos2d::CCPoint, float) {
		return reinterpret_cast<D*>(this)->D::rectIntersectsCircle(p0, p1, p2);
	}

	getWrapperOf(GJBaseGameLayer, refreshCounterLabels, , 0) {
		return reinterpret_cast<D*>(this)->D::refreshCounterLabels();
	}

	getWrapperOf(GJBaseGameLayer, releaseButton, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::releaseButton(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, removeFromGroups, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::removeFromGroups(p0);
	}

	getWrapperOf(GJBaseGameLayer, removeObjectFromSection, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::removeObjectFromSection(p0);
	}

	getWrapperOf(GJBaseGameLayer, reorderObjectSection, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::reorderObjectSection(p0);
	}

	getWrapperOf(GJBaseGameLayer, resetGroupCounters, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::resetGroupCounters(p0);
	}

	getWrapperOf(GJBaseGameLayer, resetMoveOptimizedValue, , 0) {
		return reinterpret_cast<D*>(this)->D::resetMoveOptimizedValue();
	}

	getWrapperOf(GJBaseGameLayer, sectionForPos, , 1, float) {
		return reinterpret_cast<D*>(this)->D::sectionForPos(p0);
	}

	getWrapperOf(GJBaseGameLayer, setupLayers, , 0) {
		return reinterpret_cast<D*>(this)->D::setupLayers();
	}

	getWrapperOf(GJBaseGameLayer, shouldExitHackedLevel, , 0) {
		return reinterpret_cast<D*>(this)->D::shouldExitHackedLevel();
	}

	getWrapperOf(GJBaseGameLayer, spawnGroupTriggered, , 3, int, float, int) {
		return reinterpret_cast<D*>(this)->D::spawnGroupTriggered(p0, p1, p2);
	}

	getWrapperOf(GJBaseGameLayer, staticObjectsInRect, , 1, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::staticObjectsInRect(p0);
	}

	getWrapperOf(GJBaseGameLayer, testInstantCountTrigger, , 5, int, int, int, bool, int) {
		return reinterpret_cast<D*>(this)->D::testInstantCountTrigger(p0, p1, p2, p3, p4);
	}

	getWrapperOf(GJBaseGameLayer, toggleGroup, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::toggleGroup(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, togglePlayerVisibility, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::togglePlayerVisibility(p0);
	}

	getWrapperOf(GJBaseGameLayer, triggerMoveCommand, , 1, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::triggerMoveCommand(p0);
	}

	getWrapperOf(GJBaseGameLayer, updateCollisionBlocks, , 0) {
		return reinterpret_cast<D*>(this)->D::updateCollisionBlocks();
	}

	getWrapperOf(GJBaseGameLayer, updateCounters, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::updateCounters(p0, p1);
	}

	getWrapperOf(GJBaseGameLayer, updateDisabledObjectsLastPos, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::updateDisabledObjectsLastPos(p0);
	}

	getWrapperOf(GJBaseGameLayer, updateLayerCapacity, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::updateLayerCapacity(p0);
	}

	getWrapperOf(GJBaseGameLayer, updateLegacyLayerCapacity, , 4, int, int, int, int) {
		return reinterpret_cast<D*>(this)->D::updateLegacyLayerCapacity(p0, p1, p2, p3);
	}

	getWrapperOf(GJBaseGameLayer, updateOBB2, , 1, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::updateOBB2(p0);
	}

	getWrapperOf(GJBaseGameLayer, updateQueuedLabels, , 0) {
		return reinterpret_cast<D*>(this)->D::updateQueuedLabels();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if ((mem0)(&$GJBaseGameLayer::objectsCollided) != (der0)(&D::objectsCollided)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::objectsCollidedWrapper)));
		}

		if ((mem1)(&$GJBaseGameLayer::createMoveCommand) != (der1)(&D::createMoveCommand)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::createMoveCommandWrapper)));
		}

		if ((mem2)(&$GJBaseGameLayer::updateColor) != (der2)(&D::updateColor)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::updateColorWrapper)));
		}

		if ((mem3)(&$GJBaseGameLayer::flipGravity) != (der3)(&D::flipGravity)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::flipGravityWrapper)));
		}

		if ((mem4)(&$GJBaseGameLayer::calculateColorValues) != (der4)(&D::calculateColorValues)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::calculateColorValuesWrapper)));
		}

		if ((mem5)(&$GJBaseGameLayer::toggleGroupTriggered) != (der5)(&D::toggleGroupTriggered)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::toggleGroupTriggeredWrapper)));
		}

		if ((mem6)(&$GJBaseGameLayer::spawnGroup) != (der6)(&D::spawnGroup)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::spawnGroupWrapper)));
		}

		if ((mem7)(&$GJBaseGameLayer::addToSection) != (der7)(&D::addToSection)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::addToSectionWrapper)));
		}

		if ((mem8)(&$GJBaseGameLayer::addToGroup) != (der8)(&D::addToGroup)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::addToGroupWrapper)));
		}

		if ((mem9)(&$GJBaseGameLayer::removeFromGroup) != (der9)(&D::removeFromGroup)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::removeFromGroupWrapper)));
		}

		if ((mem10)(&$GJBaseGameLayer::init) != (der10)(&D::init)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::initWrapper)));
		}

		if constexpr((mem11)(&$GJBaseGameLayer::addObjectCounter) != (der11)(&D::addObjectCounter)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::addObjectCounterWrapper)));
		}

		if constexpr((mem12)(&$GJBaseGameLayer::addToGroups) != (der12)(&D::addToGroups)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::addToGroupsWrapper)));
		}

		if constexpr((mem13)(&$GJBaseGameLayer::atlasValue) != (der13)(&D::atlasValue)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::atlasValueWrapper)));
		}

		if constexpr((mem14)(&$GJBaseGameLayer::bumpPlayer) != (der14)(&D::bumpPlayer)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::bumpPlayerWrapper)));
		}

		if constexpr((mem15)(&$GJBaseGameLayer::calculateOpacityValues) != (der15)(&D::calculateOpacityValues)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::calculateOpacityValuesWrapper)));
		}

		if constexpr((mem16)(&$GJBaseGameLayer::checkSpawnObjects) != (der16)(&D::checkSpawnObjects)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::checkSpawnObjectsWrapper)));
		}

		if constexpr((mem17)(&$GJBaseGameLayer::collectItem) != (der17)(&D::collectItem)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::collectItemWrapper)));
		}

		if constexpr((mem18)(&$GJBaseGameLayer::collectedObject) != (der18)(&D::collectedObject)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::collectedObjectWrapper)));
		}

		if constexpr((mem19)(&$GJBaseGameLayer::createTextLayers) != (der19)(&D::createTextLayers)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::createTextLayersWrapper)));
		}

		if constexpr((mem20)(&$GJBaseGameLayer::damagingObjectsInRect) != (der20)(&D::damagingObjectsInRect)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::damagingObjectsInRectWrapper)));
		}

		if constexpr((mem21)(&$GJBaseGameLayer::enableHighCapacityMode) != (der21)(&D::enableHighCapacityMode)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::enableHighCapacityModeWrapper)));
		}

		if constexpr((mem22)(&$GJBaseGameLayer::getCapacityString) != (der22)(&D::getCapacityString)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::getCapacityStringWrapper)));
		}

		if constexpr((mem23)(&$GJBaseGameLayer::getGroundHeightForMode) != (der23)(&D::getGroundHeightForMode)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::getGroundHeightForModeWrapper)));
		}

		if constexpr((mem24)(&$GJBaseGameLayer::getGroup) != (der24)(&D::getGroup)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::getGroupWrapper)));
		}

		if constexpr((mem25)(&$GJBaseGameLayer::getMoveDeltaForObjects) != (der25)(&D::getMoveDeltaForObjects)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::getMoveDeltaForObjectsWrapper)));
		}

		if constexpr((mem26)(&$GJBaseGameLayer::getOptimizedGroup) != (der26)(&D::getOptimizedGroup)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::getOptimizedGroupWrapper)));
		}

		if constexpr((mem27)(&$GJBaseGameLayer::getStaticGroup) != (der27)(&D::getStaticGroup)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::getStaticGroupWrapper)));
		}

		if constexpr((mem28)(&$GJBaseGameLayer::isGroupDisabledForObject) != (der28)(&D::isGroupDisabledForObject)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::isGroupDisabledForObjectWrapper)));
		}

		if constexpr((mem29)(&$GJBaseGameLayer::isGroupDisabledForObjectFull) != (der29)(&D::isGroupDisabledForObjectFull)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::isGroupDisabledForObjectFullWrapper)));
		}

		if constexpr((mem30)(&$GJBaseGameLayer::loadUpToPosition) != (der30)(&D::loadUpToPosition)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::loadUpToPositionWrapper)));
		}

		if constexpr((mem31)(&$GJBaseGameLayer::objectIntersectsCircle) != (der31)(&D::objectIntersectsCircle)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::objectIntersectsCircleWrapper)));
		}

		if constexpr((mem32)(&$GJBaseGameLayer::objectTriggered) != (der32)(&D::objectTriggered)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::objectTriggeredWrapper)));
		}

		if constexpr((mem33)(&$GJBaseGameLayer::optimizeMoveGroups) != (der33)(&D::optimizeMoveGroups)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::optimizeMoveGroupsWrapper)));
		}

		if constexpr((mem34)(&$GJBaseGameLayer::parentForZLayer) != (der34)(&D::parentForZLayer)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::parentForZLayerWrapper)));
		}

		if constexpr((mem35)(&$GJBaseGameLayer::playerTouchedRing) != (der35)(&D::playerTouchedRing)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::playerTouchedRingWrapper)));
		}

		if constexpr((mem36)(&$GJBaseGameLayer::processColorObject) != (der36)(&D::processColorObject)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual((der36)(&D::processColorObjectWrapper)));
		}

		if constexpr((mem37)(&$GJBaseGameLayer::processFollowActions) != (der37)(&D::processFollowActions)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::processFollowActionsWrapper)));
		}

		if constexpr((mem38)(&$GJBaseGameLayer::processMoveActions) != (der38)(&D::processMoveActions)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::processMoveActionsWrapper)));
		}

		if constexpr((mem39)(&$GJBaseGameLayer::processMoveActionsStep) != (der39)(&D::processMoveActionsStep)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::processMoveActionsStepWrapper)));
		}

		if constexpr((mem40)(&$GJBaseGameLayer::processOpacityObject) != (der40)(&D::processOpacityObject)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::processOpacityObjectWrapper)));
		}

		if constexpr((mem41)(&$GJBaseGameLayer::processPlayerFollowActions) != (der41)(&D::processPlayerFollowActions)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::processPlayerFollowActionsWrapper)));
		}

		if constexpr((mem42)(&$GJBaseGameLayer::processRotationActions) != (der42)(&D::processRotationActions)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::processRotationActionsWrapper)));
		}

		if constexpr((mem43)(&$GJBaseGameLayer::pushButton) != (der43)(&D::pushButton)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::pushButtonWrapper)));
		}

		if constexpr((mem44)(&$GJBaseGameLayer::rectIntersectsCircle) != (der44)(&D::rectIntersectsCircle)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::rectIntersectsCircleWrapper)));
		}

		if constexpr((mem45)(&$GJBaseGameLayer::refreshCounterLabels) != (der45)(&D::refreshCounterLabels)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::refreshCounterLabelsWrapper)));
		}

		if constexpr((mem46)(&$GJBaseGameLayer::releaseButton) != (der46)(&D::releaseButton)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::releaseButtonWrapper)));
		}

		if constexpr((mem47)(&$GJBaseGameLayer::removeFromGroups) != (der47)(&D::removeFromGroups)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::removeFromGroupsWrapper)));
		}

		if constexpr((mem48)(&$GJBaseGameLayer::removeObjectFromSection) != (der48)(&D::removeObjectFromSection)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::removeObjectFromSectionWrapper)));
		}

		if constexpr((mem49)(&$GJBaseGameLayer::reorderObjectSection) != (der49)(&D::reorderObjectSection)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::reorderObjectSectionWrapper)));
		}

		if constexpr((mem50)(&$GJBaseGameLayer::resetGroupCounters) != (der50)(&D::resetGroupCounters)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::resetGroupCountersWrapper)));
		}

		if constexpr((mem51)(&$GJBaseGameLayer::resetMoveOptimizedValue) != (der51)(&D::resetMoveOptimizedValue)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::resetMoveOptimizedValueWrapper)));
		}

		if constexpr((mem52)(&$GJBaseGameLayer::sectionForPos) != (der52)(&D::sectionForPos)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::sectionForPosWrapper)));
		}

		if constexpr((mem53)(&$GJBaseGameLayer::setupLayers) != (der53)(&D::setupLayers)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::setupLayersWrapper)));
		}

		if constexpr((mem54)(&$GJBaseGameLayer::shouldExitHackedLevel) != (der54)(&D::shouldExitHackedLevel)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::shouldExitHackedLevelWrapper)));
		}

		if constexpr((mem55)(&$GJBaseGameLayer::spawnGroupTriggered) != (der55)(&D::spawnGroupTriggered)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::spawnGroupTriggeredWrapper)));
		}

		if constexpr((mem56)(&$GJBaseGameLayer::staticObjectsInRect) != (der56)(&D::staticObjectsInRect)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::staticObjectsInRectWrapper)));
		}

		if constexpr((mem57)(&$GJBaseGameLayer::testInstantCountTrigger) != (der57)(&D::testInstantCountTrigger)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::testInstantCountTriggerWrapper)));
		}

		if constexpr((mem58)(&$GJBaseGameLayer::toggleGroup) != (der58)(&D::toggleGroup)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::toggleGroupWrapper)));
		}

		if constexpr((mem59)(&$GJBaseGameLayer::togglePlayerVisibility) != (der59)(&D::togglePlayerVisibility)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::togglePlayerVisibilityWrapper)));
		}

		if constexpr((mem60)(&$GJBaseGameLayer::triggerMoveCommand) != (der60)(&D::triggerMoveCommand)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::triggerMoveCommandWrapper)));
		}

		if constexpr((mem61)(&$GJBaseGameLayer::updateCollisionBlocks) != (der61)(&D::updateCollisionBlocks)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::updateCollisionBlocksWrapper)));
		}

		if constexpr((mem62)(&$GJBaseGameLayer::updateCounters) != (der62)(&D::updateCounters)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::updateCountersWrapper)));
		}

		if constexpr((mem63)(&$GJBaseGameLayer::updateDisabledObjectsLastPos) != (der63)(&D::updateDisabledObjectsLastPos)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::updateDisabledObjectsLastPosWrapper)));
		}

		if constexpr((mem64)(&$GJBaseGameLayer::updateLayerCapacity) != (der64)(&D::updateLayerCapacity)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::updateLayerCapacityWrapper)));
		}

		if constexpr((mem65)(&$GJBaseGameLayer::updateLegacyLayerCapacity) != (der65)(&D::updateLegacyLayerCapacity)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::updateLegacyLayerCapacityWrapper)));
		}

		if constexpr((mem66)(&$GJBaseGameLayer::updateOBB2) != (der66)(&D::updateOBB2)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::updateOBB2Wrapper)));
		}

		if constexpr((mem67)(&$GJBaseGameLayer::updateQueuedLabels) != (der67)(&D::updateQueuedLabels)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::updateQueuedLabelsWrapper)));
		}

		if constexpr(&$GJBaseGameLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $GJComment : GJComment, InterfaceBase {
	$GJComment(const $GJComment& c) : GJComment(c) {}
	$GJComment() = delete;
	setInterfaceTypesOf(1, GJComment, init, , 0);
	static inline auto address0 = base+0x2dfd70;
	static inline auto address1 = base+0x2dfec0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(GJComment, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GJComment, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

public:
	static bool _apply() {

		if constexpr(&$GJComment::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$GJComment::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJCommentListLayer : GJCommentListLayer, InterfaceBase {
	$GJCommentListLayer(const $GJCommentListLayer& c) : GJCommentListLayer(c) {}
	$GJCommentListLayer() = delete;
	setInterfaceStaticTypesOf(1, GJCommentListLayer, create, , 6, BoomListView*, char const*, cocos2d::_ccColor4B, float, float, bool);
	static inline auto address0 = base+0x1482a0;
	static inline auto address1 = base+0x147d00;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable static getFunctionOf(GJCommentListLayer, create, , 6, BoomListView*, char const*, cocos2d::_ccColor4B, float, float, bool) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2, p3, p4, p5);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	static getWrapperOf(GJCommentListLayer, create, , 6, BoomListView*, char const*, cocos2d::_ccColor4B, float, float, bool) {
		return D::create(p0, p1, p2, p3, p4, p5);
	}

public:
	static bool _apply() {

		if constexpr(&$GJCommentListLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem1)(&$GJCommentListLayer::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJDropDownLayer : GJDropDownLayer, InterfaceBase {
	$GJDropDownLayer(const $GJDropDownLayer& c) : GJDropDownLayer(c) {}
	$GJDropDownLayer() = delete;
	setInterfaceTypesOf(0, GJDropDownLayer, customSetup, , 0);
	setInterfaceTypesOf(1, GJDropDownLayer, enterLayer, , 0);
	setInterfaceTypesOf(2, GJDropDownLayer, exitLayer, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(3, GJDropDownLayer, showLayer, , 1, bool);
	setInterfaceTypesOf(4, GJDropDownLayer, hideLayer, , 1, bool);
	setInterfaceTypesOf(5, GJDropDownLayer, layerVisible, , 0);
	setInterfaceTypesOf(6, GJDropDownLayer, layerHidden, , 0);
	setInterfaceTypesOf(7, GJDropDownLayer, enterAnimFinished, , 0);
	setInterfaceTypesOf(8, GJDropDownLayer, disableUI, , 0);
	setInterfaceTypesOf(9, GJDropDownLayer, enableUI, , 0);
	setInterfaceTypesOf(10, GJDropDownLayer, draw, , 0);
	setInterfaceTypesOf(11, GJDropDownLayer, init, , 2, char const*, float);
	setInterfaceTypesOf(12, GJDropDownLayer, registerWithTouchDispatcher, , 0);
	setInterfaceTypesOf(13, GJDropDownLayer, keyBackClicked, , 0);
	setInterfaceStaticTypesOf(14, GJDropDownLayer, create, , 1, char const*);
	static inline auto address0 = base+0x352570;
	static inline auto address1 = base+0x3525c0;
	static inline auto address2 = base+0x352670;
	static inline auto address3 = base+0x3526c0;
	static inline auto address4 = base+0x3527b0;
	static inline auto address5 = base+0x3528b0;
	static inline auto address6 = base+0x3528d0;
	static inline auto address7 = base+0x3528a0;
	static inline auto address8 = base+0x352580;
	static inline auto address9 = base+0x3525a0;
	static inline auto address10 = base+0x352910;
	static inline auto address11 = base+0x352100;
	static inline auto address12 = base+0x3525f0;
	static inline auto address13 = base+0x352630;
	static inline auto address14 = base+0x352530;

	dupable getFunctionOf(GJDropDownLayer, customSetup, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, enterLayer, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, exitLayer, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(GJDropDownLayer, showLayer, , 1, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(GJDropDownLayer, hideLayer, , 1, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(GJDropDownLayer, layerVisible, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, layerHidden, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, enterAnimFinished, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, disableUI, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, enableUI, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, draw, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, init, , 2, char const*, float) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1);
	}

	dupable getFunctionOf(GJDropDownLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(GJDropDownLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable static getFunctionOf(GJDropDownLayer, create, , 1, char const*) {
		return reinterpret_cast<fun14>(address14)(p0);
	}

	getWrapperOf(GJDropDownLayer, customSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::customSetup();
	}

	getWrapperOf(GJDropDownLayer, enterLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::enterLayer();
	}

	getWrapperOf(GJDropDownLayer, exitLayer, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::exitLayer(p0);
	}

	getWrapperOf(GJDropDownLayer, showLayer, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::showLayer(p0);
	}

	getWrapperOf(GJDropDownLayer, hideLayer, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::hideLayer(p0);
	}

	getWrapperOf(GJDropDownLayer, layerVisible, , 0) {
		return reinterpret_cast<D*>(this)->D::layerVisible();
	}

	getWrapperOf(GJDropDownLayer, layerHidden, , 0) {
		return reinterpret_cast<D*>(this)->D::layerHidden();
	}

	getWrapperOf(GJDropDownLayer, enterAnimFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::enterAnimFinished();
	}

	getWrapperOf(GJDropDownLayer, disableUI, , 0) {
		return reinterpret_cast<D*>(this)->D::disableUI();
	}

	getWrapperOf(GJDropDownLayer, enableUI, , 0) {
		return reinterpret_cast<D*>(this)->D::enableUI();
	}

	getWrapperOf(GJDropDownLayer, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(GJDropDownLayer, init, , 2, char const*, float) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1);
	}

	getWrapperOf(GJDropDownLayer, registerWithTouchDispatcher, , 0) {
		return reinterpret_cast<D*>(this)->D::registerWithTouchDispatcher();
	}

	getWrapperOf(GJDropDownLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	static getWrapperOf(GJDropDownLayer, create, , 1, char const*) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if ((mem0)(&$GJDropDownLayer::customSetup) != (der0)(&D::customSetup)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::customSetupWrapper)));
		}

		if ((mem1)(&$GJDropDownLayer::enterLayer) != (der1)(&D::enterLayer)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::enterLayerWrapper)));
		}

		if ((mem2)(&$GJDropDownLayer::exitLayer) != (der2)(&D::exitLayer)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::exitLayerWrapper)));
		}

		if ((mem3)(&$GJDropDownLayer::showLayer) != (der3)(&D::showLayer)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::showLayerWrapper)));
		}

		if ((mem4)(&$GJDropDownLayer::hideLayer) != (der4)(&D::hideLayer)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::hideLayerWrapper)));
		}

		if ((mem5)(&$GJDropDownLayer::layerVisible) != (der5)(&D::layerVisible)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::layerVisibleWrapper)));
		}

		if ((mem6)(&$GJDropDownLayer::layerHidden) != (der6)(&D::layerHidden)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::layerHiddenWrapper)));
		}

		if ((mem7)(&$GJDropDownLayer::enterAnimFinished) != (der7)(&D::enterAnimFinished)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::enterAnimFinishedWrapper)));
		}

		if ((mem8)(&$GJDropDownLayer::disableUI) != (der8)(&D::disableUI)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::disableUIWrapper)));
		}

		if ((mem9)(&$GJDropDownLayer::enableUI) != (der9)(&D::enableUI)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::enableUIWrapper)));
		}

		if ((mem10)(&$GJDropDownLayer::draw) != (der10)(&D::draw)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::drawWrapper)));
		}

		if constexpr((mem11)(&$GJDropDownLayer::init) != (der11)(&D::init)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::initWrapper)));
		}

		if ((mem12)(&$GJDropDownLayer::registerWithTouchDispatcher) != (der12)(&D::registerWithTouchDispatcher)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::registerWithTouchDispatcherWrapper)));
		}

		if ((mem13)(&$GJDropDownLayer::keyBackClicked) != (der13)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::keyBackClickedWrapper)));
		}

		if constexpr((mem14)(&$GJDropDownLayer::create) != (der14)(&D::create)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJEffectManager : GJEffectManager, InterfaceBase {
	$GJEffectManager(const $GJEffectManager& c) : GJEffectManager(c) {}
	$GJEffectManager() = delete;
	setInterfaceTypesOf(0, GJEffectManager, init, , 0);
	setInterfaceTypesOf(1, GJEffectManager, activeColorForIndex, , 1, int);
	setInterfaceTypesOf(2, GJEffectManager, activeOpacityForIndex, , 1, int);
	setInterfaceTypesOf(3, GJEffectManager, addAllInheritedColorActions, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(4, GJEffectManager, addGroupPulseEffect, , 1, PulseEffectAction*);
	setInterfaceTypesOf(5, GJEffectManager, calculateBaseActiveColors, , 0);
	setInterfaceTypesOf(6, GJEffectManager, calculateInheritedColor, , 2, int, ColorAction*);
	setInterfaceTypesOf(7, GJEffectManager, calculateLightBGColor, , 1, cocos2d::_ccColor3B);
	setInterfaceTypesOf(8, GJEffectManager, colorActionChanged, , 1, ColorAction*);
	setInterfaceTypesOf(9, GJEffectManager, colorExists, , 1, int);
	setInterfaceTypesOf(10, GJEffectManager, colorForEffect, , 2, cocos2d::_ccColor3B, cocos2d::_ccHSVValue);
	setInterfaceTypesOf(11, GJEffectManager, colorForGroupID, , 3, int, cocos2d::_ccColor3B const&, bool);
	setInterfaceTypesOf(12, GJEffectManager, colorForIndex, , 1, int);
	setInterfaceTypesOf(13, GJEffectManager, colorForPulseEffect, , 2, cocos2d::_ccColor3B const&, PulseEffectAction*);
	setInterfaceTypesOf(14, GJEffectManager, countChangedForItem, , 1, int);
	setInterfaceTypesOf(15, GJEffectManager, countForItem, , 1, int);
	setInterfaceStaticTypesOf(16, GJEffectManager, create, , 0);
	setInterfaceTypesOf(17, GJEffectManager, createFollowCommand, , 7, float, float, float, int, int, bool, int);
	setInterfaceTypesOf(18, GJEffectManager, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int);
	setInterfaceTypesOf(19, GJEffectManager, createPlayerFollowCommand, , 7, float, float, int, float, float, int, int);
	setInterfaceTypesOf(20, GJEffectManager, createRotateCommand, , 8, int, float, int, int, int, float, bool, int);
	setInterfaceTypesOf(21, GJEffectManager, getAllColorActions, , 0);
	setInterfaceTypesOf(22, GJEffectManager, getAllColorSprites, , 0);
	setInterfaceTypesOf(23, GJEffectManager, getColorAction, , 1, int);
	setInterfaceTypesOf(24, GJEffectManager, getColorSprite, , 1, int);
	setInterfaceTypesOf(25, GJEffectManager, getCurrentStateString, , 0);
	setInterfaceTypesOf(26, GJEffectManager, getLoadedMoveOffset, , 0);
	setInterfaceTypesOf(27, GJEffectManager, getMixedColor, , 3, cocos2d::_ccColor3B, cocos2d::_ccColor3B, float);
	setInterfaceTypesOf(28, GJEffectManager, getOpacityActionForGroup, , 1, int);
	setInterfaceTypesOf(29, GJEffectManager, getSaveString, , 0);
	setInterfaceTypesOf(30, GJEffectManager, handleObjectCollision, , 3, bool, int, int);
	setInterfaceTypesOf(31, GJEffectManager, hasActiveDualTouch, , 0);
	setInterfaceTypesOf(32, GJEffectManager, hasBeenTriggered, , 1, int);
	setInterfaceTypesOf(33, GJEffectManager, hasPulseEffectForGroupID, , 1, int);
	setInterfaceTypesOf(34, GJEffectManager, isGroupEnabled, , 1, int);
	setInterfaceTypesOf(35, GJEffectManager, keyForGroupIDColor, , 3, int, cocos2d::_ccColor3B const&, bool);
	setInterfaceTypesOf(36, GJEffectManager, loadState, , 1, gd::string);
	setInterfaceTypesOf(37, GJEffectManager, objectsCollided, , 2, int, int);
	setInterfaceTypesOf(38, GJEffectManager, opacityForIndex, , 1, int);
	setInterfaceTypesOf(39, GJEffectManager, opacityModForGroup, , 1, int);
	setInterfaceTypesOf(40, GJEffectManager, playerButton, , 2, bool, bool);
	setInterfaceTypesOf(41, GJEffectManager, playerDied, , 0);
	setInterfaceTypesOf(42, GJEffectManager, postCollisionCheck, , 0);
	setInterfaceTypesOf(43, GJEffectManager, preCollisionCheck, , 0);
	setInterfaceTypesOf(44, GJEffectManager, prepareMoveActions, , 2, float, bool);
	setInterfaceTypesOf(45, GJEffectManager, processColors, , 0);
	setInterfaceTypesOf(46, GJEffectManager, processCopyColorPulseActions, , 0);
	setInterfaceTypesOf(47, GJEffectManager, processInheritedColors, , 0);
	setInterfaceTypesOf(48, GJEffectManager, processPulseActions, , 0);
	setInterfaceTypesOf(49, GJEffectManager, registerCollisionTrigger, , 6, int, int, int, bool, bool, int);
	setInterfaceTypesOf(50, GJEffectManager, removeAllPulseActions, , 0);
	setInterfaceTypesOf(51, GJEffectManager, removeColorAction, , 1, int);
	setInterfaceTypesOf(52, GJEffectManager, reset, , 0);
	setInterfaceTypesOf(53, GJEffectManager, resetColorCache, , 0);
	setInterfaceTypesOf(54, GJEffectManager, resetEffects, , 0);
	setInterfaceTypesOf(55, GJEffectManager, resetMoveActions, , 0);
	setInterfaceTypesOf(56, GJEffectManager, resetToggledGroups, , 0);
	setInterfaceTypesOf(57, GJEffectManager, resetTriggeredIDs, , 0);
	setInterfaceTypesOf(58, GJEffectManager, runCountTrigger, , 6, int, int, bool, int, bool, int);
	setInterfaceTypesOf(59, GJEffectManager, runDeathTrigger, , 3, int, bool, int);
	setInterfaceTypesOf(60, GJEffectManager, runOpacityActionOnGroup, , 4, int, float, float, int);
	setInterfaceTypesOf(61, GJEffectManager, runPulseEffect, , 13, int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int);
	setInterfaceTypesOf(62, GJEffectManager, runTouchTriggerCommand, , 5, int, bool, TouchTriggerType, bool, int);
	setInterfaceTypesOf(63, GJEffectManager, setColorAction, , 2, ColorAction*, int);
	setInterfaceTypesOf(64, GJEffectManager, setFollowing, , 3, int, int, bool);
	setInterfaceTypesOf(65, GJEffectManager, setupFromString, , 1, gd::string);
	setInterfaceTypesOf(66, GJEffectManager, shouldBlend, , 1, int);
	setInterfaceTypesOf(67, GJEffectManager, spawnGroup, , 3, int, float, int);
	setInterfaceTypesOf(68, GJEffectManager, stopActionsForTrigger, , 1, EffectGameObject*);
	setInterfaceTypesOf(69, GJEffectManager, stopMoveActionsForGroup, , 1, int);
	setInterfaceTypesOf(70, GJEffectManager, storeTriggeredID, , 1, int);
	setInterfaceTypesOf(71, GJEffectManager, toggleGroup, , 2, int, bool);
	setInterfaceTypesOf(72, GJEffectManager, traverseInheritanceChain, , 1, InheritanceNode*);
	setInterfaceTypesOf(73, GJEffectManager, updateActiveOpacityEffects, , 0);
	setInterfaceTypesOf(74, GJEffectManager, updateColorAction, , 1, ColorAction*);
	setInterfaceTypesOf(75, GJEffectManager, updateColorEffects, , 1, float);
	setInterfaceTypesOf(76, GJEffectManager, updateColors, , 2, cocos2d::_ccColor3B, cocos2d::_ccColor3B);
	setInterfaceTypesOf(77, GJEffectManager, updateEffects, , 1, float);
	setInterfaceTypesOf(78, GJEffectManager, updateOpacityAction, , 1, OpacityEffectAction*);
	setInterfaceTypesOf(79, GJEffectManager, updateOpacityEffects, , 1, float);
	setInterfaceTypesOf(80, GJEffectManager, updatePulseEffects, , 1, float);
	setInterfaceTypesOf(81, GJEffectManager, updateSpawnTriggers, , 1, float);
	setInterfaceTypesOf(82, GJEffectManager, wasFollowing, , 2, int, int);
	setInterfaceTypesOf(83, GJEffectManager, wouldCreateLoop, , 2, InheritanceNode*, int);
	static inline auto address0 = base+0x180230;
	static inline auto address1 = base+0x180cb0;
	static inline auto address2 = base+0x180e10;
	static inline auto address3 = base+0x1817a0;
	static inline auto address4 = base+0x184c10;
	static inline auto address5 = base+0x180f70;
	static inline auto address6 = base+0x1818f0;
	static inline auto address7 = base+0x185b90;
	static inline auto address8 = base+0x181dc0;
	static inline auto address9 = base+0x181da0;
	static inline auto address10 = base+0x182650;
	static inline auto address11 = base+0x184f90;
	static inline auto address12 = base+0x180ad0;
	static inline auto address13 = base+0x181bf0;
	static inline auto address14 = base+0x185a40;
	static inline auto address15 = base+0x185a10;
	static inline auto address16 = base+0x1800f0;
	static inline auto address17 = base+0x182ed0;
	static inline auto address18 = base+0x182cc0;
	static inline auto address19 = base+0x182fe0;
	static inline auto address20 = base+0x182df0;
	static inline auto address21 = base+0x180980;
	static inline auto address22 = base+0x1809e0;
	static inline auto address23 = base+0x180b00;
	static inline auto address24 = base+0x180d00;
	static inline auto address25 = base+0x1867e0;
	static inline auto address26 = base+0x184390;
	static inline auto address27 = base+0x185d30;
	static inline auto address28 = base+0x1845b0;
	static inline auto address29 = base+0x185e90;
	static inline auto address30 = base+0x1828f0;
	static inline auto address31 = base+0x185540;
	static inline auto address32 = base+0x1853b0;
	static inline auto address33 = base+0x184f60;
	static inline auto address34 = base+0x1853d0;
	static inline auto address35 = base+0x184c90;
	static inline auto address36 = base+0x188db0;
	static inline auto address37 = base+0x182a00;
	static inline auto address38 = base+0x180c80;
	static inline auto address39 = base+0x184740;
	static inline auto address40 = base+0x1855a0;
	static inline auto address41 = base+0x185860;
	static inline auto address42 = base+0x182720;
	static inline auto address43 = base+0x182680;
	static inline auto address44 = base+0x183660;
	static inline auto address45 = base+0x180e70;
	static inline auto address46 = base+0x181530;
	static inline auto address47 = base+0x181190;
	static inline auto address48 = base+0x181040;
	static inline auto address49 = base+0x182b70;
	static inline auto address50 = base+0x1825e0;
	static inline auto address51 = base+0x181d60;
	static inline auto address52 = base+0x180690;
	static inline auto address53 = base+0x185280;
	static inline auto address54 = base+0x1807d0;
	static inline auto address55 = base+0x180940;
	static inline auto address56 = base+0x1853f0;
	static inline auto address57 = base+0x182630;
	static inline auto address58 = base+0x1858d0;
	static inline auto address59 = base+0x1857a0;
	static inline auto address60 = base+0x1845d0;
	static inline auto address61 = base+0x184890;
	static inline auto address62 = base+0x185460;
	static inline auto address63 = base+0x181d00;
	static inline auto address64 = base+0x185e00;
	static inline auto address65 = base+0x186290;
	static inline auto address66 = base+0x180e40;
	static inline auto address67 = base+0x1852a0;
	static inline auto address68 = base+0x183150;
	static inline auto address69 = base+0x1830e0;
	static inline auto address70 = base+0x185380;
	static inline auto address71 = base+0x182c80;
	static inline auto address72 = base+0x181850;
	static inline auto address73 = base+0x1847e0;
	static inline auto address74 = base+0x184560;
	static inline auto address75 = base+0x181f40;
	static inline auto address76 = base+0x180a40;
	static inline auto address77 = base+0x181df0;
	static inline auto address78 = base+0x184780;
	static inline auto address79 = base+0x1823e0;
	static inline auto address80 = base+0x182130;
	static inline auto address81 = base+0x182510;
	static inline auto address82 = base+0x185e60;
	static inline auto address83 = base+0x181820;
	static inline auto address84 = base+0x17fe00;

	dupable getFunctionOf(GJEffectManager, init, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(GJEffectManager, activeColorForIndex, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, activeOpacityForIndex, , 1, int) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, addAllInheritedColorActions, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, addGroupPulseEffect, , 1, PulseEffectAction*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, calculateBaseActiveColors, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(GJEffectManager, calculateInheritedColor, , 2, int, ColorAction*) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, calculateLightBGColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, colorActionChanged, , 1, ColorAction*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, colorExists, , 1, int) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, colorForEffect, , 2, cocos2d::_ccColor3B, cocos2d::_ccHSVValue) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, colorForGroupID, , 3, int, cocos2d::_ccColor3B const&, bool) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, colorForIndex, , 1, int) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, colorForPulseEffect, , 2, cocos2d::_ccColor3B const&, PulseEffectAction*) {
		return reinterpret_cast<fun13>(address13)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, countChangedForItem, , 1, int) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, countForItem, , 1, int) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable static getFunctionOf(GJEffectManager, create, , 0) {
		return reinterpret_cast<fun16>(address16)();
	}

	dupable getFunctionOf(GJEffectManager, createFollowCommand, , 7, float, float, float, int, int, bool, int) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1, p2, p3, p4, p5, p6);
	}

	dupable getFunctionOf(GJEffectManager, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int) {
		return reinterpret_cast<fun18>(address18)(this, p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable getFunctionOf(GJEffectManager, createPlayerFollowCommand, , 7, float, float, int, float, float, int, int) {
		return reinterpret_cast<fun19>(address19)(this, p0, p1, p2, p3, p4, p5, p6);
	}

	dupable getFunctionOf(GJEffectManager, createRotateCommand, , 8, int, float, int, int, int, float, bool, int) {
		return reinterpret_cast<fun20>(address20)(this, p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable getFunctionOf(GJEffectManager, getAllColorActions, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(GJEffectManager, getAllColorSprites, , 0) {
		return reinterpret_cast<fun22>(address22)(this);
	}

	dupable getFunctionOf(GJEffectManager, getColorAction, , 1, int) {
		return reinterpret_cast<fun23>(address23)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, getColorSprite, , 1, int) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, getCurrentStateString, , 0) {
		return reinterpret_cast<fun25>(address25)(this);
	}

	dupable getFunctionOf(GJEffectManager, getLoadedMoveOffset, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(GJEffectManager, getMixedColor, , 3, cocos2d::_ccColor3B, cocos2d::_ccColor3B, float) {
		return reinterpret_cast<fun27>(address27)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, getOpacityActionForGroup, , 1, int) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, getSaveString, , 0) {
		return reinterpret_cast<fun29>(address29)(this);
	}

	dupable getFunctionOf(GJEffectManager, handleObjectCollision, , 3, bool, int, int) {
		return reinterpret_cast<fun30>(address30)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, hasActiveDualTouch, , 0) {
		return reinterpret_cast<fun31>(address31)(this);
	}

	dupable getFunctionOf(GJEffectManager, hasBeenTriggered, , 1, int) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, hasPulseEffectForGroupID, , 1, int) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, isGroupEnabled, , 1, int) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, keyForGroupIDColor, , 3, int, cocos2d::_ccColor3B const&, bool) {
		return reinterpret_cast<fun35>(address35)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, loadState, , 1, gd::string) {
		return reinterpret_cast<fun36>(address36)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, objectsCollided, , 2, int, int) {
		return reinterpret_cast<fun37>(address37)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, opacityForIndex, , 1, int) {
		return reinterpret_cast<fun38>(address38)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, opacityModForGroup, , 1, int) {
		return reinterpret_cast<fun39>(address39)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, playerButton, , 2, bool, bool) {
		return reinterpret_cast<fun40>(address40)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, playerDied, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(GJEffectManager, postCollisionCheck, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(GJEffectManager, preCollisionCheck, , 0) {
		return reinterpret_cast<fun43>(address43)(this);
	}

	dupable getFunctionOf(GJEffectManager, prepareMoveActions, , 2, float, bool) {
		return reinterpret_cast<fun44>(address44)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, processColors, , 0) {
		return reinterpret_cast<fun45>(address45)(this);
	}

	dupable getFunctionOf(GJEffectManager, processCopyColorPulseActions, , 0) {
		return reinterpret_cast<fun46>(address46)(this);
	}

	dupable getFunctionOf(GJEffectManager, processInheritedColors, , 0) {
		return reinterpret_cast<fun47>(address47)(this);
	}

	dupable getFunctionOf(GJEffectManager, processPulseActions, , 0) {
		return reinterpret_cast<fun48>(address48)(this);
	}

	dupable getFunctionOf(GJEffectManager, registerCollisionTrigger, , 6, int, int, int, bool, bool, int) {
		return reinterpret_cast<fun49>(address49)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(GJEffectManager, removeAllPulseActions, , 0) {
		return reinterpret_cast<fun50>(address50)(this);
	}

	dupable getFunctionOf(GJEffectManager, removeColorAction, , 1, int) {
		return reinterpret_cast<fun51>(address51)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, reset, , 0) {
		return reinterpret_cast<fun52>(address52)(this);
	}

	dupable getFunctionOf(GJEffectManager, resetColorCache, , 0) {
		return reinterpret_cast<fun53>(address53)(this);
	}

	dupable getFunctionOf(GJEffectManager, resetEffects, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(GJEffectManager, resetMoveActions, , 0) {
		return reinterpret_cast<fun55>(address55)(this);
	}

	dupable getFunctionOf(GJEffectManager, resetToggledGroups, , 0) {
		return reinterpret_cast<fun56>(address56)(this);
	}

	dupable getFunctionOf(GJEffectManager, resetTriggeredIDs, , 0) {
		return reinterpret_cast<fun57>(address57)(this);
	}

	dupable getFunctionOf(GJEffectManager, runCountTrigger, , 6, int, int, bool, int, bool, int) {
		return reinterpret_cast<fun58>(address58)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(GJEffectManager, runDeathTrigger, , 3, int, bool, int) {
		return reinterpret_cast<fun59>(address59)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, runOpacityActionOnGroup, , 4, int, float, float, int) {
		return reinterpret_cast<fun60>(address60)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(GJEffectManager, runPulseEffect, , 13, int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int) {
		return reinterpret_cast<fun61>(address61)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
	}

	dupable getFunctionOf(GJEffectManager, runTouchTriggerCommand, , 5, int, bool, TouchTriggerType, bool, int) {
		return reinterpret_cast<fun62>(address62)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(GJEffectManager, setColorAction, , 2, ColorAction*, int) {
		return reinterpret_cast<fun63>(address63)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, setFollowing, , 3, int, int, bool) {
		return reinterpret_cast<fun64>(address64)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, setupFromString, , 1, gd::string) {
		return reinterpret_cast<fun65>(address65)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, shouldBlend, , 1, int) {
		return reinterpret_cast<fun66>(address66)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, spawnGroup, , 3, int, float, int) {
		return reinterpret_cast<fun67>(address67)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GJEffectManager, stopActionsForTrigger, , 1, EffectGameObject*) {
		return reinterpret_cast<fun68>(address68)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, stopMoveActionsForGroup, , 1, int) {
		return reinterpret_cast<fun69>(address69)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, storeTriggeredID, , 1, int) {
		return reinterpret_cast<fun70>(address70)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, toggleGroup, , 2, int, bool) {
		return reinterpret_cast<fun71>(address71)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, traverseInheritanceChain, , 1, InheritanceNode*) {
		return reinterpret_cast<fun72>(address72)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateActiveOpacityEffects, , 0) {
		return reinterpret_cast<fun73>(address73)(this);
	}

	dupable getFunctionOf(GJEffectManager, updateColorAction, , 1, ColorAction*) {
		return reinterpret_cast<fun74>(address74)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateColorEffects, , 1, float) {
		return reinterpret_cast<fun75>(address75)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateColors, , 2, cocos2d::_ccColor3B, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun76>(address76)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, updateEffects, , 1, float) {
		return reinterpret_cast<fun77>(address77)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateOpacityAction, , 1, OpacityEffectAction*) {
		return reinterpret_cast<fun78>(address78)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateOpacityEffects, , 1, float) {
		return reinterpret_cast<fun79>(address79)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updatePulseEffects, , 1, float) {
		return reinterpret_cast<fun80>(address80)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, updateSpawnTriggers, , 1, float) {
		return reinterpret_cast<fun81>(address81)(this, p0);
	}

	dupable getFunctionOf(GJEffectManager, wasFollowing, , 2, int, int) {
		return reinterpret_cast<fun82>(address82)(this, p0, p1);
	}

	dupable getFunctionOf(GJEffectManager, wouldCreateLoop, , 2, InheritanceNode*, int) {
		return reinterpret_cast<fun83>(address83)(this, p0, p1);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address84)(this);
	}

	getWrapperOf(GJEffectManager, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(GJEffectManager, activeColorForIndex, , 1, int) {
		return reinterpret_cast<D*>(this)->D::activeColorForIndex(p0);
	}

	getWrapperOf(GJEffectManager, activeOpacityForIndex, , 1, int) {
		return reinterpret_cast<D*>(this)->D::activeOpacityForIndex(p0);
	}

	getWrapperOf(GJEffectManager, addAllInheritedColorActions, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::addAllInheritedColorActions(p0);
	}

	getWrapperOf(GJEffectManager, addGroupPulseEffect, , 1, PulseEffectAction*) {
		return reinterpret_cast<D*>(this)->D::addGroupPulseEffect(p0);
	}

	getWrapperOf(GJEffectManager, calculateBaseActiveColors, , 0) {
		return reinterpret_cast<D*>(this)->D::calculateBaseActiveColors();
	}

	getWrapperOf(GJEffectManager, calculateInheritedColor, , 2, int, ColorAction*) {
		return reinterpret_cast<D*>(this)->D::calculateInheritedColor(p0, p1);
	}

	getWrapperOf(GJEffectManager, calculateLightBGColor, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::calculateLightBGColor(p0);
	}

	getWrapperOf(GJEffectManager, colorActionChanged, , 1, ColorAction*) {
		return reinterpret_cast<D*>(this)->D::colorActionChanged(p0);
	}

	getWrapperOf(GJEffectManager, colorExists, , 1, int) {
		return reinterpret_cast<D*>(this)->D::colorExists(p0);
	}

	getWrapperOf(GJEffectManager, colorForEffect, , 2, cocos2d::_ccColor3B, cocos2d::_ccHSVValue) {
		return reinterpret_cast<D*>(this)->D::colorForEffect(p0, p1);
	}

	getWrapperOf(GJEffectManager, colorForGroupID, , 3, int, cocos2d::_ccColor3B const&, bool) {
		return reinterpret_cast<D*>(this)->D::colorForGroupID(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, colorForIndex, , 1, int) {
		return reinterpret_cast<D*>(this)->D::colorForIndex(p0);
	}

	getWrapperOf(GJEffectManager, colorForPulseEffect, , 2, cocos2d::_ccColor3B const&, PulseEffectAction*) {
		return reinterpret_cast<D*>(this)->D::colorForPulseEffect(p0, p1);
	}

	getWrapperOf(GJEffectManager, countChangedForItem, , 1, int) {
		return reinterpret_cast<D*>(this)->D::countChangedForItem(p0);
	}

	getWrapperOf(GJEffectManager, countForItem, , 1, int) {
		return reinterpret_cast<D*>(this)->D::countForItem(p0);
	}

	static getWrapperOf(GJEffectManager, create, , 0) {
		return D::create();
	}

	getWrapperOf(GJEffectManager, createFollowCommand, , 7, float, float, float, int, int, bool, int) {
		return reinterpret_cast<D*>(this)->D::createFollowCommand(p0, p1, p2, p3, p4, p5, p6);
	}

	getWrapperOf(GJEffectManager, createMoveCommand, , 8, cocos2d::CCPoint, int, float, int, float, bool, bool, int) {
		return reinterpret_cast<D*>(this)->D::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	getWrapperOf(GJEffectManager, createPlayerFollowCommand, , 7, float, float, int, float, float, int, int) {
		return reinterpret_cast<D*>(this)->D::createPlayerFollowCommand(p0, p1, p2, p3, p4, p5, p6);
	}

	getWrapperOf(GJEffectManager, createRotateCommand, , 8, int, float, int, int, int, float, bool, int) {
		return reinterpret_cast<D*>(this)->D::createRotateCommand(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	getWrapperOf(GJEffectManager, getAllColorActions, , 0) {
		return reinterpret_cast<D*>(this)->D::getAllColorActions();
	}

	getWrapperOf(GJEffectManager, getAllColorSprites, , 0) {
		return reinterpret_cast<D*>(this)->D::getAllColorSprites();
	}

	getWrapperOf(GJEffectManager, getColorAction, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getColorAction(p0);
	}

	getWrapperOf(GJEffectManager, getColorSprite, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getColorSprite(p0);
	}

	getWrapperOf(GJEffectManager, getCurrentStateString, , 0) {
		return reinterpret_cast<D*>(this)->D::getCurrentStateString();
	}

	getWrapperOf(GJEffectManager, getLoadedMoveOffset, , 0) {
		return reinterpret_cast<D*>(this)->D::getLoadedMoveOffset();
	}

	getWrapperOf(GJEffectManager, getMixedColor, , 3, cocos2d::_ccColor3B, cocos2d::_ccColor3B, float) {
		return reinterpret_cast<D*>(this)->D::getMixedColor(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, getOpacityActionForGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getOpacityActionForGroup(p0);
	}

	getWrapperOf(GJEffectManager, getSaveString, , 0) {
		return reinterpret_cast<D*>(this)->D::getSaveString();
	}

	getWrapperOf(GJEffectManager, handleObjectCollision, , 3, bool, int, int) {
		return reinterpret_cast<D*>(this)->D::handleObjectCollision(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, hasActiveDualTouch, , 0) {
		return reinterpret_cast<D*>(this)->D::hasActiveDualTouch();
	}

	getWrapperOf(GJEffectManager, hasBeenTriggered, , 1, int) {
		return reinterpret_cast<D*>(this)->D::hasBeenTriggered(p0);
	}

	getWrapperOf(GJEffectManager, hasPulseEffectForGroupID, , 1, int) {
		return reinterpret_cast<D*>(this)->D::hasPulseEffectForGroupID(p0);
	}

	getWrapperOf(GJEffectManager, isGroupEnabled, , 1, int) {
		return reinterpret_cast<D*>(this)->D::isGroupEnabled(p0);
	}

	getWrapperOf(GJEffectManager, keyForGroupIDColor, , 3, int, cocos2d::_ccColor3B const&, bool) {
		return reinterpret_cast<D*>(this)->D::keyForGroupIDColor(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, loadState, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::loadState(p0);
	}

	getWrapperOf(GJEffectManager, objectsCollided, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::objectsCollided(p0, p1);
	}

	getWrapperOf(GJEffectManager, opacityForIndex, , 1, int) {
		return reinterpret_cast<D*>(this)->D::opacityForIndex(p0);
	}

	getWrapperOf(GJEffectManager, opacityModForGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::opacityModForGroup(p0);
	}

	getWrapperOf(GJEffectManager, playerButton, , 2, bool, bool) {
		return reinterpret_cast<D*>(this)->D::playerButton(p0, p1);
	}

	getWrapperOf(GJEffectManager, playerDied, , 0) {
		return reinterpret_cast<D*>(this)->D::playerDied();
	}

	getWrapperOf(GJEffectManager, postCollisionCheck, , 0) {
		return reinterpret_cast<D*>(this)->D::postCollisionCheck();
	}

	getWrapperOf(GJEffectManager, preCollisionCheck, , 0) {
		return reinterpret_cast<D*>(this)->D::preCollisionCheck();
	}

	getWrapperOf(GJEffectManager, prepareMoveActions, , 2, float, bool) {
		return reinterpret_cast<D*>(this)->D::prepareMoveActions(p0, p1);
	}

	getWrapperOf(GJEffectManager, processColors, , 0) {
		return reinterpret_cast<D*>(this)->D::processColors();
	}

	getWrapperOf(GJEffectManager, processCopyColorPulseActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processCopyColorPulseActions();
	}

	getWrapperOf(GJEffectManager, processInheritedColors, , 0) {
		return reinterpret_cast<D*>(this)->D::processInheritedColors();
	}

	getWrapperOf(GJEffectManager, processPulseActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processPulseActions();
	}

	getWrapperOf(GJEffectManager, registerCollisionTrigger, , 6, int, int, int, bool, bool, int) {
		return reinterpret_cast<D*>(this)->D::registerCollisionTrigger(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(GJEffectManager, removeAllPulseActions, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllPulseActions();
	}

	getWrapperOf(GJEffectManager, removeColorAction, , 1, int) {
		return reinterpret_cast<D*>(this)->D::removeColorAction(p0);
	}

	getWrapperOf(GJEffectManager, reset, , 0) {
		return reinterpret_cast<D*>(this)->D::reset();
	}

	getWrapperOf(GJEffectManager, resetColorCache, , 0) {
		return reinterpret_cast<D*>(this)->D::resetColorCache();
	}

	getWrapperOf(GJEffectManager, resetEffects, , 0) {
		return reinterpret_cast<D*>(this)->D::resetEffects();
	}

	getWrapperOf(GJEffectManager, resetMoveActions, , 0) {
		return reinterpret_cast<D*>(this)->D::resetMoveActions();
	}

	getWrapperOf(GJEffectManager, resetToggledGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::resetToggledGroups();
	}

	getWrapperOf(GJEffectManager, resetTriggeredIDs, , 0) {
		return reinterpret_cast<D*>(this)->D::resetTriggeredIDs();
	}

	getWrapperOf(GJEffectManager, runCountTrigger, , 6, int, int, bool, int, bool, int) {
		return reinterpret_cast<D*>(this)->D::runCountTrigger(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(GJEffectManager, runDeathTrigger, , 3, int, bool, int) {
		return reinterpret_cast<D*>(this)->D::runDeathTrigger(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, runOpacityActionOnGroup, , 4, int, float, float, int) {
		return reinterpret_cast<D*>(this)->D::runOpacityActionOnGroup(p0, p1, p2, p3);
	}

	getWrapperOf(GJEffectManager, runPulseEffect, , 13, int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int) {
		return reinterpret_cast<D*>(this)->D::runPulseEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
	}

	getWrapperOf(GJEffectManager, runTouchTriggerCommand, , 5, int, bool, TouchTriggerType, bool, int) {
		return reinterpret_cast<D*>(this)->D::runTouchTriggerCommand(p0, p1, p2, p3, p4);
	}

	getWrapperOf(GJEffectManager, setColorAction, , 2, ColorAction*, int) {
		return reinterpret_cast<D*>(this)->D::setColorAction(p0, p1);
	}

	getWrapperOf(GJEffectManager, setFollowing, , 3, int, int, bool) {
		return reinterpret_cast<D*>(this)->D::setFollowing(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, setupFromString, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::setupFromString(p0);
	}

	getWrapperOf(GJEffectManager, shouldBlend, , 1, int) {
		return reinterpret_cast<D*>(this)->D::shouldBlend(p0);
	}

	getWrapperOf(GJEffectManager, spawnGroup, , 3, int, float, int) {
		return reinterpret_cast<D*>(this)->D::spawnGroup(p0, p1, p2);
	}

	getWrapperOf(GJEffectManager, stopActionsForTrigger, , 1, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::stopActionsForTrigger(p0);
	}

	getWrapperOf(GJEffectManager, stopMoveActionsForGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::stopMoveActionsForGroup(p0);
	}

	getWrapperOf(GJEffectManager, storeTriggeredID, , 1, int) {
		return reinterpret_cast<D*>(this)->D::storeTriggeredID(p0);
	}

	getWrapperOf(GJEffectManager, toggleGroup, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::toggleGroup(p0, p1);
	}

	getWrapperOf(GJEffectManager, traverseInheritanceChain, , 1, InheritanceNode*) {
		return reinterpret_cast<D*>(this)->D::traverseInheritanceChain(p0);
	}

	getWrapperOf(GJEffectManager, updateActiveOpacityEffects, , 0) {
		return reinterpret_cast<D*>(this)->D::updateActiveOpacityEffects();
	}

	getWrapperOf(GJEffectManager, updateColorAction, , 1, ColorAction*) {
		return reinterpret_cast<D*>(this)->D::updateColorAction(p0);
	}

	getWrapperOf(GJEffectManager, updateColorEffects, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateColorEffects(p0);
	}

	getWrapperOf(GJEffectManager, updateColors, , 2, cocos2d::_ccColor3B, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::updateColors(p0, p1);
	}

	getWrapperOf(GJEffectManager, updateEffects, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateEffects(p0);
	}

	getWrapperOf(GJEffectManager, updateOpacityAction, , 1, OpacityEffectAction*) {
		return reinterpret_cast<D*>(this)->D::updateOpacityAction(p0);
	}

	getWrapperOf(GJEffectManager, updateOpacityEffects, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateOpacityEffects(p0);
	}

	getWrapperOf(GJEffectManager, updatePulseEffects, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updatePulseEffects(p0);
	}

	getWrapperOf(GJEffectManager, updateSpawnTriggers, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateSpawnTriggers(p0);
	}

	getWrapperOf(GJEffectManager, wasFollowing, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::wasFollowing(p0, p1);
	}

	getWrapperOf(GJEffectManager, wouldCreateLoop, , 2, InheritanceNode*, int) {
		return reinterpret_cast<D*>(this)->D::wouldCreateLoop(p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if ((mem0)(&$GJEffectManager::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfVirtual((der0)(&D::initWrapper)));
		}

		if constexpr((mem1)(&$GJEffectManager::activeColorForIndex) != (der1)(&D::activeColorForIndex)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::activeColorForIndexWrapper)));
		}

		if constexpr((mem2)(&$GJEffectManager::activeOpacityForIndex) != (der2)(&D::activeOpacityForIndex)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::activeOpacityForIndexWrapper)));
		}

		if constexpr((mem3)(&$GJEffectManager::addAllInheritedColorActions) != (der3)(&D::addAllInheritedColorActions)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::addAllInheritedColorActionsWrapper)));
		}

		if constexpr((mem4)(&$GJEffectManager::addGroupPulseEffect) != (der4)(&D::addGroupPulseEffect)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::addGroupPulseEffectWrapper)));
		}

		if constexpr((mem5)(&$GJEffectManager::calculateBaseActiveColors) != (der5)(&D::calculateBaseActiveColors)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::calculateBaseActiveColorsWrapper)));
		}

		if constexpr((mem6)(&$GJEffectManager::calculateInheritedColor) != (der6)(&D::calculateInheritedColor)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::calculateInheritedColorWrapper)));
		}

		if constexpr((mem7)(&$GJEffectManager::calculateLightBGColor) != (der7)(&D::calculateLightBGColor)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::calculateLightBGColorWrapper)));
		}

		if constexpr((mem8)(&$GJEffectManager::colorActionChanged) != (der8)(&D::colorActionChanged)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::colorActionChangedWrapper)));
		}

		if constexpr((mem9)(&$GJEffectManager::colorExists) != (der9)(&D::colorExists)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::colorExistsWrapper)));
		}

		if constexpr((mem10)(&$GJEffectManager::colorForEffect) != (der10)(&D::colorForEffect)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::colorForEffectWrapper)));
		}

		if constexpr((mem11)(&$GJEffectManager::colorForGroupID) != (der11)(&D::colorForGroupID)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::colorForGroupIDWrapper)));
		}

		if constexpr((mem12)(&$GJEffectManager::colorForIndex) != (der12)(&D::colorForIndex)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::colorForIndexWrapper)));
		}

		if constexpr((mem13)(&$GJEffectManager::colorForPulseEffect) != (der13)(&D::colorForPulseEffect)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::colorForPulseEffectWrapper)));
		}

		if constexpr((mem14)(&$GJEffectManager::countChangedForItem) != (der14)(&D::countChangedForItem)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::countChangedForItemWrapper)));
		}

		if constexpr((mem15)(&$GJEffectManager::countForItem) != (der15)(&D::countForItem)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::countForItemWrapper)));
		}

		if constexpr((mem16)(&$GJEffectManager::create) != (der16)(&D::create)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::createWrapper)));
		}

		if constexpr((mem17)(&$GJEffectManager::createFollowCommand) != (der17)(&D::createFollowCommand)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::createFollowCommandWrapper)));
		}

		if constexpr((mem18)(&$GJEffectManager::createMoveCommand) != (der18)(&D::createMoveCommand)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::createMoveCommandWrapper)));
		}

		if constexpr((mem19)(&$GJEffectManager::createPlayerFollowCommand) != (der19)(&D::createPlayerFollowCommand)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::createPlayerFollowCommandWrapper)));
		}

		if constexpr((mem20)(&$GJEffectManager::createRotateCommand) != (der20)(&D::createRotateCommand)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::createRotateCommandWrapper)));
		}

		if constexpr((mem21)(&$GJEffectManager::getAllColorActions) != (der21)(&D::getAllColorActions)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::getAllColorActionsWrapper)));
		}

		if constexpr((mem22)(&$GJEffectManager::getAllColorSprites) != (der22)(&D::getAllColorSprites)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::getAllColorSpritesWrapper)));
		}

		if constexpr((mem23)(&$GJEffectManager::getColorAction) != (der23)(&D::getColorAction)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::getColorActionWrapper)));
		}

		if constexpr((mem24)(&$GJEffectManager::getColorSprite) != (der24)(&D::getColorSprite)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::getColorSpriteWrapper)));
		}

		if constexpr((mem25)(&$GJEffectManager::getCurrentStateString) != (der25)(&D::getCurrentStateString)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::getCurrentStateStringWrapper)));
		}

		if constexpr((mem26)(&$GJEffectManager::getLoadedMoveOffset) != (der26)(&D::getLoadedMoveOffset)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::getLoadedMoveOffsetWrapper)));
		}

		if constexpr((mem27)(&$GJEffectManager::getMixedColor) != (der27)(&D::getMixedColor)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::getMixedColorWrapper)));
		}

		if constexpr((mem28)(&$GJEffectManager::getOpacityActionForGroup) != (der28)(&D::getOpacityActionForGroup)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::getOpacityActionForGroupWrapper)));
		}

		if constexpr((mem29)(&$GJEffectManager::getSaveString) != (der29)(&D::getSaveString)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::getSaveStringWrapper)));
		}

		if constexpr((mem30)(&$GJEffectManager::handleObjectCollision) != (der30)(&D::handleObjectCollision)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::handleObjectCollisionWrapper)));
		}

		if constexpr((mem31)(&$GJEffectManager::hasActiveDualTouch) != (der31)(&D::hasActiveDualTouch)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::hasActiveDualTouchWrapper)));
		}

		if constexpr((mem32)(&$GJEffectManager::hasBeenTriggered) != (der32)(&D::hasBeenTriggered)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::hasBeenTriggeredWrapper)));
		}

		if constexpr((mem33)(&$GJEffectManager::hasPulseEffectForGroupID) != (der33)(&D::hasPulseEffectForGroupID)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::hasPulseEffectForGroupIDWrapper)));
		}

		if constexpr((mem34)(&$GJEffectManager::isGroupEnabled) != (der34)(&D::isGroupEnabled)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::isGroupEnabledWrapper)));
		}

		if constexpr((mem35)(&$GJEffectManager::keyForGroupIDColor) != (der35)(&D::keyForGroupIDColor)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::keyForGroupIDColorWrapper)));
		}

		if constexpr((mem36)(&$GJEffectManager::loadState) != (der36)(&D::loadState)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual((der36)(&D::loadStateWrapper)));
		}

		if constexpr((mem37)(&$GJEffectManager::objectsCollided) != (der37)(&D::objectsCollided)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::objectsCollidedWrapper)));
		}

		if constexpr((mem38)(&$GJEffectManager::opacityForIndex) != (der38)(&D::opacityForIndex)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::opacityForIndexWrapper)));
		}

		if constexpr((mem39)(&$GJEffectManager::opacityModForGroup) != (der39)(&D::opacityModForGroup)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::opacityModForGroupWrapper)));
		}

		if constexpr((mem40)(&$GJEffectManager::playerButton) != (der40)(&D::playerButton)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::playerButtonWrapper)));
		}

		if constexpr((mem41)(&$GJEffectManager::playerDied) != (der41)(&D::playerDied)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::playerDiedWrapper)));
		}

		if constexpr((mem42)(&$GJEffectManager::postCollisionCheck) != (der42)(&D::postCollisionCheck)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::postCollisionCheckWrapper)));
		}

		if constexpr((mem43)(&$GJEffectManager::preCollisionCheck) != (der43)(&D::preCollisionCheck)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::preCollisionCheckWrapper)));
		}

		if constexpr((mem44)(&$GJEffectManager::prepareMoveActions) != (der44)(&D::prepareMoveActions)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::prepareMoveActionsWrapper)));
		}

		if constexpr((mem45)(&$GJEffectManager::processColors) != (der45)(&D::processColors)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::processColorsWrapper)));
		}

		if constexpr((mem46)(&$GJEffectManager::processCopyColorPulseActions) != (der46)(&D::processCopyColorPulseActions)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::processCopyColorPulseActionsWrapper)));
		}

		if constexpr((mem47)(&$GJEffectManager::processInheritedColors) != (der47)(&D::processInheritedColors)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::processInheritedColorsWrapper)));
		}

		if constexpr((mem48)(&$GJEffectManager::processPulseActions) != (der48)(&D::processPulseActions)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::processPulseActionsWrapper)));
		}

		if constexpr((mem49)(&$GJEffectManager::registerCollisionTrigger) != (der49)(&D::registerCollisionTrigger)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::registerCollisionTriggerWrapper)));
		}

		if constexpr((mem50)(&$GJEffectManager::removeAllPulseActions) != (der50)(&D::removeAllPulseActions)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::removeAllPulseActionsWrapper)));
		}

		if constexpr((mem51)(&$GJEffectManager::removeColorAction) != (der51)(&D::removeColorAction)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::removeColorActionWrapper)));
		}

		if constexpr((mem52)(&$GJEffectManager::reset) != (der52)(&D::reset)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::resetWrapper)));
		}

		if constexpr((mem53)(&$GJEffectManager::resetColorCache) != (der53)(&D::resetColorCache)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::resetColorCacheWrapper)));
		}

		if constexpr((mem54)(&$GJEffectManager::resetEffects) != (der54)(&D::resetEffects)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::resetEffectsWrapper)));
		}

		if constexpr((mem55)(&$GJEffectManager::resetMoveActions) != (der55)(&D::resetMoveActions)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::resetMoveActionsWrapper)));
		}

		if constexpr((mem56)(&$GJEffectManager::resetToggledGroups) != (der56)(&D::resetToggledGroups)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::resetToggledGroupsWrapper)));
		}

		if constexpr((mem57)(&$GJEffectManager::resetTriggeredIDs) != (der57)(&D::resetTriggeredIDs)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::resetTriggeredIDsWrapper)));
		}

		if constexpr((mem58)(&$GJEffectManager::runCountTrigger) != (der58)(&D::runCountTrigger)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::runCountTriggerWrapper)));
		}

		if constexpr((mem59)(&$GJEffectManager::runDeathTrigger) != (der59)(&D::runDeathTrigger)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::runDeathTriggerWrapper)));
		}

		if constexpr((mem60)(&$GJEffectManager::runOpacityActionOnGroup) != (der60)(&D::runOpacityActionOnGroup)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::runOpacityActionOnGroupWrapper)));
		}

		if constexpr((mem61)(&$GJEffectManager::runPulseEffect) != (der61)(&D::runPulseEffect)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::runPulseEffectWrapper)));
		}

		if constexpr((mem62)(&$GJEffectManager::runTouchTriggerCommand) != (der62)(&D::runTouchTriggerCommand)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::runTouchTriggerCommandWrapper)));
		}

		if constexpr((mem63)(&$GJEffectManager::setColorAction) != (der63)(&D::setColorAction)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::setColorActionWrapper)));
		}

		if constexpr((mem64)(&$GJEffectManager::setFollowing) != (der64)(&D::setFollowing)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::setFollowingWrapper)));
		}

		if constexpr((mem65)(&$GJEffectManager::setupFromString) != (der65)(&D::setupFromString)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::setupFromStringWrapper)));
		}

		if constexpr((mem66)(&$GJEffectManager::shouldBlend) != (der66)(&D::shouldBlend)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::shouldBlendWrapper)));
		}

		if constexpr((mem67)(&$GJEffectManager::spawnGroup) != (der67)(&D::spawnGroup)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::spawnGroupWrapper)));
		}

		if constexpr((mem68)(&$GJEffectManager::stopActionsForTrigger) != (der68)(&D::stopActionsForTrigger)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::stopActionsForTriggerWrapper)));
		}

		if constexpr((mem69)(&$GJEffectManager::stopMoveActionsForGroup) != (der69)(&D::stopMoveActionsForGroup)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::stopMoveActionsForGroupWrapper)));
		}

		if constexpr((mem70)(&$GJEffectManager::storeTriggeredID) != (der70)(&D::storeTriggeredID)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::storeTriggeredIDWrapper)));
		}

		if constexpr((mem71)(&$GJEffectManager::toggleGroup) != (der71)(&D::toggleGroup)) {
			modContainer.registerHookEnable(address71, FunctionScrapper::addressOfNonVirtual((der71)(&D::toggleGroupWrapper)));
		}

		if constexpr((mem72)(&$GJEffectManager::traverseInheritanceChain) != (der72)(&D::traverseInheritanceChain)) {
			modContainer.registerHookEnable(address72, FunctionScrapper::addressOfNonVirtual((der72)(&D::traverseInheritanceChainWrapper)));
		}

		if constexpr((mem73)(&$GJEffectManager::updateActiveOpacityEffects) != (der73)(&D::updateActiveOpacityEffects)) {
			modContainer.registerHookEnable(address73, FunctionScrapper::addressOfNonVirtual((der73)(&D::updateActiveOpacityEffectsWrapper)));
		}

		if constexpr((mem74)(&$GJEffectManager::updateColorAction) != (der74)(&D::updateColorAction)) {
			modContainer.registerHookEnable(address74, FunctionScrapper::addressOfNonVirtual((der74)(&D::updateColorActionWrapper)));
		}

		if constexpr((mem75)(&$GJEffectManager::updateColorEffects) != (der75)(&D::updateColorEffects)) {
			modContainer.registerHookEnable(address75, FunctionScrapper::addressOfNonVirtual((der75)(&D::updateColorEffectsWrapper)));
		}

		if constexpr((mem76)(&$GJEffectManager::updateColors) != (der76)(&D::updateColors)) {
			modContainer.registerHookEnable(address76, FunctionScrapper::addressOfNonVirtual((der76)(&D::updateColorsWrapper)));
		}

		if constexpr((mem77)(&$GJEffectManager::updateEffects) != (der77)(&D::updateEffects)) {
			modContainer.registerHookEnable(address77, FunctionScrapper::addressOfNonVirtual((der77)(&D::updateEffectsWrapper)));
		}

		if constexpr((mem78)(&$GJEffectManager::updateOpacityAction) != (der78)(&D::updateOpacityAction)) {
			modContainer.registerHookEnable(address78, FunctionScrapper::addressOfNonVirtual((der78)(&D::updateOpacityActionWrapper)));
		}

		if constexpr((mem79)(&$GJEffectManager::updateOpacityEffects) != (der79)(&D::updateOpacityEffects)) {
			modContainer.registerHookEnable(address79, FunctionScrapper::addressOfNonVirtual((der79)(&D::updateOpacityEffectsWrapper)));
		}

		if constexpr((mem80)(&$GJEffectManager::updatePulseEffects) != (der80)(&D::updatePulseEffects)) {
			modContainer.registerHookEnable(address80, FunctionScrapper::addressOfNonVirtual((der80)(&D::updatePulseEffectsWrapper)));
		}

		if constexpr((mem81)(&$GJEffectManager::updateSpawnTriggers) != (der81)(&D::updateSpawnTriggers)) {
			modContainer.registerHookEnable(address81, FunctionScrapper::addressOfNonVirtual((der81)(&D::updateSpawnTriggersWrapper)));
		}

		if constexpr((mem82)(&$GJEffectManager::wasFollowing) != (der82)(&D::wasFollowing)) {
			modContainer.registerHookEnable(address82, FunctionScrapper::addressOfNonVirtual((der82)(&D::wasFollowingWrapper)));
		}

		if constexpr((mem83)(&$GJEffectManager::wouldCreateLoop) != (der83)(&D::wouldCreateLoop)) {
			modContainer.registerHookEnable(address83, FunctionScrapper::addressOfNonVirtual((der83)(&D::wouldCreateLoopWrapper)));
		}

		if constexpr(&$GJEffectManager::destructor != &D::destructor) {
			modContainer.registerHookEnable(address84, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $GJGameLevel : GJGameLevel, InterfaceBase {
	$GJGameLevel(const $GJGameLevel& c) : GJGameLevel(c) {}
	$GJGameLevel() = delete;
	setInterfaceTypesOf(1, GJGameLevel, encodeWithCoder, , 1, DS_Dictionary*);
	setInterfaceTypesOf(2, GJGameLevel, canEncode, , 0);
	setInterfaceTypesOf(3, GJGameLevel, init, , 0);
	setInterfaceStaticTypesOf(4, GJGameLevel, create, , 0);
	setInterfaceTypesOf(5, GJGameLevel, getAudioFileName, , 0);
	setInterfaceTypesOf(6, GJGameLevel, getCoinKey, , 1, int);
	setInterfaceTypesOf(7, GJGameLevel, getLengthKey, , 1, int);
	setInterfaceTypesOf(8, GJGameLevel, getNormalPercent, , 0);
	setInterfaceTypesOf(9, GJGameLevel, levelWasAltered, , 0);
	setInterfaceTypesOf(10, GJGameLevel, savePercentage, , 5, int, bool, int, int, bool);
	static inline auto address0 = base+0x2db2d0;
	static inline auto address1 = base+0x2dd1c0;
	static inline auto address2 = base+0x2ddae0;
	static inline auto address3 = base+0x2db310;
	static inline auto address4 = base+0x2b83e0;
	static inline auto address5 = base+0x2dbe70;
	static inline auto address6 = base+0x2ce360;
	static inline auto address7 = base+0x2dbba0;
	static inline auto address8 = base+0x2b8b20;
	static inline auto address9 = base+0x2db530;
	static inline auto address10 = base+0x2db700;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(GJGameLevel, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(GJGameLevel, canEncode, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(GJGameLevel, init, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable static getFunctionOf(GJGameLevel, create, , 0) {
		return reinterpret_cast<fun4>(address4)();
	}

	dupable getFunctionOf(GJGameLevel, getAudioFileName, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(GJGameLevel, getCoinKey, , 1, int) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(GJGameLevel, getLengthKey, , 1, int) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GJGameLevel, getNormalPercent, , 0) {
		return reinterpret_cast<fun8>(address8)(this);
	}

	dupable getFunctionOf(GJGameLevel, levelWasAltered, , 0) {
		return reinterpret_cast<fun9>(address9)(this);
	}

	dupable getFunctionOf(GJGameLevel, savePercentage, , 5, int, bool, int, int, bool) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1, p2, p3, p4);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GJGameLevel, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<D*>(this)->D::encodeWithCoder(p0);
	}

	getWrapperOf(GJGameLevel, canEncode, , 0) {
		return reinterpret_cast<D*>(this)->D::canEncode();
	}

	getWrapperOf(GJGameLevel, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	static getWrapperOf(GJGameLevel, create, , 0) {
		return D::create();
	}

	getWrapperOf(GJGameLevel, getAudioFileName, , 0) {
		return reinterpret_cast<D*>(this)->D::getAudioFileName();
	}

	getWrapperOf(GJGameLevel, getCoinKey, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getCoinKey(p0);
	}

	getWrapperOf(GJGameLevel, getLengthKey, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getLengthKey(p0);
	}

	getWrapperOf(GJGameLevel, getNormalPercent, , 0) {
		return reinterpret_cast<D*>(this)->D::getNormalPercent();
	}

	getWrapperOf(GJGameLevel, levelWasAltered, , 0) {
		return reinterpret_cast<D*>(this)->D::levelWasAltered();
	}

	getWrapperOf(GJGameLevel, savePercentage, , 5, int, bool, int, int, bool) {
		return reinterpret_cast<D*>(this)->D::savePercentage(p0, p1, p2, p3, p4);
	}

public:
	static bool _apply() {

		if constexpr(&$GJGameLevel::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$GJGameLevel::encodeWithCoder) != (der1)(&D::encodeWithCoder)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::encodeWithCoderWrapper)));
		}

		if ((mem2)(&$GJGameLevel::canEncode) != (der2)(&D::canEncode)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::canEncodeWrapper)));
		}

		if ((mem3)(&$GJGameLevel::init) != (der3)(&D::init)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::initWrapper)));
		}

		if constexpr((mem4)(&$GJGameLevel::create) != (der4)(&D::create)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::createWrapper)));
		}

		if constexpr((mem5)(&$GJGameLevel::getAudioFileName) != (der5)(&D::getAudioFileName)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::getAudioFileNameWrapper)));
		}

		if constexpr((mem6)(&$GJGameLevel::getCoinKey) != (der6)(&D::getCoinKey)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::getCoinKeyWrapper)));
		}

		if constexpr((mem7)(&$GJGameLevel::getLengthKey) != (der7)(&D::getLengthKey)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::getLengthKeyWrapper)));
		}

		if constexpr((mem8)(&$GJGameLevel::getNormalPercent) != (der8)(&D::getNormalPercent)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::getNormalPercentWrapper)));
		}

		if constexpr((mem9)(&$GJGameLevel::levelWasAltered) != (der9)(&D::levelWasAltered)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::levelWasAlteredWrapper)));
		}

		if constexpr((mem10)(&$GJGameLevel::savePercentage) != (der10)(&D::savePercentage)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::savePercentageWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJListLayer : GJListLayer, InterfaceBase {
	$GJListLayer(const $GJListLayer& c) : GJListLayer(c) {}
	$GJListLayer() = delete;
	static inline auto address0 = base+0x344350;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr(&$GJListLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $GJRobotSprite : GJRobotSprite, InterfaceBase {
	$GJRobotSprite(const $GJRobotSprite& c) : GJRobotSprite(c) {}
	$GJRobotSprite() = delete;
	setInterfaceTypesOf(1, GJRobotSprite, init, , 0);
	setInterfaceTypesOf(2, GJRobotSprite, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(3, GJRobotSprite, hideSecondary, , 0);
	setInterfaceStaticTypesOf(4, GJRobotSprite, create, , 0);
	setInterfaceTypesOf(5, GJRobotSprite, updateColor02, , 1, cocos2d::_ccColor3B);
	setInterfaceTypesOf(6, GJRobotSprite, updateFrame, , 1, int);
	static inline auto address0 = base+0x34aaf0;
	static inline auto address1 = base+0x34ad50;
	static inline auto address2 = base+0x34bcc0;
	static inline auto address3 = base+0x34c3b0;
	static inline auto address4 = base+0x34ac00;
	static inline auto address5 = base+0x34bbd0;
	static inline auto address6 = base+0x34bdd0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(GJRobotSprite, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(GJRobotSprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(GJRobotSprite, hideSecondary, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable static getFunctionOf(GJRobotSprite, create, , 0) {
		return reinterpret_cast<fun4>(address4)();
	}

	dupable getFunctionOf(GJRobotSprite, updateColor02, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(GJRobotSprite, updateFrame, , 1, int) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GJRobotSprite, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(GJRobotSprite, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(GJRobotSprite, hideSecondary, , 0) {
		return reinterpret_cast<D*>(this)->D::hideSecondary();
	}

	static getWrapperOf(GJRobotSprite, create, , 0) {
		return D::create();
	}

	getWrapperOf(GJRobotSprite, updateColor02, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::updateColor02(p0);
	}

	getWrapperOf(GJRobotSprite, updateFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updateFrame(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$GJRobotSprite::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$GJRobotSprite::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if ((mem2)(&$GJRobotSprite::setOpacity) != (der2)(&D::setOpacity)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setOpacityWrapper)));
		}

		if ((mem3)(&$GJRobotSprite::hideSecondary) != (der3)(&D::hideSecondary)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::hideSecondaryWrapper)));
		}

		if constexpr((mem4)(&$GJRobotSprite::create) != (der4)(&D::create)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::createWrapper)));
		}

		if constexpr((mem5)(&$GJRobotSprite::updateColor02) != (der5)(&D::updateColor02)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::updateColor02Wrapper)));
		}

		if constexpr((mem6)(&$GJRobotSprite::updateFrame) != (der6)(&D::updateFrame)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::updateFrameWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GJSpecialColorSelectDelegate : GJSpecialColorSelectDelegate, InterfaceBase {
	$GJSpecialColorSelectDelegate(const $GJSpecialColorSelectDelegate& c) : GJSpecialColorSelectDelegate(c) {}
	$GJSpecialColorSelectDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $GJSpiderSprite : GJSpiderSprite, InterfaceBase {
	$GJSpiderSprite(const $GJSpiderSprite& c) : GJSpiderSprite(c) {}
	$GJSpiderSprite() = delete;
	setInterfaceTypesOf(1, GJSpiderSprite, init, , 0);
	setInterfaceStaticTypesOf(2, GJSpiderSprite, create, , 0);
	static inline auto address0 = base+0x34c4a0;
	static inline auto address1 = base+0x34c700;
	static inline auto address2 = base+0x34c5b0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(GJSpiderSprite, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable static getFunctionOf(GJSpiderSprite, create, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GJSpiderSprite, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	static getWrapperOf(GJSpiderSprite, create, , 0) {
		return D::create();
	}

public:
	static bool _apply() {

		if constexpr(&$GJSpiderSprite::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$GJSpiderSprite::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$GJSpiderSprite::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GManager : GManager, InterfaceBase {
	$GManager(const $GManager& c) : GManager(c) {}
	$GManager() = delete;
	setInterfaceTypesOf(1, GManager, save, , 0);
	setInterfaceTypesOf(2, GManager, saveData, , 2, DS_Dictionary*, gd::string);
	setInterfaceTypesOf(3, GManager, saveGMTo, , 1, gd::string);
	static inline auto address1 = base+0x26f300;
	static inline auto address2 = base+0x26f4b0;
	static inline auto address3 = base+0x26f3b0;

	dupable getFunctionOf(GManager, save, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(GManager, saveData, , 2, DS_Dictionary*, gd::string) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1);
	}

	dupable getFunctionOf(GManager, saveGMTo, , 1, gd::string) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	getWrapperOf(GManager, save, , 0) {
		return reinterpret_cast<D*>(this)->D::save();
	}

	getWrapperOf(GManager, saveData, , 2, DS_Dictionary*, gd::string) {
		return reinterpret_cast<D*>(this)->D::saveData(p0, p1);
	}

	getWrapperOf(GManager, saveGMTo, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::saveGMTo(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem1)(&$GManager::save) != (der1)(&D::save)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::saveWrapper)));
		}

		if constexpr((mem2)(&$GManager::saveData) != (der2)(&D::saveData)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::saveDataWrapper)));
		}

		if constexpr((mem3)(&$GManager::saveGMTo) != (der3)(&D::saveGMTo)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::saveGMToWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GameLevelManager : GameLevelManager, InterfaceBase {
	$GameLevelManager(const $GameLevelManager& c) : GameLevelManager(c) {}
	$GameLevelManager() = delete;
	setInterfaceTypesOf(0, GameLevelManager, createNewLevel, , 0);
	setInterfaceStaticTypesOf(1, GameLevelManager, sharedState, , 0);
	setInterfaceTypesOf(2, GameLevelManager, getPageInfo, , 1, char const*);
	setInterfaceTypesOf(3, GameLevelManager, getStoredOnlineLevels, , 1, char const*);
	setInterfaceTypesOf(4, GameLevelManager, getTopArtists, , 2, int, int);
	setInterfaceTypesOf(5, GameLevelManager, getTopArtistsKey, , 1, int);
	setInterfaceTypesOf(6, GameLevelManager, makeTimeStamp, , 1, char const*);
	static inline auto address0 = base+0x2b8180;
	static inline auto address1 = base+0x2a8340;
	static inline auto address2 = base+0x2c0050;
	static inline auto address3 = base+0x2bfe80;
	static inline auto address4 = base+0x2ce3d0;
	static inline auto address5 = base+0x2ce7a0;
	static inline auto address6 = base+0x2bfd90;

	dupable getFunctionOf(GameLevelManager, createNewLevel, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable static getFunctionOf(GameLevelManager, sharedState, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	dupable getFunctionOf(GameLevelManager, getPageInfo, , 1, char const*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(GameLevelManager, getStoredOnlineLevels, , 1, char const*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(GameLevelManager, getTopArtists, , 2, int, int) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	dupable getFunctionOf(GameLevelManager, getTopArtistsKey, , 1, int) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(GameLevelManager, makeTimeStamp, , 1, char const*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	getWrapperOf(GameLevelManager, createNewLevel, , 0) {
		return reinterpret_cast<D*>(this)->D::createNewLevel();
	}

	static getWrapperOf(GameLevelManager, sharedState, , 0) {
		return D::sharedState();
	}

	getWrapperOf(GameLevelManager, getPageInfo, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getPageInfo(p0);
	}

	getWrapperOf(GameLevelManager, getStoredOnlineLevels, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getStoredOnlineLevels(p0);
	}

	getWrapperOf(GameLevelManager, getTopArtists, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::getTopArtists(p0, p1);
	}

	getWrapperOf(GameLevelManager, getTopArtistsKey, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getTopArtistsKey(p0);
	}

	getWrapperOf(GameLevelManager, makeTimeStamp, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::makeTimeStamp(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$GameLevelManager::createNewLevel) != (der0)(&D::createNewLevel)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createNewLevelWrapper)));
		}

		if constexpr((mem1)(&$GameLevelManager::sharedState) != (der1)(&D::sharedState)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedStateWrapper)));
		}

		if constexpr((mem2)(&$GameLevelManager::getPageInfo) != (der2)(&D::getPageInfo)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getPageInfoWrapper)));
		}

		if constexpr((mem3)(&$GameLevelManager::getStoredOnlineLevels) != (der3)(&D::getStoredOnlineLevels)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getStoredOnlineLevelsWrapper)));
		}

		if constexpr((mem4)(&$GameLevelManager::getTopArtists) != (der4)(&D::getTopArtists)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::getTopArtistsWrapper)));
		}

		if constexpr((mem5)(&$GameLevelManager::getTopArtistsKey) != (der5)(&D::getTopArtistsKey)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::getTopArtistsKeyWrapper)));
		}

		if constexpr((mem6)(&$GameLevelManager::makeTimeStamp) != (der6)(&D::makeTimeStamp)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::makeTimeStampWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GameManager : GameManager, InterfaceBase {
	$GameManager(const $GameManager& c) : GameManager(c) {}
	$GameManager() = delete;
	setInterfaceTypesOf(0, GameManager, accountStatusChanged, , 0);
	setInterfaceTypesOf(1, GameManager, colorForIdx, , 1, int);
	setInterfaceTypesOf(2, GameManager, didExitPlayscene, , 0);
	setInterfaceTypesOf(3, GameManager, doQuickSave, , 0);
	setInterfaceTypesOf(4, GameManager, fadeInMusic, , 1, char const*);
	setInterfaceTypesOf(5, GameManager, getBGTexture, , 1, int);
	setInterfaceTypesOf(6, GameManager, getFontFile, , 1, int);
	setInterfaceTypesOf(7, GameManager, getGameVariable, , 1, char const*);
	setInterfaceTypesOf(8, GameManager, getIntGameVariable, , 1, char const*);
	setInterfaceTypesOf(9, GameManager, getUGV, , 1, char const*);
	setInterfaceTypesOf(10, GameManager, loadDeathEffect, , 1, int);
	setInterfaceTypesOf(11, GameManager, loadFont, , 1, int);
	setInterfaceTypesOf(12, GameManager, reloadAll, , 3, bool, bool, bool);
	setInterfaceTypesOf(13, GameManager, reloadAllStep5, , 0);
	setInterfaceTypesOf(14, GameManager, reportPercentageForLevel, , 3, int, int, bool);
	setInterfaceTypesOf(15, GameManager, setGameVariable, , 2, char const*, bool);
	setInterfaceTypesOf(16, GameManager, setIntGameVariable, , 2, char const*, int);
	setInterfaceTypesOf(17, GameManager, setUGV, , 2, char const*, bool);
	setInterfaceStaticTypesOf(18, GameManager, sharedState, , 0);
	setInterfaceTypesOf(20, GameManager, getGTexture, , 1, int);
	setInterfaceTypesOf(21, GameManager, init, , 0);
	setInterfaceTypesOf(22, GameManager, reportAchievementWithID, , 3, char const*, int, bool);
	setInterfaceTypesOf(23, GameManager, resolutionForKey, , 1, int);
	setInterfaceTypesOf(24, GameManager, update, , 1, float);
	static inline auto address0 = base+0x1cdad0;
	static inline auto address1 = base+0x1cbc80;
	static inline auto address2 = base+0x1d0230;
	static inline auto address3 = base+0x1d0200;
	static inline auto address4 = base+0x1c2ff0;
	static inline auto address5 = base+0x1cca00;
	static inline auto address6 = base+0x1cc5f0;
	static inline auto address7 = base+0x1cccd0;
	static inline auto address8 = base+0x1cd1d0;
	static inline auto address9 = base+0x1ccfa0;
	static inline auto address10 = base+0x1cc690;
	static inline auto address11 = base+0x1cc550;
	static inline auto address12 = base+0x1d08a0;
	static inline auto address13 = base+0x1d0b00;
	static inline auto address14 = base+0x1c5b00;
	static inline auto address15 = base+0x1cca80;
	static inline auto address16 = base+0x1cd0e0;
	static inline auto address17 = base+0x1cce50;
	static inline auto address18 = base+0x1c2b30;
	static inline auto address19 = base+0x1d0e00;
	static inline auto address20 = base+0x1cca40;
	static inline auto address21 = base+0x1c2ec0;
	static inline auto address22 = base+0x1c6460;
	static inline auto address23 = base+0x1d0b40;
	static inline auto address24 = base+0x1d0270;

	dupable getFunctionOf(GameManager, accountStatusChanged, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(GameManager, colorForIdx, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(GameManager, didExitPlayscene, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(GameManager, doQuickSave, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(GameManager, fadeInMusic, , 1, char const*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(GameManager, getBGTexture, , 1, int) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(GameManager, getFontFile, , 1, int) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(GameManager, getGameVariable, , 1, char const*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GameManager, getIntGameVariable, , 1, char const*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(GameManager, getUGV, , 1, char const*) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(GameManager, loadDeathEffect, , 1, int) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(GameManager, loadFont, , 1, int) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(GameManager, reloadAll, , 3, bool, bool, bool) {
		return reinterpret_cast<fun12>(address12)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GameManager, reloadAllStep5, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(GameManager, reportPercentageForLevel, , 3, int, int, bool) {
		return reinterpret_cast<fun14>(address14)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GameManager, setGameVariable, , 2, char const*, bool) {
		return reinterpret_cast<fun15>(address15)(this, p0, p1);
	}

	dupable getFunctionOf(GameManager, setIntGameVariable, , 2, char const*, int) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1);
	}

	dupable getFunctionOf(GameManager, setUGV, , 2, char const*, bool) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1);
	}

	dupable static getFunctionOf(GameManager, sharedState, , 0) {
		return reinterpret_cast<fun18>(address18)();
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address19)(this);
	}

	dupable getFunctionOf(GameManager, getGTexture, , 1, int) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(GameManager, init, , 0) {
		return reinterpret_cast<fun21>(address21)(this);
	}

	dupable getFunctionOf(GameManager, reportAchievementWithID, , 3, char const*, int, bool) {
		return reinterpret_cast<fun22>(address22)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GameManager, resolutionForKey, , 1, int) {
		return reinterpret_cast<fun23>(address23)(this, p0);
	}

	dupable getFunctionOf(GameManager, update, , 1, float) {
		return reinterpret_cast<fun24>(address24)(this, p0);
	}

	getWrapperOf(GameManager, accountStatusChanged, , 0) {
		return reinterpret_cast<D*>(this)->D::accountStatusChanged();
	}

	getWrapperOf(GameManager, colorForIdx, , 1, int) {
		return reinterpret_cast<D*>(this)->D::colorForIdx(p0);
	}

	getWrapperOf(GameManager, didExitPlayscene, , 0) {
		return reinterpret_cast<D*>(this)->D::didExitPlayscene();
	}

	getWrapperOf(GameManager, doQuickSave, , 0) {
		return reinterpret_cast<D*>(this)->D::doQuickSave();
	}

	getWrapperOf(GameManager, fadeInMusic, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::fadeInMusic(p0);
	}

	getWrapperOf(GameManager, getBGTexture, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getBGTexture(p0);
	}

	getWrapperOf(GameManager, getFontFile, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getFontFile(p0);
	}

	getWrapperOf(GameManager, getGameVariable, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getGameVariable(p0);
	}

	getWrapperOf(GameManager, getIntGameVariable, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getIntGameVariable(p0);
	}

	getWrapperOf(GameManager, getUGV, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getUGV(p0);
	}

	getWrapperOf(GameManager, loadDeathEffect, , 1, int) {
		return reinterpret_cast<D*>(this)->D::loadDeathEffect(p0);
	}

	getWrapperOf(GameManager, loadFont, , 1, int) {
		return reinterpret_cast<D*>(this)->D::loadFont(p0);
	}

	getWrapperOf(GameManager, reloadAll, , 3, bool, bool, bool) {
		return reinterpret_cast<D*>(this)->D::reloadAll(p0, p1, p2);
	}

	getWrapperOf(GameManager, reloadAllStep5, , 0) {
		return reinterpret_cast<D*>(this)->D::reloadAllStep5();
	}

	getWrapperOf(GameManager, reportPercentageForLevel, , 3, int, int, bool) {
		return reinterpret_cast<D*>(this)->D::reportPercentageForLevel(p0, p1, p2);
	}

	getWrapperOf(GameManager, setGameVariable, , 2, char const*, bool) {
		return reinterpret_cast<D*>(this)->D::setGameVariable(p0, p1);
	}

	getWrapperOf(GameManager, setIntGameVariable, , 2, char const*, int) {
		return reinterpret_cast<D*>(this)->D::setIntGameVariable(p0, p1);
	}

	getWrapperOf(GameManager, setUGV, , 2, char const*, bool) {
		return reinterpret_cast<D*>(this)->D::setUGV(p0, p1);
	}

	static getWrapperOf(GameManager, sharedState, , 0) {
		return D::sharedState();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GameManager, getGTexture, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getGTexture(p0);
	}

	getWrapperOf(GameManager, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(GameManager, reportAchievementWithID, , 3, char const*, int, bool) {
		return reinterpret_cast<D*>(this)->D::reportAchievementWithID(p0, p1, p2);
	}

	getWrapperOf(GameManager, resolutionForKey, , 1, int) {
		return reinterpret_cast<D*>(this)->D::resolutionForKey(p0);
	}

	getWrapperOf(GameManager, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$GameManager::accountStatusChanged) != (der0)(&D::accountStatusChanged)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::accountStatusChangedWrapper)));
		}

		if constexpr((mem1)(&$GameManager::colorForIdx) != (der1)(&D::colorForIdx)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::colorForIdxWrapper)));
		}

		if constexpr((mem2)(&$GameManager::didExitPlayscene) != (der2)(&D::didExitPlayscene)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::didExitPlaysceneWrapper)));
		}

		if constexpr((mem3)(&$GameManager::doQuickSave) != (der3)(&D::doQuickSave)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::doQuickSaveWrapper)));
		}

		if constexpr((mem4)(&$GameManager::fadeInMusic) != (der4)(&D::fadeInMusic)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::fadeInMusicWrapper)));
		}

		if constexpr((mem5)(&$GameManager::getBGTexture) != (der5)(&D::getBGTexture)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::getBGTextureWrapper)));
		}

		if constexpr((mem6)(&$GameManager::getFontFile) != (der6)(&D::getFontFile)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::getFontFileWrapper)));
		}

		if constexpr((mem7)(&$GameManager::getGameVariable) != (der7)(&D::getGameVariable)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::getGameVariableWrapper)));
		}

		if constexpr((mem8)(&$GameManager::getIntGameVariable) != (der8)(&D::getIntGameVariable)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::getIntGameVariableWrapper)));
		}

		if constexpr((mem9)(&$GameManager::getUGV) != (der9)(&D::getUGV)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::getUGVWrapper)));
		}

		if constexpr((mem10)(&$GameManager::loadDeathEffect) != (der10)(&D::loadDeathEffect)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::loadDeathEffectWrapper)));
		}

		if constexpr((mem11)(&$GameManager::loadFont) != (der11)(&D::loadFont)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::loadFontWrapper)));
		}

		if constexpr((mem12)(&$GameManager::reloadAll) != (der12)(&D::reloadAll)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::reloadAllWrapper)));
		}

		if constexpr((mem13)(&$GameManager::reloadAllStep5) != (der13)(&D::reloadAllStep5)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::reloadAllStep5Wrapper)));
		}

		if constexpr((mem14)(&$GameManager::reportPercentageForLevel) != (der14)(&D::reportPercentageForLevel)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::reportPercentageForLevelWrapper)));
		}

		if constexpr((mem15)(&$GameManager::setGameVariable) != (der15)(&D::setGameVariable)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::setGameVariableWrapper)));
		}

		if constexpr((mem16)(&$GameManager::setIntGameVariable) != (der16)(&D::setIntGameVariable)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::setIntGameVariableWrapper)));
		}

		if constexpr((mem17)(&$GameManager::setUGV) != (der17)(&D::setUGV)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::setUGVWrapper)));
		}

		if constexpr((mem18)(&$GameManager::sharedState) != (der18)(&D::sharedState)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::sharedStateWrapper)));
		}

		if constexpr(&$GameManager::destructor != &D::destructor) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem20)(&$GameManager::getGTexture) != (der20)(&D::getGTexture)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::getGTextureWrapper)));
		}

		if constexpr((mem21)(&$GameManager::init) != (der21)(&D::init)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::initWrapper)));
		}

		if constexpr((mem22)(&$GameManager::reportAchievementWithID) != (der22)(&D::reportAchievementWithID)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::reportAchievementWithIDWrapper)));
		}

		if constexpr((mem23)(&$GameManager::resolutionForKey) != (der23)(&D::resolutionForKey)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::resolutionForKeyWrapper)));
		}

		if constexpr((mem24)(&$GameManager::update) != (der24)(&D::update)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::updateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GameObject : GameObject, InterfaceBase {
	$GameObject(const $GameObject& c) : GameObject(c) {}
	$GameObject() = delete;
	setInterfaceTypesOf(1, GameObject, update, , 1, float);
	setInterfaceTypesOf(2, GameObject, setScaleX, , 1, float);
	setInterfaceTypesOf(3, GameObject, setScaleY, , 1, float);
	setInterfaceTypesOf(4, GameObject, setScale, , 1, float);
	setInterfaceTypesOf(5, GameObject, setPosition, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(6, GameObject, setVisible, , 1, bool);
	setInterfaceTypesOf(7, GameObject, setRotation, , 1, float);
	setInterfaceTypesOf(8, GameObject, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(9, GameObject, initWithTexture, , 1, cocos2d::CCTexture2D*);
	setInterfaceTypesOf(10, GameObject, setChildColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(11, GameObject, setFlipX, , 1, bool);
	setInterfaceTypesOf(12, GameObject, setFlipY, , 1, bool);
	setInterfaceTypesOf(13, GameObject, customSetup, , 0);
	setInterfaceTypesOf(14, GameObject, setupCustomSprites, , 0);
	setInterfaceTypesOf(15, GameObject, addMainSpriteToParent, , 1, bool);
	setInterfaceTypesOf(16, GameObject, resetObject, , 0);
	setInterfaceTypesOf(17, GameObject, triggerObject, , 1, GJBaseGameLayer*);
	setInterfaceTypesOf(18, GameObject, activateObject, , 0);
	setInterfaceTypesOf(19, GameObject, deactivateObject, , 1, bool);
	setInterfaceTypesOf(20, GameObject, getObjectRect, , 0);
	setInterfaceTypesOf(21, GameObject, getObjectRect, , 2, float, float);
	setInterfaceTypesOf(22, GameObject, getObjectRect2, , 2, float, float);
	setInterfaceTypesOf(23, GameObject, getObjectTextureRect, , 0);
	setInterfaceTypesOf(24, GameObject, getRealPosition, , 0);
	setInterfaceTypesOf(25, GameObject, setStartPos, , 1, cocos2d::CCPoint);
	setInterfaceTypesOf(26, GameObject, updateStartValues, , 0);
	setInterfaceTypesOf(27, GameObject, customObjectSetup, , 0);
	setInterfaceTypesOf(28, GameObject, getSaveString, , 0);
	setInterfaceTypesOf(29, GameObject, isFlipX, , 0);
	setInterfaceTypesOf(30, GameObject, isFlipY, , 0);
	setInterfaceTypesOf(31, GameObject, setRScaleX, , 1, float);
	setInterfaceTypesOf(32, GameObject, setRScaleY, , 1, float);
	setInterfaceTypesOf(33, GameObject, setRScale, , 1, float);
	setInterfaceTypesOf(34, GameObject, getRScaleX, , 0);
	setInterfaceTypesOf(35, GameObject, getRScaleY, , 0);
	setInterfaceTypesOf(36, GameObject, calculateSpawnXPos, , 0);
	setInterfaceTypesOf(37, GameObject, triggerActivated, , 1, float);
	setInterfaceTypesOf(38, GameObject, powerOnObject, , 0);
	setInterfaceTypesOf(39, GameObject, powerOffObject, , 0);
	setInterfaceTypesOf(40, GameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(41, GameObject, setGlowColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(42, GameObject, getOrientedBox, , 0);
	setInterfaceTypesOf(43, GameObject, addToGroup, , 1, int);
	setInterfaceTypesOf(44, GameObject, removeFromGroup, , 1, int);
	setInterfaceTypesOf(45, GameObject, spawnXPosition, , 0);
	setInterfaceTypesOf(46, GameObject, getObjectRectDirty, const, 0);
	setInterfaceTypesOf(47, GameObject, setObjectRectDirty, , 1, bool);
	setInterfaceTypesOf(48, GameObject, getOrientedRectDirty, const, 0);
	setInterfaceTypesOf(49, GameObject, setOrientedRectDirty, , 1, bool);
	setInterfaceTypesOf(50, GameObject, getType, const, 0);
	setInterfaceTypesOf(51, GameObject, setType, , 1, GameObjectType);
	setInterfaceTypesOf(52, GameObject, getStartPos, const, 0);
	setInterfaceTypesOf(53, GameObject, activatedByPlayer, , 1, GameObject*);
	setInterfaceTypesOf(54, GameObject, addColorSprite, , 0);
	setInterfaceTypesOf(55, GameObject, addColorSpriteToParent, , 1, bool);
	setInterfaceTypesOf(56, GameObject, addToTempOffset, , 2, float, float);
	setInterfaceTypesOf(57, GameObject, calculateOrientedBox, , 0);
	setInterfaceTypesOf(58, GameObject, canChangeCustomColor, , 0);
	setInterfaceTypesOf(59, GameObject, colorForMode, , 2, int, bool);
	setInterfaceTypesOf(60, GameObject, commonSetup, , 0);
	setInterfaceTypesOf(61, GameObject, copyGroups, , 1, GameObject*);
	setInterfaceStaticTypesOf(62, GameObject, createWithFrame, , 1, char const*);
	setInterfaceStaticTypesOf(63, GameObject, createWithKey, , 1, int);
	setInterfaceTypesOf(64, GameObject, destroyObject, , 0);
	setInterfaceTypesOf(65, GameObject, determineSlopeDirection, , 0);
	setInterfaceTypesOf(66, GameObject, getActiveColorForMode, , 2, int, bool);
	setInterfaceTypesOf(67, GameObject, getBallFrame, , 1, int);
	setInterfaceTypesOf(68, GameObject, getBoxOffset, , 0);
	setInterfaceTypesOf(69, GameObject, getColorIndex, , 0);
	setInterfaceTypesOf(70, GameObject, getDidUpdateLastPosition, , 0);
	setInterfaceTypesOf(71, GameObject, getGroupID, , 1, int);
	setInterfaceTypesOf(72, GameObject, getLastPosition, , 0);
	setInterfaceTypesOf(73, GameObject, getMainColorMode, , 0);
	setInterfaceTypesOf(74, GameObject, getObjectZOrder, , 0);
	setInterfaceTypesOf(75, GameObject, getObjectRadius, , 0);
	setInterfaceTypesOf(76, GameObject, getSecondaryColorMode, , 0);
	setInterfaceTypesOf(77, GameObject, getSectionIdx, , 0);
	setInterfaceTypesOf(78, GameObject, groupWasDisabled, , 0);
	setInterfaceTypesOf(79, GameObject, groupWasEnabled, , 0);
	setInterfaceTypesOf(80, GameObject, hasBeenActivated, , 0);
	setInterfaceTypesOf(81, GameObject, hasBeenActivatedByPlayer, , 1, GameObject*);
	setInterfaceTypesOf(82, GameObject, hasSecondaryColor, , 0);
	setInterfaceTypesOf(83, GameObject, ignoreEnter, , 0);
	setInterfaceTypesOf(84, GameObject, ignoreFade, , 0);
	setInterfaceTypesOf(85, GameObject, isBasicTrigger, , 0);
	setInterfaceTypesOf(86, GameObject, isColorTrigger, , 0);
	setInterfaceTypesOf(87, GameObject, isSpawnableTrigger, , 0);
	setInterfaceTypesOf(88, GameObject, isSpecialObject, , 0);
	setInterfaceStaticTypesOf(89, GameObject, objectFromString, , 2, gd::string, bool);
	setInterfaceTypesOf(90, GameObject, playShineEffect, , 0);
	setInterfaceTypesOf(91, GameObject, quickUpdatePosition, , 0);
	setInterfaceTypesOf(92, GameObject, removeGlow, , 0);
	setInterfaceTypesOf(93, GameObject, resetGroupDisabled, , 0);
	setInterfaceTypesOf(94, GameObject, saveActiveColors, , 0);
	setInterfaceTypesOf(95, GameObject, selectObject, , 1, cocos2d::_ccColor3B);
	setInterfaceTypesOf(96, GameObject, setDefaultMainColorMode, , 1, int);
	setInterfaceTypesOf(97, GameObject, setDidUpdateLastPosition, , 1, bool const&);
	setInterfaceTypesOf(98, GameObject, setGlowOpacity, , 1, unsigned char);
	setInterfaceTypesOf(99, GameObject, setLastPosition, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(100, GameObject, setMainColorMode, , 1, int);
	setInterfaceTypesOf(101, GameObject, setSectionIdx, , 1, int const&);
	setInterfaceTypesOf(102, GameObject, setupCoinArt, , 0);
	setInterfaceTypesOf(103, GameObject, slopeFloorTop, , 0);
	setInterfaceTypesOf(104, GameObject, slopeWallLeft, , 0);
	setInterfaceTypesOf(105, GameObject, updateCustomScale, , 1, float);
	setInterfaceTypesOf(106, GameObject, updateMainColor, , 0);
	setInterfaceTypesOf(107, GameObject, updateOrientedBox, , 0);
	setInterfaceTypesOf(108, GameObject, updateSecondaryColor, , 0);
	setInterfaceTypesOf(109, GameObject, updateStartPos, , 0);
	setInterfaceTypesOf(110, GameObject, updateState, , 0);
	setInterfaceTypesOf(111, GameObject, updateSyncedAnimation, , 1, float);
	static inline auto address0 = base+0x2f4ca0;
	static inline auto address1 = base+0x2fbb90;
	static inline auto address2 = base+0x335b00;
	static inline auto address3 = base+0x335b90;
	static inline auto address4 = base+0x335c20;
	static inline auto address5 = base+0x335850;
	static inline auto address6 = base+0x336280;
	static inline auto address7 = base+0x335970;
	static inline auto address8 = base+0x335f10;
	static inline auto address9 = base+0x2f56a0;
	static inline auto address10 = base+0x341f20;
	static inline auto address11 = base+0x335a60;
	static inline auto address12 = base+0x335ab0;
	static inline auto address13 = base+0x2fbba0;
	static inline auto address14 = base+0x307f60;
	static inline auto address15 = base+0x33a5b0;
	static inline auto address16 = base+0x2fa620;
	static inline auto address17 = base+0x2fa8f0;
	static inline auto address18 = base+0x2faf60;
	static inline auto address19 = base+0x2fb8f0;
	static inline auto address20 = base+0x3352b0;
	static inline auto address21 = base+0x3352d0;
	static inline auto address22 = base+0x3354e0;
	static inline auto address23 = base+0x3355b0;
	static inline auto address24 = base+0x335750;
	static inline auto address25 = base+0x2fa520;
	static inline auto address26 = base+0x2fa800;
	static inline auto address27 = base+0xdc1a0;
	static inline auto address28 = base+0x33d3d0;
	static inline auto address29 = base+0x335a40;
	static inline auto address30 = base+0x335a50;
	static inline auto address31 = base+0x335cb0;
	static inline auto address32 = base+0x335d60;
	static inline auto address33 = base+0x335e10;
	static inline auto address34 = base+0x335e50;
	static inline auto address35 = base+0x335e80;
	static inline auto address36 = base+0x336970;
	static inline auto address37 = base+0x336990;
	static inline auto address38 = base+0x3369a0;
	static inline auto address39 = base+0x3369c0;
	static inline auto address40 = base+0x341c90;
	static inline auto address41 = base+0x341ed0;
	static inline auto address42 = base+0x342ad0;
	static inline auto address43 = base+0x33ad00;
	static inline auto address44 = base+0x33ada0;
	static inline auto address45 = base+0xdc1b0;
	static inline auto address46 = base+0xdc1d0;
	static inline auto address47 = base+0xdc1e0;
	static inline auto address48 = base+0xdc1f0;
	static inline auto address49 = base+0xdc200;
	static inline auto address50 = base+0xdc210;
	static inline auto address51 = base+0xdc220;
	static inline auto address52 = base+0xdc230;
	static inline auto address53 = base+0x342a20;
	static inline auto address54 = base+0x2f7fe0;
	static inline auto address55 = base+0x2fb470;
	static inline auto address56 = base+0x335700;
	static inline auto address57 = base+0x342b20;
	static inline auto address58 = base+0x342db0;
	static inline auto address59 = base+0x343460;
	static inline auto address60 = base+0x2f5570;
	static inline auto address61 = base+0x33ae30;
	static inline auto address62 = base+0x2f5490;
	static inline auto address63 = base+0x2f4ce0;
	static inline auto address64 = base+0x336a00;
	static inline auto address65 = base+0x33a9e0;
	static inline auto address66 = base+0x343860;
	static inline auto address67 = base+0x341bf0;
	static inline auto address68 = base+0x3353d0;
	static inline auto address69 = base+0x343b90;
	static inline auto address70 = base+0x343a20;
	static inline auto address71 = base+0x33ae10;
	static inline auto address72 = base+0x3439d0;
	static inline auto address73 = base+0x334c30;
	static inline auto address74 = base+0x337d70;
	static inline auto address75 = base+0x343c10;
	static inline auto address76 = base+0x341c20;
	static inline auto address77 = base+0x343a00;
	static inline auto address78 = base+0x33b110;
	static inline auto address79 = base+0x33b0f0;
	static inline auto address80 = base+0x342a80;
	static inline auto address81 = base+0x342a50;
	static inline auto address82 = base+0x342f80;
	static inline auto address83 = base+0x3352a0;
	static inline auto address84 = base+0x335290;
	static inline auto address85 = base+0x343d10;
	static inline auto address86 = base+0x343b40;
	static inline auto address87 = base+0x343a60;
	static inline auto address88 = base+0x343c40;
	static inline auto address89 = base+0x33b720;
	static inline auto address90 = base+0x2fa9d0;
	static inline auto address91 = base+0x335790;
	static inline auto address92 = base+0x2f7f70;
	static inline auto address93 = base+0x2fa7e0;
	static inline auto address94 = base+0x33d250;
	static inline auto address95 = base+0x341f90;
	static inline auto address96 = base+0x304fc0;
	static inline auto address97 = base+0x343a30;
	static inline auto address98 = base+0x336200;
	static inline auto address99 = base+0x3439e0;
	static inline auto address100 = base+0x342e70;
	static inline auto address101 = base+0x343a10;
	static inline auto address102 = base+0x337dd0;
	static inline auto address103 = base+0x342800;
	static inline auto address104 = base+0x3427e0;
	static inline auto address105 = base+0x335eb0;
	static inline auto address106 = base+0x343340;
	static inline auto address107 = base+0x342b50;
	static inline auto address108 = base+0x343740;
	static inline auto address109 = base+0x2fa590;
	static inline auto address110 = base+0x3369e0;
	static inline auto address111 = base+0x337f00;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(GameObject, update, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(GameObject, setScaleX, , 1, float) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(GameObject, setScaleY, , 1, float) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(GameObject, setScale, , 1, float) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(GameObject, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(GameObject, setVisible, , 1, bool) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(GameObject, setRotation, , 1, float) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GameObject, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(GameObject, initWithTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(GameObject, setChildColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(GameObject, setFlipX, , 1, bool) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(GameObject, setFlipY, , 1, bool) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(GameObject, customSetup, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(GameObject, setupCustomSprites, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(GameObject, addMainSpriteToParent, , 1, bool) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(GameObject, resetObject, , 0) {
		return reinterpret_cast<fun16>(address16)(this);
	}

	dupable getFunctionOf(GameObject, triggerObject, , 1, GJBaseGameLayer*) {
		return reinterpret_cast<fun17>(address17)(this, p0);
	}

	dupable getFunctionOf(GameObject, activateObject, , 0) {
		return reinterpret_cast<fun18>(address18)(this);
	}

	dupable getFunctionOf(GameObject, deactivateObject, , 1, bool) {
		return reinterpret_cast<fun19>(address19)(this, p0);
	}

	dupable getFunctionOf(GameObject, getObjectRect, , 0) {
		return reinterpret_cast<fun20>(address20)(this);
	}

	dupable getFunctionOf(GameObject, getObjectRect, , 2, float, float) {
		return reinterpret_cast<fun21>(address21)(this, p0, p1);
	}

	dupable getFunctionOf(GameObject, getObjectRect2, , 2, float, float) {
		return reinterpret_cast<fun22>(address22)(this, p0, p1);
	}

	dupable getFunctionOf(GameObject, getObjectTextureRect, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(GameObject, getRealPosition, , 0) {
		return reinterpret_cast<fun24>(address24)(this);
	}

	dupable getFunctionOf(GameObject, setStartPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun25>(address25)(this, p0);
	}

	dupable getFunctionOf(GameObject, updateStartValues, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(GameObject, customObjectSetup, , 0) {
		return reinterpret_cast<fun27>(address27)(this);
	}

	dupable getFunctionOf(GameObject, getSaveString, , 0) {
		return reinterpret_cast<fun28>(address28)(this);
	}

	dupable getFunctionOf(GameObject, isFlipX, , 0) {
		return reinterpret_cast<fun29>(address29)(this);
	}

	dupable getFunctionOf(GameObject, isFlipY, , 0) {
		return reinterpret_cast<fun30>(address30)(this);
	}

	dupable getFunctionOf(GameObject, setRScaleX, , 1, float) {
		return reinterpret_cast<fun31>(address31)(this, p0);
	}

	dupable getFunctionOf(GameObject, setRScaleY, , 1, float) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(GameObject, setRScale, , 1, float) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(GameObject, getRScaleX, , 0) {
		return reinterpret_cast<fun34>(address34)(this);
	}

	dupable getFunctionOf(GameObject, getRScaleY, , 0) {
		return reinterpret_cast<fun35>(address35)(this);
	}

	dupable getFunctionOf(GameObject, calculateSpawnXPos, , 0) {
		return reinterpret_cast<fun36>(address36)(this);
	}

	dupable getFunctionOf(GameObject, triggerActivated, , 1, float) {
		return reinterpret_cast<fun37>(address37)(this, p0);
	}

	dupable getFunctionOf(GameObject, powerOnObject, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(GameObject, powerOffObject, , 0) {
		return reinterpret_cast<fun39>(address39)(this);
	}

	dupable getFunctionOf(GameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun40>(address40)(this, p0);
	}

	dupable getFunctionOf(GameObject, setGlowColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun41>(address41)(this, p0);
	}

	dupable getFunctionOf(GameObject, getOrientedBox, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(GameObject, addToGroup, , 1, int) {
		return reinterpret_cast<fun43>(address43)(this, p0);
	}

	dupable getFunctionOf(GameObject, removeFromGroup, , 1, int) {
		return reinterpret_cast<fun44>(address44)(this, p0);
	}

	dupable getFunctionOf(GameObject, spawnXPosition, , 0) {
		return reinterpret_cast<fun45>(address45)(this);
	}

	dupable getFunctionOf(GameObject, getObjectRectDirty, const, 0) {
		return reinterpret_cast<fun46>(address46)(this);
	}

	dupable getFunctionOf(GameObject, setObjectRectDirty, , 1, bool) {
		return reinterpret_cast<fun47>(address47)(this, p0);
	}

	dupable getFunctionOf(GameObject, getOrientedRectDirty, const, 0) {
		return reinterpret_cast<fun48>(address48)(this);
	}

	dupable getFunctionOf(GameObject, setOrientedRectDirty, , 1, bool) {
		return reinterpret_cast<fun49>(address49)(this, p0);
	}

	dupable getFunctionOf(GameObject, getType, const, 0) {
		return reinterpret_cast<fun50>(address50)(this);
	}

	dupable getFunctionOf(GameObject, setType, , 1, GameObjectType) {
		return reinterpret_cast<fun51>(address51)(this, p0);
	}

	dupable getFunctionOf(GameObject, getStartPos, const, 0) {
		return reinterpret_cast<fun52>(address52)(this);
	}

	dupable getFunctionOf(GameObject, activatedByPlayer, , 1, GameObject*) {
		return reinterpret_cast<fun53>(address53)(this, p0);
	}

	dupable getFunctionOf(GameObject, addColorSprite, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(GameObject, addColorSpriteToParent, , 1, bool) {
		return reinterpret_cast<fun55>(address55)(this, p0);
	}

	dupable getFunctionOf(GameObject, addToTempOffset, , 2, float, float) {
		return reinterpret_cast<fun56>(address56)(this, p0, p1);
	}

	dupable getFunctionOf(GameObject, calculateOrientedBox, , 0) {
		return reinterpret_cast<fun57>(address57)(this);
	}

	dupable getFunctionOf(GameObject, canChangeCustomColor, , 0) {
		return reinterpret_cast<fun58>(address58)(this);
	}

	dupable getFunctionOf(GameObject, colorForMode, , 2, int, bool) {
		return reinterpret_cast<fun59>(address59)(this, p0, p1);
	}

	dupable getFunctionOf(GameObject, commonSetup, , 0) {
		return reinterpret_cast<fun60>(address60)(this);
	}

	dupable getFunctionOf(GameObject, copyGroups, , 1, GameObject*) {
		return reinterpret_cast<fun61>(address61)(this, p0);
	}

	dupable static getFunctionOf(GameObject, createWithFrame, , 1, char const*) {
		return reinterpret_cast<fun62>(address62)(p0);
	}

	dupable static getFunctionOf(GameObject, createWithKey, , 1, int) {
		return reinterpret_cast<fun63>(address63)(p0);
	}

	dupable getFunctionOf(GameObject, destroyObject, , 0) {
		return reinterpret_cast<fun64>(address64)(this);
	}

	dupable getFunctionOf(GameObject, determineSlopeDirection, , 0) {
		return reinterpret_cast<fun65>(address65)(this);
	}

	dupable getFunctionOf(GameObject, getActiveColorForMode, , 2, int, bool) {
		return reinterpret_cast<fun66>(address66)(this, p0, p1);
	}

	dupable getFunctionOf(GameObject, getBallFrame, , 1, int) {
		return reinterpret_cast<fun67>(address67)(this, p0);
	}

	dupable getFunctionOf(GameObject, getBoxOffset, , 0) {
		return reinterpret_cast<fun68>(address68)(this);
	}

	dupable getFunctionOf(GameObject, getColorIndex, , 0) {
		return reinterpret_cast<fun69>(address69)(this);
	}

	dupable getFunctionOf(GameObject, getDidUpdateLastPosition, , 0) {
		return reinterpret_cast<fun70>(address70)(this);
	}

	dupable getFunctionOf(GameObject, getGroupID, , 1, int) {
		return reinterpret_cast<fun71>(address71)(this, p0);
	}

	dupable getFunctionOf(GameObject, getLastPosition, , 0) {
		return reinterpret_cast<fun72>(address72)(this);
	}

	dupable getFunctionOf(GameObject, getMainColorMode, , 0) {
		return reinterpret_cast<fun73>(address73)(this);
	}

	dupable getFunctionOf(GameObject, getObjectZOrder, , 0) {
		return reinterpret_cast<fun74>(address74)(this);
	}

	dupable getFunctionOf(GameObject, getObjectRadius, , 0) {
		return reinterpret_cast<fun75>(address75)(this);
	}

	dupable getFunctionOf(GameObject, getSecondaryColorMode, , 0) {
		return reinterpret_cast<fun76>(address76)(this);
	}

	dupable getFunctionOf(GameObject, getSectionIdx, , 0) {
		return reinterpret_cast<fun77>(address77)(this);
	}

	dupable getFunctionOf(GameObject, groupWasDisabled, , 0) {
		return reinterpret_cast<fun78>(address78)(this);
	}

	dupable getFunctionOf(GameObject, groupWasEnabled, , 0) {
		return reinterpret_cast<fun79>(address79)(this);
	}

	dupable getFunctionOf(GameObject, hasBeenActivated, , 0) {
		return reinterpret_cast<fun80>(address80)(this);
	}

	dupable getFunctionOf(GameObject, hasBeenActivatedByPlayer, , 1, GameObject*) {
		return reinterpret_cast<fun81>(address81)(this, p0);
	}

	dupable getFunctionOf(GameObject, hasSecondaryColor, , 0) {
		return reinterpret_cast<fun82>(address82)(this);
	}

	dupable getFunctionOf(GameObject, ignoreEnter, , 0) {
		return reinterpret_cast<fun83>(address83)(this);
	}

	dupable getFunctionOf(GameObject, ignoreFade, , 0) {
		return reinterpret_cast<fun84>(address84)(this);
	}

	dupable getFunctionOf(GameObject, isBasicTrigger, , 0) {
		return reinterpret_cast<fun85>(address85)(this);
	}

	dupable getFunctionOf(GameObject, isColorTrigger, , 0) {
		return reinterpret_cast<fun86>(address86)(this);
	}

	dupable getFunctionOf(GameObject, isSpawnableTrigger, , 0) {
		return reinterpret_cast<fun87>(address87)(this);
	}

	dupable getFunctionOf(GameObject, isSpecialObject, , 0) {
		return reinterpret_cast<fun88>(address88)(this);
	}

	dupable static getFunctionOf(GameObject, objectFromString, , 2, gd::string, bool) {
		return reinterpret_cast<fun89>(address89)(p0, p1);
	}

	dupable getFunctionOf(GameObject, playShineEffect, , 0) {
		return reinterpret_cast<fun90>(address90)(this);
	}

	dupable getFunctionOf(GameObject, quickUpdatePosition, , 0) {
		return reinterpret_cast<fun91>(address91)(this);
	}

	dupable getFunctionOf(GameObject, removeGlow, , 0) {
		return reinterpret_cast<fun92>(address92)(this);
	}

	dupable getFunctionOf(GameObject, resetGroupDisabled, , 0) {
		return reinterpret_cast<fun93>(address93)(this);
	}

	dupable getFunctionOf(GameObject, saveActiveColors, , 0) {
		return reinterpret_cast<fun94>(address94)(this);
	}

	dupable getFunctionOf(GameObject, selectObject, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun95>(address95)(this, p0);
	}

	dupable getFunctionOf(GameObject, setDefaultMainColorMode, , 1, int) {
		return reinterpret_cast<fun96>(address96)(this, p0);
	}

	dupable getFunctionOf(GameObject, setDidUpdateLastPosition, , 1, bool const&) {
		return reinterpret_cast<fun97>(address97)(this, p0);
	}

	dupable getFunctionOf(GameObject, setGlowOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun98>(address98)(this, p0);
	}

	dupable getFunctionOf(GameObject, setLastPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun99>(address99)(this, p0);
	}

	dupable getFunctionOf(GameObject, setMainColorMode, , 1, int) {
		return reinterpret_cast<fun100>(address100)(this, p0);
	}

	dupable getFunctionOf(GameObject, setSectionIdx, , 1, int const&) {
		return reinterpret_cast<fun101>(address101)(this, p0);
	}

	dupable getFunctionOf(GameObject, setupCoinArt, , 0) {
		return reinterpret_cast<fun102>(address102)(this);
	}

	dupable getFunctionOf(GameObject, slopeFloorTop, , 0) {
		return reinterpret_cast<fun103>(address103)(this);
	}

	dupable getFunctionOf(GameObject, slopeWallLeft, , 0) {
		return reinterpret_cast<fun104>(address104)(this);
	}

	dupable getFunctionOf(GameObject, updateCustomScale, , 1, float) {
		return reinterpret_cast<fun105>(address105)(this, p0);
	}

	dupable getFunctionOf(GameObject, updateMainColor, , 0) {
		return reinterpret_cast<fun106>(address106)(this);
	}

	dupable getFunctionOf(GameObject, updateOrientedBox, , 0) {
		return reinterpret_cast<fun107>(address107)(this);
	}

	dupable getFunctionOf(GameObject, updateSecondaryColor, , 0) {
		return reinterpret_cast<fun108>(address108)(this);
	}

	dupable getFunctionOf(GameObject, updateStartPos, , 0) {
		return reinterpret_cast<fun109>(address109)(this);
	}

	dupable getFunctionOf(GameObject, updateState, , 0) {
		return reinterpret_cast<fun110>(address110)(this);
	}

	dupable getFunctionOf(GameObject, updateSyncedAnimation, , 1, float) {
		return reinterpret_cast<fun111>(address111)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(GameObject, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

	getWrapperOf(GameObject, setScaleX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleX(p0);
	}

	getWrapperOf(GameObject, setScaleY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleY(p0);
	}

	getWrapperOf(GameObject, setScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0);
	}

	getWrapperOf(GameObject, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setPosition(p0);
	}

	getWrapperOf(GameObject, setVisible, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setVisible(p0);
	}

	getWrapperOf(GameObject, setRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotation(p0);
	}

	getWrapperOf(GameObject, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(GameObject, initWithTexture, , 1, cocos2d::CCTexture2D*) {
		return reinterpret_cast<D*>(this)->D::initWithTexture(p0);
	}

	getWrapperOf(GameObject, setChildColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setChildColor(p0);
	}

	getWrapperOf(GameObject, setFlipX, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setFlipX(p0);
	}

	getWrapperOf(GameObject, setFlipY, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setFlipY(p0);
	}

	getWrapperOf(GameObject, customSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::customSetup();
	}

	getWrapperOf(GameObject, setupCustomSprites, , 0) {
		return reinterpret_cast<D*>(this)->D::setupCustomSprites();
	}

	getWrapperOf(GameObject, addMainSpriteToParent, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::addMainSpriteToParent(p0);
	}

	getWrapperOf(GameObject, resetObject, , 0) {
		return reinterpret_cast<D*>(this)->D::resetObject();
	}

	getWrapperOf(GameObject, triggerObject, , 1, GJBaseGameLayer*) {
		return reinterpret_cast<D*>(this)->D::triggerObject(p0);
	}

	getWrapperOf(GameObject, activateObject, , 0) {
		return reinterpret_cast<D*>(this)->D::activateObject();
	}

	getWrapperOf(GameObject, deactivateObject, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::deactivateObject(p0);
	}

	getWrapperOf(GameObject, getObjectRect, , 0) {
		return reinterpret_cast<D*>(this)->D::getObjectRect();
	}

	getWrapperOf(GameObject, getObjectRect, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::getObjectRect(p0, p1);
	}

	getWrapperOf(GameObject, getObjectRect2, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::getObjectRect2(p0, p1);
	}

	getWrapperOf(GameObject, getObjectTextureRect, , 0) {
		return reinterpret_cast<D*>(this)->D::getObjectTextureRect();
	}

	getWrapperOf(GameObject, getRealPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::getRealPosition();
	}

	getWrapperOf(GameObject, setStartPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::setStartPos(p0);
	}

	getWrapperOf(GameObject, updateStartValues, , 0) {
		return reinterpret_cast<D*>(this)->D::updateStartValues();
	}

	getWrapperOf(GameObject, customObjectSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::customObjectSetup();
	}

	getWrapperOf(GameObject, getSaveString, , 0) {
		return reinterpret_cast<D*>(this)->D::getSaveString();
	}

	getWrapperOf(GameObject, isFlipX, , 0) {
		return reinterpret_cast<D*>(this)->D::isFlipX();
	}

	getWrapperOf(GameObject, isFlipY, , 0) {
		return reinterpret_cast<D*>(this)->D::isFlipY();
	}

	getWrapperOf(GameObject, setRScaleX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRScaleX(p0);
	}

	getWrapperOf(GameObject, setRScaleY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRScaleY(p0);
	}

	getWrapperOf(GameObject, setRScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRScale(p0);
	}

	getWrapperOf(GameObject, getRScaleX, , 0) {
		return reinterpret_cast<D*>(this)->D::getRScaleX();
	}

	getWrapperOf(GameObject, getRScaleY, , 0) {
		return reinterpret_cast<D*>(this)->D::getRScaleY();
	}

	getWrapperOf(GameObject, calculateSpawnXPos, , 0) {
		return reinterpret_cast<D*>(this)->D::calculateSpawnXPos();
	}

	getWrapperOf(GameObject, triggerActivated, , 1, float) {
		return reinterpret_cast<D*>(this)->D::triggerActivated(p0);
	}

	getWrapperOf(GameObject, powerOnObject, , 0) {
		return reinterpret_cast<D*>(this)->D::powerOnObject();
	}

	getWrapperOf(GameObject, powerOffObject, , 0) {
		return reinterpret_cast<D*>(this)->D::powerOffObject();
	}

	getWrapperOf(GameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setObjectColor(p0);
	}

	getWrapperOf(GameObject, setGlowColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setGlowColor(p0);
	}

	getWrapperOf(GameObject, getOrientedBox, , 0) {
		return reinterpret_cast<D*>(this)->D::getOrientedBox();
	}

	getWrapperOf(GameObject, addToGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::addToGroup(p0);
	}

	getWrapperOf(GameObject, removeFromGroup, , 1, int) {
		return reinterpret_cast<D*>(this)->D::removeFromGroup(p0);
	}

	getWrapperOf(GameObject, spawnXPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnXPosition();
	}

	getWrapperOf(GameObject, getObjectRectDirty, const, 0) {
		return reinterpret_cast<D*>(this)->D::getObjectRectDirty();
	}

	getWrapperOf(GameObject, setObjectRectDirty, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setObjectRectDirty(p0);
	}

	getWrapperOf(GameObject, getOrientedRectDirty, const, 0) {
		return reinterpret_cast<D*>(this)->D::getOrientedRectDirty();
	}

	getWrapperOf(GameObject, setOrientedRectDirty, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setOrientedRectDirty(p0);
	}

	getWrapperOf(GameObject, getType, const, 0) {
		return reinterpret_cast<D*>(this)->D::getType();
	}

	getWrapperOf(GameObject, setType, , 1, GameObjectType) {
		return reinterpret_cast<D*>(this)->D::setType(p0);
	}

	getWrapperOf(GameObject, getStartPos, const, 0) {
		return reinterpret_cast<D*>(this)->D::getStartPos();
	}

	getWrapperOf(GameObject, activatedByPlayer, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::activatedByPlayer(p0);
	}

	getWrapperOf(GameObject, addColorSprite, , 0) {
		return reinterpret_cast<D*>(this)->D::addColorSprite();
	}

	getWrapperOf(GameObject, addColorSpriteToParent, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::addColorSpriteToParent(p0);
	}

	getWrapperOf(GameObject, addToTempOffset, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::addToTempOffset(p0, p1);
	}

	getWrapperOf(GameObject, calculateOrientedBox, , 0) {
		return reinterpret_cast<D*>(this)->D::calculateOrientedBox();
	}

	getWrapperOf(GameObject, canChangeCustomColor, , 0) {
		return reinterpret_cast<D*>(this)->D::canChangeCustomColor();
	}

	getWrapperOf(GameObject, colorForMode, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::colorForMode(p0, p1);
	}

	getWrapperOf(GameObject, commonSetup, , 0) {
		return reinterpret_cast<D*>(this)->D::commonSetup();
	}

	getWrapperOf(GameObject, copyGroups, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::copyGroups(p0);
	}

	static getWrapperOf(GameObject, createWithFrame, , 1, char const*) {
		return D::createWithFrame(p0);
	}

	static getWrapperOf(GameObject, createWithKey, , 1, int) {
		return D::createWithKey(p0);
	}

	getWrapperOf(GameObject, destroyObject, , 0) {
		return reinterpret_cast<D*>(this)->D::destroyObject();
	}

	getWrapperOf(GameObject, determineSlopeDirection, , 0) {
		return reinterpret_cast<D*>(this)->D::determineSlopeDirection();
	}

	getWrapperOf(GameObject, getActiveColorForMode, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::getActiveColorForMode(p0, p1);
	}

	getWrapperOf(GameObject, getBallFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getBallFrame(p0);
	}

	getWrapperOf(GameObject, getBoxOffset, , 0) {
		return reinterpret_cast<D*>(this)->D::getBoxOffset();
	}

	getWrapperOf(GameObject, getColorIndex, , 0) {
		return reinterpret_cast<D*>(this)->D::getColorIndex();
	}

	getWrapperOf(GameObject, getDidUpdateLastPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::getDidUpdateLastPosition();
	}

	getWrapperOf(GameObject, getGroupID, , 1, int) {
		return reinterpret_cast<D*>(this)->D::getGroupID(p0);
	}

	getWrapperOf(GameObject, getLastPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::getLastPosition();
	}

	getWrapperOf(GameObject, getMainColorMode, , 0) {
		return reinterpret_cast<D*>(this)->D::getMainColorMode();
	}

	getWrapperOf(GameObject, getObjectZOrder, , 0) {
		return reinterpret_cast<D*>(this)->D::getObjectZOrder();
	}

	getWrapperOf(GameObject, getObjectRadius, , 0) {
		return reinterpret_cast<D*>(this)->D::getObjectRadius();
	}

	getWrapperOf(GameObject, getSecondaryColorMode, , 0) {
		return reinterpret_cast<D*>(this)->D::getSecondaryColorMode();
	}

	getWrapperOf(GameObject, getSectionIdx, , 0) {
		return reinterpret_cast<D*>(this)->D::getSectionIdx();
	}

	getWrapperOf(GameObject, groupWasDisabled, , 0) {
		return reinterpret_cast<D*>(this)->D::groupWasDisabled();
	}

	getWrapperOf(GameObject, groupWasEnabled, , 0) {
		return reinterpret_cast<D*>(this)->D::groupWasEnabled();
	}

	getWrapperOf(GameObject, hasBeenActivated, , 0) {
		return reinterpret_cast<D*>(this)->D::hasBeenActivated();
	}

	getWrapperOf(GameObject, hasBeenActivatedByPlayer, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::hasBeenActivatedByPlayer(p0);
	}

	getWrapperOf(GameObject, hasSecondaryColor, , 0) {
		return reinterpret_cast<D*>(this)->D::hasSecondaryColor();
	}

	getWrapperOf(GameObject, ignoreEnter, , 0) {
		return reinterpret_cast<D*>(this)->D::ignoreEnter();
	}

	getWrapperOf(GameObject, ignoreFade, , 0) {
		return reinterpret_cast<D*>(this)->D::ignoreFade();
	}

	getWrapperOf(GameObject, isBasicTrigger, , 0) {
		return reinterpret_cast<D*>(this)->D::isBasicTrigger();
	}

	getWrapperOf(GameObject, isColorTrigger, , 0) {
		return reinterpret_cast<D*>(this)->D::isColorTrigger();
	}

	getWrapperOf(GameObject, isSpawnableTrigger, , 0) {
		return reinterpret_cast<D*>(this)->D::isSpawnableTrigger();
	}

	getWrapperOf(GameObject, isSpecialObject, , 0) {
		return reinterpret_cast<D*>(this)->D::isSpecialObject();
	}

	static getWrapperOf(GameObject, objectFromString, , 2, gd::string, bool) {
		return D::objectFromString(p0, p1);
	}

	getWrapperOf(GameObject, playShineEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::playShineEffect();
	}

	getWrapperOf(GameObject, quickUpdatePosition, , 0) {
		return reinterpret_cast<D*>(this)->D::quickUpdatePosition();
	}

	getWrapperOf(GameObject, removeGlow, , 0) {
		return reinterpret_cast<D*>(this)->D::removeGlow();
	}

	getWrapperOf(GameObject, resetGroupDisabled, , 0) {
		return reinterpret_cast<D*>(this)->D::resetGroupDisabled();
	}

	getWrapperOf(GameObject, saveActiveColors, , 0) {
		return reinterpret_cast<D*>(this)->D::saveActiveColors();
	}

	getWrapperOf(GameObject, selectObject, , 1, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::selectObject(p0);
	}

	getWrapperOf(GameObject, setDefaultMainColorMode, , 1, int) {
		return reinterpret_cast<D*>(this)->D::setDefaultMainColorMode(p0);
	}

	getWrapperOf(GameObject, setDidUpdateLastPosition, , 1, bool const&) {
		return reinterpret_cast<D*>(this)->D::setDidUpdateLastPosition(p0);
	}

	getWrapperOf(GameObject, setGlowOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setGlowOpacity(p0);
	}

	getWrapperOf(GameObject, setLastPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setLastPosition(p0);
	}

	getWrapperOf(GameObject, setMainColorMode, , 1, int) {
		return reinterpret_cast<D*>(this)->D::setMainColorMode(p0);
	}

	getWrapperOf(GameObject, setSectionIdx, , 1, int const&) {
		return reinterpret_cast<D*>(this)->D::setSectionIdx(p0);
	}

	getWrapperOf(GameObject, setupCoinArt, , 0) {
		return reinterpret_cast<D*>(this)->D::setupCoinArt();
	}

	getWrapperOf(GameObject, slopeFloorTop, , 0) {
		return reinterpret_cast<D*>(this)->D::slopeFloorTop();
	}

	getWrapperOf(GameObject, slopeWallLeft, , 0) {
		return reinterpret_cast<D*>(this)->D::slopeWallLeft();
	}

	getWrapperOf(GameObject, updateCustomScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateCustomScale(p0);
	}

	getWrapperOf(GameObject, updateMainColor, , 0) {
		return reinterpret_cast<D*>(this)->D::updateMainColor();
	}

	getWrapperOf(GameObject, updateOrientedBox, , 0) {
		return reinterpret_cast<D*>(this)->D::updateOrientedBox();
	}

	getWrapperOf(GameObject, updateSecondaryColor, , 0) {
		return reinterpret_cast<D*>(this)->D::updateSecondaryColor();
	}

	getWrapperOf(GameObject, updateStartPos, , 0) {
		return reinterpret_cast<D*>(this)->D::updateStartPos();
	}

	getWrapperOf(GameObject, updateState, , 0) {
		return reinterpret_cast<D*>(this)->D::updateState();
	}

	getWrapperOf(GameObject, updateSyncedAnimation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateSyncedAnimation(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$GameObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$GameObject::update) != (der1)(&D::update)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::updateWrapper)));
		}

		if ((mem2)(&$GameObject::setScaleX) != (der2)(&D::setScaleX)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setScaleXWrapper)));
		}

		if ((mem3)(&$GameObject::setScaleY) != (der3)(&D::setScaleY)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setScaleYWrapper)));
		}

		if ((mem4)(&$GameObject::setScale) != (der4)(&D::setScale)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setScaleWrapper)));
		}

		if ((mem5)(&$GameObject::setPosition) != (der5)(&D::setPosition)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setPositionWrapper)));
		}

		if ((mem6)(&$GameObject::setVisible) != (der6)(&D::setVisible)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::setVisibleWrapper)));
		}

		if ((mem7)(&$GameObject::setRotation) != (der7)(&D::setRotation)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setRotationWrapper)));
		}

		if ((mem8)(&$GameObject::setOpacity) != (der8)(&D::setOpacity)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setOpacityWrapper)));
		}

		if ((mem9)(&$GameObject::initWithTexture) != (der9)(&D::initWithTexture)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::initWithTextureWrapper)));
		}

		if ((mem10)(&$GameObject::setChildColor) != (der10)(&D::setChildColor)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::setChildColorWrapper)));
		}

		if ((mem11)(&$GameObject::setFlipX) != (der11)(&D::setFlipX)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setFlipXWrapper)));
		}

		if ((mem12)(&$GameObject::setFlipY) != (der12)(&D::setFlipY)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::setFlipYWrapper)));
		}

		if ((mem13)(&$GameObject::customSetup) != (der13)(&D::customSetup)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::customSetupWrapper)));
		}

		if ((mem14)(&$GameObject::setupCustomSprites) != (der14)(&D::setupCustomSprites)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::setupCustomSpritesWrapper)));
		}

		if ((mem15)(&$GameObject::addMainSpriteToParent) != (der15)(&D::addMainSpriteToParent)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::addMainSpriteToParentWrapper)));
		}

		if ((mem16)(&$GameObject::resetObject) != (der16)(&D::resetObject)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfVirtual((der16)(&D::resetObjectWrapper)));
		}

		if ((mem17)(&$GameObject::triggerObject) != (der17)(&D::triggerObject)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfVirtual((der17)(&D::triggerObjectWrapper)));
		}

		if ((mem18)(&$GameObject::activateObject) != (der18)(&D::activateObject)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfVirtual((der18)(&D::activateObjectWrapper)));
		}

		if ((mem19)(&$GameObject::deactivateObject) != (der19)(&D::deactivateObject)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfVirtual((der19)(&D::deactivateObjectWrapper)));
		}

		if ((mem20)(&$GameObject::getObjectRect) != (der20)(&D::getObjectRect)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfVirtual((der20)(&D::getObjectRectWrapper)));
		}

		if ((mem21)(&$GameObject::getObjectRect) != (der21)(&D::getObjectRect)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfVirtual((der21)(&D::getObjectRectWrapper)));
		}

		if ((mem22)(&$GameObject::getObjectRect2) != (der22)(&D::getObjectRect2)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfVirtual((der22)(&D::getObjectRect2Wrapper)));
		}

		if ((mem23)(&$GameObject::getObjectTextureRect) != (der23)(&D::getObjectTextureRect)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfVirtual((der23)(&D::getObjectTextureRectWrapper)));
		}

		if ((mem24)(&$GameObject::getRealPosition) != (der24)(&D::getRealPosition)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfVirtual((der24)(&D::getRealPositionWrapper)));
		}

		if ((mem25)(&$GameObject::setStartPos) != (der25)(&D::setStartPos)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfVirtual((der25)(&D::setStartPosWrapper)));
		}

		if ((mem26)(&$GameObject::updateStartValues) != (der26)(&D::updateStartValues)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfVirtual((der26)(&D::updateStartValuesWrapper)));
		}

		if ((mem27)(&$GameObject::customObjectSetup) != (der27)(&D::customObjectSetup)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfVirtual((der27)(&D::customObjectSetupWrapper)));
		}

		if ((mem28)(&$GameObject::getSaveString) != (der28)(&D::getSaveString)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfVirtual((der28)(&D::getSaveStringWrapper)));
		}

		if ((mem29)(&$GameObject::isFlipX) != (der29)(&D::isFlipX)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfVirtual((der29)(&D::isFlipXWrapper)));
		}

		if ((mem30)(&$GameObject::isFlipY) != (der30)(&D::isFlipY)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfVirtual((der30)(&D::isFlipYWrapper)));
		}

		if ((mem31)(&$GameObject::setRScaleX) != (der31)(&D::setRScaleX)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfVirtual((der31)(&D::setRScaleXWrapper)));
		}

		if ((mem32)(&$GameObject::setRScaleY) != (der32)(&D::setRScaleY)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfVirtual((der32)(&D::setRScaleYWrapper)));
		}

		if ((mem33)(&$GameObject::setRScale) != (der33)(&D::setRScale)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfVirtual((der33)(&D::setRScaleWrapper)));
		}

		if ((mem34)(&$GameObject::getRScaleX) != (der34)(&D::getRScaleX)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfVirtual((der34)(&D::getRScaleXWrapper)));
		}

		if ((mem35)(&$GameObject::getRScaleY) != (der35)(&D::getRScaleY)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfVirtual((der35)(&D::getRScaleYWrapper)));
		}

		if ((mem36)(&$GameObject::calculateSpawnXPos) != (der36)(&D::calculateSpawnXPos)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfVirtual((der36)(&D::calculateSpawnXPosWrapper)));
		}

		if ((mem37)(&$GameObject::triggerActivated) != (der37)(&D::triggerActivated)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfVirtual((der37)(&D::triggerActivatedWrapper)));
		}

		if ((mem38)(&$GameObject::powerOnObject) != (der38)(&D::powerOnObject)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfVirtual((der38)(&D::powerOnObjectWrapper)));
		}

		if ((mem39)(&$GameObject::powerOffObject) != (der39)(&D::powerOffObject)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfVirtual((der39)(&D::powerOffObjectWrapper)));
		}

		if ((mem40)(&$GameObject::setObjectColor) != (der40)(&D::setObjectColor)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfVirtual((der40)(&D::setObjectColorWrapper)));
		}

		if ((mem41)(&$GameObject::setGlowColor) != (der41)(&D::setGlowColor)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfVirtual((der41)(&D::setGlowColorWrapper)));
		}

		if ((mem42)(&$GameObject::getOrientedBox) != (der42)(&D::getOrientedBox)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfVirtual((der42)(&D::getOrientedBoxWrapper)));
		}

		if ((mem43)(&$GameObject::addToGroup) != (der43)(&D::addToGroup)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfVirtual((der43)(&D::addToGroupWrapper)));
		}

		if ((mem44)(&$GameObject::removeFromGroup) != (der44)(&D::removeFromGroup)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfVirtual((der44)(&D::removeFromGroupWrapper)));
		}

		if ((mem45)(&$GameObject::spawnXPosition) != (der45)(&D::spawnXPosition)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfVirtual((der45)(&D::spawnXPositionWrapper)));
		}

		if ((mem46)(&$GameObject::getObjectRectDirty) != (der46)(&D::getObjectRectDirty)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfVirtual((der46)(&D::getObjectRectDirtyWrapper)));
		}

		if ((mem47)(&$GameObject::setObjectRectDirty) != (der47)(&D::setObjectRectDirty)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfVirtual((der47)(&D::setObjectRectDirtyWrapper)));
		}

		if ((mem48)(&$GameObject::getOrientedRectDirty) != (der48)(&D::getOrientedRectDirty)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfVirtual((der48)(&D::getOrientedRectDirtyWrapper)));
		}

		if ((mem49)(&$GameObject::setOrientedRectDirty) != (der49)(&D::setOrientedRectDirty)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfVirtual((der49)(&D::setOrientedRectDirtyWrapper)));
		}

		if ((mem50)(&$GameObject::getType) != (der50)(&D::getType)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfVirtual((der50)(&D::getTypeWrapper)));
		}

		if ((mem51)(&$GameObject::setType) != (der51)(&D::setType)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfVirtual((der51)(&D::setTypeWrapper)));
		}

		if ((mem52)(&$GameObject::getStartPos) != (der52)(&D::getStartPos)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfVirtual((der52)(&D::getStartPosWrapper)));
		}

		if constexpr((mem53)(&$GameObject::activatedByPlayer) != (der53)(&D::activatedByPlayer)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::activatedByPlayerWrapper)));
		}

		if constexpr((mem54)(&$GameObject::addColorSprite) != (der54)(&D::addColorSprite)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::addColorSpriteWrapper)));
		}

		if constexpr((mem55)(&$GameObject::addColorSpriteToParent) != (der55)(&D::addColorSpriteToParent)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::addColorSpriteToParentWrapper)));
		}

		if constexpr((mem56)(&$GameObject::addToTempOffset) != (der56)(&D::addToTempOffset)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::addToTempOffsetWrapper)));
		}

		if constexpr((mem57)(&$GameObject::calculateOrientedBox) != (der57)(&D::calculateOrientedBox)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::calculateOrientedBoxWrapper)));
		}

		if constexpr((mem58)(&$GameObject::canChangeCustomColor) != (der58)(&D::canChangeCustomColor)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::canChangeCustomColorWrapper)));
		}

		if constexpr((mem59)(&$GameObject::colorForMode) != (der59)(&D::colorForMode)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::colorForModeWrapper)));
		}

		if constexpr((mem60)(&$GameObject::commonSetup) != (der60)(&D::commonSetup)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::commonSetupWrapper)));
		}

		if constexpr((mem61)(&$GameObject::copyGroups) != (der61)(&D::copyGroups)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::copyGroupsWrapper)));
		}

		if constexpr((mem62)(&$GameObject::createWithFrame) != (der62)(&D::createWithFrame)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::createWithFrameWrapper)));
		}

		if constexpr((mem63)(&$GameObject::createWithKey) != (der63)(&D::createWithKey)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::createWithKeyWrapper)));
		}

		if constexpr((mem64)(&$GameObject::destroyObject) != (der64)(&D::destroyObject)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::destroyObjectWrapper)));
		}

		if constexpr((mem65)(&$GameObject::determineSlopeDirection) != (der65)(&D::determineSlopeDirection)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::determineSlopeDirectionWrapper)));
		}

		if constexpr((mem66)(&$GameObject::getActiveColorForMode) != (der66)(&D::getActiveColorForMode)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::getActiveColorForModeWrapper)));
		}

		if constexpr((mem67)(&$GameObject::getBallFrame) != (der67)(&D::getBallFrame)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::getBallFrameWrapper)));
		}

		if constexpr((mem68)(&$GameObject::getBoxOffset) != (der68)(&D::getBoxOffset)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::getBoxOffsetWrapper)));
		}

		if constexpr((mem69)(&$GameObject::getColorIndex) != (der69)(&D::getColorIndex)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::getColorIndexWrapper)));
		}

		if constexpr((mem70)(&$GameObject::getDidUpdateLastPosition) != (der70)(&D::getDidUpdateLastPosition)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::getDidUpdateLastPositionWrapper)));
		}

		if constexpr((mem71)(&$GameObject::getGroupID) != (der71)(&D::getGroupID)) {
			modContainer.registerHookEnable(address71, FunctionScrapper::addressOfNonVirtual((der71)(&D::getGroupIDWrapper)));
		}

		if constexpr((mem72)(&$GameObject::getLastPosition) != (der72)(&D::getLastPosition)) {
			modContainer.registerHookEnable(address72, FunctionScrapper::addressOfNonVirtual((der72)(&D::getLastPositionWrapper)));
		}

		if constexpr((mem73)(&$GameObject::getMainColorMode) != (der73)(&D::getMainColorMode)) {
			modContainer.registerHookEnable(address73, FunctionScrapper::addressOfNonVirtual((der73)(&D::getMainColorModeWrapper)));
		}

		if constexpr((mem74)(&$GameObject::getObjectZOrder) != (der74)(&D::getObjectZOrder)) {
			modContainer.registerHookEnable(address74, FunctionScrapper::addressOfNonVirtual((der74)(&D::getObjectZOrderWrapper)));
		}

		if constexpr((mem75)(&$GameObject::getObjectRadius) != (der75)(&D::getObjectRadius)) {
			modContainer.registerHookEnable(address75, FunctionScrapper::addressOfNonVirtual((der75)(&D::getObjectRadiusWrapper)));
		}

		if constexpr((mem76)(&$GameObject::getSecondaryColorMode) != (der76)(&D::getSecondaryColorMode)) {
			modContainer.registerHookEnable(address76, FunctionScrapper::addressOfNonVirtual((der76)(&D::getSecondaryColorModeWrapper)));
		}

		if constexpr((mem77)(&$GameObject::getSectionIdx) != (der77)(&D::getSectionIdx)) {
			modContainer.registerHookEnable(address77, FunctionScrapper::addressOfNonVirtual((der77)(&D::getSectionIdxWrapper)));
		}

		if constexpr((mem78)(&$GameObject::groupWasDisabled) != (der78)(&D::groupWasDisabled)) {
			modContainer.registerHookEnable(address78, FunctionScrapper::addressOfNonVirtual((der78)(&D::groupWasDisabledWrapper)));
		}

		if constexpr((mem79)(&$GameObject::groupWasEnabled) != (der79)(&D::groupWasEnabled)) {
			modContainer.registerHookEnable(address79, FunctionScrapper::addressOfNonVirtual((der79)(&D::groupWasEnabledWrapper)));
		}

		if constexpr((mem80)(&$GameObject::hasBeenActivated) != (der80)(&D::hasBeenActivated)) {
			modContainer.registerHookEnable(address80, FunctionScrapper::addressOfNonVirtual((der80)(&D::hasBeenActivatedWrapper)));
		}

		if constexpr((mem81)(&$GameObject::hasBeenActivatedByPlayer) != (der81)(&D::hasBeenActivatedByPlayer)) {
			modContainer.registerHookEnable(address81, FunctionScrapper::addressOfNonVirtual((der81)(&D::hasBeenActivatedByPlayerWrapper)));
		}

		if constexpr((mem82)(&$GameObject::hasSecondaryColor) != (der82)(&D::hasSecondaryColor)) {
			modContainer.registerHookEnable(address82, FunctionScrapper::addressOfNonVirtual((der82)(&D::hasSecondaryColorWrapper)));
		}

		if constexpr((mem83)(&$GameObject::ignoreEnter) != (der83)(&D::ignoreEnter)) {
			modContainer.registerHookEnable(address83, FunctionScrapper::addressOfNonVirtual((der83)(&D::ignoreEnterWrapper)));
		}

		if constexpr((mem84)(&$GameObject::ignoreFade) != (der84)(&D::ignoreFade)) {
			modContainer.registerHookEnable(address84, FunctionScrapper::addressOfNonVirtual((der84)(&D::ignoreFadeWrapper)));
		}

		if constexpr((mem85)(&$GameObject::isBasicTrigger) != (der85)(&D::isBasicTrigger)) {
			modContainer.registerHookEnable(address85, FunctionScrapper::addressOfNonVirtual((der85)(&D::isBasicTriggerWrapper)));
		}

		if constexpr((mem86)(&$GameObject::isColorTrigger) != (der86)(&D::isColorTrigger)) {
			modContainer.registerHookEnable(address86, FunctionScrapper::addressOfNonVirtual((der86)(&D::isColorTriggerWrapper)));
		}

		if constexpr((mem87)(&$GameObject::isSpawnableTrigger) != (der87)(&D::isSpawnableTrigger)) {
			modContainer.registerHookEnable(address87, FunctionScrapper::addressOfNonVirtual((der87)(&D::isSpawnableTriggerWrapper)));
		}

		if constexpr((mem88)(&$GameObject::isSpecialObject) != (der88)(&D::isSpecialObject)) {
			modContainer.registerHookEnable(address88, FunctionScrapper::addressOfNonVirtual((der88)(&D::isSpecialObjectWrapper)));
		}

		if constexpr((mem89)(&$GameObject::objectFromString) != (der89)(&D::objectFromString)) {
			modContainer.registerHookEnable(address89, FunctionScrapper::addressOfNonVirtual((der89)(&D::objectFromStringWrapper)));
		}

		if constexpr((mem90)(&$GameObject::playShineEffect) != (der90)(&D::playShineEffect)) {
			modContainer.registerHookEnable(address90, FunctionScrapper::addressOfNonVirtual((der90)(&D::playShineEffectWrapper)));
		}

		if constexpr((mem91)(&$GameObject::quickUpdatePosition) != (der91)(&D::quickUpdatePosition)) {
			modContainer.registerHookEnable(address91, FunctionScrapper::addressOfNonVirtual((der91)(&D::quickUpdatePositionWrapper)));
		}

		if constexpr((mem92)(&$GameObject::removeGlow) != (der92)(&D::removeGlow)) {
			modContainer.registerHookEnable(address92, FunctionScrapper::addressOfNonVirtual((der92)(&D::removeGlowWrapper)));
		}

		if constexpr((mem93)(&$GameObject::resetGroupDisabled) != (der93)(&D::resetGroupDisabled)) {
			modContainer.registerHookEnable(address93, FunctionScrapper::addressOfNonVirtual((der93)(&D::resetGroupDisabledWrapper)));
		}

		if constexpr((mem94)(&$GameObject::saveActiveColors) != (der94)(&D::saveActiveColors)) {
			modContainer.registerHookEnable(address94, FunctionScrapper::addressOfNonVirtual((der94)(&D::saveActiveColorsWrapper)));
		}

		if constexpr((mem95)(&$GameObject::selectObject) != (der95)(&D::selectObject)) {
			modContainer.registerHookEnable(address95, FunctionScrapper::addressOfNonVirtual((der95)(&D::selectObjectWrapper)));
		}

		if constexpr((mem96)(&$GameObject::setDefaultMainColorMode) != (der96)(&D::setDefaultMainColorMode)) {
			modContainer.registerHookEnable(address96, FunctionScrapper::addressOfNonVirtual((der96)(&D::setDefaultMainColorModeWrapper)));
		}

		if constexpr((mem97)(&$GameObject::setDidUpdateLastPosition) != (der97)(&D::setDidUpdateLastPosition)) {
			modContainer.registerHookEnable(address97, FunctionScrapper::addressOfNonVirtual((der97)(&D::setDidUpdateLastPositionWrapper)));
		}

		if constexpr((mem98)(&$GameObject::setGlowOpacity) != (der98)(&D::setGlowOpacity)) {
			modContainer.registerHookEnable(address98, FunctionScrapper::addressOfNonVirtual((der98)(&D::setGlowOpacityWrapper)));
		}

		if constexpr((mem99)(&$GameObject::setLastPosition) != (der99)(&D::setLastPosition)) {
			modContainer.registerHookEnable(address99, FunctionScrapper::addressOfNonVirtual((der99)(&D::setLastPositionWrapper)));
		}

		if constexpr((mem100)(&$GameObject::setMainColorMode) != (der100)(&D::setMainColorMode)) {
			modContainer.registerHookEnable(address100, FunctionScrapper::addressOfNonVirtual((der100)(&D::setMainColorModeWrapper)));
		}

		if constexpr((mem101)(&$GameObject::setSectionIdx) != (der101)(&D::setSectionIdx)) {
			modContainer.registerHookEnable(address101, FunctionScrapper::addressOfNonVirtual((der101)(&D::setSectionIdxWrapper)));
		}

		if constexpr((mem102)(&$GameObject::setupCoinArt) != (der102)(&D::setupCoinArt)) {
			modContainer.registerHookEnable(address102, FunctionScrapper::addressOfNonVirtual((der102)(&D::setupCoinArtWrapper)));
		}

		if constexpr((mem103)(&$GameObject::slopeFloorTop) != (der103)(&D::slopeFloorTop)) {
			modContainer.registerHookEnable(address103, FunctionScrapper::addressOfNonVirtual((der103)(&D::slopeFloorTopWrapper)));
		}

		if constexpr((mem104)(&$GameObject::slopeWallLeft) != (der104)(&D::slopeWallLeft)) {
			modContainer.registerHookEnable(address104, FunctionScrapper::addressOfNonVirtual((der104)(&D::slopeWallLeftWrapper)));
		}

		if constexpr((mem105)(&$GameObject::updateCustomScale) != (der105)(&D::updateCustomScale)) {
			modContainer.registerHookEnable(address105, FunctionScrapper::addressOfNonVirtual((der105)(&D::updateCustomScaleWrapper)));
		}

		if constexpr((mem106)(&$GameObject::updateMainColor) != (der106)(&D::updateMainColor)) {
			modContainer.registerHookEnable(address106, FunctionScrapper::addressOfNonVirtual((der106)(&D::updateMainColorWrapper)));
		}

		if constexpr((mem107)(&$GameObject::updateOrientedBox) != (der107)(&D::updateOrientedBox)) {
			modContainer.registerHookEnable(address107, FunctionScrapper::addressOfNonVirtual((der107)(&D::updateOrientedBoxWrapper)));
		}

		if constexpr((mem108)(&$GameObject::updateSecondaryColor) != (der108)(&D::updateSecondaryColor)) {
			modContainer.registerHookEnable(address108, FunctionScrapper::addressOfNonVirtual((der108)(&D::updateSecondaryColorWrapper)));
		}

		if constexpr((mem109)(&$GameObject::updateStartPos) != (der109)(&D::updateStartPos)) {
			modContainer.registerHookEnable(address109, FunctionScrapper::addressOfNonVirtual((der109)(&D::updateStartPosWrapper)));
		}

		if constexpr((mem110)(&$GameObject::updateState) != (der110)(&D::updateState)) {
			modContainer.registerHookEnable(address110, FunctionScrapper::addressOfNonVirtual((der110)(&D::updateStateWrapper)));
		}

		if constexpr((mem111)(&$GameObject::updateSyncedAnimation) != (der111)(&D::updateSyncedAnimation)) {
			modContainer.registerHookEnable(address111, FunctionScrapper::addressOfNonVirtual((der111)(&D::updateSyncedAnimationWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GameObjectCopy : GameObjectCopy, InterfaceBase {
	$GameObjectCopy(const $GameObjectCopy& c) : GameObjectCopy(c) {}
	$GameObjectCopy() = delete;
	setInterfaceStaticTypesOf(1, GameObjectCopy, create, , 1, GameObject*);
	setInterfaceTypesOf(2, GameObjectCopy, resetObject, , 0);
	static inline auto address0 = base+0xa3290;
	static inline auto address1 = base+0x975a0;
	static inline auto address2 = base+0x976a0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable static getFunctionOf(GameObjectCopy, create, , 1, GameObject*) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	dupable getFunctionOf(GameObjectCopy, resetObject, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	static getWrapperOf(GameObjectCopy, create, , 1, GameObject*) {
		return D::create(p0);
	}

	getWrapperOf(GameObjectCopy, resetObject, , 0) {
		return reinterpret_cast<D*>(this)->D::resetObject();
	}

public:
	static bool _apply() {

		if constexpr(&$GameObjectCopy::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem1)(&$GameObjectCopy::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$GameObjectCopy::resetObject) != (der2)(&D::resetObject)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::resetObjectWrapper)));
		}

		return true;
	}
};

template<class D>
struct $GameSoundManager : GameSoundManager, InterfaceBase {
	$GameSoundManager(const $GameSoundManager& c) : GameSoundManager(c) {}
	$GameSoundManager() = delete;
	setInterfaceTypesOf(0, GameSoundManager, disableMetering, , 0);
	setInterfaceTypesOf(1, GameSoundManager, enableMetering, , 0);
	setInterfaceTypesOf(2, GameSoundManager, getMeteringValue, , 0);
	setInterfaceTypesOf(3, GameSoundManager, playBackgroundMusic, , 3, gd::string, bool, bool);
	setInterfaceTypesOf(4, GameSoundManager, playEffect, , 4, gd::string, float, float, float);
	setInterfaceTypesOf(5, GameSoundManager, sharedManager, , 0);
	setInterfaceTypesOf(6, GameSoundManager, stopBackgroundMusic, , 0);
	static inline auto address0 = base+0x362d80;
	static inline auto address1 = base+0x362d00;
	static inline auto address2 = base+0x362db0;
	static inline auto address3 = base+0x362070;
	static inline auto address4 = base+0x3623d0;
	static inline auto address5 = base+0x3610f0;
	static inline auto address6 = base+0x362130;
	static inline auto address7 = base+0x362c00;

	dupable getFunctionOf(GameSoundManager, disableMetering, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(GameSoundManager, enableMetering, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(GameSoundManager, getMeteringValue, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(GameSoundManager, playBackgroundMusic, , 3, gd::string, bool, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1, p2);
	}

	dupable getFunctionOf(GameSoundManager, playEffect, , 4, gd::string, float, float, float) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(GameSoundManager, sharedManager, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	dupable getFunctionOf(GameSoundManager, stopBackgroundMusic, , 0) {
		return reinterpret_cast<fun6>(address6)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address7)(this);
	}

	getWrapperOf(GameSoundManager, disableMetering, , 0) {
		return reinterpret_cast<D*>(this)->D::disableMetering();
	}

	getWrapperOf(GameSoundManager, enableMetering, , 0) {
		return reinterpret_cast<D*>(this)->D::enableMetering();
	}

	getWrapperOf(GameSoundManager, getMeteringValue, , 0) {
		return reinterpret_cast<D*>(this)->D::getMeteringValue();
	}

	getWrapperOf(GameSoundManager, playBackgroundMusic, , 3, gd::string, bool, bool) {
		return reinterpret_cast<D*>(this)->D::playBackgroundMusic(p0, p1, p2);
	}

	getWrapperOf(GameSoundManager, playEffect, , 4, gd::string, float, float, float) {
		return reinterpret_cast<D*>(this)->D::playEffect(p0, p1, p2, p3);
	}

	getWrapperOf(GameSoundManager, sharedManager, , 0) {
		return reinterpret_cast<D*>(this)->D::sharedManager();
	}

	getWrapperOf(GameSoundManager, stopBackgroundMusic, , 0) {
		return reinterpret_cast<D*>(this)->D::stopBackgroundMusic();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$GameSoundManager::disableMetering) != (der0)(&D::disableMetering)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::disableMeteringWrapper)));
		}

		if constexpr((mem1)(&$GameSoundManager::enableMetering) != (der1)(&D::enableMetering)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::enableMeteringWrapper)));
		}

		if constexpr((mem2)(&$GameSoundManager::getMeteringValue) != (der2)(&D::getMeteringValue)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getMeteringValueWrapper)));
		}

		if constexpr((mem3)(&$GameSoundManager::playBackgroundMusic) != (der3)(&D::playBackgroundMusic)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::playBackgroundMusicWrapper)));
		}

		if constexpr((mem4)(&$GameSoundManager::playEffect) != (der4)(&D::playEffect)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::playEffectWrapper)));
		}

		if constexpr((mem5)(&$GameSoundManager::sharedManager) != (der5)(&D::sharedManager)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::sharedManagerWrapper)));
		}

		if constexpr((mem6)(&$GameSoundManager::stopBackgroundMusic) != (der6)(&D::stopBackgroundMusic)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::stopBackgroundMusicWrapper)));
		}

		if constexpr(&$GameSoundManager::destructor != &D::destructor) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $GameStatsManager : GameStatsManager, InterfaceBase {
	$GameStatsManager(const $GameStatsManager& c) : GameStatsManager(c) {}
	$GameStatsManager() = delete;
	setInterfaceTypesOf(0, GameStatsManager, awardCurrencyForLevel, , 1, GJGameLevel*);
	setInterfaceTypesOf(1, GameStatsManager, awardDiamondsForLevel, , 1, GJGameLevel*);
	setInterfaceTypesOf(2, GameStatsManager, awardSecretKey, , 0);
	setInterfaceTypesOf(3, GameStatsManager, getSecretCoinKey, , 1, char const*);
	setInterfaceTypesOf(4, GameStatsManager, getStat, , 1, char const*);
	setInterfaceTypesOf(5, GameStatsManager, hasPendingUserCoin, , 1, char const*);
	setInterfaceTypesOf(6, GameStatsManager, hasSecretCoin, , 1, char const*);
	setInterfaceTypesOf(7, GameStatsManager, hasUserCoin, , 1, char const*);
	setInterfaceTypesOf(8, GameStatsManager, incrementStat, , 1, char const*);
	setInterfaceTypesOf(9, GameStatsManager, incrementStat, , 2, char const*, int);
	setInterfaceTypesOf(10, GameStatsManager, sharedState, , 0);
	setInterfaceTypesOf(11, GameStatsManager, storePendingUserCoin, , 1, char const*);
	setInterfaceTypesOf(12, GameStatsManager, storeSecretCoin, , 1, char const*);
	setInterfaceTypesOf(13, GameStatsManager, storeUserCoin, , 1, char const*);
	static inline auto address0 = base+0x43600;
	static inline auto address1 = base+0x43c60;
	static inline auto address2 = base+0x4b1e0;
	static inline auto address3 = base+0x429f0;
	static inline auto address4 = base+0x3d310;
	static inline auto address5 = base+0x42730;
	static inline auto address6 = base+0x40730;
	static inline auto address7 = base+0x427e0;
	static inline auto address8 = base+0x3d6d0;
	static inline auto address9 = base+0x3d6e0;
	static inline auto address10 = base+0x38f20;
	static inline auto address11 = base+0x42940;
	static inline auto address12 = base+0x42a10;
	static inline auto address13 = base+0x42890;

	dupable getFunctionOf(GameStatsManager, awardCurrencyForLevel, , 1, GJGameLevel*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, awardDiamondsForLevel, , 1, GJGameLevel*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, awardSecretKey, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(GameStatsManager, getSecretCoinKey, , 1, char const*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, getStat, , 1, char const*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, hasPendingUserCoin, , 1, char const*) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, hasSecretCoin, , 1, char const*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, hasUserCoin, , 1, char const*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, incrementStat, , 1, char const*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, incrementStat, , 2, char const*, int) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1);
	}

	dupable getFunctionOf(GameStatsManager, sharedState, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(GameStatsManager, storePendingUserCoin, , 1, char const*) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, storeSecretCoin, , 1, char const*) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(GameStatsManager, storeUserCoin, , 1, char const*) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	getWrapperOf(GameStatsManager, awardCurrencyForLevel, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::awardCurrencyForLevel(p0);
	}

	getWrapperOf(GameStatsManager, awardDiamondsForLevel, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::awardDiamondsForLevel(p0);
	}

	getWrapperOf(GameStatsManager, awardSecretKey, , 0) {
		return reinterpret_cast<D*>(this)->D::awardSecretKey();
	}

	getWrapperOf(GameStatsManager, getSecretCoinKey, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getSecretCoinKey(p0);
	}

	getWrapperOf(GameStatsManager, getStat, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::getStat(p0);
	}

	getWrapperOf(GameStatsManager, hasPendingUserCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::hasPendingUserCoin(p0);
	}

	getWrapperOf(GameStatsManager, hasSecretCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::hasSecretCoin(p0);
	}

	getWrapperOf(GameStatsManager, hasUserCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::hasUserCoin(p0);
	}

	getWrapperOf(GameStatsManager, incrementStat, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::incrementStat(p0);
	}

	getWrapperOf(GameStatsManager, incrementStat, , 2, char const*, int) {
		return reinterpret_cast<D*>(this)->D::incrementStat(p0, p1);
	}

	getWrapperOf(GameStatsManager, sharedState, , 0) {
		return reinterpret_cast<D*>(this)->D::sharedState();
	}

	getWrapperOf(GameStatsManager, storePendingUserCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::storePendingUserCoin(p0);
	}

	getWrapperOf(GameStatsManager, storeSecretCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::storeSecretCoin(p0);
	}

	getWrapperOf(GameStatsManager, storeUserCoin, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::storeUserCoin(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$GameStatsManager::awardCurrencyForLevel) != (der0)(&D::awardCurrencyForLevel)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::awardCurrencyForLevelWrapper)));
		}

		if constexpr((mem1)(&$GameStatsManager::awardDiamondsForLevel) != (der1)(&D::awardDiamondsForLevel)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::awardDiamondsForLevelWrapper)));
		}

		if constexpr((mem2)(&$GameStatsManager::awardSecretKey) != (der2)(&D::awardSecretKey)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::awardSecretKeyWrapper)));
		}

		if constexpr((mem3)(&$GameStatsManager::getSecretCoinKey) != (der3)(&D::getSecretCoinKey)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::getSecretCoinKeyWrapper)));
		}

		if constexpr((mem4)(&$GameStatsManager::getStat) != (der4)(&D::getStat)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::getStatWrapper)));
		}

		if constexpr((mem5)(&$GameStatsManager::hasPendingUserCoin) != (der5)(&D::hasPendingUserCoin)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::hasPendingUserCoinWrapper)));
		}

		if constexpr((mem6)(&$GameStatsManager::hasSecretCoin) != (der6)(&D::hasSecretCoin)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::hasSecretCoinWrapper)));
		}

		if constexpr((mem7)(&$GameStatsManager::hasUserCoin) != (der7)(&D::hasUserCoin)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::hasUserCoinWrapper)));
		}

		if constexpr((mem8)(&$GameStatsManager::incrementStat) != (der8)(&D::incrementStat)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::incrementStatWrapper)));
		}

		if constexpr((mem9)(&$GameStatsManager::incrementStat) != (der9)(&D::incrementStat)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfNonVirtual((der9)(&D::incrementStatWrapper)));
		}

		if constexpr((mem10)(&$GameStatsManager::sharedState) != (der10)(&D::sharedState)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::sharedStateWrapper)));
		}

		if constexpr((mem11)(&$GameStatsManager::storePendingUserCoin) != (der11)(&D::storePendingUserCoin)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::storePendingUserCoinWrapper)));
		}

		if constexpr((mem12)(&$GameStatsManager::storeSecretCoin) != (der12)(&D::storeSecretCoin)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::storeSecretCoinWrapper)));
		}

		if constexpr((mem13)(&$GameStatsManager::storeUserCoin) != (der13)(&D::storeUserCoin)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::storeUserCoinWrapper)));
		}

		return true;
	}
};

template<class D>
struct $HardStreak : HardStreak, InterfaceBase {
	$HardStreak(const $HardStreak& c) : HardStreak(c) {}
	$HardStreak() = delete;
	setInterfaceTypesOf(1, HardStreak, init, , 0);
	setInterfaceTypesOf(2, HardStreak, addPoint, , 1, cocos2d::CCPoint);
	setInterfaceTypesOf(3, HardStreak, reset, , 0);
	setInterfaceTypesOf(4, HardStreak, resumeStroke, , 0);
	setInterfaceTypesOf(5, HardStreak, stopStroke, , 0);
	static inline auto address0 = base+0x5bf00;
	static inline auto address1 = base+0x5c090;
	static inline auto address2 = base+0x5c950;
	static inline auto address3 = base+0x5c930;
	static inline auto address4 = base+0x5c210;
	static inline auto address5 = base+0x5c8f0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(HardStreak, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(HardStreak, addPoint, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(HardStreak, reset, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	dupable getFunctionOf(HardStreak, resumeStroke, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(HardStreak, stopStroke, , 0) {
		return reinterpret_cast<fun5>(address5)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(HardStreak, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(HardStreak, addPoint, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::addPoint(p0);
	}

	getWrapperOf(HardStreak, reset, , 0) {
		return reinterpret_cast<D*>(this)->D::reset();
	}

	getWrapperOf(HardStreak, resumeStroke, , 0) {
		return reinterpret_cast<D*>(this)->D::resumeStroke();
	}

	getWrapperOf(HardStreak, stopStroke, , 0) {
		return reinterpret_cast<D*>(this)->D::stopStroke();
	}

public:
	static bool _apply() {

		if constexpr(&$HardStreak::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$HardStreak::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$HardStreak::addPoint) != (der2)(&D::addPoint)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::addPointWrapper)));
		}

		if constexpr((mem3)(&$HardStreak::reset) != (der3)(&D::reset)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::resetWrapper)));
		}

		if constexpr((mem4)(&$HardStreak::resumeStroke) != (der4)(&D::resumeStroke)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::resumeStrokeWrapper)));
		}

		if constexpr((mem5)(&$HardStreak::stopStroke) != (der5)(&D::stopStroke)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::stopStrokeWrapper)));
		}

		return true;
	}
};

template<class D>
struct $InheritanceNode : InheritanceNode, InterfaceBase {
	$InheritanceNode(const $InheritanceNode& c) : InheritanceNode(c) {}
	$InheritanceNode() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $LabelGameObject : LabelGameObject, InterfaceBase {
	$LabelGameObject(const $LabelGameObject& c) : LabelGameObject(c) {}
	$LabelGameObject() = delete;
	setInterfaceTypesOf(0, LabelGameObject, init, , 0);
	setInterfaceTypesOf(1, LabelGameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&);
	static inline auto address0 = base+0x2f5520;
	static inline auto address1 = base+0xdbca0;

	dupable getFunctionOf(LabelGameObject, init, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(LabelGameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(LabelGameObject, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(LabelGameObject, setObjectColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setObjectColor(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$LabelGameObject::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::initWrapper)));
		}

		if constexpr((mem1)(&$LabelGameObject::setObjectColor) != (der1)(&D::setObjectColor)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setObjectColorWrapper)));
		}

		return true;
	}
};

template<class D>
struct $LevelEditorLayer : LevelEditorLayer, InterfaceBase {
	$LevelEditorLayer(const $LevelEditorLayer& c) : LevelEditorLayer(c) {}
	$LevelEditorLayer() = delete;
	setInterfaceTypesOf(1, LevelEditorLayer, update, , 1, float);
	setInterfaceTypesOf(2, LevelEditorLayer, draw, , 0);
	setInterfaceTypesOf(3, LevelEditorLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*);
	setInterfaceTypesOf(4, LevelEditorLayer, flipGravity, , 3, PlayerObject*, bool, bool);
	setInterfaceTypesOf(5, LevelEditorLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*);
	setInterfaceTypesOf(6, LevelEditorLayer, addToGroup, , 3, GameObject*, int, bool);
	setInterfaceTypesOf(7, LevelEditorLayer, removeFromGroup, , 2, GameObject*, int);
	setInterfaceTypesOf(8, LevelEditorLayer, timeForXPos, , 1, float);
	setInterfaceTypesOf(9, LevelEditorLayer, xPosForTime, , 1, float);
	setInterfaceTypesOf(10, LevelEditorLayer, levelSettingsUpdated, , 0);
	setInterfaceTypesOf(11, LevelEditorLayer, activateTriggerEffect, , 4, EffectGameObject*, float, float, float);
	setInterfaceTypesOf(12, LevelEditorLayer, addObjectFromString, , 1, gd::string);
	setInterfaceTypesOf(13, LevelEditorLayer, addSpecial, , 1, GameObject*);
	setInterfaceTypesOf(14, LevelEditorLayer, addToRedoList, , 1, UndoObject*);
	setInterfaceTypesOf(15, LevelEditorLayer, addToUndoList, , 2, UndoObject*, bool);
	setInterfaceTypesOf(16, LevelEditorLayer, animateInDualGround, , 3, GameObject*, float, bool);
	setInterfaceTypesOf(17, LevelEditorLayer, checkCollisions, , 2, PlayerObject*, float);
	setInterfaceStaticTypesOf(18, LevelEditorLayer, create, , 1, GJGameLevel*);
	setInterfaceTypesOf(19, LevelEditorLayer, createBackground, , 0);
	setInterfaceTypesOf(20, LevelEditorLayer, createGroundLayer, , 0);
	setInterfaceTypesOf(21, LevelEditorLayer, createObject, , 3, int, cocos2d::CCPoint, bool);
	setInterfaceTypesOf(22, LevelEditorLayer, createObjectsFromSetup, , 1, gd::string);
	setInterfaceTypesOf(23, LevelEditorLayer, createObjectsFromString, , 2, gd::string, bool);
	setInterfaceTypesOf(24, LevelEditorLayer, getLastObjectX, , 0);
	setInterfaceTypesOf(25, LevelEditorLayer, getLevelString, , 0);
	setInterfaceTypesOf(26, LevelEditorLayer, getNextColorChannel, , 0);
	setInterfaceTypesOf(27, LevelEditorLayer, getNextFreeBlockID, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(28, LevelEditorLayer, getNextFreeGroupID, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(29, LevelEditorLayer, getNextFreeItemID, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(30, LevelEditorLayer, getObjectRect, , 2, GameObject*, bool);
	setInterfaceTypesOf(31, LevelEditorLayer, getRelativeOffset, , 1, GameObject*);
	setInterfaceTypesOf(32, LevelEditorLayer, handleAction, , 2, bool, cocos2d::CCArray*);
	setInterfaceTypesOf(33, LevelEditorLayer, init, , 1, GJGameLevel*);
	setInterfaceTypesOf(34, LevelEditorLayer, objectAtPosition, , 1, cocos2d::CCPoint);
	setInterfaceTypesOf(35, LevelEditorLayer, objectMoved, , 1, GameObject*);
	setInterfaceTypesOf(36, LevelEditorLayer, objectsInRect, , 2, cocos2d::CCRect, bool);
	setInterfaceTypesOf(37, LevelEditorLayer, onPlaytest, , 0);
	setInterfaceTypesOf(38, LevelEditorLayer, onStopPlaytest, , 0);
	setInterfaceTypesOf(39, LevelEditorLayer, playMusic, , 0);
	setInterfaceTypesOf(40, LevelEditorLayer, recreateGroups, , 0);
	setInterfaceTypesOf(41, LevelEditorLayer, redoLastAction, , 0);
	setInterfaceTypesOf(42, LevelEditorLayer, removeAllObjects, , 0);
	setInterfaceTypesOf(43, LevelEditorLayer, removeAllObjectsOfType, , 1, int);
	setInterfaceTypesOf(44, LevelEditorLayer, removeObject, , 2, GameObject*, bool);
	setInterfaceTypesOf(45, LevelEditorLayer, removeSpecial, , 1, GameObject*);
	setInterfaceTypesOf(46, LevelEditorLayer, resetMovingObjects, , 0);
	setInterfaceTypesOf(47, LevelEditorLayer, resetObjectVector, , 0);
	setInterfaceTypesOf(48, LevelEditorLayer, resetToggledGroups, , 0);
	setInterfaceTypesOf(49, LevelEditorLayer, resetToggledGroupsAndObjects, , 0);
	setInterfaceTypesOf(50, LevelEditorLayer, resetUnusedColorChannels, , 0);
	setInterfaceTypesOf(51, LevelEditorLayer, rotationForSlopeNearObject, , 1, GameObject*);
	setInterfaceTypesOf(52, LevelEditorLayer, runColorEffect, , 5, EffectGameObject*, int, float, float, bool);
	setInterfaceTypesOf(53, LevelEditorLayer, scene, , 1, GJGameLevel*);
	setInterfaceTypesOf(54, LevelEditorLayer, setupLevelStart, , 1, LevelSettingsObject*);
	setInterfaceTypesOf(55, LevelEditorLayer, sortStickyGroups, , 0);
	setInterfaceTypesOf(56, LevelEditorLayer, stopTriggersInGroup, , 2, int, float);
	setInterfaceTypesOf(57, LevelEditorLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool);
	setInterfaceTypesOf(58, LevelEditorLayer, toggleGroupPreview, , 2, int, bool);
	setInterfaceTypesOf(59, LevelEditorLayer, transferDefaultColors, , 2, GJEffectManager*, GJEffectManager*);
	setInterfaceTypesOf(60, LevelEditorLayer, undoLastAction, , 0);
	setInterfaceTypesOf(61, LevelEditorLayer, updateBGAndGColors, , 0);
	setInterfaceTypesOf(62, LevelEditorLayer, updateBlendValues, , 0);
	setInterfaceTypesOf(63, LevelEditorLayer, updateDualGround, , 3, PlayerObject*, int, bool);
	setInterfaceTypesOf(64, LevelEditorLayer, updateEditorMode, , 0);
	setInterfaceTypesOf(65, LevelEditorLayer, updateGameObjectsNew, , 0);
	setInterfaceTypesOf(66, LevelEditorLayer, updateGround, , 1, float);
	setInterfaceTypesOf(67, LevelEditorLayer, updateGroundWidth, , 0);
	setInterfaceTypesOf(68, LevelEditorLayer, updateOptions, , 0);
	setInterfaceTypesOf(69, LevelEditorLayer, updateToggledGroups, , 0);
	setInterfaceTypesOf(70, LevelEditorLayer, updateVisibility, , 1, float);
	static inline auto address0 = base+0x90e80;
	static inline auto address1 = base+0xa1b70;
	static inline auto address2 = base+0xa2a70;
	static inline auto address3 = base+0x9c200;
	static inline auto address4 = base+0xa04e0;
	static inline auto address5 = base+0x9c590;
	static inline auto address6 = base+0x9dab0;
	static inline auto address7 = base+0x9db60;
	static inline auto address8 = base+0x9c7d0;
	static inline auto address9 = base+0x9c800;
	static inline auto address10 = base+0x93f30;
	static inline auto address11 = base+0x9b520;
	static inline auto address12 = base+0x94640;
	static inline auto address13 = base+0x94f30;
	static inline auto address14 = base+0x96f80;
	static inline auto address15 = base+0x94e20;
	static inline auto address16 = base+0xa2780;
	static inline auto address17 = base+0x9e620;
	static inline auto address18 = base+0x90fb0;
	static inline auto address19 = base+0x929f0;
	static inline auto address20 = base+0x92840;
	static inline auto address21 = base+0x957c0;
	static inline auto address22 = base+0x92230;
	static inline auto address23 = base+0x94730;
	static inline auto address24 = base+0x9c860;
	static inline auto address25 = base+0x97790;
	static inline auto address26 = base+0x9a610;
	static inline auto address27 = base+0x9a4e0;
	static inline auto address28 = base+0x9a1b0;
	static inline auto address29 = base+0x9a390;
	static inline auto address30 = base+0x96240;
	static inline auto address31 = base+0x96840;
	static inline auto address32 = base+0x97020;
	static inline auto address33 = base+0x91010;
	static inline auto address34 = base+0x960c0;
	static inline auto address35 = base+0x999f0;
	static inline auto address36 = base+0x95e60;
	static inline auto address37 = base+0xa06b0;
	static inline auto address38 = base+0xa1780;
	static inline auto address39 = base+0xa13c0;
	static inline auto address40 = base+0x9dbf0;
	static inline auto address41 = base+0x97750;
	static inline auto address42 = base+0x93d80;
	static inline auto address43 = base+0x96d40;
	static inline auto address44 = base+0x96890;
	static inline auto address45 = base+0x969c0;
	static inline auto address46 = base+0x9ddc0;
	static inline auto address47 = base+0x9c4b0;
	static inline auto address48 = base+0x9aa70;
	static inline auto address49 = base+0x9c3c0;
	static inline auto address50 = base+0x9a870;
	static inline auto address51 = base+0x95cd0;
	static inline auto address52 = base+0x9bd30;
	static inline auto address53 = base+0x90f20;
	static inline auto address54 = base+0xa0ca0;
	static inline auto address55 = base+0x92b10;
	static inline auto address56 = base+0x9c030;
	static inline auto address57 = base+0xa0200;
	static inline auto address58 = base+0x9bea0;
	static inline auto address59 = base+0x9ab50;
	static inline auto address60 = base+0x97770;
	static inline auto address61 = base+0x9b9b0;
	static inline auto address62 = base+0x9bc60;
	static inline auto address63 = base+0xa1a60;
	static inline auto address64 = base+0x93b50;
	static inline auto address65 = base+0x9adc0;
	static inline auto address66 = base+0x93a60;
	static inline auto address67 = base+0x92af0;
	static inline auto address68 = base+0x91ed0;
	static inline auto address69 = base+0x9bb10;
	static inline auto address70 = base+0x92c70;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, update, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, draw, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	dupable getFunctionOf(LevelEditorLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2);
	}

	dupable getFunctionOf(LevelEditorLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(LevelEditorLayer, addToGroup, , 3, GameObject*, int, bool) {
		return reinterpret_cast<fun6>(address6)(this, p0, p1, p2);
	}

	dupable getFunctionOf(LevelEditorLayer, removeFromGroup, , 2, GameObject*, int) {
		return reinterpret_cast<fun7>(address7)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, timeForXPos, , 1, float) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, xPosForTime, , 1, float) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, levelSettingsUpdated, , 0) {
		return reinterpret_cast<fun10>(address10)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, activateTriggerEffect, , 4, EffectGameObject*, float, float, float) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(LevelEditorLayer, addObjectFromString, , 1, gd::string) {
		return reinterpret_cast<fun12>(address12)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, addSpecial, , 1, GameObject*) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, addToRedoList, , 1, UndoObject*) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, addToUndoList, , 2, UndoObject*, bool) {
		return reinterpret_cast<fun15>(address15)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, animateInDualGround, , 3, GameObject*, float, bool) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1, p2);
	}

	dupable getFunctionOf(LevelEditorLayer, checkCollisions, , 2, PlayerObject*, float) {
		return reinterpret_cast<fun17>(address17)(this, p0, p1);
	}

	dupable static getFunctionOf(LevelEditorLayer, create, , 1, GJGameLevel*) {
		return reinterpret_cast<fun18>(address18)(p0);
	}

	dupable getFunctionOf(LevelEditorLayer, createBackground, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, createGroundLayer, , 0) {
		return reinterpret_cast<fun20>(address20)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, createObject, , 3, int, cocos2d::CCPoint, bool) {
		return reinterpret_cast<fun21>(address21)(this, p0, p1, p2);
	}

	dupable getFunctionOf(LevelEditorLayer, createObjectsFromSetup, , 1, gd::string) {
		return reinterpret_cast<fun22>(address22)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, createObjectsFromString, , 2, gd::string, bool) {
		return reinterpret_cast<fun23>(address23)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, getLastObjectX, , 0) {
		return reinterpret_cast<fun24>(address24)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, getLevelString, , 0) {
		return reinterpret_cast<fun25>(address25)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, getNextColorChannel, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, getNextFreeBlockID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun27>(address27)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, getNextFreeGroupID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun28>(address28)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, getNextFreeItemID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun29>(address29)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, getObjectRect, , 2, GameObject*, bool) {
		return reinterpret_cast<fun30>(address30)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, getRelativeOffset, , 1, GameObject*) {
		return reinterpret_cast<fun31>(address31)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, handleAction, , 2, bool, cocos2d::CCArray*) {
		return reinterpret_cast<fun32>(address32)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, init, , 1, GJGameLevel*) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, objectAtPosition, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, objectMoved, , 1, GameObject*) {
		return reinterpret_cast<fun35>(address35)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, objectsInRect, , 2, cocos2d::CCRect, bool) {
		return reinterpret_cast<fun36>(address36)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, onPlaytest, , 0) {
		return reinterpret_cast<fun37>(address37)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, onStopPlaytest, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, playMusic, , 0) {
		return reinterpret_cast<fun39>(address39)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, recreateGroups, , 0) {
		return reinterpret_cast<fun40>(address40)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, redoLastAction, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, removeAllObjects, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, removeAllObjectsOfType, , 1, int) {
		return reinterpret_cast<fun43>(address43)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, removeObject, , 2, GameObject*, bool) {
		return reinterpret_cast<fun44>(address44)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, removeSpecial, , 1, GameObject*) {
		return reinterpret_cast<fun45>(address45)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, resetMovingObjects, , 0) {
		return reinterpret_cast<fun46>(address46)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, resetObjectVector, , 0) {
		return reinterpret_cast<fun47>(address47)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, resetToggledGroups, , 0) {
		return reinterpret_cast<fun48>(address48)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, resetToggledGroupsAndObjects, , 0) {
		return reinterpret_cast<fun49>(address49)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, resetUnusedColorChannels, , 0) {
		return reinterpret_cast<fun50>(address50)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, rotationForSlopeNearObject, , 1, GameObject*) {
		return reinterpret_cast<fun51>(address51)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, runColorEffect, , 5, EffectGameObject*, int, float, float, bool) {
		return reinterpret_cast<fun52>(address52)(this, p0, p1, p2, p3, p4);
	}

	dupable getFunctionOf(LevelEditorLayer, scene, , 1, GJGameLevel*) {
		return reinterpret_cast<fun53>(address53)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, setupLevelStart, , 1, LevelSettingsObject*) {
		return reinterpret_cast<fun54>(address54)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, sortStickyGroups, , 0) {
		return reinterpret_cast<fun55>(address55)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, stopTriggersInGroup, , 2, int, float) {
		return reinterpret_cast<fun56>(address56)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool) {
		return reinterpret_cast<fun57>(address57)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(LevelEditorLayer, toggleGroupPreview, , 2, int, bool) {
		return reinterpret_cast<fun58>(address58)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, transferDefaultColors, , 2, GJEffectManager*, GJEffectManager*) {
		return reinterpret_cast<fun59>(address59)(this, p0, p1);
	}

	dupable getFunctionOf(LevelEditorLayer, undoLastAction, , 0) {
		return reinterpret_cast<fun60>(address60)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateBGAndGColors, , 0) {
		return reinterpret_cast<fun61>(address61)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateBlendValues, , 0) {
		return reinterpret_cast<fun62>(address62)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateDualGround, , 3, PlayerObject*, int, bool) {
		return reinterpret_cast<fun63>(address63)(this, p0, p1, p2);
	}

	dupable getFunctionOf(LevelEditorLayer, updateEditorMode, , 0) {
		return reinterpret_cast<fun64>(address64)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateGameObjectsNew, , 0) {
		return reinterpret_cast<fun65>(address65)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateGround, , 1, float) {
		return reinterpret_cast<fun66>(address66)(this, p0);
	}

	dupable getFunctionOf(LevelEditorLayer, updateGroundWidth, , 0) {
		return reinterpret_cast<fun67>(address67)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateOptions, , 0) {
		return reinterpret_cast<fun68>(address68)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateToggledGroups, , 0) {
		return reinterpret_cast<fun69>(address69)(this);
	}

	dupable getFunctionOf(LevelEditorLayer, updateVisibility, , 1, float) {
		return reinterpret_cast<fun70>(address70)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(LevelEditorLayer, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

	getWrapperOf(LevelEditorLayer, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(LevelEditorLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	getWrapperOf(LevelEditorLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<D*>(this)->D::flipGravity(p0, p1, p2);
	}

	getWrapperOf(LevelEditorLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::calculateColorValues(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(LevelEditorLayer, addToGroup, , 3, GameObject*, int, bool) {
		return reinterpret_cast<D*>(this)->D::addToGroup(p0, p1, p2);
	}

	getWrapperOf(LevelEditorLayer, removeFromGroup, , 2, GameObject*, int) {
		return reinterpret_cast<D*>(this)->D::removeFromGroup(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, timeForXPos, , 1, float) {
		return reinterpret_cast<D*>(this)->D::timeForXPos(p0);
	}

	getWrapperOf(LevelEditorLayer, xPosForTime, , 1, float) {
		return reinterpret_cast<D*>(this)->D::xPosForTime(p0);
	}

	getWrapperOf(LevelEditorLayer, levelSettingsUpdated, , 0) {
		return reinterpret_cast<D*>(this)->D::levelSettingsUpdated();
	}

	getWrapperOf(LevelEditorLayer, activateTriggerEffect, , 4, EffectGameObject*, float, float, float) {
		return reinterpret_cast<D*>(this)->D::activateTriggerEffect(p0, p1, p2, p3);
	}

	getWrapperOf(LevelEditorLayer, addObjectFromString, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::addObjectFromString(p0);
	}

	getWrapperOf(LevelEditorLayer, addSpecial, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addSpecial(p0);
	}

	getWrapperOf(LevelEditorLayer, addToRedoList, , 1, UndoObject*) {
		return reinterpret_cast<D*>(this)->D::addToRedoList(p0);
	}

	getWrapperOf(LevelEditorLayer, addToUndoList, , 2, UndoObject*, bool) {
		return reinterpret_cast<D*>(this)->D::addToUndoList(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, animateInDualGround, , 3, GameObject*, float, bool) {
		return reinterpret_cast<D*>(this)->D::animateInDualGround(p0, p1, p2);
	}

	getWrapperOf(LevelEditorLayer, checkCollisions, , 2, PlayerObject*, float) {
		return reinterpret_cast<D*>(this)->D::checkCollisions(p0, p1);
	}

	static getWrapperOf(LevelEditorLayer, create, , 1, GJGameLevel*) {
		return D::create(p0);
	}

	getWrapperOf(LevelEditorLayer, createBackground, , 0) {
		return reinterpret_cast<D*>(this)->D::createBackground();
	}

	getWrapperOf(LevelEditorLayer, createGroundLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::createGroundLayer();
	}

	getWrapperOf(LevelEditorLayer, createObject, , 3, int, cocos2d::CCPoint, bool) {
		return reinterpret_cast<D*>(this)->D::createObject(p0, p1, p2);
	}

	getWrapperOf(LevelEditorLayer, createObjectsFromSetup, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::createObjectsFromSetup(p0);
	}

	getWrapperOf(LevelEditorLayer, createObjectsFromString, , 2, gd::string, bool) {
		return reinterpret_cast<D*>(this)->D::createObjectsFromString(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, getLastObjectX, , 0) {
		return reinterpret_cast<D*>(this)->D::getLastObjectX();
	}

	getWrapperOf(LevelEditorLayer, getLevelString, , 0) {
		return reinterpret_cast<D*>(this)->D::getLevelString();
	}

	getWrapperOf(LevelEditorLayer, getNextColorChannel, , 0) {
		return reinterpret_cast<D*>(this)->D::getNextColorChannel();
	}

	getWrapperOf(LevelEditorLayer, getNextFreeBlockID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::getNextFreeBlockID(p0);
	}

	getWrapperOf(LevelEditorLayer, getNextFreeGroupID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::getNextFreeGroupID(p0);
	}

	getWrapperOf(LevelEditorLayer, getNextFreeItemID, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::getNextFreeItemID(p0);
	}

	getWrapperOf(LevelEditorLayer, getObjectRect, , 2, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::getObjectRect(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, getRelativeOffset, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::getRelativeOffset(p0);
	}

	getWrapperOf(LevelEditorLayer, handleAction, , 2, bool, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::handleAction(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, init, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::init(p0);
	}

	getWrapperOf(LevelEditorLayer, objectAtPosition, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::objectAtPosition(p0);
	}

	getWrapperOf(LevelEditorLayer, objectMoved, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::objectMoved(p0);
	}

	getWrapperOf(LevelEditorLayer, objectsInRect, , 2, cocos2d::CCRect, bool) {
		return reinterpret_cast<D*>(this)->D::objectsInRect(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, onPlaytest, , 0) {
		return reinterpret_cast<D*>(this)->D::onPlaytest();
	}

	getWrapperOf(LevelEditorLayer, onStopPlaytest, , 0) {
		return reinterpret_cast<D*>(this)->D::onStopPlaytest();
	}

	getWrapperOf(LevelEditorLayer, playMusic, , 0) {
		return reinterpret_cast<D*>(this)->D::playMusic();
	}

	getWrapperOf(LevelEditorLayer, recreateGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::recreateGroups();
	}

	getWrapperOf(LevelEditorLayer, redoLastAction, , 0) {
		return reinterpret_cast<D*>(this)->D::redoLastAction();
	}

	getWrapperOf(LevelEditorLayer, removeAllObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllObjects();
	}

	getWrapperOf(LevelEditorLayer, removeAllObjectsOfType, , 1, int) {
		return reinterpret_cast<D*>(this)->D::removeAllObjectsOfType(p0);
	}

	getWrapperOf(LevelEditorLayer, removeObject, , 2, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::removeObject(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, removeSpecial, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::removeSpecial(p0);
	}

	getWrapperOf(LevelEditorLayer, resetMovingObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::resetMovingObjects();
	}

	getWrapperOf(LevelEditorLayer, resetObjectVector, , 0) {
		return reinterpret_cast<D*>(this)->D::resetObjectVector();
	}

	getWrapperOf(LevelEditorLayer, resetToggledGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::resetToggledGroups();
	}

	getWrapperOf(LevelEditorLayer, resetToggledGroupsAndObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::resetToggledGroupsAndObjects();
	}

	getWrapperOf(LevelEditorLayer, resetUnusedColorChannels, , 0) {
		return reinterpret_cast<D*>(this)->D::resetUnusedColorChannels();
	}

	getWrapperOf(LevelEditorLayer, rotationForSlopeNearObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::rotationForSlopeNearObject(p0);
	}

	getWrapperOf(LevelEditorLayer, runColorEffect, , 5, EffectGameObject*, int, float, float, bool) {
		return reinterpret_cast<D*>(this)->D::runColorEffect(p0, p1, p2, p3, p4);
	}

	getWrapperOf(LevelEditorLayer, scene, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::scene(p0);
	}

	getWrapperOf(LevelEditorLayer, setupLevelStart, , 1, LevelSettingsObject*) {
		return reinterpret_cast<D*>(this)->D::setupLevelStart(p0);
	}

	getWrapperOf(LevelEditorLayer, sortStickyGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::sortStickyGroups();
	}

	getWrapperOf(LevelEditorLayer, stopTriggersInGroup, , 2, int, float) {
		return reinterpret_cast<D*>(this)->D::stopTriggersInGroup(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool) {
		return reinterpret_cast<D*>(this)->D::toggleDualMode(p0, p1, p2, p3);
	}

	getWrapperOf(LevelEditorLayer, toggleGroupPreview, , 2, int, bool) {
		return reinterpret_cast<D*>(this)->D::toggleGroupPreview(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, transferDefaultColors, , 2, GJEffectManager*, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::transferDefaultColors(p0, p1);
	}

	getWrapperOf(LevelEditorLayer, undoLastAction, , 0) {
		return reinterpret_cast<D*>(this)->D::undoLastAction();
	}

	getWrapperOf(LevelEditorLayer, updateBGAndGColors, , 0) {
		return reinterpret_cast<D*>(this)->D::updateBGAndGColors();
	}

	getWrapperOf(LevelEditorLayer, updateBlendValues, , 0) {
		return reinterpret_cast<D*>(this)->D::updateBlendValues();
	}

	getWrapperOf(LevelEditorLayer, updateDualGround, , 3, PlayerObject*, int, bool) {
		return reinterpret_cast<D*>(this)->D::updateDualGround(p0, p1, p2);
	}

	getWrapperOf(LevelEditorLayer, updateEditorMode, , 0) {
		return reinterpret_cast<D*>(this)->D::updateEditorMode();
	}

	getWrapperOf(LevelEditorLayer, updateGameObjectsNew, , 0) {
		return reinterpret_cast<D*>(this)->D::updateGameObjectsNew();
	}

	getWrapperOf(LevelEditorLayer, updateGround, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateGround(p0);
	}

	getWrapperOf(LevelEditorLayer, updateGroundWidth, , 0) {
		return reinterpret_cast<D*>(this)->D::updateGroundWidth();
	}

	getWrapperOf(LevelEditorLayer, updateOptions, , 0) {
		return reinterpret_cast<D*>(this)->D::updateOptions();
	}

	getWrapperOf(LevelEditorLayer, updateToggledGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::updateToggledGroups();
	}

	getWrapperOf(LevelEditorLayer, updateVisibility, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateVisibility(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$LevelEditorLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$LevelEditorLayer::update) != (der1)(&D::update)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::updateWrapper)));
		}

		if ((mem2)(&$LevelEditorLayer::draw) != (der2)(&D::draw)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::drawWrapper)));
		}

		if ((mem3)(&$LevelEditorLayer::updateColor) != (der3)(&D::updateColor)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::updateColorWrapper)));
		}

		if ((mem4)(&$LevelEditorLayer::flipGravity) != (der4)(&D::flipGravity)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::flipGravityWrapper)));
		}

		if ((mem5)(&$LevelEditorLayer::calculateColorValues) != (der5)(&D::calculateColorValues)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::calculateColorValuesWrapper)));
		}

		if ((mem6)(&$LevelEditorLayer::addToGroup) != (der6)(&D::addToGroup)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::addToGroupWrapper)));
		}

		if ((mem7)(&$LevelEditorLayer::removeFromGroup) != (der7)(&D::removeFromGroup)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::removeFromGroupWrapper)));
		}

		if ((mem8)(&$LevelEditorLayer::timeForXPos) != (der8)(&D::timeForXPos)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::timeForXPosWrapper)));
		}

		if ((mem9)(&$LevelEditorLayer::xPosForTime) != (der9)(&D::xPosForTime)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::xPosForTimeWrapper)));
		}

		if ((mem10)(&$LevelEditorLayer::levelSettingsUpdated) != (der10)(&D::levelSettingsUpdated)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::levelSettingsUpdatedWrapper)));
		}

		if constexpr((mem11)(&$LevelEditorLayer::activateTriggerEffect) != (der11)(&D::activateTriggerEffect)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::activateTriggerEffectWrapper)));
		}

		if constexpr((mem12)(&$LevelEditorLayer::addObjectFromString) != (der12)(&D::addObjectFromString)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::addObjectFromStringWrapper)));
		}

		if constexpr((mem13)(&$LevelEditorLayer::addSpecial) != (der13)(&D::addSpecial)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::addSpecialWrapper)));
		}

		if constexpr((mem14)(&$LevelEditorLayer::addToRedoList) != (der14)(&D::addToRedoList)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::addToRedoListWrapper)));
		}

		if constexpr((mem15)(&$LevelEditorLayer::addToUndoList) != (der15)(&D::addToUndoList)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::addToUndoListWrapper)));
		}

		if constexpr((mem16)(&$LevelEditorLayer::animateInDualGround) != (der16)(&D::animateInDualGround)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::animateInDualGroundWrapper)));
		}

		if constexpr((mem17)(&$LevelEditorLayer::checkCollisions) != (der17)(&D::checkCollisions)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::checkCollisionsWrapper)));
		}

		if constexpr((mem18)(&$LevelEditorLayer::create) != (der18)(&D::create)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::createWrapper)));
		}

		if constexpr((mem19)(&$LevelEditorLayer::createBackground) != (der19)(&D::createBackground)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::createBackgroundWrapper)));
		}

		if constexpr((mem20)(&$LevelEditorLayer::createGroundLayer) != (der20)(&D::createGroundLayer)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::createGroundLayerWrapper)));
		}

		if constexpr((mem21)(&$LevelEditorLayer::createObject) != (der21)(&D::createObject)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::createObjectWrapper)));
		}

		if constexpr((mem22)(&$LevelEditorLayer::createObjectsFromSetup) != (der22)(&D::createObjectsFromSetup)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::createObjectsFromSetupWrapper)));
		}

		if constexpr((mem23)(&$LevelEditorLayer::createObjectsFromString) != (der23)(&D::createObjectsFromString)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::createObjectsFromStringWrapper)));
		}

		if constexpr((mem24)(&$LevelEditorLayer::getLastObjectX) != (der24)(&D::getLastObjectX)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::getLastObjectXWrapper)));
		}

		if constexpr((mem25)(&$LevelEditorLayer::getLevelString) != (der25)(&D::getLevelString)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::getLevelStringWrapper)));
		}

		if constexpr((mem26)(&$LevelEditorLayer::getNextColorChannel) != (der26)(&D::getNextColorChannel)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::getNextColorChannelWrapper)));
		}

		if constexpr((mem27)(&$LevelEditorLayer::getNextFreeBlockID) != (der27)(&D::getNextFreeBlockID)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::getNextFreeBlockIDWrapper)));
		}

		if constexpr((mem28)(&$LevelEditorLayer::getNextFreeGroupID) != (der28)(&D::getNextFreeGroupID)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::getNextFreeGroupIDWrapper)));
		}

		if constexpr((mem29)(&$LevelEditorLayer::getNextFreeItemID) != (der29)(&D::getNextFreeItemID)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::getNextFreeItemIDWrapper)));
		}

		if constexpr((mem30)(&$LevelEditorLayer::getObjectRect) != (der30)(&D::getObjectRect)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::getObjectRectWrapper)));
		}

		if constexpr((mem31)(&$LevelEditorLayer::getRelativeOffset) != (der31)(&D::getRelativeOffset)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::getRelativeOffsetWrapper)));
		}

		if constexpr((mem32)(&$LevelEditorLayer::handleAction) != (der32)(&D::handleAction)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::handleActionWrapper)));
		}

		if constexpr((mem33)(&$LevelEditorLayer::init) != (der33)(&D::init)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::initWrapper)));
		}

		if constexpr((mem34)(&$LevelEditorLayer::objectAtPosition) != (der34)(&D::objectAtPosition)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::objectAtPositionWrapper)));
		}

		if constexpr((mem35)(&$LevelEditorLayer::objectMoved) != (der35)(&D::objectMoved)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::objectMovedWrapper)));
		}

		if constexpr((mem36)(&$LevelEditorLayer::objectsInRect) != (der36)(&D::objectsInRect)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual((der36)(&D::objectsInRectWrapper)));
		}

		if constexpr((mem37)(&$LevelEditorLayer::onPlaytest) != (der37)(&D::onPlaytest)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::onPlaytestWrapper)));
		}

		if constexpr((mem38)(&$LevelEditorLayer::onStopPlaytest) != (der38)(&D::onStopPlaytest)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::onStopPlaytestWrapper)));
		}

		if constexpr((mem39)(&$LevelEditorLayer::playMusic) != (der39)(&D::playMusic)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::playMusicWrapper)));
		}

		if constexpr((mem40)(&$LevelEditorLayer::recreateGroups) != (der40)(&D::recreateGroups)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::recreateGroupsWrapper)));
		}

		if constexpr((mem41)(&$LevelEditorLayer::redoLastAction) != (der41)(&D::redoLastAction)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::redoLastActionWrapper)));
		}

		if constexpr((mem42)(&$LevelEditorLayer::removeAllObjects) != (der42)(&D::removeAllObjects)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::removeAllObjectsWrapper)));
		}

		if constexpr((mem43)(&$LevelEditorLayer::removeAllObjectsOfType) != (der43)(&D::removeAllObjectsOfType)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::removeAllObjectsOfTypeWrapper)));
		}

		if constexpr((mem44)(&$LevelEditorLayer::removeObject) != (der44)(&D::removeObject)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::removeObjectWrapper)));
		}

		if constexpr((mem45)(&$LevelEditorLayer::removeSpecial) != (der45)(&D::removeSpecial)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::removeSpecialWrapper)));
		}

		if constexpr((mem46)(&$LevelEditorLayer::resetMovingObjects) != (der46)(&D::resetMovingObjects)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::resetMovingObjectsWrapper)));
		}

		if constexpr((mem47)(&$LevelEditorLayer::resetObjectVector) != (der47)(&D::resetObjectVector)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::resetObjectVectorWrapper)));
		}

		if constexpr((mem48)(&$LevelEditorLayer::resetToggledGroups) != (der48)(&D::resetToggledGroups)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::resetToggledGroupsWrapper)));
		}

		if constexpr((mem49)(&$LevelEditorLayer::resetToggledGroupsAndObjects) != (der49)(&D::resetToggledGroupsAndObjects)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::resetToggledGroupsAndObjectsWrapper)));
		}

		if constexpr((mem50)(&$LevelEditorLayer::resetUnusedColorChannels) != (der50)(&D::resetUnusedColorChannels)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::resetUnusedColorChannelsWrapper)));
		}

		if constexpr((mem51)(&$LevelEditorLayer::rotationForSlopeNearObject) != (der51)(&D::rotationForSlopeNearObject)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::rotationForSlopeNearObjectWrapper)));
		}

		if constexpr((mem52)(&$LevelEditorLayer::runColorEffect) != (der52)(&D::runColorEffect)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::runColorEffectWrapper)));
		}

		if constexpr((mem53)(&$LevelEditorLayer::scene) != (der53)(&D::scene)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::sceneWrapper)));
		}

		if constexpr((mem54)(&$LevelEditorLayer::setupLevelStart) != (der54)(&D::setupLevelStart)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::setupLevelStartWrapper)));
		}

		if constexpr((mem55)(&$LevelEditorLayer::sortStickyGroups) != (der55)(&D::sortStickyGroups)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::sortStickyGroupsWrapper)));
		}

		if constexpr((mem56)(&$LevelEditorLayer::stopTriggersInGroup) != (der56)(&D::stopTriggersInGroup)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::stopTriggersInGroupWrapper)));
		}

		if constexpr((mem57)(&$LevelEditorLayer::toggleDualMode) != (der57)(&D::toggleDualMode)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::toggleDualModeWrapper)));
		}

		if constexpr((mem58)(&$LevelEditorLayer::toggleGroupPreview) != (der58)(&D::toggleGroupPreview)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::toggleGroupPreviewWrapper)));
		}

		if constexpr((mem59)(&$LevelEditorLayer::transferDefaultColors) != (der59)(&D::transferDefaultColors)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::transferDefaultColorsWrapper)));
		}

		if constexpr((mem60)(&$LevelEditorLayer::undoLastAction) != (der60)(&D::undoLastAction)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::undoLastActionWrapper)));
		}

		if constexpr((mem61)(&$LevelEditorLayer::updateBGAndGColors) != (der61)(&D::updateBGAndGColors)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::updateBGAndGColorsWrapper)));
		}

		if constexpr((mem62)(&$LevelEditorLayer::updateBlendValues) != (der62)(&D::updateBlendValues)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::updateBlendValuesWrapper)));
		}

		if constexpr((mem63)(&$LevelEditorLayer::updateDualGround) != (der63)(&D::updateDualGround)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::updateDualGroundWrapper)));
		}

		if constexpr((mem64)(&$LevelEditorLayer::updateEditorMode) != (der64)(&D::updateEditorMode)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::updateEditorModeWrapper)));
		}

		if constexpr((mem65)(&$LevelEditorLayer::updateGameObjectsNew) != (der65)(&D::updateGameObjectsNew)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::updateGameObjectsNewWrapper)));
		}

		if constexpr((mem66)(&$LevelEditorLayer::updateGround) != (der66)(&D::updateGround)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::updateGroundWrapper)));
		}

		if constexpr((mem67)(&$LevelEditorLayer::updateGroundWidth) != (der67)(&D::updateGroundWidth)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::updateGroundWidthWrapper)));
		}

		if constexpr((mem68)(&$LevelEditorLayer::updateOptions) != (der68)(&D::updateOptions)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::updateOptionsWrapper)));
		}

		if constexpr((mem69)(&$LevelEditorLayer::updateToggledGroups) != (der69)(&D::updateToggledGroups)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::updateToggledGroupsWrapper)));
		}

		if constexpr((mem70)(&$LevelEditorLayer::updateVisibility) != (der70)(&D::updateVisibility)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::updateVisibilityWrapper)));
		}

		return true;
	}
};

template<class D>
struct $LevelSettingsObject : LevelSettingsObject, InterfaceBase {
	$LevelSettingsObject(const $LevelSettingsObject& c) : LevelSettingsObject(c) {}
	$LevelSettingsObject() = delete;
	setInterfaceTypesOf(1, LevelSettingsObject, init, , 0);
	setInterfaceStaticTypesOf(2, LevelSettingsObject, create, , 0);
	setInterfaceTypesOf(3, LevelSettingsObject, objectFromDict, , 1, cocos2d::CCDictionary*);
	setInterfaceStaticTypesOf(4, LevelSettingsObject, objectFromString, , 1, gd::string);
	setInterfaceTypesOf(5, LevelSettingsObject, setupColorsFromLegacyMode, , 1, cocos2d::CCDictionary*);
	static inline auto address0 = base+0xa5650;
	static inline auto address1 = base+0xa5690;
	static inline auto address2 = base+0x92760;
	static inline auto address3 = base+0xa5810;
	static inline auto address4 = base+0x945a0;
	static inline auto address5 = base+0xa6a30;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(LevelSettingsObject, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable static getFunctionOf(LevelSettingsObject, create, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	dupable getFunctionOf(LevelSettingsObject, objectFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable static getFunctionOf(LevelSettingsObject, objectFromString, , 1, gd::string) {
		return reinterpret_cast<fun4>(address4)(p0);
	}

	dupable getFunctionOf(LevelSettingsObject, setupColorsFromLegacyMode, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(LevelSettingsObject, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	static getWrapperOf(LevelSettingsObject, create, , 0) {
		return D::create();
	}

	getWrapperOf(LevelSettingsObject, objectFromDict, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<D*>(this)->D::objectFromDict(p0);
	}

	static getWrapperOf(LevelSettingsObject, objectFromString, , 1, gd::string) {
		return D::objectFromString(p0);
	}

	getWrapperOf(LevelSettingsObject, setupColorsFromLegacyMode, , 1, cocos2d::CCDictionary*) {
		return reinterpret_cast<D*>(this)->D::setupColorsFromLegacyMode(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$LevelSettingsObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$LevelSettingsObject::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$LevelSettingsObject::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		if constexpr((mem3)(&$LevelSettingsObject::objectFromDict) != (der3)(&D::objectFromDict)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::objectFromDictWrapper)));
		}

		if constexpr((mem4)(&$LevelSettingsObject::objectFromString) != (der4)(&D::objectFromString)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::objectFromStringWrapper)));
		}

		if constexpr((mem5)(&$LevelSettingsObject::setupColorsFromLegacyMode) != (der5)(&D::setupColorsFromLegacyMode)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::setupColorsFromLegacyModeWrapper)));
		}

		return true;
	}
};

template<class D>
struct $LocalLevelManager : LocalLevelManager, InterfaceBase {
	$LocalLevelManager(const $LocalLevelManager& c) : LocalLevelManager(c) {}
	$LocalLevelManager() = delete;
	setInterfaceStaticTypesOf(0, LocalLevelManager, sharedState, , 0);
	static inline auto address0 = base+0x35dd60;

	dupable static getFunctionOf(LocalLevelManager, sharedState, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	static getWrapperOf(LocalLevelManager, sharedState, , 0) {
		return D::sharedState();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$LocalLevelManager::sharedState) != (der0)(&D::sharedState)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::sharedStateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $MenuGameLayer : MenuGameLayer, InterfaceBase {
	$MenuGameLayer(const $MenuGameLayer& c) : MenuGameLayer(c) {}
	$MenuGameLayer() = delete;
	setInterfaceTypesOf(0, MenuGameLayer, resetPlayer, , 0);
	setInterfaceTypesOf(1, MenuGameLayer, update, , 1, float);
	static inline auto address0 = base+0x28fdc0;
	static inline auto address1 = base+0x28fa70;

	dupable getFunctionOf(MenuGameLayer, resetPlayer, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(MenuGameLayer, update, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	getWrapperOf(MenuGameLayer, resetPlayer, , 0) {
		return reinterpret_cast<D*>(this)->D::resetPlayer();
	}

	getWrapperOf(MenuGameLayer, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$MenuGameLayer::resetPlayer) != (der0)(&D::resetPlayer)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::resetPlayerWrapper)));
		}

		if constexpr((mem1)(&$MenuGameLayer::update) != (der1)(&D::update)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::updateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $MenuLayer : MenuLayer, InterfaceBase {
	$MenuLayer(const $MenuLayer& c) : MenuLayer(c) {}
	$MenuLayer() = delete;
	setInterfaceTypesOf(1, MenuLayer, init, , 0);
	setInterfaceTypesOf(2, MenuLayer, keyBackClicked, , 0);
	setInterfaceTypesOf(3, MenuLayer, keyDown, , 1, cocos2d::enumKeyCodes);
	setInterfaceTypesOf(4, MenuLayer, googlePlaySignedIn, , 0);
	setInterfaceTypesOf(5, MenuLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool);
	setInterfaceTypesOf(6, MenuLayer, onMoreGames, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(7, MenuLayer, onQuit, , 1, cocos2d::CCObject*);
	setInterfaceStaticTypesOf(8, MenuLayer, scene, , 1, bool);
	static inline auto address0 = base+0x1d1230;
	static inline auto address1 = base+0x1d14b0;
	static inline auto address2 = base+0x1d3160;
	static inline auto address3 = base+0x1d33d0;
	static inline auto address4 = base+0x1d2f30;
	static inline auto address5 = base+0x1d3190;
	static inline auto address6 = base+0x1d2ad0;
	static inline auto address7 = base+0x1d2b40;
	static inline auto address8 = base+0x1d12d0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(MenuLayer, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(MenuLayer, keyBackClicked, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(MenuLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(MenuLayer, googlePlaySignedIn, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	dupable getFunctionOf(MenuLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool) {
		return reinterpret_cast<fun5>(address5)(this, p0, p1);
	}

	dupable getFunctionOf(MenuLayer, onMoreGames, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(MenuLayer, onQuit, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable static getFunctionOf(MenuLayer, scene, , 1, bool) {
		return reinterpret_cast<fun8>(address8)(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(MenuLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(MenuLayer, keyBackClicked, , 0) {
		return reinterpret_cast<D*>(this)->D::keyBackClicked();
	}

	getWrapperOf(MenuLayer, keyDown, , 1, cocos2d::enumKeyCodes) {
		return reinterpret_cast<D*>(this)->D::keyDown(p0);
	}

	getWrapperOf(MenuLayer, googlePlaySignedIn, , 0) {
		return reinterpret_cast<D*>(this)->D::googlePlaySignedIn();
	}

	getWrapperOf(MenuLayer, FLAlert_Clicked, , 2, FLAlertLayer*, bool) {
		return reinterpret_cast<D*>(this)->D::FLAlert_Clicked(p0, p1);
	}

	getWrapperOf(MenuLayer, onMoreGames, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onMoreGames(p0);
	}

	getWrapperOf(MenuLayer, onQuit, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onQuit(p0);
	}

	static getWrapperOf(MenuLayer, scene, , 1, bool) {
		return D::scene(p0);
	}

public:
	static bool _apply() {

		if constexpr(&$MenuLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$MenuLayer::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if ((mem2)(&$MenuLayer::keyBackClicked) != (der2)(&D::keyBackClicked)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::keyBackClickedWrapper)));
		}

		if ((mem3)(&$MenuLayer::keyDown) != (der3)(&D::keyDown)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::keyDownWrapper)));
		}

		if ((mem4)(&$MenuLayer::googlePlaySignedIn) != (der4)(&D::googlePlaySignedIn)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::googlePlaySignedInWrapper)));
		}

		if ((mem5)(&$MenuLayer::FLAlert_Clicked) != (der5)(&D::FLAlert_Clicked)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::FLAlert_ClickedWrapper)));
		}

		if constexpr((mem6)(&$MenuLayer::onMoreGames) != (der6)(&D::onMoreGames)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::onMoreGamesWrapper)));
		}

		if constexpr((mem7)(&$MenuLayer::onQuit) != (der7)(&D::onQuit)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::onQuitWrapper)));
		}

		if constexpr((mem8)(&$MenuLayer::scene) != (der8)(&D::scene)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::sceneWrapper)));
		}

		return true;
	}
};

template<class D>
struct $MoreVideoOptionsLayer : MoreVideoOptionsLayer, InterfaceBase {
	$MoreVideoOptionsLayer(const $MoreVideoOptionsLayer& c) : MoreVideoOptionsLayer(c) {}
	$MoreVideoOptionsLayer() = delete;
	setInterfaceStaticTypesOf(0, MoreVideoOptionsLayer, create, , 0);
	setInterfaceTypesOf(1, MoreVideoOptionsLayer, init, , 0);
	static inline auto address0 = base+0x443c10;
	static inline auto address1 = base+0x444150;

	dupable static getFunctionOf(MoreVideoOptionsLayer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(MoreVideoOptionsLayer, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	static getWrapperOf(MoreVideoOptionsLayer, create, , 0) {
		return D::create();
	}

	getWrapperOf(MoreVideoOptionsLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$MoreVideoOptionsLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$MoreVideoOptionsLayer::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		return true;
	}
};

template<class D>
struct $MusicDownloadManager : MusicDownloadManager, InterfaceBase {
	$MusicDownloadManager(const $MusicDownloadManager& c) : MusicDownloadManager(c) {}
	$MusicDownloadManager() = delete;
	setInterfaceTypesOf(0, MusicDownloadManager, incrementPriorityForSong, , 1, int);
	setInterfaceStaticTypesOf(1, MusicDownloadManager, sharedState, , 0);
	static inline auto address0 = base+0x2ef750;
	static inline auto address1 = base+0x2ee4c0;

	dupable getFunctionOf(MusicDownloadManager, incrementPriorityForSong, , 1, int) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable static getFunctionOf(MusicDownloadManager, sharedState, , 0) {
		return reinterpret_cast<fun1>(address1)();
	}

	getWrapperOf(MusicDownloadManager, incrementPriorityForSong, , 1, int) {
		return reinterpret_cast<D*>(this)->D::incrementPriorityForSong(p0);
	}

	static getWrapperOf(MusicDownloadManager, sharedState, , 0) {
		return D::sharedState();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$MusicDownloadManager::incrementPriorityForSong) != (der0)(&D::incrementPriorityForSong)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::incrementPriorityForSongWrapper)));
		}

		if constexpr((mem1)(&$MusicDownloadManager::sharedState) != (der1)(&D::sharedState)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::sharedStateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $OBB2D : OBB2D, InterfaceBase {
	$OBB2D(const $OBB2D& c) : OBB2D(c) {}
	$OBB2D() = delete;
	setInterfaceTypesOf(0, OBB2D, calculateWithCenter, , 4, cocos2d::CCPoint, float, float, float);
	setInterfaceStaticTypesOf(1, OBB2D, create, , 4, cocos2d::CCPoint, float, float, float);
	setInterfaceTypesOf(2, OBB2D, getBoundingRect, , 0);
	setInterfaceTypesOf(3, OBB2D, overlaps, , 1, OBB2D*);
	setInterfaceTypesOf(4, OBB2D, overlaps1Way, , 1, OBB2D*);
	static inline auto address0 = base+0x35a9c0;
	static inline auto address1 = base+0x35a890;
	static inline auto address2 = base+0x35b2b0;
	static inline auto address3 = base+0x35b0a0;
	static inline auto address4 = base+0x35b0d0;

	dupable getFunctionOf(OBB2D, calculateWithCenter, , 4, cocos2d::CCPoint, float, float, float) {
		return reinterpret_cast<fun0>(address0)(this, p0, p1, p2, p3);
	}

	dupable static getFunctionOf(OBB2D, create, , 4, cocos2d::CCPoint, float, float, float) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2, p3);
	}

	dupable getFunctionOf(OBB2D, getBoundingRect, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(OBB2D, overlaps, , 1, OBB2D*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(OBB2D, overlaps1Way, , 1, OBB2D*) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	getWrapperOf(OBB2D, calculateWithCenter, , 4, cocos2d::CCPoint, float, float, float) {
		return reinterpret_cast<D*>(this)->D::calculateWithCenter(p0, p1, p2, p3);
	}

	static getWrapperOf(OBB2D, create, , 4, cocos2d::CCPoint, float, float, float) {
		return D::create(p0, p1, p2, p3);
	}

	getWrapperOf(OBB2D, getBoundingRect, , 0) {
		return reinterpret_cast<D*>(this)->D::getBoundingRect();
	}

	getWrapperOf(OBB2D, overlaps, , 1, OBB2D*) {
		return reinterpret_cast<D*>(this)->D::overlaps(p0);
	}

	getWrapperOf(OBB2D, overlaps1Way, , 1, OBB2D*) {
		return reinterpret_cast<D*>(this)->D::overlaps1Way(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$OBB2D::calculateWithCenter) != (der0)(&D::calculateWithCenter)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::calculateWithCenterWrapper)));
		}

		if constexpr((mem1)(&$OBB2D::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$OBB2D::getBoundingRect) != (der2)(&D::getBoundingRect)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getBoundingRectWrapper)));
		}

		if constexpr((mem3)(&$OBB2D::overlaps) != (der3)(&D::overlaps)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::overlapsWrapper)));
		}

		if constexpr((mem4)(&$OBB2D::overlaps1Way) != (der4)(&D::overlaps1Way)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::overlaps1WayWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ObjectToolbox : ObjectToolbox, InterfaceBase {
	$ObjectToolbox(const $ObjectToolbox& c) : ObjectToolbox(c) {}
	$ObjectToolbox() = delete;
	setInterfaceTypesOf(0, ObjectToolbox, init, , 0);
	setInterfaceTypesOf(1, ObjectToolbox, intKeyToFrame, , 1, int);
	setInterfaceStaticTypesOf(2, ObjectToolbox, sharedState, , 0);
	static inline auto address0 = base+0x3b2d80;
	static inline auto address1 = base+0x4173b0;
	static inline auto address2 = base+0x3b2bc0;

	dupable getFunctionOf(ObjectToolbox, init, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(ObjectToolbox, intKeyToFrame, , 1, int) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable static getFunctionOf(ObjectToolbox, sharedState, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	getWrapperOf(ObjectToolbox, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(ObjectToolbox, intKeyToFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::intKeyToFrame(p0);
	}

	static getWrapperOf(ObjectToolbox, sharedState, , 0) {
		return D::sharedState();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ObjectToolbox::init) != (der0)(&D::init)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::initWrapper)));
		}

		if constexpr((mem1)(&$ObjectToolbox::intKeyToFrame) != (der1)(&D::intKeyToFrame)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::intKeyToFrameWrapper)));
		}

		if constexpr((mem2)(&$ObjectToolbox::sharedState) != (der2)(&D::sharedState)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::sharedStateWrapper)));
		}

		return true;
	}
};

template<class D>
struct $OpacityEffectAction : OpacityEffectAction, InterfaceBase {
	$OpacityEffectAction(const $OpacityEffectAction& c) : OpacityEffectAction(c) {}
	$OpacityEffectAction() = delete;
	setInterfaceStaticTypesOf(0, OpacityEffectAction, create, , 4, float, float, float, int);
	setInterfaceStaticTypesOf(1, OpacityEffectAction, createFromString, , 1, gd::string);
	setInterfaceTypesOf(2, OpacityEffectAction, init, , 4, float, float, float, int);
	setInterfaceTypesOf(3, OpacityEffectAction, step, , 1, float);
	static inline auto address0 = base+0x1789f0;
	static inline auto address1 = base+0x178c10;
	static inline auto address2 = base+0x178b00;
	static inline auto address3 = base+0x178b90;

	dupable static getFunctionOf(OpacityEffectAction, create, , 4, float, float, float, int) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3);
	}

	dupable static getFunctionOf(OpacityEffectAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun1>(address1)(p0);
	}

	dupable getFunctionOf(OpacityEffectAction, init, , 4, float, float, float, int) {
		return reinterpret_cast<fun2>(address2)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(OpacityEffectAction, step, , 1, float) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	static getWrapperOf(OpacityEffectAction, create, , 4, float, float, float, int) {
		return D::create(p0, p1, p2, p3);
	}

	static getWrapperOf(OpacityEffectAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

	getWrapperOf(OpacityEffectAction, init, , 4, float, float, float, int) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2, p3);
	}

	getWrapperOf(OpacityEffectAction, step, , 1, float) {
		return reinterpret_cast<D*>(this)->D::step(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$OpacityEffectAction::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$OpacityEffectAction::createFromString) != (der1)(&D::createFromString)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createFromStringWrapper)));
		}

		if constexpr((mem2)(&$OpacityEffectAction::init) != (der2)(&D::init)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::initWrapper)));
		}

		if constexpr((mem3)(&$OpacityEffectAction::step) != (der3)(&D::step)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::stepWrapper)));
		}

		return true;
	}
};

template<class D>
struct $PauseLayer : PauseLayer, InterfaceBase {
	$PauseLayer(const $PauseLayer& c) : PauseLayer(c) {}
	$PauseLayer() = delete;
	setInterfaceStaticTypesOf(0, PauseLayer, create, , 1, bool);
	setInterfaceTypesOf(1, PauseLayer, onEdit, , 1, cocos2d::CCObject*);
	static inline auto address0 = base+0x20b1e0;
	static inline auto address1 = base+0x20c630;

	dupable static getFunctionOf(PauseLayer, create, , 1, bool) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(PauseLayer, onEdit, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	static getWrapperOf(PauseLayer, create, , 1, bool) {
		return D::create(p0);
	}

	getWrapperOf(PauseLayer, onEdit, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onEdit(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$PauseLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$PauseLayer::onEdit) != (der1)(&D::onEdit)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onEditWrapper)));
		}

		return true;
	}
};

template<class D>
struct $PlatformToolbox : PlatformToolbox, InterfaceBase {
	$PlatformToolbox(const $PlatformToolbox& c) : PlatformToolbox(c) {}
	$PlatformToolbox() = delete;
	setInterfaceTypesOf(0, PlatformToolbox, hideCursor, , 0);
	setInterfaceTypesOf(1, PlatformToolbox, showCursor, , 0);
	static inline auto address0 = base+0x27c340;
	static inline auto address1 = base+0x27c360;

	dupable getFunctionOf(PlatformToolbox, hideCursor, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	dupable getFunctionOf(PlatformToolbox, showCursor, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	getWrapperOf(PlatformToolbox, hideCursor, , 0) {
		return reinterpret_cast<D*>(this)->D::hideCursor();
	}

	getWrapperOf(PlatformToolbox, showCursor, , 0) {
		return reinterpret_cast<D*>(this)->D::showCursor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$PlatformToolbox::hideCursor) != (der0)(&D::hideCursor)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::hideCursorWrapper)));
		}

		if constexpr((mem1)(&$PlatformToolbox::showCursor) != (der1)(&D::showCursor)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::showCursorWrapper)));
		}

		return true;
	}
};

template<class D>
struct $PlayLayer : PlayLayer, InterfaceBase {
	$PlayLayer(const $PlayLayer& c) : PlayLayer(c) {}
	$PlayLayer() = delete;
	setInterfaceTypesOf(0, PlayLayer, addCircle, , 1, CCCircleWave*);
	setInterfaceTypesOf(1, PlayLayer, addObject, , 1, GameObject*);
	setInterfaceTypesOf(2, PlayLayer, addToGroupOld, , 1, GameObject*);
	setInterfaceTypesOf(3, PlayLayer, addToSpeedObjects, , 1, GameObject*);
	setInterfaceTypesOf(4, PlayLayer, animateInDualGround, , 3, GameObject*, float, bool);
	setInterfaceTypesOf(5, PlayLayer, animateInGround, , 1, bool);
	setInterfaceTypesOf(6, PlayLayer, animateOutGround, , 1, bool);
	setInterfaceTypesOf(7, PlayLayer, animateOutGroundFinished, , 0);
	setInterfaceTypesOf(8, PlayLayer, applyEnterEffect, , 1, GameObject*);
	setInterfaceTypesOf(9, PlayLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*);
	setInterfaceTypesOf(10, PlayLayer, cameraMoveX, , 3, float, float, float);
	setInterfaceTypesOf(11, PlayLayer, cameraMoveY, , 3, float, float, float);
	setInterfaceTypesOf(12, PlayLayer, checkCollisions, , 2, PlayerObject*, float);
	setInterfaceTypesOf(13, PlayLayer, circleWaveWillBeRemoved, , 1, CCCircleWave*);
	setInterfaceTypesOf(14, PlayLayer, claimParticle, , 1, gd::string);
	setInterfaceTypesOf(15, PlayLayer, clearPickedUpItems, , 0);
	setInterfaceTypesOf(16, PlayLayer, colorObject, , 2, int, cocos2d::_ccColor3B);
	setInterfaceTypesOf(17, PlayLayer, commitJumps, , 0);
	setInterfaceStaticTypesOf(18, PlayLayer, create, , 1, GJGameLevel*);
	setInterfaceTypesOf(19, PlayLayer, createCheckpoint, , 0);
	setInterfaceTypesOf(20, PlayLayer, createObjectsFromSetup, , 1, gd::string);
	setInterfaceTypesOf(21, PlayLayer, createParticle, , 4, int, char const*, int, cocos2d::tCCPositionType);
	setInterfaceTypesOf(22, PlayLayer, currencyWillExit, , 1, CurrencyRewardLayer*);
	setInterfaceTypesOf(23, PlayLayer, delayedResetLevel, , 0);
	setInterfaceTypesOf(24, PlayLayer, destroyPlayer, , 2, PlayerObject*, GameObject*);
	setInterfaceTypesOf(25, PlayLayer, dialogClosed, , 1, DialogLayer*);
	setInterfaceTypesOf(26, PlayLayer, draw, , 0);
	setInterfaceTypesOf(27, PlayLayer, enterDualMode, , 2, GameObject*, bool);
	setInterfaceTypesOf(28, PlayLayer, exitAirMode, , 0);
	setInterfaceTypesOf(29, PlayLayer, exitBirdMode, , 1, PlayerObject*);
	setInterfaceTypesOf(30, PlayLayer, exitDartMode, , 1, PlayerObject*);
	setInterfaceTypesOf(31, PlayLayer, exitFlyMode, , 1, PlayerObject*);
	setInterfaceTypesOf(32, PlayLayer, exitRobotMode, , 1, PlayerObject*);
	setInterfaceTypesOf(33, PlayLayer, exitRollMode, , 1, PlayerObject*);
	setInterfaceTypesOf(34, PlayLayer, exitSpiderMode, , 1, PlayerObject*);
	setInterfaceTypesOf(35, PlayLayer, flipFinished, , 0);
	setInterfaceTypesOf(36, PlayLayer, flipGravity, , 3, PlayerObject*, bool, bool);
	setInterfaceTypesOf(37, PlayLayer, flipObjects, , 0);
	setInterfaceTypesOf(38, PlayLayer, fullReset, , 0);
	setInterfaceTypesOf(39, PlayLayer, getLastCheckpoint, , 0);
	setInterfaceTypesOf(40, PlayLayer, getMaxPortalY, , 0);
	setInterfaceTypesOf(41, PlayLayer, getMinPortalY, , 0);
	setInterfaceTypesOf(42, PlayLayer, getObjectsState, , 0);
	setInterfaceTypesOf(43, PlayLayer, getOtherPlayer, , 1, PlayerObject*);
	setInterfaceTypesOf(44, PlayLayer, getParticleKey, , 4, int, char const*, int, cocos2d::tCCPositionType);
	setInterfaceTypesOf(45, PlayLayer, getParticleKey2, , 1, gd::string);
	setInterfaceTypesOf(46, PlayLayer, getRelativeMod, , 4, cocos2d::CCPoint, float, float, float);
	setInterfaceTypesOf(47, PlayLayer, getTempMilliTime, , 0);
	setInterfaceTypesOf(48, PlayLayer, gravityEffectFinished, , 0);
	setInterfaceTypesOf(49, PlayLayer, hasItem, , 1, int);
	setInterfaceTypesOf(50, PlayLayer, hasUniqueCoin, , 1, GameObject*);
	setInterfaceTypesOf(51, PlayLayer, incrementJumps, , 0);
	setInterfaceTypesOf(52, PlayLayer, init, , 1, GJGameLevel*);
	setInterfaceTypesOf(53, PlayLayer, isFlipping, , 0);
	setInterfaceTypesOf(54, PlayLayer, levelComplete, , 0);
	setInterfaceTypesOf(55, PlayLayer, lightningFlash, , 8, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float);
	setInterfaceTypesOf(56, PlayLayer, lightningFlash, , 2, cocos2d::CCPoint, cocos2d::_ccColor3B);
	setInterfaceTypesOf(57, PlayLayer, loadDefaultColors, , 0);
	setInterfaceTypesOf(58, PlayLayer, loadFromCheckpoint, , 1, CheckpointObject*);
	setInterfaceTypesOf(59, PlayLayer, loadLastCheckpoint, , 0);
	setInterfaceTypesOf(60, PlayLayer, loadSavedObjectsState, , 1, gd::string);
	setInterfaceTypesOf(61, PlayLayer, markCheckpoint, , 0);
	setInterfaceTypesOf(62, PlayLayer, moveCameraToPos, , 1, cocos2d::CCPoint);
	setInterfaceTypesOf(63, PlayLayer, onEnterTransitionDidFinish, , 0);
	setInterfaceTypesOf(64, PlayLayer, onExit, , 0);
	setInterfaceTypesOf(65, PlayLayer, onQuit, , 0);
	setInterfaceTypesOf(66, PlayLayer, optimizeColorGroups, , 0);
	setInterfaceTypesOf(67, PlayLayer, optimizeOpacityGroups, , 0);
	setInterfaceTypesOf(68, PlayLayer, optimizeSaveRequiredGroups, , 0);
	setInterfaceTypesOf(69, PlayLayer, pauseGame, , 1, bool);
	setInterfaceTypesOf(70, PlayLayer, pickupItem, , 1, GameObject*);
	setInterfaceTypesOf(71, PlayLayer, playAnimationCommand, , 2, int, int);
	setInterfaceTypesOf(72, PlayLayer, playEndAnimationToPos, , 1, cocos2d::CCPoint);
	setInterfaceTypesOf(73, PlayLayer, playExitDualEffect, , 1, PlayerObject*);
	setInterfaceTypesOf(74, PlayLayer, playFlashEffect, , 3, float, int, float);
	setInterfaceTypesOf(75, PlayLayer, playGravityEffect, , 1, bool);
	setInterfaceTypesOf(76, PlayLayer, playSpeedParticle, , 1, float);
	setInterfaceTypesOf(77, PlayLayer, playerWillSwitchMode, , 2, PlayerObject*, GameObject*);
	setInterfaceTypesOf(78, PlayLayer, prepareSpawnObjects, , 0);
	setInterfaceTypesOf(79, PlayLayer, processItems, , 0);
	setInterfaceTypesOf(80, PlayLayer, processLoadedMoveActions, , 0);
	setInterfaceTypesOf(81, PlayLayer, recordAction, , 2, bool, PlayerObject*);
	setInterfaceTypesOf(82, PlayLayer, registerActiveObject, , 1, GameObject*);
	setInterfaceTypesOf(83, PlayLayer, registerStateObject, , 1, GameObject*);
	setInterfaceTypesOf(84, PlayLayer, removeAllObjects, , 0);
	setInterfaceTypesOf(85, PlayLayer, removeFromGroupOld, , 1, GameObject*);
	setInterfaceTypesOf(86, PlayLayer, removeLastCheckpoint, , 0);
	setInterfaceTypesOf(87, PlayLayer, removePlayer2, , 0);
	setInterfaceTypesOf(88, PlayLayer, resetLevel, , 0);
	setInterfaceTypesOf(89, PlayLayer, resume, , 0);
	setInterfaceTypesOf(90, PlayLayer, resumeAndRestart, , 0);
	setInterfaceTypesOf(91, PlayLayer, saveRecordAction, , 2, bool, PlayerObject*);
	setInterfaceTypesOf(92, PlayLayer, scene, , 1, GJGameLevel*);
	setInterfaceTypesOf(93, PlayLayer, setupLevelStart, , 1, LevelSettingsObject*);
	setInterfaceTypesOf(94, PlayLayer, setupReplay, , 1, gd::string);
	setInterfaceTypesOf(95, PlayLayer, shakeCamera, , 3, float, float, float);
	setInterfaceTypesOf(96, PlayLayer, shouldBlend, , 1, int);
	setInterfaceTypesOf(97, PlayLayer, showCompleteEffect, , 0);
	setInterfaceTypesOf(98, PlayLayer, showCompleteText, , 0);
	setInterfaceTypesOf(99, PlayLayer, showEndLayer, , 0);
	setInterfaceTypesOf(100, PlayLayer, showHint, , 0);
	setInterfaceTypesOf(101, PlayLayer, showNewBest, , 6, bool, int, int, bool, bool, bool);
	setInterfaceTypesOf(102, PlayLayer, showRetryLayer, , 0);
	setInterfaceTypesOf(103, PlayLayer, showTwoPlayerGuide, , 0);
	setInterfaceTypesOf(104, PlayLayer, sortGroups, , 0);
	setInterfaceTypesOf(105, PlayLayer, spawnCircle, , 0);
	setInterfaceTypesOf(106, PlayLayer, spawnFirework, , 0);
	setInterfaceTypesOf(107, PlayLayer, spawnParticle, , 4, char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint);
	setInterfaceTypesOf(108, PlayLayer, spawnPlayer2, , 0);
	setInterfaceTypesOf(109, PlayLayer, startGame, , 0);
	setInterfaceTypesOf(110, PlayLayer, startMusic, , 0);
	setInterfaceTypesOf(111, PlayLayer, startRecording, , 0);
	setInterfaceTypesOf(112, PlayLayer, startRecordingDelayed, , 0);
	setInterfaceTypesOf(113, PlayLayer, stopCameraShake, , 0);
	setInterfaceTypesOf(114, PlayLayer, stopRecording, , 0);
	setInterfaceTypesOf(115, PlayLayer, storeCheckpoint, , 1, CheckpointObject*);
	setInterfaceTypesOf(116, PlayLayer, switchToFlyMode, , 4, PlayerObject*, GameObject*, bool, int);
	setInterfaceTypesOf(117, PlayLayer, switchToRobotMode, , 3, PlayerObject*, GameObject*, bool);
	setInterfaceTypesOf(118, PlayLayer, switchToRollMode, , 3, PlayerObject*, GameObject*, bool);
	setInterfaceTypesOf(119, PlayLayer, switchToSpiderMode, , 3, PlayerObject*, GameObject*, bool);
	setInterfaceTypesOf(120, PlayLayer, timeForXPos, , 1, float);
	setInterfaceTypesOf(121, PlayLayer, timeForXPos2, , 2, float, bool);
	setInterfaceTypesOf(122, PlayLayer, toggleBGEffectVisibility, , 1, bool);
	setInterfaceTypesOf(123, PlayLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool);
	setInterfaceTypesOf(124, PlayLayer, toggleFlipped, , 2, bool, bool);
	setInterfaceTypesOf(125, PlayLayer, toggleGhostEffect, , 1, int);
	setInterfaceTypesOf(126, PlayLayer, toggleGlitter, , 1, bool);
	setInterfaceTypesOf(127, PlayLayer, togglePracticeMode, , 1, bool);
	setInterfaceTypesOf(128, PlayLayer, toggleProgressbar, , 0);
	setInterfaceTypesOf(129, PlayLayer, tryStartRecord, , 0);
	setInterfaceTypesOf(130, PlayLayer, unclaimParticle, , 2, char const*, cocos2d::CCParticleSystemQuad*);
	setInterfaceTypesOf(131, PlayLayer, unregisterActiveObject, , 1, GameObject*);
	setInterfaceTypesOf(132, PlayLayer, unregisterStateObject, , 1, GameObject*);
	setInterfaceTypesOf(133, PlayLayer, update, , 1, float);
	setInterfaceTypesOf(134, PlayLayer, updateAttempts, , 0);
	setInterfaceTypesOf(135, PlayLayer, updateCamera, , 1, float);
	setInterfaceTypesOf(136, PlayLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*);
	setInterfaceTypesOf(137, PlayLayer, updateDualGround, , 3, PlayerObject*, int, bool);
	setInterfaceTypesOf(138, PlayLayer, updateEffectPositions, , 0);
	setInterfaceTypesOf(139, PlayLayer, updateLevelColors, , 0);
	setInterfaceTypesOf(140, PlayLayer, updateMoveObjectsLastPosition, , 0);
	setInterfaceTypesOf(141, PlayLayer, updateProgressbar, , 0);
	setInterfaceTypesOf(142, PlayLayer, updateReplay, , 1, float);
	setInterfaceTypesOf(143, PlayLayer, updateTimeMod, , 2, float, bool);
	setInterfaceTypesOf(144, PlayLayer, updateTweenAction, , 2, float, char const*);
	setInterfaceTypesOf(145, PlayLayer, updateVisibility, , 0);
	setInterfaceTypesOf(146, PlayLayer, vfDChk, , 0);
	setInterfaceTypesOf(147, PlayLayer, visit, , 0);
	setInterfaceTypesOf(148, PlayLayer, visitWithColorFlash, , 0);
	setInterfaceTypesOf(149, PlayLayer, willSwitchToMode, , 2, int, PlayerObject*);
	setInterfaceTypesOf(150, PlayLayer, xPosForTime, , 1, float);
	static inline auto address0 = base+0x7e0f0;
	static inline auto address1 = base+0x70e50;
	static inline auto address2 = base+0x77680;
	static inline auto address3 = base+0x7cfc0;
	static inline auto address4 = base+0x7d710;
	static inline auto address5 = base+0x7d9d0;
	static inline auto address6 = base+0x6f350;
	static inline auto address7 = base+0x7de80;
	static inline auto address8 = base+0x7c310;
	static inline auto address9 = base+0x7aa10;
	static inline auto address10 = base+0x7cbe0;
	static inline auto address11 = base+0x7cc60;
	static inline auto address12 = base+0x78c90;
	static inline auto address13 = base+0x7e110;
	static inline auto address14 = base+0x76ba0;
	static inline auto address15 = base+0x7cfa0;
	static inline auto address16 = base+0x77810;
	static inline auto address17 = base+0x737e0;
	static inline auto address18 = base+0x6b590;
	static inline auto address19 = base+0x7e470;
	static inline auto address20 = base+0x6d130;
	static inline auto address21 = base+0x76800;
	static inline auto address22 = base+0x7e070;
	static inline auto address23 = base+0x7e050;
	static inline auto address24 = base+0x7ab80;
	static inline auto address25 = base+0x7e0b0;
	static inline auto address26 = base+0x7d160;
	static inline auto address27 = base+0x7d6a0;
	static inline auto address28 = base+0x7dd40;
	static inline auto address29 = base+0x7dd80;
	static inline auto address30 = base+0x7ddd0;
	static inline auto address31 = base+0x7dcf0;
	static inline auto address32 = base+0x7de20;
	static inline auto address33 = base+0x7de60;
	static inline auto address34 = base+0x7de40;
	static inline auto address35 = base+0x7e150;
	static inline auto address36 = base+0x7cd10;
	static inline auto address37 = base+0x76130;
	static inline auto address38 = base+0x7f8e0;
	static inline auto address39 = base+0x7f840;
	static inline auto address40 = base+0x7b4e0;
	static inline auto address41 = base+0x7b550;
	static inline auto address42 = base+0x7e9d0;
	static inline auto address43 = base+0x7dcc0;
	static inline auto address44 = base+0x764d0;
	static inline auto address45 = base+0x767b0;
	static inline auto address46 = base+0x7c2a0;
	static inline auto address47 = base+0x778e0;
	static inline auto address48 = base+0x7cec0;
	static inline auto address49 = base+0x7cee0;
	static inline auto address50 = base+0x77510;
	static inline auto address51 = base+0x7ff40;
	static inline auto address52 = base+0x6b5f0;
	static inline auto address53 = base+0x76100;
	static inline auto address54 = base+0x72b80;
	static inline auto address55 = base+0x75cc0;
	static inline auto address56 = base+0x75bf0;
	static inline auto address57 = base+0x6ef30;
	static inline auto address58 = base+0x7f000;
	static inline auto address59 = base+0x7efc0;
	static inline auto address60 = base+0x7f3d0;
	static inline auto address61 = base+0x7ef60;
	static inline auto address62 = base+0x7c980;
	static inline auto address63 = base+0x806e0;
	static inline auto address64 = base+0x80710;
	static inline auto address65 = base+0x72710;
	static inline auto address66 = base+0x6dad0;
	static inline auto address67 = base+0x6dc20;
	static inline auto address68 = base+0x6dd70;
	static inline auto address69 = base+0x802d0;
	static inline auto address70 = base+0x7c1d0;
	static inline auto address71 = base+0x75930;
	static inline auto address72 = base+0x759a0;
	static inline auto address73 = base+0x7d1d0;
	static inline auto address74 = base+0x75e50;
	static inline auto address75 = base+0x7b5a0;
	static inline auto address76 = base+0x77030;
	static inline auto address77 = base+0x7b820;
	static inline auto address78 = base+0x7fc00;
	static inline auto address79 = base+0x735c0;
	static inline auto address80 = base+0x7a7c0;
	static inline auto address81 = base+0x7e190;
	static inline auto address82 = base+0x77620;
	static inline auto address83 = base+0x777b0;
	static inline auto address84 = base+0x727b0;
	static inline auto address85 = base+0x77750;
	static inline auto address86 = base+0x7f870;
	static inline auto address87 = base+0x7d630;
	static inline auto address88 = base+0x71c50;
	static inline auto address89 = base+0x80480;
	static inline auto address90 = base+0x80400;
	static inline auto address91 = base+0x78750;
	static inline auto address92 = base+0x6b500;
	static inline auto address93 = base+0x6f560;
	static inline auto address94 = base+0x7e1e0;
	static inline auto address95 = base+0x744a0;
	static inline auto address96 = base+0x771b0;
	static inline auto address97 = base+0x738e0;
	static inline auto address98 = base+0x73be0;
	static inline auto address99 = base+0x74450;
	static inline auto address100 = base+0x7deb0;
	static inline auto address101 = base+0x74580;
	static inline auto address102 = base+0x75ba0;
	static inline auto address103 = base+0x6df00;
	static inline auto address104 = base+0x6d9e0;
	static inline auto address105 = base+0x73820;
	static inline auto address106 = base+0x74200;
	static inline auto address107 = base+0x76330;
	static inline auto address108 = base+0x7d170;
	static inline auto address109 = base+0x726b0;
	static inline auto address110 = base+0x72910;
	static inline auto address111 = base+0x7fec0;
	static inline auto address112 = base+0x7fed0;
	static inline auto address113 = base+0x75900;
	static inline auto address114 = base+0x6d090;
	static inline auto address115 = base+0x7ef10;
	static inline auto address116 = base+0x7baf0;
	static inline auto address117 = base+0x7bc80;
	static inline auto address118 = base+0x7bbe0;
	static inline auto address119 = base+0x7bd20;
	static inline auto address120 = base+0x7d120;
	static inline auto address121 = base+0x293eb0;
	static inline auto address122 = base+0x7fe80;
	static inline auto address123 = base+0x7bf90;
	static inline auto address124 = base+0x7bdc0;
	static inline auto address125 = base+0x7fe40;
	static inline auto address126 = base+0x70e00;
	static inline auto address127 = base+0x7f9e0;
	static inline auto address128 = base+0x6eeb0;
	static inline auto address129 = base+0x7fe00;
	static inline auto address130 = base+0x76e00;
	static inline auto address131 = base+0x77660;
	static inline auto address132 = base+0x777f0;
	static inline auto address133 = base+0x77900;
	static inline auto address134 = base+0x7fcd0;
	static inline auto address135 = base+0x6e2b0;
	static inline auto address136 = base+0x7c7f0;
	static inline auto address137 = base+0x7caa0;
	static inline auto address138 = base+0x7a6d0;
	static inline auto address139 = base+0x6f1e0;
	static inline auto address140 = base+0x7a720;
	static inline auto address141 = base+0x6ed70;
	static inline auto address142 = base+0x78b60;
	static inline auto address143 = base+0x786f0;
	static inline auto address144 = base+0x7ffb0;
	static inline auto address145 = base+0x6fb90;
	static inline auto address146 = base+0x7fcb0;
	static inline auto address147 = base+0x75ef0;
	static inline auto address148 = base+0x761f0;
	static inline auto address149 = base+0x7b9e0;
	static inline auto address150 = base+0x7d140;
	static inline auto address151 = base+0x6b090;

	dupable getFunctionOf(PlayLayer, addCircle, , 1, CCCircleWave*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, addObject, , 1, GameObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, addToGroupOld, , 1, GameObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, addToSpeedObjects, , 1, GameObject*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, animateInDualGround, , 3, GameObject*, float, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, animateInGround, , 1, bool) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, animateOutGround, , 1, bool) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, animateOutGroundFinished, , 0) {
		return reinterpret_cast<fun7>(address7)(this);
	}

	dupable getFunctionOf(PlayLayer, applyEnterEffect, , 1, GameObject*) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<fun9>(address9)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(PlayLayer, cameraMoveX, , 3, float, float, float) {
		return reinterpret_cast<fun10>(address10)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, cameraMoveY, , 3, float, float, float) {
		return reinterpret_cast<fun11>(address11)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, checkCollisions, , 2, PlayerObject*, float) {
		return reinterpret_cast<fun12>(address12)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, circleWaveWillBeRemoved, , 1, CCCircleWave*) {
		return reinterpret_cast<fun13>(address13)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, claimParticle, , 1, gd::string) {
		return reinterpret_cast<fun14>(address14)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, clearPickedUpItems, , 0) {
		return reinterpret_cast<fun15>(address15)(this);
	}

	dupable getFunctionOf(PlayLayer, colorObject, , 2, int, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun16>(address16)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, commitJumps, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable static getFunctionOf(PlayLayer, create, , 1, GJGameLevel*) {
		return reinterpret_cast<fun18>(address18)(p0);
	}

	dupable getFunctionOf(PlayLayer, createCheckpoint, , 0) {
		return reinterpret_cast<fun19>(address19)(this);
	}

	dupable getFunctionOf(PlayLayer, createObjectsFromSetup, , 1, gd::string) {
		return reinterpret_cast<fun20>(address20)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, createParticle, , 4, int, char const*, int, cocos2d::tCCPositionType) {
		return reinterpret_cast<fun21>(address21)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, currencyWillExit, , 1, CurrencyRewardLayer*) {
		return reinterpret_cast<fun22>(address22)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, delayedResetLevel, , 0) {
		return reinterpret_cast<fun23>(address23)(this);
	}

	dupable getFunctionOf(PlayLayer, destroyPlayer, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<fun24>(address24)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, dialogClosed, , 1, DialogLayer*) {
		return reinterpret_cast<fun25>(address25)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, draw, , 0) {
		return reinterpret_cast<fun26>(address26)(this);
	}

	dupable getFunctionOf(PlayLayer, enterDualMode, , 2, GameObject*, bool) {
		return reinterpret_cast<fun27>(address27)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, exitAirMode, , 0) {
		return reinterpret_cast<fun28>(address28)(this);
	}

	dupable getFunctionOf(PlayLayer, exitBirdMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun29>(address29)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, exitDartMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, exitFlyMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun31>(address31)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, exitRobotMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun32>(address32)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, exitRollMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun33>(address33)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, exitSpiderMode, , 1, PlayerObject*) {
		return reinterpret_cast<fun34>(address34)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, flipFinished, , 0) {
		return reinterpret_cast<fun35>(address35)(this);
	}

	dupable getFunctionOf(PlayLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<fun36>(address36)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, flipObjects, , 0) {
		return reinterpret_cast<fun37>(address37)(this);
	}

	dupable getFunctionOf(PlayLayer, fullReset, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(PlayLayer, getLastCheckpoint, , 0) {
		return reinterpret_cast<fun39>(address39)(this);
	}

	dupable getFunctionOf(PlayLayer, getMaxPortalY, , 0) {
		return reinterpret_cast<fun40>(address40)(this);
	}

	dupable getFunctionOf(PlayLayer, getMinPortalY, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(PlayLayer, getObjectsState, , 0) {
		return reinterpret_cast<fun42>(address42)(this);
	}

	dupable getFunctionOf(PlayLayer, getOtherPlayer, , 1, PlayerObject*) {
		return reinterpret_cast<fun43>(address43)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, getParticleKey, , 4, int, char const*, int, cocos2d::tCCPositionType) {
		return reinterpret_cast<fun44>(address44)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, getParticleKey2, , 1, gd::string) {
		return reinterpret_cast<fun45>(address45)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, getRelativeMod, , 4, cocos2d::CCPoint, float, float, float) {
		return reinterpret_cast<fun46>(address46)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, getTempMilliTime, , 0) {
		return reinterpret_cast<fun47>(address47)(this);
	}

	dupable getFunctionOf(PlayLayer, gravityEffectFinished, , 0) {
		return reinterpret_cast<fun48>(address48)(this);
	}

	dupable getFunctionOf(PlayLayer, hasItem, , 1, int) {
		return reinterpret_cast<fun49>(address49)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, hasUniqueCoin, , 1, GameObject*) {
		return reinterpret_cast<fun50>(address50)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, incrementJumps, , 0) {
		return reinterpret_cast<fun51>(address51)(this);
	}

	dupable getFunctionOf(PlayLayer, init, , 1, GJGameLevel*) {
		return reinterpret_cast<fun52>(address52)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, isFlipping, , 0) {
		return reinterpret_cast<fun53>(address53)(this);
	}

	dupable getFunctionOf(PlayLayer, levelComplete, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(PlayLayer, lightningFlash, , 8, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float) {
		return reinterpret_cast<fun55>(address55)(this, p0, p1, p2, p3, p4, p5, p6, p7);
	}

	dupable getFunctionOf(PlayLayer, lightningFlash, , 2, cocos2d::CCPoint, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun56>(address56)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, loadDefaultColors, , 0) {
		return reinterpret_cast<fun57>(address57)(this);
	}

	dupable getFunctionOf(PlayLayer, loadFromCheckpoint, , 1, CheckpointObject*) {
		return reinterpret_cast<fun58>(address58)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, loadLastCheckpoint, , 0) {
		return reinterpret_cast<fun59>(address59)(this);
	}

	dupable getFunctionOf(PlayLayer, loadSavedObjectsState, , 1, gd::string) {
		return reinterpret_cast<fun60>(address60)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, markCheckpoint, , 0) {
		return reinterpret_cast<fun61>(address61)(this);
	}

	dupable getFunctionOf(PlayLayer, moveCameraToPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun62>(address62)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<fun63>(address63)(this);
	}

	dupable getFunctionOf(PlayLayer, onExit, , 0) {
		return reinterpret_cast<fun64>(address64)(this);
	}

	dupable getFunctionOf(PlayLayer, onQuit, , 0) {
		return reinterpret_cast<fun65>(address65)(this);
	}

	dupable getFunctionOf(PlayLayer, optimizeColorGroups, , 0) {
		return reinterpret_cast<fun66>(address66)(this);
	}

	dupable getFunctionOf(PlayLayer, optimizeOpacityGroups, , 0) {
		return reinterpret_cast<fun67>(address67)(this);
	}

	dupable getFunctionOf(PlayLayer, optimizeSaveRequiredGroups, , 0) {
		return reinterpret_cast<fun68>(address68)(this);
	}

	dupable getFunctionOf(PlayLayer, pauseGame, , 1, bool) {
		return reinterpret_cast<fun69>(address69)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, pickupItem, , 1, GameObject*) {
		return reinterpret_cast<fun70>(address70)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, playAnimationCommand, , 2, int, int) {
		return reinterpret_cast<fun71>(address71)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, playEndAnimationToPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<fun72>(address72)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, playExitDualEffect, , 1, PlayerObject*) {
		return reinterpret_cast<fun73>(address73)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, playFlashEffect, , 3, float, int, float) {
		return reinterpret_cast<fun74>(address74)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, playGravityEffect, , 1, bool) {
		return reinterpret_cast<fun75>(address75)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, playSpeedParticle, , 1, float) {
		return reinterpret_cast<fun76>(address76)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, playerWillSwitchMode, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<fun77>(address77)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, prepareSpawnObjects, , 0) {
		return reinterpret_cast<fun78>(address78)(this);
	}

	dupable getFunctionOf(PlayLayer, processItems, , 0) {
		return reinterpret_cast<fun79>(address79)(this);
	}

	dupable getFunctionOf(PlayLayer, processLoadedMoveActions, , 0) {
		return reinterpret_cast<fun80>(address80)(this);
	}

	dupable getFunctionOf(PlayLayer, recordAction, , 2, bool, PlayerObject*) {
		return reinterpret_cast<fun81>(address81)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, registerActiveObject, , 1, GameObject*) {
		return reinterpret_cast<fun82>(address82)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, registerStateObject, , 1, GameObject*) {
		return reinterpret_cast<fun83>(address83)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, removeAllObjects, , 0) {
		return reinterpret_cast<fun84>(address84)(this);
	}

	dupable getFunctionOf(PlayLayer, removeFromGroupOld, , 1, GameObject*) {
		return reinterpret_cast<fun85>(address85)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, removeLastCheckpoint, , 0) {
		return reinterpret_cast<fun86>(address86)(this);
	}

	dupable getFunctionOf(PlayLayer, removePlayer2, , 0) {
		return reinterpret_cast<fun87>(address87)(this);
	}

	dupable getFunctionOf(PlayLayer, resetLevel, , 0) {
		return reinterpret_cast<fun88>(address88)(this);
	}

	dupable getFunctionOf(PlayLayer, resume, , 0) {
		return reinterpret_cast<fun89>(address89)(this);
	}

	dupable getFunctionOf(PlayLayer, resumeAndRestart, , 0) {
		return reinterpret_cast<fun90>(address90)(this);
	}

	dupable getFunctionOf(PlayLayer, saveRecordAction, , 2, bool, PlayerObject*) {
		return reinterpret_cast<fun91>(address91)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, scene, , 1, GJGameLevel*) {
		return reinterpret_cast<fun92>(address92)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, setupLevelStart, , 1, LevelSettingsObject*) {
		return reinterpret_cast<fun93>(address93)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, setupReplay, , 1, gd::string) {
		return reinterpret_cast<fun94>(address94)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, shakeCamera, , 3, float, float, float) {
		return reinterpret_cast<fun95>(address95)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, shouldBlend, , 1, int) {
		return reinterpret_cast<fun96>(address96)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, showCompleteEffect, , 0) {
		return reinterpret_cast<fun97>(address97)(this);
	}

	dupable getFunctionOf(PlayLayer, showCompleteText, , 0) {
		return reinterpret_cast<fun98>(address98)(this);
	}

	dupable getFunctionOf(PlayLayer, showEndLayer, , 0) {
		return reinterpret_cast<fun99>(address99)(this);
	}

	dupable getFunctionOf(PlayLayer, showHint, , 0) {
		return reinterpret_cast<fun100>(address100)(this);
	}

	dupable getFunctionOf(PlayLayer, showNewBest, , 6, bool, int, int, bool, bool, bool) {
		return reinterpret_cast<fun101>(address101)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(PlayLayer, showRetryLayer, , 0) {
		return reinterpret_cast<fun102>(address102)(this);
	}

	dupable getFunctionOf(PlayLayer, showTwoPlayerGuide, , 0) {
		return reinterpret_cast<fun103>(address103)(this);
	}

	dupable getFunctionOf(PlayLayer, sortGroups, , 0) {
		return reinterpret_cast<fun104>(address104)(this);
	}

	dupable getFunctionOf(PlayLayer, spawnCircle, , 0) {
		return reinterpret_cast<fun105>(address105)(this);
	}

	dupable getFunctionOf(PlayLayer, spawnFirework, , 0) {
		return reinterpret_cast<fun106>(address106)(this);
	}

	dupable getFunctionOf(PlayLayer, spawnParticle, , 4, char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint) {
		return reinterpret_cast<fun107>(address107)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, spawnPlayer2, , 0) {
		return reinterpret_cast<fun108>(address108)(this);
	}

	dupable getFunctionOf(PlayLayer, startGame, , 0) {
		return reinterpret_cast<fun109>(address109)(this);
	}

	dupable getFunctionOf(PlayLayer, startMusic, , 0) {
		return reinterpret_cast<fun110>(address110)(this);
	}

	dupable getFunctionOf(PlayLayer, startRecording, , 0) {
		return reinterpret_cast<fun111>(address111)(this);
	}

	dupable getFunctionOf(PlayLayer, startRecordingDelayed, , 0) {
		return reinterpret_cast<fun112>(address112)(this);
	}

	dupable getFunctionOf(PlayLayer, stopCameraShake, , 0) {
		return reinterpret_cast<fun113>(address113)(this);
	}

	dupable getFunctionOf(PlayLayer, stopRecording, , 0) {
		return reinterpret_cast<fun114>(address114)(this);
	}

	dupable getFunctionOf(PlayLayer, storeCheckpoint, , 1, CheckpointObject*) {
		return reinterpret_cast<fun115>(address115)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, switchToFlyMode, , 4, PlayerObject*, GameObject*, bool, int) {
		return reinterpret_cast<fun116>(address116)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, switchToRobotMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<fun117>(address117)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, switchToRollMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<fun118>(address118)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, switchToSpiderMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<fun119>(address119)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, timeForXPos, , 1, float) {
		return reinterpret_cast<fun120>(address120)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, timeForXPos2, , 2, float, bool) {
		return reinterpret_cast<fun121>(address121)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, toggleBGEffectVisibility, , 1, bool) {
		return reinterpret_cast<fun122>(address122)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool) {
		return reinterpret_cast<fun123>(address123)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayLayer, toggleFlipped, , 2, bool, bool) {
		return reinterpret_cast<fun124>(address124)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, toggleGhostEffect, , 1, int) {
		return reinterpret_cast<fun125>(address125)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, toggleGlitter, , 1, bool) {
		return reinterpret_cast<fun126>(address126)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, togglePracticeMode, , 1, bool) {
		return reinterpret_cast<fun127>(address127)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, toggleProgressbar, , 0) {
		return reinterpret_cast<fun128>(address128)(this);
	}

	dupable getFunctionOf(PlayLayer, tryStartRecord, , 0) {
		return reinterpret_cast<fun129>(address129)(this);
	}

	dupable getFunctionOf(PlayLayer, unclaimParticle, , 2, char const*, cocos2d::CCParticleSystemQuad*) {
		return reinterpret_cast<fun130>(address130)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, unregisterActiveObject, , 1, GameObject*) {
		return reinterpret_cast<fun131>(address131)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, unregisterStateObject, , 1, GameObject*) {
		return reinterpret_cast<fun132>(address132)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, update, , 1, float) {
		return reinterpret_cast<fun133>(address133)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, updateAttempts, , 0) {
		return reinterpret_cast<fun134>(address134)(this);
	}

	dupable getFunctionOf(PlayLayer, updateCamera, , 1, float) {
		return reinterpret_cast<fun135>(address135)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<fun136>(address136)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	dupable getFunctionOf(PlayLayer, updateDualGround, , 3, PlayerObject*, int, bool) {
		return reinterpret_cast<fun137>(address137)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayLayer, updateEffectPositions, , 0) {
		return reinterpret_cast<fun138>(address138)(this);
	}

	dupable getFunctionOf(PlayLayer, updateLevelColors, , 0) {
		return reinterpret_cast<fun139>(address139)(this);
	}

	dupable getFunctionOf(PlayLayer, updateMoveObjectsLastPosition, , 0) {
		return reinterpret_cast<fun140>(address140)(this);
	}

	dupable getFunctionOf(PlayLayer, updateProgressbar, , 0) {
		return reinterpret_cast<fun141>(address141)(this);
	}

	dupable getFunctionOf(PlayLayer, updateReplay, , 1, float) {
		return reinterpret_cast<fun142>(address142)(this, p0);
	}

	dupable getFunctionOf(PlayLayer, updateTimeMod, , 2, float, bool) {
		return reinterpret_cast<fun143>(address143)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, updateTweenAction, , 2, float, char const*) {
		return reinterpret_cast<fun144>(address144)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, updateVisibility, , 0) {
		return reinterpret_cast<fun145>(address145)(this);
	}

	dupable getFunctionOf(PlayLayer, vfDChk, , 0) {
		return reinterpret_cast<fun146>(address146)(this);
	}

	dupable getFunctionOf(PlayLayer, visit, , 0) {
		return reinterpret_cast<fun147>(address147)(this);
	}

	dupable getFunctionOf(PlayLayer, visitWithColorFlash, , 0) {
		return reinterpret_cast<fun148>(address148)(this);
	}

	dupable getFunctionOf(PlayLayer, willSwitchToMode, , 2, int, PlayerObject*) {
		return reinterpret_cast<fun149>(address149)(this, p0, p1);
	}

	dupable getFunctionOf(PlayLayer, xPosForTime, , 1, float) {
		return reinterpret_cast<fun150>(address150)(this, p0);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address151)(this);
	}

	getWrapperOf(PlayLayer, addCircle, , 1, CCCircleWave*) {
		return reinterpret_cast<D*>(this)->D::addCircle(p0);
	}

	getWrapperOf(PlayLayer, addObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addObject(p0);
	}

	getWrapperOf(PlayLayer, addToGroupOld, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addToGroupOld(p0);
	}

	getWrapperOf(PlayLayer, addToSpeedObjects, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addToSpeedObjects(p0);
	}

	getWrapperOf(PlayLayer, animateInDualGround, , 3, GameObject*, float, bool) {
		return reinterpret_cast<D*>(this)->D::animateInDualGround(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, animateInGround, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::animateInGround(p0);
	}

	getWrapperOf(PlayLayer, animateOutGround, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::animateOutGround(p0);
	}

	getWrapperOf(PlayLayer, animateOutGroundFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::animateOutGroundFinished();
	}

	getWrapperOf(PlayLayer, applyEnterEffect, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::applyEnterEffect(p0);
	}

	getWrapperOf(PlayLayer, calculateColorValues, , 6, EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*) {
		return reinterpret_cast<D*>(this)->D::calculateColorValues(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(PlayLayer, cameraMoveX, , 3, float, float, float) {
		return reinterpret_cast<D*>(this)->D::cameraMoveX(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, cameraMoveY, , 3, float, float, float) {
		return reinterpret_cast<D*>(this)->D::cameraMoveY(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, checkCollisions, , 2, PlayerObject*, float) {
		return reinterpret_cast<D*>(this)->D::checkCollisions(p0, p1);
	}

	getWrapperOf(PlayLayer, circleWaveWillBeRemoved, , 1, CCCircleWave*) {
		return reinterpret_cast<D*>(this)->D::circleWaveWillBeRemoved(p0);
	}

	getWrapperOf(PlayLayer, claimParticle, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::claimParticle(p0);
	}

	getWrapperOf(PlayLayer, clearPickedUpItems, , 0) {
		return reinterpret_cast<D*>(this)->D::clearPickedUpItems();
	}

	getWrapperOf(PlayLayer, colorObject, , 2, int, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::colorObject(p0, p1);
	}

	getWrapperOf(PlayLayer, commitJumps, , 0) {
		return reinterpret_cast<D*>(this)->D::commitJumps();
	}

	static getWrapperOf(PlayLayer, create, , 1, GJGameLevel*) {
		return D::create(p0);
	}

	getWrapperOf(PlayLayer, createCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::createCheckpoint();
	}

	getWrapperOf(PlayLayer, createObjectsFromSetup, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::createObjectsFromSetup(p0);
	}

	getWrapperOf(PlayLayer, createParticle, , 4, int, char const*, int, cocos2d::tCCPositionType) {
		return reinterpret_cast<D*>(this)->D::createParticle(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, currencyWillExit, , 1, CurrencyRewardLayer*) {
		return reinterpret_cast<D*>(this)->D::currencyWillExit(p0);
	}

	getWrapperOf(PlayLayer, delayedResetLevel, , 0) {
		return reinterpret_cast<D*>(this)->D::delayedResetLevel();
	}

	getWrapperOf(PlayLayer, destroyPlayer, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<D*>(this)->D::destroyPlayer(p0, p1);
	}

	getWrapperOf(PlayLayer, dialogClosed, , 1, DialogLayer*) {
		return reinterpret_cast<D*>(this)->D::dialogClosed(p0);
	}

	getWrapperOf(PlayLayer, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(PlayLayer, enterDualMode, , 2, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::enterDualMode(p0, p1);
	}

	getWrapperOf(PlayLayer, exitAirMode, , 0) {
		return reinterpret_cast<D*>(this)->D::exitAirMode();
	}

	getWrapperOf(PlayLayer, exitBirdMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitBirdMode(p0);
	}

	getWrapperOf(PlayLayer, exitDartMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitDartMode(p0);
	}

	getWrapperOf(PlayLayer, exitFlyMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitFlyMode(p0);
	}

	getWrapperOf(PlayLayer, exitRobotMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitRobotMode(p0);
	}

	getWrapperOf(PlayLayer, exitRollMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitRollMode(p0);
	}

	getWrapperOf(PlayLayer, exitSpiderMode, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::exitSpiderMode(p0);
	}

	getWrapperOf(PlayLayer, flipFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::flipFinished();
	}

	getWrapperOf(PlayLayer, flipGravity, , 3, PlayerObject*, bool, bool) {
		return reinterpret_cast<D*>(this)->D::flipGravity(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, flipObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::flipObjects();
	}

	getWrapperOf(PlayLayer, fullReset, , 0) {
		return reinterpret_cast<D*>(this)->D::fullReset();
	}

	getWrapperOf(PlayLayer, getLastCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::getLastCheckpoint();
	}

	getWrapperOf(PlayLayer, getMaxPortalY, , 0) {
		return reinterpret_cast<D*>(this)->D::getMaxPortalY();
	}

	getWrapperOf(PlayLayer, getMinPortalY, , 0) {
		return reinterpret_cast<D*>(this)->D::getMinPortalY();
	}

	getWrapperOf(PlayLayer, getObjectsState, , 0) {
		return reinterpret_cast<D*>(this)->D::getObjectsState();
	}

	getWrapperOf(PlayLayer, getOtherPlayer, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::getOtherPlayer(p0);
	}

	getWrapperOf(PlayLayer, getParticleKey, , 4, int, char const*, int, cocos2d::tCCPositionType) {
		return reinterpret_cast<D*>(this)->D::getParticleKey(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, getParticleKey2, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::getParticleKey2(p0);
	}

	getWrapperOf(PlayLayer, getRelativeMod, , 4, cocos2d::CCPoint, float, float, float) {
		return reinterpret_cast<D*>(this)->D::getRelativeMod(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, getTempMilliTime, , 0) {
		return reinterpret_cast<D*>(this)->D::getTempMilliTime();
	}

	getWrapperOf(PlayLayer, gravityEffectFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::gravityEffectFinished();
	}

	getWrapperOf(PlayLayer, hasItem, , 1, int) {
		return reinterpret_cast<D*>(this)->D::hasItem(p0);
	}

	getWrapperOf(PlayLayer, hasUniqueCoin, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::hasUniqueCoin(p0);
	}

	getWrapperOf(PlayLayer, incrementJumps, , 0) {
		return reinterpret_cast<D*>(this)->D::incrementJumps();
	}

	getWrapperOf(PlayLayer, init, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::init(p0);
	}

	getWrapperOf(PlayLayer, isFlipping, , 0) {
		return reinterpret_cast<D*>(this)->D::isFlipping();
	}

	getWrapperOf(PlayLayer, levelComplete, , 0) {
		return reinterpret_cast<D*>(this)->D::levelComplete();
	}

	getWrapperOf(PlayLayer, lightningFlash, , 8, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float) {
		return reinterpret_cast<D*>(this)->D::lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7);
	}

	getWrapperOf(PlayLayer, lightningFlash, , 2, cocos2d::CCPoint, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::lightningFlash(p0, p1);
	}

	getWrapperOf(PlayLayer, loadDefaultColors, , 0) {
		return reinterpret_cast<D*>(this)->D::loadDefaultColors();
	}

	getWrapperOf(PlayLayer, loadFromCheckpoint, , 1, CheckpointObject*) {
		return reinterpret_cast<D*>(this)->D::loadFromCheckpoint(p0);
	}

	getWrapperOf(PlayLayer, loadLastCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::loadLastCheckpoint();
	}

	getWrapperOf(PlayLayer, loadSavedObjectsState, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::loadSavedObjectsState(p0);
	}

	getWrapperOf(PlayLayer, markCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::markCheckpoint();
	}

	getWrapperOf(PlayLayer, moveCameraToPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::moveCameraToPos(p0);
	}

	getWrapperOf(PlayLayer, onEnterTransitionDidFinish, , 0) {
		return reinterpret_cast<D*>(this)->D::onEnterTransitionDidFinish();
	}

	getWrapperOf(PlayLayer, onExit, , 0) {
		return reinterpret_cast<D*>(this)->D::onExit();
	}

	getWrapperOf(PlayLayer, onQuit, , 0) {
		return reinterpret_cast<D*>(this)->D::onQuit();
	}

	getWrapperOf(PlayLayer, optimizeColorGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::optimizeColorGroups();
	}

	getWrapperOf(PlayLayer, optimizeOpacityGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::optimizeOpacityGroups();
	}

	getWrapperOf(PlayLayer, optimizeSaveRequiredGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::optimizeSaveRequiredGroups();
	}

	getWrapperOf(PlayLayer, pauseGame, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::pauseGame(p0);
	}

	getWrapperOf(PlayLayer, pickupItem, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::pickupItem(p0);
	}

	getWrapperOf(PlayLayer, playAnimationCommand, , 2, int, int) {
		return reinterpret_cast<D*>(this)->D::playAnimationCommand(p0, p1);
	}

	getWrapperOf(PlayLayer, playEndAnimationToPos, , 1, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::playEndAnimationToPos(p0);
	}

	getWrapperOf(PlayLayer, playExitDualEffect, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::playExitDualEffect(p0);
	}

	getWrapperOf(PlayLayer, playFlashEffect, , 3, float, int, float) {
		return reinterpret_cast<D*>(this)->D::playFlashEffect(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, playGravityEffect, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::playGravityEffect(p0);
	}

	getWrapperOf(PlayLayer, playSpeedParticle, , 1, float) {
		return reinterpret_cast<D*>(this)->D::playSpeedParticle(p0);
	}

	getWrapperOf(PlayLayer, playerWillSwitchMode, , 2, PlayerObject*, GameObject*) {
		return reinterpret_cast<D*>(this)->D::playerWillSwitchMode(p0, p1);
	}

	getWrapperOf(PlayLayer, prepareSpawnObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::prepareSpawnObjects();
	}

	getWrapperOf(PlayLayer, processItems, , 0) {
		return reinterpret_cast<D*>(this)->D::processItems();
	}

	getWrapperOf(PlayLayer, processLoadedMoveActions, , 0) {
		return reinterpret_cast<D*>(this)->D::processLoadedMoveActions();
	}

	getWrapperOf(PlayLayer, recordAction, , 2, bool, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::recordAction(p0, p1);
	}

	getWrapperOf(PlayLayer, registerActiveObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::registerActiveObject(p0);
	}

	getWrapperOf(PlayLayer, registerStateObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::registerStateObject(p0);
	}

	getWrapperOf(PlayLayer, removeAllObjects, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllObjects();
	}

	getWrapperOf(PlayLayer, removeFromGroupOld, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::removeFromGroupOld(p0);
	}

	getWrapperOf(PlayLayer, removeLastCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::removeLastCheckpoint();
	}

	getWrapperOf(PlayLayer, removePlayer2, , 0) {
		return reinterpret_cast<D*>(this)->D::removePlayer2();
	}

	getWrapperOf(PlayLayer, resetLevel, , 0) {
		return reinterpret_cast<D*>(this)->D::resetLevel();
	}

	getWrapperOf(PlayLayer, resume, , 0) {
		return reinterpret_cast<D*>(this)->D::resume();
	}

	getWrapperOf(PlayLayer, resumeAndRestart, , 0) {
		return reinterpret_cast<D*>(this)->D::resumeAndRestart();
	}

	getWrapperOf(PlayLayer, saveRecordAction, , 2, bool, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::saveRecordAction(p0, p1);
	}

	getWrapperOf(PlayLayer, scene, , 1, GJGameLevel*) {
		return reinterpret_cast<D*>(this)->D::scene(p0);
	}

	getWrapperOf(PlayLayer, setupLevelStart, , 1, LevelSettingsObject*) {
		return reinterpret_cast<D*>(this)->D::setupLevelStart(p0);
	}

	getWrapperOf(PlayLayer, setupReplay, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::setupReplay(p0);
	}

	getWrapperOf(PlayLayer, shakeCamera, , 3, float, float, float) {
		return reinterpret_cast<D*>(this)->D::shakeCamera(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, shouldBlend, , 1, int) {
		return reinterpret_cast<D*>(this)->D::shouldBlend(p0);
	}

	getWrapperOf(PlayLayer, showCompleteEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::showCompleteEffect();
	}

	getWrapperOf(PlayLayer, showCompleteText, , 0) {
		return reinterpret_cast<D*>(this)->D::showCompleteText();
	}

	getWrapperOf(PlayLayer, showEndLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::showEndLayer();
	}

	getWrapperOf(PlayLayer, showHint, , 0) {
		return reinterpret_cast<D*>(this)->D::showHint();
	}

	getWrapperOf(PlayLayer, showNewBest, , 6, bool, int, int, bool, bool, bool) {
		return reinterpret_cast<D*>(this)->D::showNewBest(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(PlayLayer, showRetryLayer, , 0) {
		return reinterpret_cast<D*>(this)->D::showRetryLayer();
	}

	getWrapperOf(PlayLayer, showTwoPlayerGuide, , 0) {
		return reinterpret_cast<D*>(this)->D::showTwoPlayerGuide();
	}

	getWrapperOf(PlayLayer, sortGroups, , 0) {
		return reinterpret_cast<D*>(this)->D::sortGroups();
	}

	getWrapperOf(PlayLayer, spawnCircle, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnCircle();
	}

	getWrapperOf(PlayLayer, spawnFirework, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnFirework();
	}

	getWrapperOf(PlayLayer, spawnParticle, , 4, char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint) {
		return reinterpret_cast<D*>(this)->D::spawnParticle(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, spawnPlayer2, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnPlayer2();
	}

	getWrapperOf(PlayLayer, startGame, , 0) {
		return reinterpret_cast<D*>(this)->D::startGame();
	}

	getWrapperOf(PlayLayer, startMusic, , 0) {
		return reinterpret_cast<D*>(this)->D::startMusic();
	}

	getWrapperOf(PlayLayer, startRecording, , 0) {
		return reinterpret_cast<D*>(this)->D::startRecording();
	}

	getWrapperOf(PlayLayer, startRecordingDelayed, , 0) {
		return reinterpret_cast<D*>(this)->D::startRecordingDelayed();
	}

	getWrapperOf(PlayLayer, stopCameraShake, , 0) {
		return reinterpret_cast<D*>(this)->D::stopCameraShake();
	}

	getWrapperOf(PlayLayer, stopRecording, , 0) {
		return reinterpret_cast<D*>(this)->D::stopRecording();
	}

	getWrapperOf(PlayLayer, storeCheckpoint, , 1, CheckpointObject*) {
		return reinterpret_cast<D*>(this)->D::storeCheckpoint(p0);
	}

	getWrapperOf(PlayLayer, switchToFlyMode, , 4, PlayerObject*, GameObject*, bool, int) {
		return reinterpret_cast<D*>(this)->D::switchToFlyMode(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, switchToRobotMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::switchToRobotMode(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, switchToRollMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::switchToRollMode(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, switchToSpiderMode, , 3, PlayerObject*, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::switchToSpiderMode(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, timeForXPos, , 1, float) {
		return reinterpret_cast<D*>(this)->D::timeForXPos(p0);
	}

	getWrapperOf(PlayLayer, timeForXPos2, , 2, float, bool) {
		return reinterpret_cast<D*>(this)->D::timeForXPos2(p0, p1);
	}

	getWrapperOf(PlayLayer, toggleBGEffectVisibility, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleBGEffectVisibility(p0);
	}

	getWrapperOf(PlayLayer, toggleDualMode, , 4, GameObject*, bool, PlayerObject*, bool) {
		return reinterpret_cast<D*>(this)->D::toggleDualMode(p0, p1, p2, p3);
	}

	getWrapperOf(PlayLayer, toggleFlipped, , 2, bool, bool) {
		return reinterpret_cast<D*>(this)->D::toggleFlipped(p0, p1);
	}

	getWrapperOf(PlayLayer, toggleGhostEffect, , 1, int) {
		return reinterpret_cast<D*>(this)->D::toggleGhostEffect(p0);
	}

	getWrapperOf(PlayLayer, toggleGlitter, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleGlitter(p0);
	}

	getWrapperOf(PlayLayer, togglePracticeMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::togglePracticeMode(p0);
	}

	getWrapperOf(PlayLayer, toggleProgressbar, , 0) {
		return reinterpret_cast<D*>(this)->D::toggleProgressbar();
	}

	getWrapperOf(PlayLayer, tryStartRecord, , 0) {
		return reinterpret_cast<D*>(this)->D::tryStartRecord();
	}

	getWrapperOf(PlayLayer, unclaimParticle, , 2, char const*, cocos2d::CCParticleSystemQuad*) {
		return reinterpret_cast<D*>(this)->D::unclaimParticle(p0, p1);
	}

	getWrapperOf(PlayLayer, unregisterActiveObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::unregisterActiveObject(p0);
	}

	getWrapperOf(PlayLayer, unregisterStateObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::unregisterStateObject(p0);
	}

	getWrapperOf(PlayLayer, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

	getWrapperOf(PlayLayer, updateAttempts, , 0) {
		return reinterpret_cast<D*>(this)->D::updateAttempts();
	}

	getWrapperOf(PlayLayer, updateCamera, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateCamera(p0);
	}

	getWrapperOf(PlayLayer, updateColor, , 10, cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*) {
		return reinterpret_cast<D*>(this)->D::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	}

	getWrapperOf(PlayLayer, updateDualGround, , 3, PlayerObject*, int, bool) {
		return reinterpret_cast<D*>(this)->D::updateDualGround(p0, p1, p2);
	}

	getWrapperOf(PlayLayer, updateEffectPositions, , 0) {
		return reinterpret_cast<D*>(this)->D::updateEffectPositions();
	}

	getWrapperOf(PlayLayer, updateLevelColors, , 0) {
		return reinterpret_cast<D*>(this)->D::updateLevelColors();
	}

	getWrapperOf(PlayLayer, updateMoveObjectsLastPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::updateMoveObjectsLastPosition();
	}

	getWrapperOf(PlayLayer, updateProgressbar, , 0) {
		return reinterpret_cast<D*>(this)->D::updateProgressbar();
	}

	getWrapperOf(PlayLayer, updateReplay, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateReplay(p0);
	}

	getWrapperOf(PlayLayer, updateTimeMod, , 2, float, bool) {
		return reinterpret_cast<D*>(this)->D::updateTimeMod(p0, p1);
	}

	getWrapperOf(PlayLayer, updateTweenAction, , 2, float, char const*) {
		return reinterpret_cast<D*>(this)->D::updateTweenAction(p0, p1);
	}

	getWrapperOf(PlayLayer, updateVisibility, , 0) {
		return reinterpret_cast<D*>(this)->D::updateVisibility();
	}

	getWrapperOf(PlayLayer, vfDChk, , 0) {
		return reinterpret_cast<D*>(this)->D::vfDChk();
	}

	getWrapperOf(PlayLayer, visit, , 0) {
		return reinterpret_cast<D*>(this)->D::visit();
	}

	getWrapperOf(PlayLayer, visitWithColorFlash, , 0) {
		return reinterpret_cast<D*>(this)->D::visitWithColorFlash();
	}

	getWrapperOf(PlayLayer, willSwitchToMode, , 2, int, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::willSwitchToMode(p0, p1);
	}

	getWrapperOf(PlayLayer, xPosForTime, , 1, float) {
		return reinterpret_cast<D*>(this)->D::xPosForTime(p0);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$PlayLayer::addCircle) != (der0)(&D::addCircle)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::addCircleWrapper)));
		}

		if constexpr((mem1)(&$PlayLayer::addObject) != (der1)(&D::addObject)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::addObjectWrapper)));
		}

		if constexpr((mem2)(&$PlayLayer::addToGroupOld) != (der2)(&D::addToGroupOld)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::addToGroupOldWrapper)));
		}

		if constexpr((mem3)(&$PlayLayer::addToSpeedObjects) != (der3)(&D::addToSpeedObjects)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::addToSpeedObjectsWrapper)));
		}

		if constexpr((mem4)(&$PlayLayer::animateInDualGround) != (der4)(&D::animateInDualGround)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::animateInDualGroundWrapper)));
		}

		if constexpr((mem5)(&$PlayLayer::animateInGround) != (der5)(&D::animateInGround)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfNonVirtual((der5)(&D::animateInGroundWrapper)));
		}

		if constexpr((mem6)(&$PlayLayer::animateOutGround) != (der6)(&D::animateOutGround)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfNonVirtual((der6)(&D::animateOutGroundWrapper)));
		}

		if constexpr((mem7)(&$PlayLayer::animateOutGroundFinished) != (der7)(&D::animateOutGroundFinished)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfNonVirtual((der7)(&D::animateOutGroundFinishedWrapper)));
		}

		if constexpr((mem8)(&$PlayLayer::applyEnterEffect) != (der8)(&D::applyEnterEffect)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfNonVirtual((der8)(&D::applyEnterEffectWrapper)));
		}

		if ((mem9)(&$PlayLayer::calculateColorValues) != (der9)(&D::calculateColorValues)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::calculateColorValuesWrapper)));
		}

		if constexpr((mem10)(&$PlayLayer::cameraMoveX) != (der10)(&D::cameraMoveX)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfNonVirtual((der10)(&D::cameraMoveXWrapper)));
		}

		if constexpr((mem11)(&$PlayLayer::cameraMoveY) != (der11)(&D::cameraMoveY)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfNonVirtual((der11)(&D::cameraMoveYWrapper)));
		}

		if constexpr((mem12)(&$PlayLayer::checkCollisions) != (der12)(&D::checkCollisions)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfNonVirtual((der12)(&D::checkCollisionsWrapper)));
		}

		if constexpr((mem13)(&$PlayLayer::circleWaveWillBeRemoved) != (der13)(&D::circleWaveWillBeRemoved)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfNonVirtual((der13)(&D::circleWaveWillBeRemovedWrapper)));
		}

		if constexpr((mem14)(&$PlayLayer::claimParticle) != (der14)(&D::claimParticle)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfNonVirtual((der14)(&D::claimParticleWrapper)));
		}

		if constexpr((mem15)(&$PlayLayer::clearPickedUpItems) != (der15)(&D::clearPickedUpItems)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfNonVirtual((der15)(&D::clearPickedUpItemsWrapper)));
		}

		if constexpr((mem16)(&$PlayLayer::colorObject) != (der16)(&D::colorObject)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::colorObjectWrapper)));
		}

		if constexpr((mem17)(&$PlayLayer::commitJumps) != (der17)(&D::commitJumps)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::commitJumpsWrapper)));
		}

		if constexpr((mem18)(&$PlayLayer::create) != (der18)(&D::create)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::createWrapper)));
		}

		if constexpr((mem19)(&$PlayLayer::createCheckpoint) != (der19)(&D::createCheckpoint)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::createCheckpointWrapper)));
		}

		if constexpr((mem20)(&$PlayLayer::createObjectsFromSetup) != (der20)(&D::createObjectsFromSetup)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::createObjectsFromSetupWrapper)));
		}

		if constexpr((mem21)(&$PlayLayer::createParticle) != (der21)(&D::createParticle)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::createParticleWrapper)));
		}

		if constexpr((mem22)(&$PlayLayer::currencyWillExit) != (der22)(&D::currencyWillExit)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::currencyWillExitWrapper)));
		}

		if constexpr((mem23)(&$PlayLayer::delayedResetLevel) != (der23)(&D::delayedResetLevel)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::delayedResetLevelWrapper)));
		}

		if constexpr((mem24)(&$PlayLayer::destroyPlayer) != (der24)(&D::destroyPlayer)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::destroyPlayerWrapper)));
		}

		if constexpr((mem25)(&$PlayLayer::dialogClosed) != (der25)(&D::dialogClosed)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::dialogClosedWrapper)));
		}

		if ((mem26)(&$PlayLayer::draw) != (der26)(&D::draw)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfVirtual((der26)(&D::drawWrapper)));
		}

		if constexpr((mem27)(&$PlayLayer::enterDualMode) != (der27)(&D::enterDualMode)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::enterDualModeWrapper)));
		}

		if constexpr((mem28)(&$PlayLayer::exitAirMode) != (der28)(&D::exitAirMode)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::exitAirModeWrapper)));
		}

		if constexpr((mem29)(&$PlayLayer::exitBirdMode) != (der29)(&D::exitBirdMode)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::exitBirdModeWrapper)));
		}

		if constexpr((mem30)(&$PlayLayer::exitDartMode) != (der30)(&D::exitDartMode)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::exitDartModeWrapper)));
		}

		if constexpr((mem31)(&$PlayLayer::exitFlyMode) != (der31)(&D::exitFlyMode)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::exitFlyModeWrapper)));
		}

		if constexpr((mem32)(&$PlayLayer::exitRobotMode) != (der32)(&D::exitRobotMode)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::exitRobotModeWrapper)));
		}

		if constexpr((mem33)(&$PlayLayer::exitRollMode) != (der33)(&D::exitRollMode)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::exitRollModeWrapper)));
		}

		if constexpr((mem34)(&$PlayLayer::exitSpiderMode) != (der34)(&D::exitSpiderMode)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::exitSpiderModeWrapper)));
		}

		if constexpr((mem35)(&$PlayLayer::flipFinished) != (der35)(&D::flipFinished)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::flipFinishedWrapper)));
		}

		if ((mem36)(&$PlayLayer::flipGravity) != (der36)(&D::flipGravity)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfVirtual((der36)(&D::flipGravityWrapper)));
		}

		if constexpr((mem37)(&$PlayLayer::flipObjects) != (der37)(&D::flipObjects)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::flipObjectsWrapper)));
		}

		if constexpr((mem38)(&$PlayLayer::fullReset) != (der38)(&D::fullReset)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::fullResetWrapper)));
		}

		if constexpr((mem39)(&$PlayLayer::getLastCheckpoint) != (der39)(&D::getLastCheckpoint)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::getLastCheckpointWrapper)));
		}

		if constexpr((mem40)(&$PlayLayer::getMaxPortalY) != (der40)(&D::getMaxPortalY)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::getMaxPortalYWrapper)));
		}

		if constexpr((mem41)(&$PlayLayer::getMinPortalY) != (der41)(&D::getMinPortalY)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::getMinPortalYWrapper)));
		}

		if constexpr((mem42)(&$PlayLayer::getObjectsState) != (der42)(&D::getObjectsState)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::getObjectsStateWrapper)));
		}

		if constexpr((mem43)(&$PlayLayer::getOtherPlayer) != (der43)(&D::getOtherPlayer)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::getOtherPlayerWrapper)));
		}

		if constexpr((mem44)(&$PlayLayer::getParticleKey) != (der44)(&D::getParticleKey)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::getParticleKeyWrapper)));
		}

		if constexpr((mem45)(&$PlayLayer::getParticleKey2) != (der45)(&D::getParticleKey2)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::getParticleKey2Wrapper)));
		}

		if constexpr((mem46)(&$PlayLayer::getRelativeMod) != (der46)(&D::getRelativeMod)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::getRelativeModWrapper)));
		}

		if constexpr((mem47)(&$PlayLayer::getTempMilliTime) != (der47)(&D::getTempMilliTime)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::getTempMilliTimeWrapper)));
		}

		if constexpr((mem48)(&$PlayLayer::gravityEffectFinished) != (der48)(&D::gravityEffectFinished)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::gravityEffectFinishedWrapper)));
		}

		if constexpr((mem49)(&$PlayLayer::hasItem) != (der49)(&D::hasItem)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::hasItemWrapper)));
		}

		if constexpr((mem50)(&$PlayLayer::hasUniqueCoin) != (der50)(&D::hasUniqueCoin)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::hasUniqueCoinWrapper)));
		}

		if constexpr((mem51)(&$PlayLayer::incrementJumps) != (der51)(&D::incrementJumps)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::incrementJumpsWrapper)));
		}

		if constexpr((mem52)(&$PlayLayer::init) != (der52)(&D::init)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::initWrapper)));
		}

		if constexpr((mem53)(&$PlayLayer::isFlipping) != (der53)(&D::isFlipping)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::isFlippingWrapper)));
		}

		if constexpr((mem54)(&$PlayLayer::levelComplete) != (der54)(&D::levelComplete)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::levelCompleteWrapper)));
		}

		if constexpr((mem55)(&$PlayLayer::lightningFlash) != (der55)(&D::lightningFlash)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::lightningFlashWrapper)));
		}

		if constexpr((mem56)(&$PlayLayer::lightningFlash) != (der56)(&D::lightningFlash)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::lightningFlashWrapper)));
		}

		if constexpr((mem57)(&$PlayLayer::loadDefaultColors) != (der57)(&D::loadDefaultColors)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::loadDefaultColorsWrapper)));
		}

		if constexpr((mem58)(&$PlayLayer::loadFromCheckpoint) != (der58)(&D::loadFromCheckpoint)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::loadFromCheckpointWrapper)));
		}

		if constexpr((mem59)(&$PlayLayer::loadLastCheckpoint) != (der59)(&D::loadLastCheckpoint)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::loadLastCheckpointWrapper)));
		}

		if constexpr((mem60)(&$PlayLayer::loadSavedObjectsState) != (der60)(&D::loadSavedObjectsState)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::loadSavedObjectsStateWrapper)));
		}

		if constexpr((mem61)(&$PlayLayer::markCheckpoint) != (der61)(&D::markCheckpoint)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::markCheckpointWrapper)));
		}

		if constexpr((mem62)(&$PlayLayer::moveCameraToPos) != (der62)(&D::moveCameraToPos)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::moveCameraToPosWrapper)));
		}

		if ((mem63)(&$PlayLayer::onEnterTransitionDidFinish) != (der63)(&D::onEnterTransitionDidFinish)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfVirtual((der63)(&D::onEnterTransitionDidFinishWrapper)));
		}

		if ((mem64)(&$PlayLayer::onExit) != (der64)(&D::onExit)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfVirtual((der64)(&D::onExitWrapper)));
		}

		if constexpr((mem65)(&$PlayLayer::onQuit) != (der65)(&D::onQuit)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::onQuitWrapper)));
		}

		if constexpr((mem66)(&$PlayLayer::optimizeColorGroups) != (der66)(&D::optimizeColorGroups)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::optimizeColorGroupsWrapper)));
		}

		if constexpr((mem67)(&$PlayLayer::optimizeOpacityGroups) != (der67)(&D::optimizeOpacityGroups)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::optimizeOpacityGroupsWrapper)));
		}

		if constexpr((mem68)(&$PlayLayer::optimizeSaveRequiredGroups) != (der68)(&D::optimizeSaveRequiredGroups)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::optimizeSaveRequiredGroupsWrapper)));
		}

		if constexpr((mem69)(&$PlayLayer::pauseGame) != (der69)(&D::pauseGame)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::pauseGameWrapper)));
		}

		if constexpr((mem70)(&$PlayLayer::pickupItem) != (der70)(&D::pickupItem)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::pickupItemWrapper)));
		}

		if constexpr((mem71)(&$PlayLayer::playAnimationCommand) != (der71)(&D::playAnimationCommand)) {
			modContainer.registerHookEnable(address71, FunctionScrapper::addressOfNonVirtual((der71)(&D::playAnimationCommandWrapper)));
		}

		if constexpr((mem72)(&$PlayLayer::playEndAnimationToPos) != (der72)(&D::playEndAnimationToPos)) {
			modContainer.registerHookEnable(address72, FunctionScrapper::addressOfNonVirtual((der72)(&D::playEndAnimationToPosWrapper)));
		}

		if constexpr((mem73)(&$PlayLayer::playExitDualEffect) != (der73)(&D::playExitDualEffect)) {
			modContainer.registerHookEnable(address73, FunctionScrapper::addressOfNonVirtual((der73)(&D::playExitDualEffectWrapper)));
		}

		if constexpr((mem74)(&$PlayLayer::playFlashEffect) != (der74)(&D::playFlashEffect)) {
			modContainer.registerHookEnable(address74, FunctionScrapper::addressOfNonVirtual((der74)(&D::playFlashEffectWrapper)));
		}

		if constexpr((mem75)(&$PlayLayer::playGravityEffect) != (der75)(&D::playGravityEffect)) {
			modContainer.registerHookEnable(address75, FunctionScrapper::addressOfNonVirtual((der75)(&D::playGravityEffectWrapper)));
		}

		if constexpr((mem76)(&$PlayLayer::playSpeedParticle) != (der76)(&D::playSpeedParticle)) {
			modContainer.registerHookEnable(address76, FunctionScrapper::addressOfNonVirtual((der76)(&D::playSpeedParticleWrapper)));
		}

		if constexpr((mem77)(&$PlayLayer::playerWillSwitchMode) != (der77)(&D::playerWillSwitchMode)) {
			modContainer.registerHookEnable(address77, FunctionScrapper::addressOfNonVirtual((der77)(&D::playerWillSwitchModeWrapper)));
		}

		if constexpr((mem78)(&$PlayLayer::prepareSpawnObjects) != (der78)(&D::prepareSpawnObjects)) {
			modContainer.registerHookEnable(address78, FunctionScrapper::addressOfNonVirtual((der78)(&D::prepareSpawnObjectsWrapper)));
		}

		if constexpr((mem79)(&$PlayLayer::processItems) != (der79)(&D::processItems)) {
			modContainer.registerHookEnable(address79, FunctionScrapper::addressOfNonVirtual((der79)(&D::processItemsWrapper)));
		}

		if constexpr((mem80)(&$PlayLayer::processLoadedMoveActions) != (der80)(&D::processLoadedMoveActions)) {
			modContainer.registerHookEnable(address80, FunctionScrapper::addressOfNonVirtual((der80)(&D::processLoadedMoveActionsWrapper)));
		}

		if constexpr((mem81)(&$PlayLayer::recordAction) != (der81)(&D::recordAction)) {
			modContainer.registerHookEnable(address81, FunctionScrapper::addressOfNonVirtual((der81)(&D::recordActionWrapper)));
		}

		if constexpr((mem82)(&$PlayLayer::registerActiveObject) != (der82)(&D::registerActiveObject)) {
			modContainer.registerHookEnable(address82, FunctionScrapper::addressOfNonVirtual((der82)(&D::registerActiveObjectWrapper)));
		}

		if constexpr((mem83)(&$PlayLayer::registerStateObject) != (der83)(&D::registerStateObject)) {
			modContainer.registerHookEnable(address83, FunctionScrapper::addressOfNonVirtual((der83)(&D::registerStateObjectWrapper)));
		}

		if constexpr((mem84)(&$PlayLayer::removeAllObjects) != (der84)(&D::removeAllObjects)) {
			modContainer.registerHookEnable(address84, FunctionScrapper::addressOfNonVirtual((der84)(&D::removeAllObjectsWrapper)));
		}

		if constexpr((mem85)(&$PlayLayer::removeFromGroupOld) != (der85)(&D::removeFromGroupOld)) {
			modContainer.registerHookEnable(address85, FunctionScrapper::addressOfNonVirtual((der85)(&D::removeFromGroupOldWrapper)));
		}

		if constexpr((mem86)(&$PlayLayer::removeLastCheckpoint) != (der86)(&D::removeLastCheckpoint)) {
			modContainer.registerHookEnable(address86, FunctionScrapper::addressOfNonVirtual((der86)(&D::removeLastCheckpointWrapper)));
		}

		if constexpr((mem87)(&$PlayLayer::removePlayer2) != (der87)(&D::removePlayer2)) {
			modContainer.registerHookEnable(address87, FunctionScrapper::addressOfNonVirtual((der87)(&D::removePlayer2Wrapper)));
		}

		if constexpr((mem88)(&$PlayLayer::resetLevel) != (der88)(&D::resetLevel)) {
			modContainer.registerHookEnable(address88, FunctionScrapper::addressOfNonVirtual((der88)(&D::resetLevelWrapper)));
		}

		if constexpr((mem89)(&$PlayLayer::resume) != (der89)(&D::resume)) {
			modContainer.registerHookEnable(address89, FunctionScrapper::addressOfNonVirtual((der89)(&D::resumeWrapper)));
		}

		if constexpr((mem90)(&$PlayLayer::resumeAndRestart) != (der90)(&D::resumeAndRestart)) {
			modContainer.registerHookEnable(address90, FunctionScrapper::addressOfNonVirtual((der90)(&D::resumeAndRestartWrapper)));
		}

		if constexpr((mem91)(&$PlayLayer::saveRecordAction) != (der91)(&D::saveRecordAction)) {
			modContainer.registerHookEnable(address91, FunctionScrapper::addressOfNonVirtual((der91)(&D::saveRecordActionWrapper)));
		}

		if constexpr((mem92)(&$PlayLayer::scene) != (der92)(&D::scene)) {
			modContainer.registerHookEnable(address92, FunctionScrapper::addressOfNonVirtual((der92)(&D::sceneWrapper)));
		}

		if constexpr((mem93)(&$PlayLayer::setupLevelStart) != (der93)(&D::setupLevelStart)) {
			modContainer.registerHookEnable(address93, FunctionScrapper::addressOfNonVirtual((der93)(&D::setupLevelStartWrapper)));
		}

		if constexpr((mem94)(&$PlayLayer::setupReplay) != (der94)(&D::setupReplay)) {
			modContainer.registerHookEnable(address94, FunctionScrapper::addressOfNonVirtual((der94)(&D::setupReplayWrapper)));
		}

		if constexpr((mem95)(&$PlayLayer::shakeCamera) != (der95)(&D::shakeCamera)) {
			modContainer.registerHookEnable(address95, FunctionScrapper::addressOfNonVirtual((der95)(&D::shakeCameraWrapper)));
		}

		if constexpr((mem96)(&$PlayLayer::shouldBlend) != (der96)(&D::shouldBlend)) {
			modContainer.registerHookEnable(address96, FunctionScrapper::addressOfNonVirtual((der96)(&D::shouldBlendWrapper)));
		}

		if constexpr((mem97)(&$PlayLayer::showCompleteEffect) != (der97)(&D::showCompleteEffect)) {
			modContainer.registerHookEnable(address97, FunctionScrapper::addressOfNonVirtual((der97)(&D::showCompleteEffectWrapper)));
		}

		if constexpr((mem98)(&$PlayLayer::showCompleteText) != (der98)(&D::showCompleteText)) {
			modContainer.registerHookEnable(address98, FunctionScrapper::addressOfNonVirtual((der98)(&D::showCompleteTextWrapper)));
		}

		if constexpr((mem99)(&$PlayLayer::showEndLayer) != (der99)(&D::showEndLayer)) {
			modContainer.registerHookEnable(address99, FunctionScrapper::addressOfNonVirtual((der99)(&D::showEndLayerWrapper)));
		}

		if constexpr((mem100)(&$PlayLayer::showHint) != (der100)(&D::showHint)) {
			modContainer.registerHookEnable(address100, FunctionScrapper::addressOfNonVirtual((der100)(&D::showHintWrapper)));
		}

		if constexpr((mem101)(&$PlayLayer::showNewBest) != (der101)(&D::showNewBest)) {
			modContainer.registerHookEnable(address101, FunctionScrapper::addressOfNonVirtual((der101)(&D::showNewBestWrapper)));
		}

		if constexpr((mem102)(&$PlayLayer::showRetryLayer) != (der102)(&D::showRetryLayer)) {
			modContainer.registerHookEnable(address102, FunctionScrapper::addressOfNonVirtual((der102)(&D::showRetryLayerWrapper)));
		}

		if constexpr((mem103)(&$PlayLayer::showTwoPlayerGuide) != (der103)(&D::showTwoPlayerGuide)) {
			modContainer.registerHookEnable(address103, FunctionScrapper::addressOfNonVirtual((der103)(&D::showTwoPlayerGuideWrapper)));
		}

		if constexpr((mem104)(&$PlayLayer::sortGroups) != (der104)(&D::sortGroups)) {
			modContainer.registerHookEnable(address104, FunctionScrapper::addressOfNonVirtual((der104)(&D::sortGroupsWrapper)));
		}

		if constexpr((mem105)(&$PlayLayer::spawnCircle) != (der105)(&D::spawnCircle)) {
			modContainer.registerHookEnable(address105, FunctionScrapper::addressOfNonVirtual((der105)(&D::spawnCircleWrapper)));
		}

		if constexpr((mem106)(&$PlayLayer::spawnFirework) != (der106)(&D::spawnFirework)) {
			modContainer.registerHookEnable(address106, FunctionScrapper::addressOfNonVirtual((der106)(&D::spawnFireworkWrapper)));
		}

		if constexpr((mem107)(&$PlayLayer::spawnParticle) != (der107)(&D::spawnParticle)) {
			modContainer.registerHookEnable(address107, FunctionScrapper::addressOfNonVirtual((der107)(&D::spawnParticleWrapper)));
		}

		if constexpr((mem108)(&$PlayLayer::spawnPlayer2) != (der108)(&D::spawnPlayer2)) {
			modContainer.registerHookEnable(address108, FunctionScrapper::addressOfNonVirtual((der108)(&D::spawnPlayer2Wrapper)));
		}

		if constexpr((mem109)(&$PlayLayer::startGame) != (der109)(&D::startGame)) {
			modContainer.registerHookEnable(address109, FunctionScrapper::addressOfNonVirtual((der109)(&D::startGameWrapper)));
		}

		if constexpr((mem110)(&$PlayLayer::startMusic) != (der110)(&D::startMusic)) {
			modContainer.registerHookEnable(address110, FunctionScrapper::addressOfNonVirtual((der110)(&D::startMusicWrapper)));
		}

		if constexpr((mem111)(&$PlayLayer::startRecording) != (der111)(&D::startRecording)) {
			modContainer.registerHookEnable(address111, FunctionScrapper::addressOfNonVirtual((der111)(&D::startRecordingWrapper)));
		}

		if constexpr((mem112)(&$PlayLayer::startRecordingDelayed) != (der112)(&D::startRecordingDelayed)) {
			modContainer.registerHookEnable(address112, FunctionScrapper::addressOfNonVirtual((der112)(&D::startRecordingDelayedWrapper)));
		}

		if constexpr((mem113)(&$PlayLayer::stopCameraShake) != (der113)(&D::stopCameraShake)) {
			modContainer.registerHookEnable(address113, FunctionScrapper::addressOfNonVirtual((der113)(&D::stopCameraShakeWrapper)));
		}

		if constexpr((mem114)(&$PlayLayer::stopRecording) != (der114)(&D::stopRecording)) {
			modContainer.registerHookEnable(address114, FunctionScrapper::addressOfNonVirtual((der114)(&D::stopRecordingWrapper)));
		}

		if constexpr((mem115)(&$PlayLayer::storeCheckpoint) != (der115)(&D::storeCheckpoint)) {
			modContainer.registerHookEnable(address115, FunctionScrapper::addressOfNonVirtual((der115)(&D::storeCheckpointWrapper)));
		}

		if constexpr((mem116)(&$PlayLayer::switchToFlyMode) != (der116)(&D::switchToFlyMode)) {
			modContainer.registerHookEnable(address116, FunctionScrapper::addressOfNonVirtual((der116)(&D::switchToFlyModeWrapper)));
		}

		if constexpr((mem117)(&$PlayLayer::switchToRobotMode) != (der117)(&D::switchToRobotMode)) {
			modContainer.registerHookEnable(address117, FunctionScrapper::addressOfNonVirtual((der117)(&D::switchToRobotModeWrapper)));
		}

		if constexpr((mem118)(&$PlayLayer::switchToRollMode) != (der118)(&D::switchToRollMode)) {
			modContainer.registerHookEnable(address118, FunctionScrapper::addressOfNonVirtual((der118)(&D::switchToRollModeWrapper)));
		}

		if constexpr((mem119)(&$PlayLayer::switchToSpiderMode) != (der119)(&D::switchToSpiderMode)) {
			modContainer.registerHookEnable(address119, FunctionScrapper::addressOfNonVirtual((der119)(&D::switchToSpiderModeWrapper)));
		}

		if constexpr((mem120)(&$PlayLayer::timeForXPos) != (der120)(&D::timeForXPos)) {
			modContainer.registerHookEnable(address120, FunctionScrapper::addressOfNonVirtual((der120)(&D::timeForXPosWrapper)));
		}

		if constexpr((mem121)(&$PlayLayer::timeForXPos2) != (der121)(&D::timeForXPos2)) {
			modContainer.registerHookEnable(address121, FunctionScrapper::addressOfNonVirtual((der121)(&D::timeForXPos2Wrapper)));
		}

		if constexpr((mem122)(&$PlayLayer::toggleBGEffectVisibility) != (der122)(&D::toggleBGEffectVisibility)) {
			modContainer.registerHookEnable(address122, FunctionScrapper::addressOfNonVirtual((der122)(&D::toggleBGEffectVisibilityWrapper)));
		}

		if constexpr((mem123)(&$PlayLayer::toggleDualMode) != (der123)(&D::toggleDualMode)) {
			modContainer.registerHookEnable(address123, FunctionScrapper::addressOfNonVirtual((der123)(&D::toggleDualModeWrapper)));
		}

		if constexpr((mem124)(&$PlayLayer::toggleFlipped) != (der124)(&D::toggleFlipped)) {
			modContainer.registerHookEnable(address124, FunctionScrapper::addressOfNonVirtual((der124)(&D::toggleFlippedWrapper)));
		}

		if constexpr((mem125)(&$PlayLayer::toggleGhostEffect) != (der125)(&D::toggleGhostEffect)) {
			modContainer.registerHookEnable(address125, FunctionScrapper::addressOfNonVirtual((der125)(&D::toggleGhostEffectWrapper)));
		}

		if constexpr((mem126)(&$PlayLayer::toggleGlitter) != (der126)(&D::toggleGlitter)) {
			modContainer.registerHookEnable(address126, FunctionScrapper::addressOfNonVirtual((der126)(&D::toggleGlitterWrapper)));
		}

		if constexpr((mem127)(&$PlayLayer::togglePracticeMode) != (der127)(&D::togglePracticeMode)) {
			modContainer.registerHookEnable(address127, FunctionScrapper::addressOfNonVirtual((der127)(&D::togglePracticeModeWrapper)));
		}

		if constexpr((mem128)(&$PlayLayer::toggleProgressbar) != (der128)(&D::toggleProgressbar)) {
			modContainer.registerHookEnable(address128, FunctionScrapper::addressOfNonVirtual((der128)(&D::toggleProgressbarWrapper)));
		}

		if constexpr((mem129)(&$PlayLayer::tryStartRecord) != (der129)(&D::tryStartRecord)) {
			modContainer.registerHookEnable(address129, FunctionScrapper::addressOfNonVirtual((der129)(&D::tryStartRecordWrapper)));
		}

		if constexpr((mem130)(&$PlayLayer::unclaimParticle) != (der130)(&D::unclaimParticle)) {
			modContainer.registerHookEnable(address130, FunctionScrapper::addressOfNonVirtual((der130)(&D::unclaimParticleWrapper)));
		}

		if constexpr((mem131)(&$PlayLayer::unregisterActiveObject) != (der131)(&D::unregisterActiveObject)) {
			modContainer.registerHookEnable(address131, FunctionScrapper::addressOfNonVirtual((der131)(&D::unregisterActiveObjectWrapper)));
		}

		if constexpr((mem132)(&$PlayLayer::unregisterStateObject) != (der132)(&D::unregisterStateObject)) {
			modContainer.registerHookEnable(address132, FunctionScrapper::addressOfNonVirtual((der132)(&D::unregisterStateObjectWrapper)));
		}

		if ((mem133)(&$PlayLayer::update) != (der133)(&D::update)) {
			modContainer.registerHookEnable(address133, FunctionScrapper::addressOfVirtual((der133)(&D::updateWrapper)));
		}

		if constexpr((mem134)(&$PlayLayer::updateAttempts) != (der134)(&D::updateAttempts)) {
			modContainer.registerHookEnable(address134, FunctionScrapper::addressOfNonVirtual((der134)(&D::updateAttemptsWrapper)));
		}

		if constexpr((mem135)(&$PlayLayer::updateCamera) != (der135)(&D::updateCamera)) {
			modContainer.registerHookEnable(address135, FunctionScrapper::addressOfNonVirtual((der135)(&D::updateCameraWrapper)));
		}

		if ((mem136)(&$PlayLayer::updateColor) != (der136)(&D::updateColor)) {
			modContainer.registerHookEnable(address136, FunctionScrapper::addressOfVirtual((der136)(&D::updateColorWrapper)));
		}

		if constexpr((mem137)(&$PlayLayer::updateDualGround) != (der137)(&D::updateDualGround)) {
			modContainer.registerHookEnable(address137, FunctionScrapper::addressOfNonVirtual((der137)(&D::updateDualGroundWrapper)));
		}

		if constexpr((mem138)(&$PlayLayer::updateEffectPositions) != (der138)(&D::updateEffectPositions)) {
			modContainer.registerHookEnable(address138, FunctionScrapper::addressOfNonVirtual((der138)(&D::updateEffectPositionsWrapper)));
		}

		if constexpr((mem139)(&$PlayLayer::updateLevelColors) != (der139)(&D::updateLevelColors)) {
			modContainer.registerHookEnable(address139, FunctionScrapper::addressOfNonVirtual((der139)(&D::updateLevelColorsWrapper)));
		}

		if constexpr((mem140)(&$PlayLayer::updateMoveObjectsLastPosition) != (der140)(&D::updateMoveObjectsLastPosition)) {
			modContainer.registerHookEnable(address140, FunctionScrapper::addressOfNonVirtual((der140)(&D::updateMoveObjectsLastPositionWrapper)));
		}

		if constexpr((mem141)(&$PlayLayer::updateProgressbar) != (der141)(&D::updateProgressbar)) {
			modContainer.registerHookEnable(address141, FunctionScrapper::addressOfNonVirtual((der141)(&D::updateProgressbarWrapper)));
		}

		if constexpr((mem142)(&$PlayLayer::updateReplay) != (der142)(&D::updateReplay)) {
			modContainer.registerHookEnable(address142, FunctionScrapper::addressOfNonVirtual((der142)(&D::updateReplayWrapper)));
		}

		if constexpr((mem143)(&$PlayLayer::updateTimeMod) != (der143)(&D::updateTimeMod)) {
			modContainer.registerHookEnable(address143, FunctionScrapper::addressOfNonVirtual((der143)(&D::updateTimeModWrapper)));
		}

		if ((mem144)(&$PlayLayer::updateTweenAction) != (der144)(&D::updateTweenAction)) {
			modContainer.registerHookEnable(address144, FunctionScrapper::addressOfVirtual((der144)(&D::updateTweenActionWrapper)));
		}

		if constexpr((mem145)(&$PlayLayer::updateVisibility) != (der145)(&D::updateVisibility)) {
			modContainer.registerHookEnable(address145, FunctionScrapper::addressOfNonVirtual((der145)(&D::updateVisibilityWrapper)));
		}

		if constexpr((mem146)(&$PlayLayer::vfDChk) != (der146)(&D::vfDChk)) {
			modContainer.registerHookEnable(address146, FunctionScrapper::addressOfNonVirtual((der146)(&D::vfDChkWrapper)));
		}

		if ((mem147)(&$PlayLayer::visit) != (der147)(&D::visit)) {
			modContainer.registerHookEnable(address147, FunctionScrapper::addressOfVirtual((der147)(&D::visitWrapper)));
		}

		if constexpr((mem148)(&$PlayLayer::visitWithColorFlash) != (der148)(&D::visitWithColorFlash)) {
			modContainer.registerHookEnable(address148, FunctionScrapper::addressOfNonVirtual((der148)(&D::visitWithColorFlashWrapper)));
		}

		if constexpr((mem149)(&$PlayLayer::willSwitchToMode) != (der149)(&D::willSwitchToMode)) {
			modContainer.registerHookEnable(address149, FunctionScrapper::addressOfNonVirtual((der149)(&D::willSwitchToModeWrapper)));
		}

		if constexpr((mem150)(&$PlayLayer::xPosForTime) != (der150)(&D::xPosForTime)) {
			modContainer.registerHookEnable(address150, FunctionScrapper::addressOfNonVirtual((der150)(&D::xPosForTimeWrapper)));
		}

		if constexpr(&$PlayLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address151, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $PlayerCheckpoint : PlayerCheckpoint, InterfaceBase {
	$PlayerCheckpoint(const $PlayerCheckpoint& c) : PlayerCheckpoint(c) {}
	$PlayerCheckpoint() = delete;
	setInterfaceTypesOf(1, PlayerCheckpoint, init, , 0);
	setInterfaceStaticTypesOf(2, PlayerCheckpoint, create, , 0);
	static inline auto address0 = base+0x80760;
	static inline auto address1 = base+0x807a0;
	static inline auto address2 = base+0x7e8c0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(PlayerCheckpoint, init, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable static getFunctionOf(PlayerCheckpoint, create, , 0) {
		return reinterpret_cast<fun2>(address2)();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(PlayerCheckpoint, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	static getWrapperOf(PlayerCheckpoint, create, , 0) {
		return D::create();
	}

public:
	static bool _apply() {

		if constexpr(&$PlayerCheckpoint::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$PlayerCheckpoint::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$PlayerCheckpoint::create) != (der2)(&D::create)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $PlayerObject : PlayerObject, InterfaceBase {
	$PlayerObject(const $PlayerObject& c) : PlayerObject(c) {}
	$PlayerObject() = delete;
	setInterfaceTypesOf(1, PlayerObject, update, , 1, float);
	setInterfaceTypesOf(2, PlayerObject, setScaleX, , 1, float);
	setInterfaceTypesOf(3, PlayerObject, setScaleY, , 1, float);
	setInterfaceTypesOf(4, PlayerObject, setScale, , 1, float);
	setInterfaceTypesOf(5, PlayerObject, setPosition, , 1, cocos2d::CCPoint const&);
	setInterfaceTypesOf(6, PlayerObject, setVisible, , 1, bool);
	setInterfaceTypesOf(7, PlayerObject, setRotation, , 1, float);
	setInterfaceTypesOf(8, PlayerObject, setOpacity, , 1, unsigned char);
	setInterfaceTypesOf(9, PlayerObject, setColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(10, PlayerObject, setFlipX, , 1, bool);
	setInterfaceTypesOf(11, PlayerObject, setFlipY, , 1, bool);
	setInterfaceTypesOf(12, PlayerObject, resetObject, , 0);
	setInterfaceTypesOf(13, PlayerObject, getRealPosition, , 0);
	setInterfaceTypesOf(14, PlayerObject, getOrientedBox, , 0);
	setInterfaceTypesOf(15, PlayerObject, animationFinished, , 1, char const*);
	setInterfaceTypesOf(16, PlayerObject, activateStreak, , 0);
	setInterfaceTypesOf(17, PlayerObject, addAllParticles, , 0);
	setInterfaceTypesOf(18, PlayerObject, addToTouchedRings, , 1, GameObject*);
	setInterfaceTypesOf(19, PlayerObject, boostPlayer, , 1, float);
	setInterfaceTypesOf(20, PlayerObject, bumpPlayer, , 2, float, int);
	setInterfaceTypesOf(21, PlayerObject, buttonDown, , 1, PlayerButton);
	setInterfaceTypesOf(22, PlayerObject, checkSnapJumpToObject, , 1, GameObject*);
	setInterfaceTypesOf(23, PlayerObject, collidedWithObject, , 2, float, GameObject*);
	setInterfaceTypesOf(24, PlayerObject, collidedWithObject, , 3, float, GameObject*, cocos2d::CCRect);
	setInterfaceTypesOf(25, PlayerObject, collidedWithSlope, , 3, float, GameObject*, bool);
	setInterfaceTypesOf(26, PlayerObject, convertToClosestRotation, , 1, float);
	setInterfaceTypesOf(27, PlayerObject, copyAttributes, , 1, PlayerObject*);
	setInterfaceStaticTypesOf(28, PlayerObject, create, , 3, int, int, cocos2d::CCLayer*);
	setInterfaceTypesOf(29, PlayerObject, deactivateParticle, , 0);
	setInterfaceTypesOf(30, PlayerObject, deactivateStreak, , 1, bool);
	setInterfaceTypesOf(31, PlayerObject, fadeOutStreak2, , 1, float);
	setInterfaceTypesOf(32, PlayerObject, flashPlayer, , 4, float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B);
	setInterfaceTypesOf(33, PlayerObject, flipGravity, , 2, bool, bool);
	setInterfaceTypesOf(34, PlayerObject, flipMod, , 0);
	setInterfaceTypesOf(35, PlayerObject, getActiveMode, , 0);
	setInterfaceTypesOf(36, PlayerObject, getModifiedSlopeYVel, , 0);
	setInterfaceTypesOf(37, PlayerObject, getOldPosition, , 1, float);
	setInterfaceTypesOf(38, PlayerObject, getSecondColor, , 0);
	setInterfaceTypesOf(39, PlayerObject, gravityDown, , 0);
	setInterfaceTypesOf(40, PlayerObject, gravityUp, , 0);
	setInterfaceTypesOf(41, PlayerObject, hardFlipGravity, , 0);
	setInterfaceTypesOf(42, PlayerObject, hitGround, , 1, bool);
	setInterfaceTypesOf(43, PlayerObject, incrementJumps, , 0);
	setInterfaceTypesOf(44, PlayerObject, init, , 3, int, int, cocos2d::CCLayer*);
	setInterfaceTypesOf(45, PlayerObject, isBoostValid, , 1, float);
	setInterfaceTypesOf(46, PlayerObject, isFlying, , 0);
	setInterfaceTypesOf(47, PlayerObject, isSafeFlip, , 1, float);
	setInterfaceTypesOf(48, PlayerObject, isSafeMode, , 1, float);
	setInterfaceTypesOf(49, PlayerObject, isSafeSpiderFlip, , 1, float);
	setInterfaceTypesOf(50, PlayerObject, levelFlipFinished, , 0);
	setInterfaceTypesOf(51, PlayerObject, levelFlipping, , 0);
	setInterfaceTypesOf(52, PlayerObject, levelWillFlip, , 0);
	setInterfaceTypesOf(53, PlayerObject, loadFromCheckpoint, , 1, PlayerCheckpoint*);
	setInterfaceTypesOf(54, PlayerObject, lockPlayer, , 0);
	setInterfaceTypesOf(55, PlayerObject, logValues, , 0);
	setInterfaceTypesOf(56, PlayerObject, modeDidChange, , 0);
	setInterfaceTypesOf(57, PlayerObject, placeStreakPoint, , 0);
	setInterfaceTypesOf(58, PlayerObject, playBurstEffect, , 0);
	setInterfaceTypesOf(59, PlayerObject, playDeathEffect, , 0);
	setInterfaceTypesOf(60, PlayerObject, playDynamicSpiderRun, , 0);
	setInterfaceTypesOf(61, PlayerObject, playerDestroyed, , 1, bool);
	setInterfaceTypesOf(62, PlayerObject, playerIsFalling, , 0);
	setInterfaceTypesOf(63, PlayerObject, playerTeleported, , 0);
	setInterfaceTypesOf(64, PlayerObject, playingEndEffect, , 0);
	setInterfaceTypesOf(65, PlayerObject, postCollision, , 1, float);
	setInterfaceTypesOf(66, PlayerObject, preCollision, , 0);
	setInterfaceTypesOf(67, PlayerObject, preSlopeCollision, , 2, float, GameObject*);
	setInterfaceTypesOf(68, PlayerObject, propellPlayer, , 1, float);
	setInterfaceTypesOf(69, PlayerObject, pushButton, , 1, PlayerButton);
	setInterfaceTypesOf(70, PlayerObject, pushDown, , 0);
	setInterfaceTypesOf(71, PlayerObject, pushPlayer, , 1, float);
	setInterfaceTypesOf(72, PlayerObject, releaseButton, , 1, PlayerButton);
	setInterfaceTypesOf(73, PlayerObject, removeAllParticles, , 0);
	setInterfaceTypesOf(74, PlayerObject, removePendingCheckpoint, , 0);
	setInterfaceTypesOf(75, PlayerObject, resetAllParticles, , 0);
	setInterfaceTypesOf(76, PlayerObject, resetCollisionLog, , 0);
	setInterfaceTypesOf(77, PlayerObject, resetPlayerIcon, , 0);
	setInterfaceTypesOf(78, PlayerObject, resetStateVariables, , 0);
	setInterfaceTypesOf(79, PlayerObject, resetStreak, , 0);
	setInterfaceTypesOf(80, PlayerObject, ringJump, , 1, GameObject*);
	setInterfaceTypesOf(81, PlayerObject, runBallRotation, , 1, float);
	setInterfaceTypesOf(82, PlayerObject, runBallRotation2, , 0);
	setInterfaceTypesOf(83, PlayerObject, runNormalRotation, , 0);
	setInterfaceTypesOf(84, PlayerObject, runRotateAction, , 1, bool);
	setInterfaceTypesOf(85, PlayerObject, saveToCheckpoint, , 1, PlayerCheckpoint*);
	setInterfaceTypesOf(86, PlayerObject, setSecondColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(87, PlayerObject, setupStreak, , 0);
	setInterfaceTypesOf(88, PlayerObject, spawnCircle, , 0);
	setInterfaceTypesOf(89, PlayerObject, spawnCircle2, , 0);
	setInterfaceTypesOf(90, PlayerObject, spawnDualCircle, , 0);
	setInterfaceTypesOf(91, PlayerObject, spawnFromPlayer, , 1, PlayerObject*);
	setInterfaceTypesOf(92, PlayerObject, spawnPortalCircle, , 2, cocos2d::_ccColor3B, float);
	setInterfaceTypesOf(93, PlayerObject, spawnScaleCircle, , 0);
	setInterfaceTypesOf(94, PlayerObject, specialGroundHit, , 0);
	setInterfaceTypesOf(95, PlayerObject, speedDown, , 0);
	setInterfaceTypesOf(96, PlayerObject, speedUp, , 0);
	setInterfaceTypesOf(97, PlayerObject, spiderTestJump, , 1, bool);
	setInterfaceTypesOf(98, PlayerObject, startDashing, , 1, GameObject*);
	setInterfaceTypesOf(99, PlayerObject, stopBurstEffect, , 0);
	setInterfaceTypesOf(100, PlayerObject, stopDashing, , 0);
	setInterfaceTypesOf(101, PlayerObject, stopRotation, , 1, bool);
	setInterfaceTypesOf(102, PlayerObject, storeCollision, , 2, bool, int);
	setInterfaceTypesOf(103, PlayerObject, switchedToMode, , 1, GameObjectType);
	setInterfaceTypesOf(104, PlayerObject, testForMoving, , 2, float, GameObject*);
	setInterfaceTypesOf(105, PlayerObject, toggleBirdMode, , 1, bool);
	setInterfaceTypesOf(106, PlayerObject, toggleDartMode, , 1, bool);
	setInterfaceTypesOf(107, PlayerObject, toggleFlyMode, , 1, bool);
	setInterfaceTypesOf(108, PlayerObject, toggleGhostEffect, , 1, GhostType);
	setInterfaceTypesOf(109, PlayerObject, togglePlayerScale, , 1, bool);
	setInterfaceTypesOf(110, PlayerObject, toggleRobotMode, , 1, bool);
	setInterfaceTypesOf(111, PlayerObject, toggleRollMode, , 1, bool);
	setInterfaceTypesOf(112, PlayerObject, toggleSpiderMode, , 1, bool);
	setInterfaceTypesOf(113, PlayerObject, toggleVisibility, , 1, bool);
	setInterfaceTypesOf(114, PlayerObject, touchedObject, , 1, GameObject*);
	setInterfaceTypesOf(115, PlayerObject, tryPlaceCheckpoint, , 0);
	setInterfaceTypesOf(116, PlayerObject, updateCheckpointMode, , 1, bool);
	setInterfaceTypesOf(117, PlayerObject, updateCheckpointTest, , 0);
	setInterfaceTypesOf(118, PlayerObject, updateCollide, , 2, bool, int);
	setInterfaceTypesOf(119, PlayerObject, updateCollideBottom, , 2, float, int);
	setInterfaceTypesOf(120, PlayerObject, updateCollideTop, , 2, float, int);
	setInterfaceTypesOf(121, PlayerObject, updateDashAnimation, , 0);
	setInterfaceTypesOf(122, PlayerObject, updateDashArt, , 0);
	setInterfaceTypesOf(123, PlayerObject, updateGlowColor, , 0);
	setInterfaceTypesOf(124, PlayerObject, updateJump, , 1, float);
	setInterfaceTypesOf(125, PlayerObject, updateJumpVariables, , 0);
	setInterfaceTypesOf(126, PlayerObject, updatePlayerBirdFrame, , 1, int);
	setInterfaceTypesOf(127, PlayerObject, updatePlayerDartFrame, , 1, int);
	setInterfaceTypesOf(128, PlayerObject, updatePlayerFrame, , 1, int);
	setInterfaceTypesOf(129, PlayerObject, updatePlayerGlow, , 0);
	setInterfaceTypesOf(130, PlayerObject, updatePlayerRobotFrame, , 1, int);
	setInterfaceTypesOf(131, PlayerObject, updatePlayerRollFrame, , 1, int);
	setInterfaceTypesOf(132, PlayerObject, updatePlayerScale, , 0);
	setInterfaceTypesOf(133, PlayerObject, updatePlayerShipFrame, , 1, int);
	setInterfaceTypesOf(134, PlayerObject, updatePlayerSpiderFrame, , 1, int);
	setInterfaceTypesOf(135, PlayerObject, updatePlayerSpriteExtra, , 1, gd::string);
	setInterfaceTypesOf(136, PlayerObject, updateRobotAnimationSpeed, , 0);
	setInterfaceTypesOf(137, PlayerObject, updateRotation, , 1, float);
	setInterfaceTypesOf(138, PlayerObject, updateRotation, , 2, float, float);
	setInterfaceTypesOf(139, PlayerObject, updateShipRotation, , 1, float);
	setInterfaceTypesOf(140, PlayerObject, updateShipSpriteExtra, , 1, gd::string);
	setInterfaceTypesOf(141, PlayerObject, updateSlopeRotation, , 1, float);
	setInterfaceTypesOf(142, PlayerObject, updateSlopeYVelocity, , 1, float);
	setInterfaceTypesOf(143, PlayerObject, updateSpecial, , 1, float);
	setInterfaceTypesOf(144, PlayerObject, updateStateVariables, , 0);
	setInterfaceTypesOf(145, PlayerObject, updateTimeMod, , 1, float);
	setInterfaceTypesOf(146, PlayerObject, usingWallLimitedMode, , 0);
	setInterfaceTypesOf(147, PlayerObject, yStartDown, , 0);
	setInterfaceTypesOf(148, PlayerObject, yStartUp, , 0);
	static inline auto address0 = base+0x217220;
	static inline auto address1 = base+0x218bf0;
	static inline auto address2 = base+0x22e7f0;
	static inline auto address3 = base+0x22e830;
	static inline auto address4 = base+0x22e870;
	static inline auto address5 = base+0x22c8b0;
	static inline auto address6 = base+0x22e8b0;
	static inline auto address7 = base+0x22e6e0;
	static inline auto address8 = base+0x22d400;
	static inline auto address9 = base+0x22cdf0;
	static inline auto address10 = base+0x22e720;
	static inline auto address11 = base+0x22e7b0;
	static inline auto address12 = base+0x223170;
	static inline auto address13 = base+0x22d5f0;
	static inline auto address14 = base+0x22dee0;
	static inline auto address15 = base+0x22e9d0;
	static inline auto address16 = base+0x21aef0;
	static inline auto address17 = base+0x2189b0;
	static inline auto address18 = base+0x22b800;
	static inline auto address19 = base+0x21d6b0;
	static inline auto address20 = base+0x22d890;
	static inline auto address21 = base+0x22b7e0;
	static inline auto address22 = base+0x2217f0;
	static inline auto address23 = base+0x21d880;
	static inline auto address24 = base+0x21f0b0;
	static inline auto address25 = base+0x21d8d0;
	static inline auto address26 = base+0x21c860;
	static inline auto address27 = base+0x22dc70;
	static inline auto address28 = base+0x217260;
	static inline auto address29 = base+0x21a540;
	static inline auto address30 = base+0x218b30;
	static inline auto address31 = base+0x225890;
	static inline auto address32 = base+0x221c80;
	static inline auto address33 = base+0x21c090;
	static inline auto address34 = base+0x21a4c0;
	static inline auto address35 = base+0x22b950;
	static inline auto address36 = base+0x21bff0;
	static inline auto address37 = base+0x21a830;
	static inline auto address38 = base+0x22cee0;
	static inline auto address39 = base+0x22e930;
	static inline auto address40 = base+0x22e900;
	static inline auto address41 = base+0x22b860;
	static inline auto address42 = base+0x220a30;
	static inline auto address43 = base+0x21c050;
	static inline auto address44 = base+0x2172e0;
	static inline auto address45 = base+0x21d650;
	static inline auto address46 = base+0x21a4e0;
	static inline auto address47 = base+0x2209f0;
	static inline auto address48 = base+0x2209b0;
	static inline auto address49 = base+0x221be0;
	static inline auto address50 = base+0x21b060;
	static inline auto address51 = base+0x21a510;
	static inline auto address52 = base+0x21b020;
	static inline auto address53 = base+0x22e420;
	static inline auto address54 = base+0x22d680;
	static inline auto address55 = base+0x221220;
	static inline auto address56 = base+0x22bfd0;
	static inline auto address57 = base+0x21af90;
	static inline auto address58 = base+0x21c780;
	static inline auto address59 = base+0x225930;
	static inline auto address60 = base+0x222ec0;
	static inline auto address61 = base+0x2256d0;
	static inline auto address62 = base+0x21c730;
	static inline auto address63 = base+0x22b840;
	static inline auto address64 = base+0x22d7e0;
	static inline auto address65 = base+0x21cd10;
	static inline auto address66 = base+0x21ccc0;
	static inline auto address67 = base+0x21ec80;
	static inline auto address68 = base+0x22d8e0;
	static inline auto address69 = base+0x22aa00;
	static inline auto address70 = base+0x22dbd0;
	static inline auto address71 = base+0x22dbb0;
	static inline auto address72 = base+0x22b6f0;
	static inline auto address73 = base+0x218ac0;
	static inline auto address74 = base+0x2237b0;
	static inline auto address75 = base+0x21adb0;
	static inline auto address76 = base+0x21cc20;
	static inline auto address77 = base+0x22be00;
	static inline auto address78 = base+0x223760;
	static inline auto address79 = base+0x21ae10;
	static inline auto address80 = base+0x22abf0;
	static inline auto address81 = base+0x21ca10;
	static inline auto address82 = base+0x21cb10;
	static inline auto address83 = base+0x21c960;
	static inline auto address84 = base+0x21c570;
	static inline auto address85 = base+0x22e2f0;
	static inline auto address86 = base+0x219610;
	static inline auto address87 = base+0x218720;
	static inline auto address88 = base+0x225480;
	static inline auto address89 = base+0x2252a0;
	static inline auto address90 = base+0x2255c0;
	static inline auto address91 = base+0x22dde0;
	static inline auto address92 = base+0x225350;
	static inline auto address93 = base+0x2251b0;
	static inline auto address94 = base+0x22dbf0;
	static inline auto address95 = base+0x22e970;
	static inline auto address96 = base+0x22e950;
	static inline auto address97 = base+0x21b160;
	static inline auto address98 = base+0x221d70;
	static inline auto address99 = base+0x22c680;
	static inline auto address100 = base+0x222990;
	static inline auto address101 = base+0x21c830;
	static inline auto address102 = base+0x21cc60;
	static inline auto address103 = base+0x22b9a0;
	static inline auto address104 = base+0x21eb70;
	static inline auto address105 = base+0x224070;
	static inline auto address106 = base+0x2243f0;
	static inline auto address107 = base+0x223820;
	static inline auto address108 = base+0x225000;
	static inline auto address109 = base+0x224bd0;
	static inline auto address110 = base+0x223c70;
	static inline auto address111 = base+0x223b20;
	static inline auto address112 = base+0x224830;
	static inline auto address113 = base+0x21abf0;
	static inline auto address114 = base+0x22e660;
	static inline auto address115 = base+0x21a950;
	static inline auto address116 = base+0x218980;
	static inline auto address117 = base+0x21a890;
	static inline auto address118 = base+0x220f10;
	static inline auto address119 = base+0x221790;
	static inline auto address120 = base+0x221c20;
	static inline auto address121 = base+0x21a570;
	static inline auto address122 = base+0x222520;
	static inline auto address123 = base+0x22cf10;
	static inline auto address124 = base+0x219680;
	static inline auto address125 = base+0x21a740;
	static inline auto address126 = base+0x22bfe0;
	static inline auto address127 = base+0x22c260;
	static inline auto address128 = base+0x22c470;
	static inline auto address129 = base+0x22bc50;
	static inline auto address130 = base+0x22d620;
	static inline auto address131 = base+0x22c6a0;
	static inline auto address132 = base+0x22b8b0;
	static inline auto address133 = base+0x22ba40;
	static inline auto address134 = base+0x22d650;
	static inline auto address135 = base+0x218440;
	static inline auto address136 = base+0x22df40;
	static inline auto address137 = base+0x2214b0;
	static inline auto address138 = base+0x221230;
	static inline auto address139 = base+0x221310;
	static inline auto address140 = base+0x218510;
	static inline auto address141 = base+0x221030;
	static inline auto address142 = base+0x22e920;
	static inline auto address143 = base+0x21a790;
	static inline auto address144 = base+0x21a770;
	static inline auto address145 = base+0x2185e0;
	static inline auto address146 = base+0x22df00;
	static inline auto address147 = base+0x22e9b0;
	static inline auto address148 = base+0x22e990;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(PlayerObject, update, , 1, float) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setScaleX, , 1, float) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setScaleY, , 1, float) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setScale, , 1, float) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<fun5>(address5)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setVisible, , 1, bool) {
		return reinterpret_cast<fun6>(address6)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setRotation, , 1, float) {
		return reinterpret_cast<fun7>(address7)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun8>(address8)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun9>(address9)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setFlipX, , 1, bool) {
		return reinterpret_cast<fun10>(address10)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setFlipY, , 1, bool) {
		return reinterpret_cast<fun11>(address11)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, resetObject, , 0) {
		return reinterpret_cast<fun12>(address12)(this);
	}

	dupable getFunctionOf(PlayerObject, getRealPosition, , 0) {
		return reinterpret_cast<fun13>(address13)(this);
	}

	dupable getFunctionOf(PlayerObject, getOrientedBox, , 0) {
		return reinterpret_cast<fun14>(address14)(this);
	}

	dupable getFunctionOf(PlayerObject, animationFinished, , 1, char const*) {
		return reinterpret_cast<fun15>(address15)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, activateStreak, , 0) {
		return reinterpret_cast<fun16>(address16)(this);
	}

	dupable getFunctionOf(PlayerObject, addAllParticles, , 0) {
		return reinterpret_cast<fun17>(address17)(this);
	}

	dupable getFunctionOf(PlayerObject, addToTouchedRings, , 1, GameObject*) {
		return reinterpret_cast<fun18>(address18)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, boostPlayer, , 1, float) {
		return reinterpret_cast<fun19>(address19)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, bumpPlayer, , 2, float, int) {
		return reinterpret_cast<fun20>(address20)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, buttonDown, , 1, PlayerButton) {
		return reinterpret_cast<fun21>(address21)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, checkSnapJumpToObject, , 1, GameObject*) {
		return reinterpret_cast<fun22>(address22)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, collidedWithObject, , 2, float, GameObject*) {
		return reinterpret_cast<fun23>(address23)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, collidedWithObject, , 3, float, GameObject*, cocos2d::CCRect) {
		return reinterpret_cast<fun24>(address24)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayerObject, collidedWithSlope, , 3, float, GameObject*, bool) {
		return reinterpret_cast<fun25>(address25)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayerObject, convertToClosestRotation, , 1, float) {
		return reinterpret_cast<fun26>(address26)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, copyAttributes, , 1, PlayerObject*) {
		return reinterpret_cast<fun27>(address27)(this, p0);
	}

	dupable static getFunctionOf(PlayerObject, create, , 3, int, int, cocos2d::CCLayer*) {
		return reinterpret_cast<fun28>(address28)(p0, p1, p2);
	}

	dupable getFunctionOf(PlayerObject, deactivateParticle, , 0) {
		return reinterpret_cast<fun29>(address29)(this);
	}

	dupable getFunctionOf(PlayerObject, deactivateStreak, , 1, bool) {
		return reinterpret_cast<fun30>(address30)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, fadeOutStreak2, , 1, float) {
		return reinterpret_cast<fun31>(address31)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, flashPlayer, , 4, float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B) {
		return reinterpret_cast<fun32>(address32)(this, p0, p1, p2, p3);
	}

	dupable getFunctionOf(PlayerObject, flipGravity, , 2, bool, bool) {
		return reinterpret_cast<fun33>(address33)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, flipMod, , 0) {
		return reinterpret_cast<fun34>(address34)(this);
	}

	dupable getFunctionOf(PlayerObject, getActiveMode, , 0) {
		return reinterpret_cast<fun35>(address35)(this);
	}

	dupable getFunctionOf(PlayerObject, getModifiedSlopeYVel, , 0) {
		return reinterpret_cast<fun36>(address36)(this);
	}

	dupable getFunctionOf(PlayerObject, getOldPosition, , 1, float) {
		return reinterpret_cast<fun37>(address37)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, getSecondColor, , 0) {
		return reinterpret_cast<fun38>(address38)(this);
	}

	dupable getFunctionOf(PlayerObject, gravityDown, , 0) {
		return reinterpret_cast<fun39>(address39)(this);
	}

	dupable getFunctionOf(PlayerObject, gravityUp, , 0) {
		return reinterpret_cast<fun40>(address40)(this);
	}

	dupable getFunctionOf(PlayerObject, hardFlipGravity, , 0) {
		return reinterpret_cast<fun41>(address41)(this);
	}

	dupable getFunctionOf(PlayerObject, hitGround, , 1, bool) {
		return reinterpret_cast<fun42>(address42)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, incrementJumps, , 0) {
		return reinterpret_cast<fun43>(address43)(this);
	}

	dupable getFunctionOf(PlayerObject, init, , 3, int, int, cocos2d::CCLayer*) {
		return reinterpret_cast<fun44>(address44)(this, p0, p1, p2);
	}

	dupable getFunctionOf(PlayerObject, isBoostValid, , 1, float) {
		return reinterpret_cast<fun45>(address45)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, isFlying, , 0) {
		return reinterpret_cast<fun46>(address46)(this);
	}

	dupable getFunctionOf(PlayerObject, isSafeFlip, , 1, float) {
		return reinterpret_cast<fun47>(address47)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, isSafeMode, , 1, float) {
		return reinterpret_cast<fun48>(address48)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, isSafeSpiderFlip, , 1, float) {
		return reinterpret_cast<fun49>(address49)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, levelFlipFinished, , 0) {
		return reinterpret_cast<fun50>(address50)(this);
	}

	dupable getFunctionOf(PlayerObject, levelFlipping, , 0) {
		return reinterpret_cast<fun51>(address51)(this);
	}

	dupable getFunctionOf(PlayerObject, levelWillFlip, , 0) {
		return reinterpret_cast<fun52>(address52)(this);
	}

	dupable getFunctionOf(PlayerObject, loadFromCheckpoint, , 1, PlayerCheckpoint*) {
		return reinterpret_cast<fun53>(address53)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, lockPlayer, , 0) {
		return reinterpret_cast<fun54>(address54)(this);
	}

	dupable getFunctionOf(PlayerObject, logValues, , 0) {
		return reinterpret_cast<fun55>(address55)(this);
	}

	dupable getFunctionOf(PlayerObject, modeDidChange, , 0) {
		return reinterpret_cast<fun56>(address56)(this);
	}

	dupable getFunctionOf(PlayerObject, placeStreakPoint, , 0) {
		return reinterpret_cast<fun57>(address57)(this);
	}

	dupable getFunctionOf(PlayerObject, playBurstEffect, , 0) {
		return reinterpret_cast<fun58>(address58)(this);
	}

	dupable getFunctionOf(PlayerObject, playDeathEffect, , 0) {
		return reinterpret_cast<fun59>(address59)(this);
	}

	dupable getFunctionOf(PlayerObject, playDynamicSpiderRun, , 0) {
		return reinterpret_cast<fun60>(address60)(this);
	}

	dupable getFunctionOf(PlayerObject, playerDestroyed, , 1, bool) {
		return reinterpret_cast<fun61>(address61)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, playerIsFalling, , 0) {
		return reinterpret_cast<fun62>(address62)(this);
	}

	dupable getFunctionOf(PlayerObject, playerTeleported, , 0) {
		return reinterpret_cast<fun63>(address63)(this);
	}

	dupable getFunctionOf(PlayerObject, playingEndEffect, , 0) {
		return reinterpret_cast<fun64>(address64)(this);
	}

	dupable getFunctionOf(PlayerObject, postCollision, , 1, float) {
		return reinterpret_cast<fun65>(address65)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, preCollision, , 0) {
		return reinterpret_cast<fun66>(address66)(this);
	}

	dupable getFunctionOf(PlayerObject, preSlopeCollision, , 2, float, GameObject*) {
		return reinterpret_cast<fun67>(address67)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, propellPlayer, , 1, float) {
		return reinterpret_cast<fun68>(address68)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, pushButton, , 1, PlayerButton) {
		return reinterpret_cast<fun69>(address69)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, pushDown, , 0) {
		return reinterpret_cast<fun70>(address70)(this);
	}

	dupable getFunctionOf(PlayerObject, pushPlayer, , 1, float) {
		return reinterpret_cast<fun71>(address71)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, releaseButton, , 1, PlayerButton) {
		return reinterpret_cast<fun72>(address72)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, removeAllParticles, , 0) {
		return reinterpret_cast<fun73>(address73)(this);
	}

	dupable getFunctionOf(PlayerObject, removePendingCheckpoint, , 0) {
		return reinterpret_cast<fun74>(address74)(this);
	}

	dupable getFunctionOf(PlayerObject, resetAllParticles, , 0) {
		return reinterpret_cast<fun75>(address75)(this);
	}

	dupable getFunctionOf(PlayerObject, resetCollisionLog, , 0) {
		return reinterpret_cast<fun76>(address76)(this);
	}

	dupable getFunctionOf(PlayerObject, resetPlayerIcon, , 0) {
		return reinterpret_cast<fun77>(address77)(this);
	}

	dupable getFunctionOf(PlayerObject, resetStateVariables, , 0) {
		return reinterpret_cast<fun78>(address78)(this);
	}

	dupable getFunctionOf(PlayerObject, resetStreak, , 0) {
		return reinterpret_cast<fun79>(address79)(this);
	}

	dupable getFunctionOf(PlayerObject, ringJump, , 1, GameObject*) {
		return reinterpret_cast<fun80>(address80)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, runBallRotation, , 1, float) {
		return reinterpret_cast<fun81>(address81)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, runBallRotation2, , 0) {
		return reinterpret_cast<fun82>(address82)(this);
	}

	dupable getFunctionOf(PlayerObject, runNormalRotation, , 0) {
		return reinterpret_cast<fun83>(address83)(this);
	}

	dupable getFunctionOf(PlayerObject, runRotateAction, , 1, bool) {
		return reinterpret_cast<fun84>(address84)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, saveToCheckpoint, , 1, PlayerCheckpoint*) {
		return reinterpret_cast<fun85>(address85)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setSecondColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun86>(address86)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, setupStreak, , 0) {
		return reinterpret_cast<fun87>(address87)(this);
	}

	dupable getFunctionOf(PlayerObject, spawnCircle, , 0) {
		return reinterpret_cast<fun88>(address88)(this);
	}

	dupable getFunctionOf(PlayerObject, spawnCircle2, , 0) {
		return reinterpret_cast<fun89>(address89)(this);
	}

	dupable getFunctionOf(PlayerObject, spawnDualCircle, , 0) {
		return reinterpret_cast<fun90>(address90)(this);
	}

	dupable getFunctionOf(PlayerObject, spawnFromPlayer, , 1, PlayerObject*) {
		return reinterpret_cast<fun91>(address91)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, spawnPortalCircle, , 2, cocos2d::_ccColor3B, float) {
		return reinterpret_cast<fun92>(address92)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, spawnScaleCircle, , 0) {
		return reinterpret_cast<fun93>(address93)(this);
	}

	dupable getFunctionOf(PlayerObject, specialGroundHit, , 0) {
		return reinterpret_cast<fun94>(address94)(this);
	}

	dupable getFunctionOf(PlayerObject, speedDown, , 0) {
		return reinterpret_cast<fun95>(address95)(this);
	}

	dupable getFunctionOf(PlayerObject, speedUp, , 0) {
		return reinterpret_cast<fun96>(address96)(this);
	}

	dupable getFunctionOf(PlayerObject, spiderTestJump, , 1, bool) {
		return reinterpret_cast<fun97>(address97)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, startDashing, , 1, GameObject*) {
		return reinterpret_cast<fun98>(address98)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, stopBurstEffect, , 0) {
		return reinterpret_cast<fun99>(address99)(this);
	}

	dupable getFunctionOf(PlayerObject, stopDashing, , 0) {
		return reinterpret_cast<fun100>(address100)(this);
	}

	dupable getFunctionOf(PlayerObject, stopRotation, , 1, bool) {
		return reinterpret_cast<fun101>(address101)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, storeCollision, , 2, bool, int) {
		return reinterpret_cast<fun102>(address102)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, switchedToMode, , 1, GameObjectType) {
		return reinterpret_cast<fun103>(address103)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, testForMoving, , 2, float, GameObject*) {
		return reinterpret_cast<fun104>(address104)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, toggleBirdMode, , 1, bool) {
		return reinterpret_cast<fun105>(address105)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleDartMode, , 1, bool) {
		return reinterpret_cast<fun106>(address106)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleFlyMode, , 1, bool) {
		return reinterpret_cast<fun107>(address107)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleGhostEffect, , 1, GhostType) {
		return reinterpret_cast<fun108>(address108)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, togglePlayerScale, , 1, bool) {
		return reinterpret_cast<fun109>(address109)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleRobotMode, , 1, bool) {
		return reinterpret_cast<fun110>(address110)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleRollMode, , 1, bool) {
		return reinterpret_cast<fun111>(address111)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleSpiderMode, , 1, bool) {
		return reinterpret_cast<fun112>(address112)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, toggleVisibility, , 1, bool) {
		return reinterpret_cast<fun113>(address113)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, touchedObject, , 1, GameObject*) {
		return reinterpret_cast<fun114>(address114)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, tryPlaceCheckpoint, , 0) {
		return reinterpret_cast<fun115>(address115)(this);
	}

	dupable getFunctionOf(PlayerObject, updateCheckpointMode, , 1, bool) {
		return reinterpret_cast<fun116>(address116)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateCheckpointTest, , 0) {
		return reinterpret_cast<fun117>(address117)(this);
	}

	dupable getFunctionOf(PlayerObject, updateCollide, , 2, bool, int) {
		return reinterpret_cast<fun118>(address118)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, updateCollideBottom, , 2, float, int) {
		return reinterpret_cast<fun119>(address119)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, updateCollideTop, , 2, float, int) {
		return reinterpret_cast<fun120>(address120)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, updateDashAnimation, , 0) {
		return reinterpret_cast<fun121>(address121)(this);
	}

	dupable getFunctionOf(PlayerObject, updateDashArt, , 0) {
		return reinterpret_cast<fun122>(address122)(this);
	}

	dupable getFunctionOf(PlayerObject, updateGlowColor, , 0) {
		return reinterpret_cast<fun123>(address123)(this);
	}

	dupable getFunctionOf(PlayerObject, updateJump, , 1, float) {
		return reinterpret_cast<fun124>(address124)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateJumpVariables, , 0) {
		return reinterpret_cast<fun125>(address125)(this);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerBirdFrame, , 1, int) {
		return reinterpret_cast<fun126>(address126)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerDartFrame, , 1, int) {
		return reinterpret_cast<fun127>(address127)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerFrame, , 1, int) {
		return reinterpret_cast<fun128>(address128)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerGlow, , 0) {
		return reinterpret_cast<fun129>(address129)(this);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerRobotFrame, , 1, int) {
		return reinterpret_cast<fun130>(address130)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerRollFrame, , 1, int) {
		return reinterpret_cast<fun131>(address131)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerScale, , 0) {
		return reinterpret_cast<fun132>(address132)(this);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerShipFrame, , 1, int) {
		return reinterpret_cast<fun133>(address133)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerSpiderFrame, , 1, int) {
		return reinterpret_cast<fun134>(address134)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updatePlayerSpriteExtra, , 1, gd::string) {
		return reinterpret_cast<fun135>(address135)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateRobotAnimationSpeed, , 0) {
		return reinterpret_cast<fun136>(address136)(this);
	}

	dupable getFunctionOf(PlayerObject, updateRotation, , 1, float) {
		return reinterpret_cast<fun137>(address137)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateRotation, , 2, float, float) {
		return reinterpret_cast<fun138>(address138)(this, p0, p1);
	}

	dupable getFunctionOf(PlayerObject, updateShipRotation, , 1, float) {
		return reinterpret_cast<fun139>(address139)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateShipSpriteExtra, , 1, gd::string) {
		return reinterpret_cast<fun140>(address140)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateSlopeRotation, , 1, float) {
		return reinterpret_cast<fun141>(address141)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateSlopeYVelocity, , 1, float) {
		return reinterpret_cast<fun142>(address142)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateSpecial, , 1, float) {
		return reinterpret_cast<fun143>(address143)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, updateStateVariables, , 0) {
		return reinterpret_cast<fun144>(address144)(this);
	}

	dupable getFunctionOf(PlayerObject, updateTimeMod, , 1, float) {
		return reinterpret_cast<fun145>(address145)(this, p0);
	}

	dupable getFunctionOf(PlayerObject, usingWallLimitedMode, , 0) {
		return reinterpret_cast<fun146>(address146)(this);
	}

	dupable getFunctionOf(PlayerObject, yStartDown, , 0) {
		return reinterpret_cast<fun147>(address147)(this);
	}

	dupable getFunctionOf(PlayerObject, yStartUp, , 0) {
		return reinterpret_cast<fun148>(address148)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(PlayerObject, update, , 1, float) {
		return reinterpret_cast<D*>(this)->D::update(p0);
	}

	getWrapperOf(PlayerObject, setScaleX, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleX(p0);
	}

	getWrapperOf(PlayerObject, setScaleY, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScaleY(p0);
	}

	getWrapperOf(PlayerObject, setScale, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setScale(p0);
	}

	getWrapperOf(PlayerObject, setPosition, , 1, cocos2d::CCPoint const&) {
		return reinterpret_cast<D*>(this)->D::setPosition(p0);
	}

	getWrapperOf(PlayerObject, setVisible, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setVisible(p0);
	}

	getWrapperOf(PlayerObject, setRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setRotation(p0);
	}

	getWrapperOf(PlayerObject, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	getWrapperOf(PlayerObject, setColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setColor(p0);
	}

	getWrapperOf(PlayerObject, setFlipX, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setFlipX(p0);
	}

	getWrapperOf(PlayerObject, setFlipY, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setFlipY(p0);
	}

	getWrapperOf(PlayerObject, resetObject, , 0) {
		return reinterpret_cast<D*>(this)->D::resetObject();
	}

	getWrapperOf(PlayerObject, getRealPosition, , 0) {
		return reinterpret_cast<D*>(this)->D::getRealPosition();
	}

	getWrapperOf(PlayerObject, getOrientedBox, , 0) {
		return reinterpret_cast<D*>(this)->D::getOrientedBox();
	}

	getWrapperOf(PlayerObject, animationFinished, , 1, char const*) {
		return reinterpret_cast<D*>(this)->D::animationFinished(p0);
	}

	getWrapperOf(PlayerObject, activateStreak, , 0) {
		return reinterpret_cast<D*>(this)->D::activateStreak();
	}

	getWrapperOf(PlayerObject, addAllParticles, , 0) {
		return reinterpret_cast<D*>(this)->D::addAllParticles();
	}

	getWrapperOf(PlayerObject, addToTouchedRings, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::addToTouchedRings(p0);
	}

	getWrapperOf(PlayerObject, boostPlayer, , 1, float) {
		return reinterpret_cast<D*>(this)->D::boostPlayer(p0);
	}

	getWrapperOf(PlayerObject, bumpPlayer, , 2, float, int) {
		return reinterpret_cast<D*>(this)->D::bumpPlayer(p0, p1);
	}

	getWrapperOf(PlayerObject, buttonDown, , 1, PlayerButton) {
		return reinterpret_cast<D*>(this)->D::buttonDown(p0);
	}

	getWrapperOf(PlayerObject, checkSnapJumpToObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::checkSnapJumpToObject(p0);
	}

	getWrapperOf(PlayerObject, collidedWithObject, , 2, float, GameObject*) {
		return reinterpret_cast<D*>(this)->D::collidedWithObject(p0, p1);
	}

	getWrapperOf(PlayerObject, collidedWithObject, , 3, float, GameObject*, cocos2d::CCRect) {
		return reinterpret_cast<D*>(this)->D::collidedWithObject(p0, p1, p2);
	}

	getWrapperOf(PlayerObject, collidedWithSlope, , 3, float, GameObject*, bool) {
		return reinterpret_cast<D*>(this)->D::collidedWithSlope(p0, p1, p2);
	}

	getWrapperOf(PlayerObject, convertToClosestRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::convertToClosestRotation(p0);
	}

	getWrapperOf(PlayerObject, copyAttributes, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::copyAttributes(p0);
	}

	static getWrapperOf(PlayerObject, create, , 3, int, int, cocos2d::CCLayer*) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(PlayerObject, deactivateParticle, , 0) {
		return reinterpret_cast<D*>(this)->D::deactivateParticle();
	}

	getWrapperOf(PlayerObject, deactivateStreak, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::deactivateStreak(p0);
	}

	getWrapperOf(PlayerObject, fadeOutStreak2, , 1, float) {
		return reinterpret_cast<D*>(this)->D::fadeOutStreak2(p0);
	}

	getWrapperOf(PlayerObject, flashPlayer, , 4, float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B) {
		return reinterpret_cast<D*>(this)->D::flashPlayer(p0, p1, p2, p3);
	}

	getWrapperOf(PlayerObject, flipGravity, , 2, bool, bool) {
		return reinterpret_cast<D*>(this)->D::flipGravity(p0, p1);
	}

	getWrapperOf(PlayerObject, flipMod, , 0) {
		return reinterpret_cast<D*>(this)->D::flipMod();
	}

	getWrapperOf(PlayerObject, getActiveMode, , 0) {
		return reinterpret_cast<D*>(this)->D::getActiveMode();
	}

	getWrapperOf(PlayerObject, getModifiedSlopeYVel, , 0) {
		return reinterpret_cast<D*>(this)->D::getModifiedSlopeYVel();
	}

	getWrapperOf(PlayerObject, getOldPosition, , 1, float) {
		return reinterpret_cast<D*>(this)->D::getOldPosition(p0);
	}

	getWrapperOf(PlayerObject, getSecondColor, , 0) {
		return reinterpret_cast<D*>(this)->D::getSecondColor();
	}

	getWrapperOf(PlayerObject, gravityDown, , 0) {
		return reinterpret_cast<D*>(this)->D::gravityDown();
	}

	getWrapperOf(PlayerObject, gravityUp, , 0) {
		return reinterpret_cast<D*>(this)->D::gravityUp();
	}

	getWrapperOf(PlayerObject, hardFlipGravity, , 0) {
		return reinterpret_cast<D*>(this)->D::hardFlipGravity();
	}

	getWrapperOf(PlayerObject, hitGround, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::hitGround(p0);
	}

	getWrapperOf(PlayerObject, incrementJumps, , 0) {
		return reinterpret_cast<D*>(this)->D::incrementJumps();
	}

	getWrapperOf(PlayerObject, init, , 3, int, int, cocos2d::CCLayer*) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1, p2);
	}

	getWrapperOf(PlayerObject, isBoostValid, , 1, float) {
		return reinterpret_cast<D*>(this)->D::isBoostValid(p0);
	}

	getWrapperOf(PlayerObject, isFlying, , 0) {
		return reinterpret_cast<D*>(this)->D::isFlying();
	}

	getWrapperOf(PlayerObject, isSafeFlip, , 1, float) {
		return reinterpret_cast<D*>(this)->D::isSafeFlip(p0);
	}

	getWrapperOf(PlayerObject, isSafeMode, , 1, float) {
		return reinterpret_cast<D*>(this)->D::isSafeMode(p0);
	}

	getWrapperOf(PlayerObject, isSafeSpiderFlip, , 1, float) {
		return reinterpret_cast<D*>(this)->D::isSafeSpiderFlip(p0);
	}

	getWrapperOf(PlayerObject, levelFlipFinished, , 0) {
		return reinterpret_cast<D*>(this)->D::levelFlipFinished();
	}

	getWrapperOf(PlayerObject, levelFlipping, , 0) {
		return reinterpret_cast<D*>(this)->D::levelFlipping();
	}

	getWrapperOf(PlayerObject, levelWillFlip, , 0) {
		return reinterpret_cast<D*>(this)->D::levelWillFlip();
	}

	getWrapperOf(PlayerObject, loadFromCheckpoint, , 1, PlayerCheckpoint*) {
		return reinterpret_cast<D*>(this)->D::loadFromCheckpoint(p0);
	}

	getWrapperOf(PlayerObject, lockPlayer, , 0) {
		return reinterpret_cast<D*>(this)->D::lockPlayer();
	}

	getWrapperOf(PlayerObject, logValues, , 0) {
		return reinterpret_cast<D*>(this)->D::logValues();
	}

	getWrapperOf(PlayerObject, modeDidChange, , 0) {
		return reinterpret_cast<D*>(this)->D::modeDidChange();
	}

	getWrapperOf(PlayerObject, placeStreakPoint, , 0) {
		return reinterpret_cast<D*>(this)->D::placeStreakPoint();
	}

	getWrapperOf(PlayerObject, playBurstEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::playBurstEffect();
	}

	getWrapperOf(PlayerObject, playDeathEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::playDeathEffect();
	}

	getWrapperOf(PlayerObject, playDynamicSpiderRun, , 0) {
		return reinterpret_cast<D*>(this)->D::playDynamicSpiderRun();
	}

	getWrapperOf(PlayerObject, playerDestroyed, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::playerDestroyed(p0);
	}

	getWrapperOf(PlayerObject, playerIsFalling, , 0) {
		return reinterpret_cast<D*>(this)->D::playerIsFalling();
	}

	getWrapperOf(PlayerObject, playerTeleported, , 0) {
		return reinterpret_cast<D*>(this)->D::playerTeleported();
	}

	getWrapperOf(PlayerObject, playingEndEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::playingEndEffect();
	}

	getWrapperOf(PlayerObject, postCollision, , 1, float) {
		return reinterpret_cast<D*>(this)->D::postCollision(p0);
	}

	getWrapperOf(PlayerObject, preCollision, , 0) {
		return reinterpret_cast<D*>(this)->D::preCollision();
	}

	getWrapperOf(PlayerObject, preSlopeCollision, , 2, float, GameObject*) {
		return reinterpret_cast<D*>(this)->D::preSlopeCollision(p0, p1);
	}

	getWrapperOf(PlayerObject, propellPlayer, , 1, float) {
		return reinterpret_cast<D*>(this)->D::propellPlayer(p0);
	}

	getWrapperOf(PlayerObject, pushButton, , 1, PlayerButton) {
		return reinterpret_cast<D*>(this)->D::pushButton(p0);
	}

	getWrapperOf(PlayerObject, pushDown, , 0) {
		return reinterpret_cast<D*>(this)->D::pushDown();
	}

	getWrapperOf(PlayerObject, pushPlayer, , 1, float) {
		return reinterpret_cast<D*>(this)->D::pushPlayer(p0);
	}

	getWrapperOf(PlayerObject, releaseButton, , 1, PlayerButton) {
		return reinterpret_cast<D*>(this)->D::releaseButton(p0);
	}

	getWrapperOf(PlayerObject, removeAllParticles, , 0) {
		return reinterpret_cast<D*>(this)->D::removeAllParticles();
	}

	getWrapperOf(PlayerObject, removePendingCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::removePendingCheckpoint();
	}

	getWrapperOf(PlayerObject, resetAllParticles, , 0) {
		return reinterpret_cast<D*>(this)->D::resetAllParticles();
	}

	getWrapperOf(PlayerObject, resetCollisionLog, , 0) {
		return reinterpret_cast<D*>(this)->D::resetCollisionLog();
	}

	getWrapperOf(PlayerObject, resetPlayerIcon, , 0) {
		return reinterpret_cast<D*>(this)->D::resetPlayerIcon();
	}

	getWrapperOf(PlayerObject, resetStateVariables, , 0) {
		return reinterpret_cast<D*>(this)->D::resetStateVariables();
	}

	getWrapperOf(PlayerObject, resetStreak, , 0) {
		return reinterpret_cast<D*>(this)->D::resetStreak();
	}

	getWrapperOf(PlayerObject, ringJump, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::ringJump(p0);
	}

	getWrapperOf(PlayerObject, runBallRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::runBallRotation(p0);
	}

	getWrapperOf(PlayerObject, runBallRotation2, , 0) {
		return reinterpret_cast<D*>(this)->D::runBallRotation2();
	}

	getWrapperOf(PlayerObject, runNormalRotation, , 0) {
		return reinterpret_cast<D*>(this)->D::runNormalRotation();
	}

	getWrapperOf(PlayerObject, runRotateAction, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::runRotateAction(p0);
	}

	getWrapperOf(PlayerObject, saveToCheckpoint, , 1, PlayerCheckpoint*) {
		return reinterpret_cast<D*>(this)->D::saveToCheckpoint(p0);
	}

	getWrapperOf(PlayerObject, setSecondColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setSecondColor(p0);
	}

	getWrapperOf(PlayerObject, setupStreak, , 0) {
		return reinterpret_cast<D*>(this)->D::setupStreak();
	}

	getWrapperOf(PlayerObject, spawnCircle, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnCircle();
	}

	getWrapperOf(PlayerObject, spawnCircle2, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnCircle2();
	}

	getWrapperOf(PlayerObject, spawnDualCircle, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnDualCircle();
	}

	getWrapperOf(PlayerObject, spawnFromPlayer, , 1, PlayerObject*) {
		return reinterpret_cast<D*>(this)->D::spawnFromPlayer(p0);
	}

	getWrapperOf(PlayerObject, spawnPortalCircle, , 2, cocos2d::_ccColor3B, float) {
		return reinterpret_cast<D*>(this)->D::spawnPortalCircle(p0, p1);
	}

	getWrapperOf(PlayerObject, spawnScaleCircle, , 0) {
		return reinterpret_cast<D*>(this)->D::spawnScaleCircle();
	}

	getWrapperOf(PlayerObject, specialGroundHit, , 0) {
		return reinterpret_cast<D*>(this)->D::specialGroundHit();
	}

	getWrapperOf(PlayerObject, speedDown, , 0) {
		return reinterpret_cast<D*>(this)->D::speedDown();
	}

	getWrapperOf(PlayerObject, speedUp, , 0) {
		return reinterpret_cast<D*>(this)->D::speedUp();
	}

	getWrapperOf(PlayerObject, spiderTestJump, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::spiderTestJump(p0);
	}

	getWrapperOf(PlayerObject, startDashing, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::startDashing(p0);
	}

	getWrapperOf(PlayerObject, stopBurstEffect, , 0) {
		return reinterpret_cast<D*>(this)->D::stopBurstEffect();
	}

	getWrapperOf(PlayerObject, stopDashing, , 0) {
		return reinterpret_cast<D*>(this)->D::stopDashing();
	}

	getWrapperOf(PlayerObject, stopRotation, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::stopRotation(p0);
	}

	getWrapperOf(PlayerObject, storeCollision, , 2, bool, int) {
		return reinterpret_cast<D*>(this)->D::storeCollision(p0, p1);
	}

	getWrapperOf(PlayerObject, switchedToMode, , 1, GameObjectType) {
		return reinterpret_cast<D*>(this)->D::switchedToMode(p0);
	}

	getWrapperOf(PlayerObject, testForMoving, , 2, float, GameObject*) {
		return reinterpret_cast<D*>(this)->D::testForMoving(p0, p1);
	}

	getWrapperOf(PlayerObject, toggleBirdMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleBirdMode(p0);
	}

	getWrapperOf(PlayerObject, toggleDartMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleDartMode(p0);
	}

	getWrapperOf(PlayerObject, toggleFlyMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleFlyMode(p0);
	}

	getWrapperOf(PlayerObject, toggleGhostEffect, , 1, GhostType) {
		return reinterpret_cast<D*>(this)->D::toggleGhostEffect(p0);
	}

	getWrapperOf(PlayerObject, togglePlayerScale, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::togglePlayerScale(p0);
	}

	getWrapperOf(PlayerObject, toggleRobotMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleRobotMode(p0);
	}

	getWrapperOf(PlayerObject, toggleRollMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleRollMode(p0);
	}

	getWrapperOf(PlayerObject, toggleSpiderMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleSpiderMode(p0);
	}

	getWrapperOf(PlayerObject, toggleVisibility, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleVisibility(p0);
	}

	getWrapperOf(PlayerObject, touchedObject, , 1, GameObject*) {
		return reinterpret_cast<D*>(this)->D::touchedObject(p0);
	}

	getWrapperOf(PlayerObject, tryPlaceCheckpoint, , 0) {
		return reinterpret_cast<D*>(this)->D::tryPlaceCheckpoint();
	}

	getWrapperOf(PlayerObject, updateCheckpointMode, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::updateCheckpointMode(p0);
	}

	getWrapperOf(PlayerObject, updateCheckpointTest, , 0) {
		return reinterpret_cast<D*>(this)->D::updateCheckpointTest();
	}

	getWrapperOf(PlayerObject, updateCollide, , 2, bool, int) {
		return reinterpret_cast<D*>(this)->D::updateCollide(p0, p1);
	}

	getWrapperOf(PlayerObject, updateCollideBottom, , 2, float, int) {
		return reinterpret_cast<D*>(this)->D::updateCollideBottom(p0, p1);
	}

	getWrapperOf(PlayerObject, updateCollideTop, , 2, float, int) {
		return reinterpret_cast<D*>(this)->D::updateCollideTop(p0, p1);
	}

	getWrapperOf(PlayerObject, updateDashAnimation, , 0) {
		return reinterpret_cast<D*>(this)->D::updateDashAnimation();
	}

	getWrapperOf(PlayerObject, updateDashArt, , 0) {
		return reinterpret_cast<D*>(this)->D::updateDashArt();
	}

	getWrapperOf(PlayerObject, updateGlowColor, , 0) {
		return reinterpret_cast<D*>(this)->D::updateGlowColor();
	}

	getWrapperOf(PlayerObject, updateJump, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateJump(p0);
	}

	getWrapperOf(PlayerObject, updateJumpVariables, , 0) {
		return reinterpret_cast<D*>(this)->D::updateJumpVariables();
	}

	getWrapperOf(PlayerObject, updatePlayerBirdFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerBirdFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerDartFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerDartFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerGlow, , 0) {
		return reinterpret_cast<D*>(this)->D::updatePlayerGlow();
	}

	getWrapperOf(PlayerObject, updatePlayerRobotFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerRobotFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerRollFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerRollFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerScale, , 0) {
		return reinterpret_cast<D*>(this)->D::updatePlayerScale();
	}

	getWrapperOf(PlayerObject, updatePlayerShipFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerShipFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerSpiderFrame, , 1, int) {
		return reinterpret_cast<D*>(this)->D::updatePlayerSpiderFrame(p0);
	}

	getWrapperOf(PlayerObject, updatePlayerSpriteExtra, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::updatePlayerSpriteExtra(p0);
	}

	getWrapperOf(PlayerObject, updateRobotAnimationSpeed, , 0) {
		return reinterpret_cast<D*>(this)->D::updateRobotAnimationSpeed();
	}

	getWrapperOf(PlayerObject, updateRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateRotation(p0);
	}

	getWrapperOf(PlayerObject, updateRotation, , 2, float, float) {
		return reinterpret_cast<D*>(this)->D::updateRotation(p0, p1);
	}

	getWrapperOf(PlayerObject, updateShipRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateShipRotation(p0);
	}

	getWrapperOf(PlayerObject, updateShipSpriteExtra, , 1, gd::string) {
		return reinterpret_cast<D*>(this)->D::updateShipSpriteExtra(p0);
	}

	getWrapperOf(PlayerObject, updateSlopeRotation, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateSlopeRotation(p0);
	}

	getWrapperOf(PlayerObject, updateSlopeYVelocity, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateSlopeYVelocity(p0);
	}

	getWrapperOf(PlayerObject, updateSpecial, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateSpecial(p0);
	}

	getWrapperOf(PlayerObject, updateStateVariables, , 0) {
		return reinterpret_cast<D*>(this)->D::updateStateVariables();
	}

	getWrapperOf(PlayerObject, updateTimeMod, , 1, float) {
		return reinterpret_cast<D*>(this)->D::updateTimeMod(p0);
	}

	getWrapperOf(PlayerObject, usingWallLimitedMode, , 0) {
		return reinterpret_cast<D*>(this)->D::usingWallLimitedMode();
	}

	getWrapperOf(PlayerObject, yStartDown, , 0) {
		return reinterpret_cast<D*>(this)->D::yStartDown();
	}

	getWrapperOf(PlayerObject, yStartUp, , 0) {
		return reinterpret_cast<D*>(this)->D::yStartUp();
	}

public:
	static bool _apply() {

		if constexpr(&$PlayerObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$PlayerObject::update) != (der1)(&D::update)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::updateWrapper)));
		}

		if ((mem2)(&$PlayerObject::setScaleX) != (der2)(&D::setScaleX)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setScaleXWrapper)));
		}

		if ((mem3)(&$PlayerObject::setScaleY) != (der3)(&D::setScaleY)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfVirtual((der3)(&D::setScaleYWrapper)));
		}

		if ((mem4)(&$PlayerObject::setScale) != (der4)(&D::setScale)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfVirtual((der4)(&D::setScaleWrapper)));
		}

		if ((mem5)(&$PlayerObject::setPosition) != (der5)(&D::setPosition)) {
			modContainer.registerHookEnable(address5, FunctionScrapper::addressOfVirtual((der5)(&D::setPositionWrapper)));
		}

		if ((mem6)(&$PlayerObject::setVisible) != (der6)(&D::setVisible)) {
			modContainer.registerHookEnable(address6, FunctionScrapper::addressOfVirtual((der6)(&D::setVisibleWrapper)));
		}

		if ((mem7)(&$PlayerObject::setRotation) != (der7)(&D::setRotation)) {
			modContainer.registerHookEnable(address7, FunctionScrapper::addressOfVirtual((der7)(&D::setRotationWrapper)));
		}

		if ((mem8)(&$PlayerObject::setOpacity) != (der8)(&D::setOpacity)) {
			modContainer.registerHookEnable(address8, FunctionScrapper::addressOfVirtual((der8)(&D::setOpacityWrapper)));
		}

		if ((mem9)(&$PlayerObject::setColor) != (der9)(&D::setColor)) {
			modContainer.registerHookEnable(address9, FunctionScrapper::addressOfVirtual((der9)(&D::setColorWrapper)));
		}

		if ((mem10)(&$PlayerObject::setFlipX) != (der10)(&D::setFlipX)) {
			modContainer.registerHookEnable(address10, FunctionScrapper::addressOfVirtual((der10)(&D::setFlipXWrapper)));
		}

		if ((mem11)(&$PlayerObject::setFlipY) != (der11)(&D::setFlipY)) {
			modContainer.registerHookEnable(address11, FunctionScrapper::addressOfVirtual((der11)(&D::setFlipYWrapper)));
		}

		if ((mem12)(&$PlayerObject::resetObject) != (der12)(&D::resetObject)) {
			modContainer.registerHookEnable(address12, FunctionScrapper::addressOfVirtual((der12)(&D::resetObjectWrapper)));
		}

		if ((mem13)(&$PlayerObject::getRealPosition) != (der13)(&D::getRealPosition)) {
			modContainer.registerHookEnable(address13, FunctionScrapper::addressOfVirtual((der13)(&D::getRealPositionWrapper)));
		}

		if ((mem14)(&$PlayerObject::getOrientedBox) != (der14)(&D::getOrientedBox)) {
			modContainer.registerHookEnable(address14, FunctionScrapper::addressOfVirtual((der14)(&D::getOrientedBoxWrapper)));
		}

		if ((mem15)(&$PlayerObject::animationFinished) != (der15)(&D::animationFinished)) {
			modContainer.registerHookEnable(address15, FunctionScrapper::addressOfVirtual((der15)(&D::animationFinishedWrapper)));
		}

		if constexpr((mem16)(&$PlayerObject::activateStreak) != (der16)(&D::activateStreak)) {
			modContainer.registerHookEnable(address16, FunctionScrapper::addressOfNonVirtual((der16)(&D::activateStreakWrapper)));
		}

		if constexpr((mem17)(&$PlayerObject::addAllParticles) != (der17)(&D::addAllParticles)) {
			modContainer.registerHookEnable(address17, FunctionScrapper::addressOfNonVirtual((der17)(&D::addAllParticlesWrapper)));
		}

		if constexpr((mem18)(&$PlayerObject::addToTouchedRings) != (der18)(&D::addToTouchedRings)) {
			modContainer.registerHookEnable(address18, FunctionScrapper::addressOfNonVirtual((der18)(&D::addToTouchedRingsWrapper)));
		}

		if constexpr((mem19)(&$PlayerObject::boostPlayer) != (der19)(&D::boostPlayer)) {
			modContainer.registerHookEnable(address19, FunctionScrapper::addressOfNonVirtual((der19)(&D::boostPlayerWrapper)));
		}

		if constexpr((mem20)(&$PlayerObject::bumpPlayer) != (der20)(&D::bumpPlayer)) {
			modContainer.registerHookEnable(address20, FunctionScrapper::addressOfNonVirtual((der20)(&D::bumpPlayerWrapper)));
		}

		if constexpr((mem21)(&$PlayerObject::buttonDown) != (der21)(&D::buttonDown)) {
			modContainer.registerHookEnable(address21, FunctionScrapper::addressOfNonVirtual((der21)(&D::buttonDownWrapper)));
		}

		if constexpr((mem22)(&$PlayerObject::checkSnapJumpToObject) != (der22)(&D::checkSnapJumpToObject)) {
			modContainer.registerHookEnable(address22, FunctionScrapper::addressOfNonVirtual((der22)(&D::checkSnapJumpToObjectWrapper)));
		}

		if constexpr((mem23)(&$PlayerObject::collidedWithObject) != (der23)(&D::collidedWithObject)) {
			modContainer.registerHookEnable(address23, FunctionScrapper::addressOfNonVirtual((der23)(&D::collidedWithObjectWrapper)));
		}

		if constexpr((mem24)(&$PlayerObject::collidedWithObject) != (der24)(&D::collidedWithObject)) {
			modContainer.registerHookEnable(address24, FunctionScrapper::addressOfNonVirtual((der24)(&D::collidedWithObjectWrapper)));
		}

		if constexpr((mem25)(&$PlayerObject::collidedWithSlope) != (der25)(&D::collidedWithSlope)) {
			modContainer.registerHookEnable(address25, FunctionScrapper::addressOfNonVirtual((der25)(&D::collidedWithSlopeWrapper)));
		}

		if constexpr((mem26)(&$PlayerObject::convertToClosestRotation) != (der26)(&D::convertToClosestRotation)) {
			modContainer.registerHookEnable(address26, FunctionScrapper::addressOfNonVirtual((der26)(&D::convertToClosestRotationWrapper)));
		}

		if constexpr((mem27)(&$PlayerObject::copyAttributes) != (der27)(&D::copyAttributes)) {
			modContainer.registerHookEnable(address27, FunctionScrapper::addressOfNonVirtual((der27)(&D::copyAttributesWrapper)));
		}

		if constexpr((mem28)(&$PlayerObject::create) != (der28)(&D::create)) {
			modContainer.registerHookEnable(address28, FunctionScrapper::addressOfNonVirtual((der28)(&D::createWrapper)));
		}

		if constexpr((mem29)(&$PlayerObject::deactivateParticle) != (der29)(&D::deactivateParticle)) {
			modContainer.registerHookEnable(address29, FunctionScrapper::addressOfNonVirtual((der29)(&D::deactivateParticleWrapper)));
		}

		if constexpr((mem30)(&$PlayerObject::deactivateStreak) != (der30)(&D::deactivateStreak)) {
			modContainer.registerHookEnable(address30, FunctionScrapper::addressOfNonVirtual((der30)(&D::deactivateStreakWrapper)));
		}

		if constexpr((mem31)(&$PlayerObject::fadeOutStreak2) != (der31)(&D::fadeOutStreak2)) {
			modContainer.registerHookEnable(address31, FunctionScrapper::addressOfNonVirtual((der31)(&D::fadeOutStreak2Wrapper)));
		}

		if constexpr((mem32)(&$PlayerObject::flashPlayer) != (der32)(&D::flashPlayer)) {
			modContainer.registerHookEnable(address32, FunctionScrapper::addressOfNonVirtual((der32)(&D::flashPlayerWrapper)));
		}

		if constexpr((mem33)(&$PlayerObject::flipGravity) != (der33)(&D::flipGravity)) {
			modContainer.registerHookEnable(address33, FunctionScrapper::addressOfNonVirtual((der33)(&D::flipGravityWrapper)));
		}

		if constexpr((mem34)(&$PlayerObject::flipMod) != (der34)(&D::flipMod)) {
			modContainer.registerHookEnable(address34, FunctionScrapper::addressOfNonVirtual((der34)(&D::flipModWrapper)));
		}

		if constexpr((mem35)(&$PlayerObject::getActiveMode) != (der35)(&D::getActiveMode)) {
			modContainer.registerHookEnable(address35, FunctionScrapper::addressOfNonVirtual((der35)(&D::getActiveModeWrapper)));
		}

		if constexpr((mem36)(&$PlayerObject::getModifiedSlopeYVel) != (der36)(&D::getModifiedSlopeYVel)) {
			modContainer.registerHookEnable(address36, FunctionScrapper::addressOfNonVirtual((der36)(&D::getModifiedSlopeYVelWrapper)));
		}

		if constexpr((mem37)(&$PlayerObject::getOldPosition) != (der37)(&D::getOldPosition)) {
			modContainer.registerHookEnable(address37, FunctionScrapper::addressOfNonVirtual((der37)(&D::getOldPositionWrapper)));
		}

		if constexpr((mem38)(&$PlayerObject::getSecondColor) != (der38)(&D::getSecondColor)) {
			modContainer.registerHookEnable(address38, FunctionScrapper::addressOfNonVirtual((der38)(&D::getSecondColorWrapper)));
		}

		if constexpr((mem39)(&$PlayerObject::gravityDown) != (der39)(&D::gravityDown)) {
			modContainer.registerHookEnable(address39, FunctionScrapper::addressOfNonVirtual((der39)(&D::gravityDownWrapper)));
		}

		if constexpr((mem40)(&$PlayerObject::gravityUp) != (der40)(&D::gravityUp)) {
			modContainer.registerHookEnable(address40, FunctionScrapper::addressOfNonVirtual((der40)(&D::gravityUpWrapper)));
		}

		if constexpr((mem41)(&$PlayerObject::hardFlipGravity) != (der41)(&D::hardFlipGravity)) {
			modContainer.registerHookEnable(address41, FunctionScrapper::addressOfNonVirtual((der41)(&D::hardFlipGravityWrapper)));
		}

		if constexpr((mem42)(&$PlayerObject::hitGround) != (der42)(&D::hitGround)) {
			modContainer.registerHookEnable(address42, FunctionScrapper::addressOfNonVirtual((der42)(&D::hitGroundWrapper)));
		}

		if constexpr((mem43)(&$PlayerObject::incrementJumps) != (der43)(&D::incrementJumps)) {
			modContainer.registerHookEnable(address43, FunctionScrapper::addressOfNonVirtual((der43)(&D::incrementJumpsWrapper)));
		}

		if constexpr((mem44)(&$PlayerObject::init) != (der44)(&D::init)) {
			modContainer.registerHookEnable(address44, FunctionScrapper::addressOfNonVirtual((der44)(&D::initWrapper)));
		}

		if constexpr((mem45)(&$PlayerObject::isBoostValid) != (der45)(&D::isBoostValid)) {
			modContainer.registerHookEnable(address45, FunctionScrapper::addressOfNonVirtual((der45)(&D::isBoostValidWrapper)));
		}

		if constexpr((mem46)(&$PlayerObject::isFlying) != (der46)(&D::isFlying)) {
			modContainer.registerHookEnable(address46, FunctionScrapper::addressOfNonVirtual((der46)(&D::isFlyingWrapper)));
		}

		if constexpr((mem47)(&$PlayerObject::isSafeFlip) != (der47)(&D::isSafeFlip)) {
			modContainer.registerHookEnable(address47, FunctionScrapper::addressOfNonVirtual((der47)(&D::isSafeFlipWrapper)));
		}

		if constexpr((mem48)(&$PlayerObject::isSafeMode) != (der48)(&D::isSafeMode)) {
			modContainer.registerHookEnable(address48, FunctionScrapper::addressOfNonVirtual((der48)(&D::isSafeModeWrapper)));
		}

		if constexpr((mem49)(&$PlayerObject::isSafeSpiderFlip) != (der49)(&D::isSafeSpiderFlip)) {
			modContainer.registerHookEnable(address49, FunctionScrapper::addressOfNonVirtual((der49)(&D::isSafeSpiderFlipWrapper)));
		}

		if constexpr((mem50)(&$PlayerObject::levelFlipFinished) != (der50)(&D::levelFlipFinished)) {
			modContainer.registerHookEnable(address50, FunctionScrapper::addressOfNonVirtual((der50)(&D::levelFlipFinishedWrapper)));
		}

		if constexpr((mem51)(&$PlayerObject::levelFlipping) != (der51)(&D::levelFlipping)) {
			modContainer.registerHookEnable(address51, FunctionScrapper::addressOfNonVirtual((der51)(&D::levelFlippingWrapper)));
		}

		if constexpr((mem52)(&$PlayerObject::levelWillFlip) != (der52)(&D::levelWillFlip)) {
			modContainer.registerHookEnable(address52, FunctionScrapper::addressOfNonVirtual((der52)(&D::levelWillFlipWrapper)));
		}

		if constexpr((mem53)(&$PlayerObject::loadFromCheckpoint) != (der53)(&D::loadFromCheckpoint)) {
			modContainer.registerHookEnable(address53, FunctionScrapper::addressOfNonVirtual((der53)(&D::loadFromCheckpointWrapper)));
		}

		if constexpr((mem54)(&$PlayerObject::lockPlayer) != (der54)(&D::lockPlayer)) {
			modContainer.registerHookEnable(address54, FunctionScrapper::addressOfNonVirtual((der54)(&D::lockPlayerWrapper)));
		}

		if constexpr((mem55)(&$PlayerObject::logValues) != (der55)(&D::logValues)) {
			modContainer.registerHookEnable(address55, FunctionScrapper::addressOfNonVirtual((der55)(&D::logValuesWrapper)));
		}

		if constexpr((mem56)(&$PlayerObject::modeDidChange) != (der56)(&D::modeDidChange)) {
			modContainer.registerHookEnable(address56, FunctionScrapper::addressOfNonVirtual((der56)(&D::modeDidChangeWrapper)));
		}

		if constexpr((mem57)(&$PlayerObject::placeStreakPoint) != (der57)(&D::placeStreakPoint)) {
			modContainer.registerHookEnable(address57, FunctionScrapper::addressOfNonVirtual((der57)(&D::placeStreakPointWrapper)));
		}

		if constexpr((mem58)(&$PlayerObject::playBurstEffect) != (der58)(&D::playBurstEffect)) {
			modContainer.registerHookEnable(address58, FunctionScrapper::addressOfNonVirtual((der58)(&D::playBurstEffectWrapper)));
		}

		if constexpr((mem59)(&$PlayerObject::playDeathEffect) != (der59)(&D::playDeathEffect)) {
			modContainer.registerHookEnable(address59, FunctionScrapper::addressOfNonVirtual((der59)(&D::playDeathEffectWrapper)));
		}

		if constexpr((mem60)(&$PlayerObject::playDynamicSpiderRun) != (der60)(&D::playDynamicSpiderRun)) {
			modContainer.registerHookEnable(address60, FunctionScrapper::addressOfNonVirtual((der60)(&D::playDynamicSpiderRunWrapper)));
		}

		if constexpr((mem61)(&$PlayerObject::playerDestroyed) != (der61)(&D::playerDestroyed)) {
			modContainer.registerHookEnable(address61, FunctionScrapper::addressOfNonVirtual((der61)(&D::playerDestroyedWrapper)));
		}

		if constexpr((mem62)(&$PlayerObject::playerIsFalling) != (der62)(&D::playerIsFalling)) {
			modContainer.registerHookEnable(address62, FunctionScrapper::addressOfNonVirtual((der62)(&D::playerIsFallingWrapper)));
		}

		if constexpr((mem63)(&$PlayerObject::playerTeleported) != (der63)(&D::playerTeleported)) {
			modContainer.registerHookEnable(address63, FunctionScrapper::addressOfNonVirtual((der63)(&D::playerTeleportedWrapper)));
		}

		if constexpr((mem64)(&$PlayerObject::playingEndEffect) != (der64)(&D::playingEndEffect)) {
			modContainer.registerHookEnable(address64, FunctionScrapper::addressOfNonVirtual((der64)(&D::playingEndEffectWrapper)));
		}

		if constexpr((mem65)(&$PlayerObject::postCollision) != (der65)(&D::postCollision)) {
			modContainer.registerHookEnable(address65, FunctionScrapper::addressOfNonVirtual((der65)(&D::postCollisionWrapper)));
		}

		if constexpr((mem66)(&$PlayerObject::preCollision) != (der66)(&D::preCollision)) {
			modContainer.registerHookEnable(address66, FunctionScrapper::addressOfNonVirtual((der66)(&D::preCollisionWrapper)));
		}

		if constexpr((mem67)(&$PlayerObject::preSlopeCollision) != (der67)(&D::preSlopeCollision)) {
			modContainer.registerHookEnable(address67, FunctionScrapper::addressOfNonVirtual((der67)(&D::preSlopeCollisionWrapper)));
		}

		if constexpr((mem68)(&$PlayerObject::propellPlayer) != (der68)(&D::propellPlayer)) {
			modContainer.registerHookEnable(address68, FunctionScrapper::addressOfNonVirtual((der68)(&D::propellPlayerWrapper)));
		}

		if constexpr((mem69)(&$PlayerObject::pushButton) != (der69)(&D::pushButton)) {
			modContainer.registerHookEnable(address69, FunctionScrapper::addressOfNonVirtual((der69)(&D::pushButtonWrapper)));
		}

		if constexpr((mem70)(&$PlayerObject::pushDown) != (der70)(&D::pushDown)) {
			modContainer.registerHookEnable(address70, FunctionScrapper::addressOfNonVirtual((der70)(&D::pushDownWrapper)));
		}

		if constexpr((mem71)(&$PlayerObject::pushPlayer) != (der71)(&D::pushPlayer)) {
			modContainer.registerHookEnable(address71, FunctionScrapper::addressOfNonVirtual((der71)(&D::pushPlayerWrapper)));
		}

		if constexpr((mem72)(&$PlayerObject::releaseButton) != (der72)(&D::releaseButton)) {
			modContainer.registerHookEnable(address72, FunctionScrapper::addressOfNonVirtual((der72)(&D::releaseButtonWrapper)));
		}

		if constexpr((mem73)(&$PlayerObject::removeAllParticles) != (der73)(&D::removeAllParticles)) {
			modContainer.registerHookEnable(address73, FunctionScrapper::addressOfNonVirtual((der73)(&D::removeAllParticlesWrapper)));
		}

		if constexpr((mem74)(&$PlayerObject::removePendingCheckpoint) != (der74)(&D::removePendingCheckpoint)) {
			modContainer.registerHookEnable(address74, FunctionScrapper::addressOfNonVirtual((der74)(&D::removePendingCheckpointWrapper)));
		}

		if constexpr((mem75)(&$PlayerObject::resetAllParticles) != (der75)(&D::resetAllParticles)) {
			modContainer.registerHookEnable(address75, FunctionScrapper::addressOfNonVirtual((der75)(&D::resetAllParticlesWrapper)));
		}

		if constexpr((mem76)(&$PlayerObject::resetCollisionLog) != (der76)(&D::resetCollisionLog)) {
			modContainer.registerHookEnable(address76, FunctionScrapper::addressOfNonVirtual((der76)(&D::resetCollisionLogWrapper)));
		}

		if constexpr((mem77)(&$PlayerObject::resetPlayerIcon) != (der77)(&D::resetPlayerIcon)) {
			modContainer.registerHookEnable(address77, FunctionScrapper::addressOfNonVirtual((der77)(&D::resetPlayerIconWrapper)));
		}

		if constexpr((mem78)(&$PlayerObject::resetStateVariables) != (der78)(&D::resetStateVariables)) {
			modContainer.registerHookEnable(address78, FunctionScrapper::addressOfNonVirtual((der78)(&D::resetStateVariablesWrapper)));
		}

		if constexpr((mem79)(&$PlayerObject::resetStreak) != (der79)(&D::resetStreak)) {
			modContainer.registerHookEnable(address79, FunctionScrapper::addressOfNonVirtual((der79)(&D::resetStreakWrapper)));
		}

		if constexpr((mem80)(&$PlayerObject::ringJump) != (der80)(&D::ringJump)) {
			modContainer.registerHookEnable(address80, FunctionScrapper::addressOfNonVirtual((der80)(&D::ringJumpWrapper)));
		}

		if constexpr((mem81)(&$PlayerObject::runBallRotation) != (der81)(&D::runBallRotation)) {
			modContainer.registerHookEnable(address81, FunctionScrapper::addressOfNonVirtual((der81)(&D::runBallRotationWrapper)));
		}

		if constexpr((mem82)(&$PlayerObject::runBallRotation2) != (der82)(&D::runBallRotation2)) {
			modContainer.registerHookEnable(address82, FunctionScrapper::addressOfNonVirtual((der82)(&D::runBallRotation2Wrapper)));
		}

		if constexpr((mem83)(&$PlayerObject::runNormalRotation) != (der83)(&D::runNormalRotation)) {
			modContainer.registerHookEnable(address83, FunctionScrapper::addressOfNonVirtual((der83)(&D::runNormalRotationWrapper)));
		}

		if constexpr((mem84)(&$PlayerObject::runRotateAction) != (der84)(&D::runRotateAction)) {
			modContainer.registerHookEnable(address84, FunctionScrapper::addressOfNonVirtual((der84)(&D::runRotateActionWrapper)));
		}

		if constexpr((mem85)(&$PlayerObject::saveToCheckpoint) != (der85)(&D::saveToCheckpoint)) {
			modContainer.registerHookEnable(address85, FunctionScrapper::addressOfNonVirtual((der85)(&D::saveToCheckpointWrapper)));
		}

		if constexpr((mem86)(&$PlayerObject::setSecondColor) != (der86)(&D::setSecondColor)) {
			modContainer.registerHookEnable(address86, FunctionScrapper::addressOfNonVirtual((der86)(&D::setSecondColorWrapper)));
		}

		if constexpr((mem87)(&$PlayerObject::setupStreak) != (der87)(&D::setupStreak)) {
			modContainer.registerHookEnable(address87, FunctionScrapper::addressOfNonVirtual((der87)(&D::setupStreakWrapper)));
		}

		if constexpr((mem88)(&$PlayerObject::spawnCircle) != (der88)(&D::spawnCircle)) {
			modContainer.registerHookEnable(address88, FunctionScrapper::addressOfNonVirtual((der88)(&D::spawnCircleWrapper)));
		}

		if constexpr((mem89)(&$PlayerObject::spawnCircle2) != (der89)(&D::spawnCircle2)) {
			modContainer.registerHookEnable(address89, FunctionScrapper::addressOfNonVirtual((der89)(&D::spawnCircle2Wrapper)));
		}

		if constexpr((mem90)(&$PlayerObject::spawnDualCircle) != (der90)(&D::spawnDualCircle)) {
			modContainer.registerHookEnable(address90, FunctionScrapper::addressOfNonVirtual((der90)(&D::spawnDualCircleWrapper)));
		}

		if constexpr((mem91)(&$PlayerObject::spawnFromPlayer) != (der91)(&D::spawnFromPlayer)) {
			modContainer.registerHookEnable(address91, FunctionScrapper::addressOfNonVirtual((der91)(&D::spawnFromPlayerWrapper)));
		}

		if constexpr((mem92)(&$PlayerObject::spawnPortalCircle) != (der92)(&D::spawnPortalCircle)) {
			modContainer.registerHookEnable(address92, FunctionScrapper::addressOfNonVirtual((der92)(&D::spawnPortalCircleWrapper)));
		}

		if constexpr((mem93)(&$PlayerObject::spawnScaleCircle) != (der93)(&D::spawnScaleCircle)) {
			modContainer.registerHookEnable(address93, FunctionScrapper::addressOfNonVirtual((der93)(&D::spawnScaleCircleWrapper)));
		}

		if constexpr((mem94)(&$PlayerObject::specialGroundHit) != (der94)(&D::specialGroundHit)) {
			modContainer.registerHookEnable(address94, FunctionScrapper::addressOfNonVirtual((der94)(&D::specialGroundHitWrapper)));
		}

		if constexpr((mem95)(&$PlayerObject::speedDown) != (der95)(&D::speedDown)) {
			modContainer.registerHookEnable(address95, FunctionScrapper::addressOfNonVirtual((der95)(&D::speedDownWrapper)));
		}

		if constexpr((mem96)(&$PlayerObject::speedUp) != (der96)(&D::speedUp)) {
			modContainer.registerHookEnable(address96, FunctionScrapper::addressOfNonVirtual((der96)(&D::speedUpWrapper)));
		}

		if constexpr((mem97)(&$PlayerObject::spiderTestJump) != (der97)(&D::spiderTestJump)) {
			modContainer.registerHookEnable(address97, FunctionScrapper::addressOfNonVirtual((der97)(&D::spiderTestJumpWrapper)));
		}

		if constexpr((mem98)(&$PlayerObject::startDashing) != (der98)(&D::startDashing)) {
			modContainer.registerHookEnable(address98, FunctionScrapper::addressOfNonVirtual((der98)(&D::startDashingWrapper)));
		}

		if constexpr((mem99)(&$PlayerObject::stopBurstEffect) != (der99)(&D::stopBurstEffect)) {
			modContainer.registerHookEnable(address99, FunctionScrapper::addressOfNonVirtual((der99)(&D::stopBurstEffectWrapper)));
		}

		if constexpr((mem100)(&$PlayerObject::stopDashing) != (der100)(&D::stopDashing)) {
			modContainer.registerHookEnable(address100, FunctionScrapper::addressOfNonVirtual((der100)(&D::stopDashingWrapper)));
		}

		if constexpr((mem101)(&$PlayerObject::stopRotation) != (der101)(&D::stopRotation)) {
			modContainer.registerHookEnable(address101, FunctionScrapper::addressOfNonVirtual((der101)(&D::stopRotationWrapper)));
		}

		if constexpr((mem102)(&$PlayerObject::storeCollision) != (der102)(&D::storeCollision)) {
			modContainer.registerHookEnable(address102, FunctionScrapper::addressOfNonVirtual((der102)(&D::storeCollisionWrapper)));
		}

		if constexpr((mem103)(&$PlayerObject::switchedToMode) != (der103)(&D::switchedToMode)) {
			modContainer.registerHookEnable(address103, FunctionScrapper::addressOfNonVirtual((der103)(&D::switchedToModeWrapper)));
		}

		if constexpr((mem104)(&$PlayerObject::testForMoving) != (der104)(&D::testForMoving)) {
			modContainer.registerHookEnable(address104, FunctionScrapper::addressOfNonVirtual((der104)(&D::testForMovingWrapper)));
		}

		if constexpr((mem105)(&$PlayerObject::toggleBirdMode) != (der105)(&D::toggleBirdMode)) {
			modContainer.registerHookEnable(address105, FunctionScrapper::addressOfNonVirtual((der105)(&D::toggleBirdModeWrapper)));
		}

		if constexpr((mem106)(&$PlayerObject::toggleDartMode) != (der106)(&D::toggleDartMode)) {
			modContainer.registerHookEnable(address106, FunctionScrapper::addressOfNonVirtual((der106)(&D::toggleDartModeWrapper)));
		}

		if constexpr((mem107)(&$PlayerObject::toggleFlyMode) != (der107)(&D::toggleFlyMode)) {
			modContainer.registerHookEnable(address107, FunctionScrapper::addressOfNonVirtual((der107)(&D::toggleFlyModeWrapper)));
		}

		if constexpr((mem108)(&$PlayerObject::toggleGhostEffect) != (der108)(&D::toggleGhostEffect)) {
			modContainer.registerHookEnable(address108, FunctionScrapper::addressOfNonVirtual((der108)(&D::toggleGhostEffectWrapper)));
		}

		if constexpr((mem109)(&$PlayerObject::togglePlayerScale) != (der109)(&D::togglePlayerScale)) {
			modContainer.registerHookEnable(address109, FunctionScrapper::addressOfNonVirtual((der109)(&D::togglePlayerScaleWrapper)));
		}

		if constexpr((mem110)(&$PlayerObject::toggleRobotMode) != (der110)(&D::toggleRobotMode)) {
			modContainer.registerHookEnable(address110, FunctionScrapper::addressOfNonVirtual((der110)(&D::toggleRobotModeWrapper)));
		}

		if constexpr((mem111)(&$PlayerObject::toggleRollMode) != (der111)(&D::toggleRollMode)) {
			modContainer.registerHookEnable(address111, FunctionScrapper::addressOfNonVirtual((der111)(&D::toggleRollModeWrapper)));
		}

		if constexpr((mem112)(&$PlayerObject::toggleSpiderMode) != (der112)(&D::toggleSpiderMode)) {
			modContainer.registerHookEnable(address112, FunctionScrapper::addressOfNonVirtual((der112)(&D::toggleSpiderModeWrapper)));
		}

		if constexpr((mem113)(&$PlayerObject::toggleVisibility) != (der113)(&D::toggleVisibility)) {
			modContainer.registerHookEnable(address113, FunctionScrapper::addressOfNonVirtual((der113)(&D::toggleVisibilityWrapper)));
		}

		if constexpr((mem114)(&$PlayerObject::touchedObject) != (der114)(&D::touchedObject)) {
			modContainer.registerHookEnable(address114, FunctionScrapper::addressOfNonVirtual((der114)(&D::touchedObjectWrapper)));
		}

		if constexpr((mem115)(&$PlayerObject::tryPlaceCheckpoint) != (der115)(&D::tryPlaceCheckpoint)) {
			modContainer.registerHookEnable(address115, FunctionScrapper::addressOfNonVirtual((der115)(&D::tryPlaceCheckpointWrapper)));
		}

		if constexpr((mem116)(&$PlayerObject::updateCheckpointMode) != (der116)(&D::updateCheckpointMode)) {
			modContainer.registerHookEnable(address116, FunctionScrapper::addressOfNonVirtual((der116)(&D::updateCheckpointModeWrapper)));
		}

		if constexpr((mem117)(&$PlayerObject::updateCheckpointTest) != (der117)(&D::updateCheckpointTest)) {
			modContainer.registerHookEnable(address117, FunctionScrapper::addressOfNonVirtual((der117)(&D::updateCheckpointTestWrapper)));
		}

		if constexpr((mem118)(&$PlayerObject::updateCollide) != (der118)(&D::updateCollide)) {
			modContainer.registerHookEnable(address118, FunctionScrapper::addressOfNonVirtual((der118)(&D::updateCollideWrapper)));
		}

		if constexpr((mem119)(&$PlayerObject::updateCollideBottom) != (der119)(&D::updateCollideBottom)) {
			modContainer.registerHookEnable(address119, FunctionScrapper::addressOfNonVirtual((der119)(&D::updateCollideBottomWrapper)));
		}

		if constexpr((mem120)(&$PlayerObject::updateCollideTop) != (der120)(&D::updateCollideTop)) {
			modContainer.registerHookEnable(address120, FunctionScrapper::addressOfNonVirtual((der120)(&D::updateCollideTopWrapper)));
		}

		if constexpr((mem121)(&$PlayerObject::updateDashAnimation) != (der121)(&D::updateDashAnimation)) {
			modContainer.registerHookEnable(address121, FunctionScrapper::addressOfNonVirtual((der121)(&D::updateDashAnimationWrapper)));
		}

		if constexpr((mem122)(&$PlayerObject::updateDashArt) != (der122)(&D::updateDashArt)) {
			modContainer.registerHookEnable(address122, FunctionScrapper::addressOfNonVirtual((der122)(&D::updateDashArtWrapper)));
		}

		if constexpr((mem123)(&$PlayerObject::updateGlowColor) != (der123)(&D::updateGlowColor)) {
			modContainer.registerHookEnable(address123, FunctionScrapper::addressOfNonVirtual((der123)(&D::updateGlowColorWrapper)));
		}

		if constexpr((mem124)(&$PlayerObject::updateJump) != (der124)(&D::updateJump)) {
			modContainer.registerHookEnable(address124, FunctionScrapper::addressOfNonVirtual((der124)(&D::updateJumpWrapper)));
		}

		if constexpr((mem125)(&$PlayerObject::updateJumpVariables) != (der125)(&D::updateJumpVariables)) {
			modContainer.registerHookEnable(address125, FunctionScrapper::addressOfNonVirtual((der125)(&D::updateJumpVariablesWrapper)));
		}

		if constexpr((mem126)(&$PlayerObject::updatePlayerBirdFrame) != (der126)(&D::updatePlayerBirdFrame)) {
			modContainer.registerHookEnable(address126, FunctionScrapper::addressOfNonVirtual((der126)(&D::updatePlayerBirdFrameWrapper)));
		}

		if constexpr((mem127)(&$PlayerObject::updatePlayerDartFrame) != (der127)(&D::updatePlayerDartFrame)) {
			modContainer.registerHookEnable(address127, FunctionScrapper::addressOfNonVirtual((der127)(&D::updatePlayerDartFrameWrapper)));
		}

		if constexpr((mem128)(&$PlayerObject::updatePlayerFrame) != (der128)(&D::updatePlayerFrame)) {
			modContainer.registerHookEnable(address128, FunctionScrapper::addressOfNonVirtual((der128)(&D::updatePlayerFrameWrapper)));
		}

		if constexpr((mem129)(&$PlayerObject::updatePlayerGlow) != (der129)(&D::updatePlayerGlow)) {
			modContainer.registerHookEnable(address129, FunctionScrapper::addressOfNonVirtual((der129)(&D::updatePlayerGlowWrapper)));
		}

		if constexpr((mem130)(&$PlayerObject::updatePlayerRobotFrame) != (der130)(&D::updatePlayerRobotFrame)) {
			modContainer.registerHookEnable(address130, FunctionScrapper::addressOfNonVirtual((der130)(&D::updatePlayerRobotFrameWrapper)));
		}

		if constexpr((mem131)(&$PlayerObject::updatePlayerRollFrame) != (der131)(&D::updatePlayerRollFrame)) {
			modContainer.registerHookEnable(address131, FunctionScrapper::addressOfNonVirtual((der131)(&D::updatePlayerRollFrameWrapper)));
		}

		if constexpr((mem132)(&$PlayerObject::updatePlayerScale) != (der132)(&D::updatePlayerScale)) {
			modContainer.registerHookEnable(address132, FunctionScrapper::addressOfNonVirtual((der132)(&D::updatePlayerScaleWrapper)));
		}

		if constexpr((mem133)(&$PlayerObject::updatePlayerShipFrame) != (der133)(&D::updatePlayerShipFrame)) {
			modContainer.registerHookEnable(address133, FunctionScrapper::addressOfNonVirtual((der133)(&D::updatePlayerShipFrameWrapper)));
		}

		if constexpr((mem134)(&$PlayerObject::updatePlayerSpiderFrame) != (der134)(&D::updatePlayerSpiderFrame)) {
			modContainer.registerHookEnable(address134, FunctionScrapper::addressOfNonVirtual((der134)(&D::updatePlayerSpiderFrameWrapper)));
		}

		if constexpr((mem135)(&$PlayerObject::updatePlayerSpriteExtra) != (der135)(&D::updatePlayerSpriteExtra)) {
			modContainer.registerHookEnable(address135, FunctionScrapper::addressOfNonVirtual((der135)(&D::updatePlayerSpriteExtraWrapper)));
		}

		if constexpr((mem136)(&$PlayerObject::updateRobotAnimationSpeed) != (der136)(&D::updateRobotAnimationSpeed)) {
			modContainer.registerHookEnable(address136, FunctionScrapper::addressOfNonVirtual((der136)(&D::updateRobotAnimationSpeedWrapper)));
		}

		if constexpr((mem137)(&$PlayerObject::updateRotation) != (der137)(&D::updateRotation)) {
			modContainer.registerHookEnable(address137, FunctionScrapper::addressOfNonVirtual((der137)(&D::updateRotationWrapper)));
		}

		if constexpr((mem138)(&$PlayerObject::updateRotation) != (der138)(&D::updateRotation)) {
			modContainer.registerHookEnable(address138, FunctionScrapper::addressOfNonVirtual((der138)(&D::updateRotationWrapper)));
		}

		if constexpr((mem139)(&$PlayerObject::updateShipRotation) != (der139)(&D::updateShipRotation)) {
			modContainer.registerHookEnable(address139, FunctionScrapper::addressOfNonVirtual((der139)(&D::updateShipRotationWrapper)));
		}

		if constexpr((mem140)(&$PlayerObject::updateShipSpriteExtra) != (der140)(&D::updateShipSpriteExtra)) {
			modContainer.registerHookEnable(address140, FunctionScrapper::addressOfNonVirtual((der140)(&D::updateShipSpriteExtraWrapper)));
		}

		if constexpr((mem141)(&$PlayerObject::updateSlopeRotation) != (der141)(&D::updateSlopeRotation)) {
			modContainer.registerHookEnable(address141, FunctionScrapper::addressOfNonVirtual((der141)(&D::updateSlopeRotationWrapper)));
		}

		if constexpr((mem142)(&$PlayerObject::updateSlopeYVelocity) != (der142)(&D::updateSlopeYVelocity)) {
			modContainer.registerHookEnable(address142, FunctionScrapper::addressOfNonVirtual((der142)(&D::updateSlopeYVelocityWrapper)));
		}

		if constexpr((mem143)(&$PlayerObject::updateSpecial) != (der143)(&D::updateSpecial)) {
			modContainer.registerHookEnable(address143, FunctionScrapper::addressOfNonVirtual((der143)(&D::updateSpecialWrapper)));
		}

		if constexpr((mem144)(&$PlayerObject::updateStateVariables) != (der144)(&D::updateStateVariables)) {
			modContainer.registerHookEnable(address144, FunctionScrapper::addressOfNonVirtual((der144)(&D::updateStateVariablesWrapper)));
		}

		if constexpr((mem145)(&$PlayerObject::updateTimeMod) != (der145)(&D::updateTimeMod)) {
			modContainer.registerHookEnable(address145, FunctionScrapper::addressOfNonVirtual((der145)(&D::updateTimeModWrapper)));
		}

		if constexpr((mem146)(&$PlayerObject::usingWallLimitedMode) != (der146)(&D::usingWallLimitedMode)) {
			modContainer.registerHookEnable(address146, FunctionScrapper::addressOfNonVirtual((der146)(&D::usingWallLimitedModeWrapper)));
		}

		if constexpr((mem147)(&$PlayerObject::yStartDown) != (der147)(&D::yStartDown)) {
			modContainer.registerHookEnable(address147, FunctionScrapper::addressOfNonVirtual((der147)(&D::yStartDownWrapper)));
		}

		if constexpr((mem148)(&$PlayerObject::yStartUp) != (der148)(&D::yStartUp)) {
			modContainer.registerHookEnable(address148, FunctionScrapper::addressOfNonVirtual((der148)(&D::yStartUpWrapper)));
		}

		return true;
	}
};

template<class D>
struct $PulseEffectAction : PulseEffectAction, InterfaceBase {
	$PulseEffectAction(const $PulseEffectAction& c) : PulseEffectAction(c) {}
	$PulseEffectAction() = delete;
	setInterfaceStaticTypesOf(0, PulseEffectAction, createFromString, , 1, gd::string);
	setInterfaceTypesOf(1, PulseEffectAction, getSaveString, , 0);
	static inline auto address0 = base+0x179e90;
	static inline auto address1 = base+0x17a850;

	dupable static getFunctionOf(PulseEffectAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(PulseEffectAction, getSaveString, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	static getWrapperOf(PulseEffectAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

	getWrapperOf(PulseEffectAction, getSaveString, , 0) {
		return reinterpret_cast<D*>(this)->D::getSaveString();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$PulseEffectAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		if constexpr((mem1)(&$PulseEffectAction::getSaveString) != (der1)(&D::getSaveString)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::getSaveStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $RetryLevelLayer : RetryLevelLayer, InterfaceBase {
	$RetryLevelLayer(const $RetryLevelLayer& c) : RetryLevelLayer(c) {}
	$RetryLevelLayer() = delete;
	setInterfaceStaticTypesOf(0, RetryLevelLayer, create, , 0);
	static inline auto address0 = base+0x28dd60;

	dupable static getFunctionOf(RetryLevelLayer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	static getWrapperOf(RetryLevelLayer, create, , 0) {
		return D::create();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$RetryLevelLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $ScrollingLayer : ScrollingLayer, InterfaceBase {
	$ScrollingLayer(const $ScrollingLayer& c) : ScrollingLayer(c) {}
	$ScrollingLayer() = delete;
	setInterfaceStaticTypesOf(0, ScrollingLayer, create, , 3, cocos2d::CCSize, cocos2d::CCPoint, float);
	static inline auto address0 = base+0x41a900;

	dupable static getFunctionOf(ScrollingLayer, create, , 3, cocos2d::CCSize, cocos2d::CCPoint, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2);
	}

	static getWrapperOf(ScrollingLayer, create, , 3, cocos2d::CCSize, cocos2d::CCPoint, float) {
		return D::create(p0, p1, p2);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ScrollingLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetGroupIDLayer : SetGroupIDLayer, InterfaceBase {
	$SetGroupIDLayer(const $SetGroupIDLayer& c) : SetGroupIDLayer(c) {}
	$SetGroupIDLayer() = delete;
	setInterfaceTypesOf(0, SetGroupIDLayer, onNextGroupID1, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(1, SetGroupIDLayer, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(2, SetGroupIDLayer, updateGroupIDLabel, , 0);
	static inline auto address0 = base+0x1967a0;
	static inline auto address1 = base+0x197af0;
	static inline auto address2 = base+0x197260;
	static inline auto address3 = base+0x194410;

	dupable getFunctionOf(SetGroupIDLayer, onNextGroupID1, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun0>(address0)(this, p0);
	}

	dupable getFunctionOf(SetGroupIDLayer, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetGroupIDLayer, updateGroupIDLabel, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address3)(this);
	}

	getWrapperOf(SetGroupIDLayer, onNextGroupID1, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onNextGroupID1(p0);
	}

	getWrapperOf(SetGroupIDLayer, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetGroupIDLayer, updateGroupIDLabel, , 0) {
		return reinterpret_cast<D*>(this)->D::updateGroupIDLabel();
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetGroupIDLayer::onNextGroupID1) != (der0)(&D::onNextGroupID1)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::onNextGroupID1Wrapper)));
		}

		if constexpr((mem1)(&$SetGroupIDLayer::textChanged) != (der1)(&D::textChanged)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::textChangedWrapper)));
		}

		if constexpr((mem2)(&$SetGroupIDLayer::updateGroupIDLabel) != (der2)(&D::updateGroupIDLabel)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::updateGroupIDLabelWrapper)));
		}

		if constexpr(&$SetGroupIDLayer::destructor != &D::destructor) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		return true;
	}
};

template<class D>
struct $SetIDLayer : SetIDLayer, InterfaceBase {
	$SetIDLayer(const $SetIDLayer& c) : SetIDLayer(c) {}
	$SetIDLayer() = delete;
	setInterfaceStaticTypesOf(0, SetIDLayer, create, , 1, GameObject*);
	static inline auto address0 = base+0x168f20;

	dupable static getFunctionOf(SetIDLayer, create, , 1, GameObject*) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(SetIDLayer, create, , 1, GameObject*) {
		return D::create(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetIDLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetIDPopup : SetIDPopup, InterfaceBase {
	$SetIDPopup(const $SetIDPopup& c) : SetIDPopup(c) {}
	$SetIDPopup() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $SetItemIDLayer : SetItemIDLayer, InterfaceBase {
	$SetItemIDLayer(const $SetItemIDLayer& c) : SetItemIDLayer(c) {}
	$SetItemIDLayer() = delete;
	setInterfaceStaticTypesOf(0, SetItemIDLayer, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	static inline auto address0 = base+0x5a830;

	dupable static getFunctionOf(SetItemIDLayer, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(SetItemIDLayer, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetItemIDLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetTargetIDLayer : SetTargetIDLayer, InterfaceBase {
	$SetTargetIDLayer(const $SetTargetIDLayer& c) : SetTargetIDLayer(c) {}
	$SetTargetIDLayer() = delete;
	setInterfaceStaticTypesOf(0, SetTargetIDLayer, create, , 3, EffectGameObject*, cocos2d::CCArray*, gd::string);
	setInterfaceTypesOf(1, SetTargetIDLayer, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetTargetIDLayer, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetTargetIDLayer, updateTargetID, , 0);
	static inline auto address0 = base+0x159d20;
	static inline auto address1 = base+0x15aed0;
	static inline auto address2 = base+0x15b6c0;
	static inline auto address3 = base+0x15b4a0;

	dupable static getFunctionOf(SetTargetIDLayer, create, , 3, EffectGameObject*, cocos2d::CCArray*, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2);
	}

	dupable getFunctionOf(SetTargetIDLayer, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetTargetIDLayer, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetTargetIDLayer, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetTargetIDLayer, create, , 3, EffectGameObject*, cocos2d::CCArray*, gd::string) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(SetTargetIDLayer, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetTargetIDLayer, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetTargetIDLayer, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetTargetIDLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetTargetIDLayer::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetTargetIDLayer::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetTargetIDLayer::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupAnimationPopup : SetupAnimationPopup, InterfaceBase {
	$SetupAnimationPopup(const $SetupAnimationPopup& c) : SetupAnimationPopup(c) {}
	$SetupAnimationPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupAnimationPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupAnimationPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupAnimationPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupAnimationPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x208b70;
	static inline auto address1 = base+0x209fc0;
	static inline auto address2 = base+0x20ab30;
	static inline auto address3 = base+0x20a910;

	dupable static getFunctionOf(SetupAnimationPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupAnimationPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupAnimationPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupAnimationPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupAnimationPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupAnimationPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupAnimationPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupAnimationPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupAnimationPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupAnimationPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupAnimationPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupAnimationPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupCollisionTriggerPopup : SetupCollisionTriggerPopup, InterfaceBase {
	$SetupCollisionTriggerPopup(const $SetupCollisionTriggerPopup& c) : SetupCollisionTriggerPopup(c) {}
	$SetupCollisionTriggerPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupCollisionTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupCollisionTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupCollisionTriggerPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupCollisionTriggerPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x1d6120;
	static inline auto address1 = base+0x1d77b0;
	static inline auto address2 = base+0x1d84d0;
	static inline auto address3 = base+0x1d82b0;

	dupable static getFunctionOf(SetupCollisionTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupCollisionTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupCollisionTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupCollisionTriggerPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupCollisionTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupCollisionTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupCollisionTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupCollisionTriggerPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupCollisionTriggerPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupCollisionTriggerPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupCollisionTriggerPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupCollisionTriggerPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupCountTriggerPopup : SetupCountTriggerPopup, InterfaceBase {
	$SetupCountTriggerPopup(const $SetupCountTriggerPopup& c) : SetupCountTriggerPopup(c) {}
	$SetupCountTriggerPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupCountTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupCountTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupCountTriggerPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupCountTriggerPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x15c6c0;
	static inline auto address1 = base+0x15dd40;
	static inline auto address2 = base+0x15e9a0;
	static inline auto address3 = base+0x15e8a0;

	dupable static getFunctionOf(SetupCountTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupCountTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupCountTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupCountTriggerPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupCountTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupCountTriggerPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupCountTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupCountTriggerPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupCountTriggerPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupCountTriggerPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupCountTriggerPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupCountTriggerPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupInstantCountPopup : SetupInstantCountPopup, InterfaceBase {
	$SetupInstantCountPopup(const $SetupInstantCountPopup& c) : SetupInstantCountPopup(c) {}
	$SetupInstantCountPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupInstantCountPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupInstantCountPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupInstantCountPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupInstantCountPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x352c10;
	static inline auto address1 = base+0x354520;
	static inline auto address2 = base+0x355270;
	static inline auto address3 = base+0x355170;

	dupable static getFunctionOf(SetupInstantCountPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupInstantCountPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupInstantCountPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupInstantCountPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupInstantCountPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupInstantCountPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupInstantCountPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupInstantCountPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupInstantCountPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupInstantCountPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupInstantCountPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupInstantCountPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupInteractObjectPopup : SetupInteractObjectPopup, InterfaceBase {
	$SetupInteractObjectPopup(const $SetupInteractObjectPopup& c) : SetupInteractObjectPopup(c) {}
	$SetupInteractObjectPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupInteractObjectPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupInteractObjectPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupInteractObjectPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupInteractObjectPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x29a400;
	static inline auto address1 = base+0x29bbc0;
	static inline auto address2 = base+0x29c2b0;
	static inline auto address3 = base+0x29c120;

	dupable static getFunctionOf(SetupInteractObjectPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupInteractObjectPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupInteractObjectPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupInteractObjectPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupInteractObjectPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupInteractObjectPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupInteractObjectPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupInteractObjectPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupInteractObjectPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupInteractObjectPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupInteractObjectPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupInteractObjectPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupObjectTogglePopup : SetupObjectTogglePopup, InterfaceBase {
	$SetupObjectTogglePopup(const $SetupObjectTogglePopup& c) : SetupObjectTogglePopup(c) {}
	$SetupObjectTogglePopup() = delete;
	setInterfaceStaticTypesOf(0, SetupObjectTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupObjectTogglePopup, init, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(2, SetupObjectTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(3, SetupObjectTogglePopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(4, SetupObjectTogglePopup, updateTargetID, , 0);
	static inline auto address0 = base+0x1c0860;
	static inline auto address1 = base+0x1c0a40;
	static inline auto address2 = base+0x1c1c40;
	static inline auto address3 = base+0x1c2660;
	static inline auto address4 = base+0x1c2440;

	dupable static getFunctionOf(SetupObjectTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupObjectTogglePopup, init, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1);
	}

	dupable getFunctionOf(SetupObjectTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupObjectTogglePopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(SetupObjectTogglePopup, updateTargetID, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	static getWrapperOf(SetupObjectTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupObjectTogglePopup, init, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::init(p0, p1);
	}

	getWrapperOf(SetupObjectTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupObjectTogglePopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupObjectTogglePopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupObjectTogglePopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupObjectTogglePopup::init) != (der1)(&D::init)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::initWrapper)));
		}

		if constexpr((mem2)(&$SetupObjectTogglePopup::onTargetIDArrow) != (der2)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem3)(&$SetupObjectTogglePopup::textChanged) != (der3)(&D::textChanged)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::textChangedWrapper)));
		}

		if constexpr((mem4)(&$SetupObjectTogglePopup::updateTargetID) != (der4)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupOpacityPopup : SetupOpacityPopup, InterfaceBase {
	$SetupOpacityPopup(const $SetupOpacityPopup& c) : SetupOpacityPopup(c) {}
	$SetupOpacityPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupOpacityPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupOpacityPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupOpacityPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupOpacityPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x32b70;
	static inline auto address1 = base+0x340a0;
	static inline auto address2 = base+0x34a60;
	static inline auto address3 = base+0x34760;

	dupable static getFunctionOf(SetupOpacityPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupOpacityPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupOpacityPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupOpacityPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupOpacityPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupOpacityPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupOpacityPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupOpacityPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupOpacityPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupOpacityPopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupOpacityPopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupOpacityPopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupPickupTriggerPopup : SetupPickupTriggerPopup, InterfaceBase {
	$SetupPickupTriggerPopup(const $SetupPickupTriggerPopup& c) : SetupPickupTriggerPopup(c) {}
	$SetupPickupTriggerPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupPickupTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupPickupTriggerPopup, onItemIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupPickupTriggerPopup, onNextItemID, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(3, SetupPickupTriggerPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(4, SetupPickupTriggerPopup, updateItemID, , 0);
	static inline auto address0 = base+0x35e70;
	static inline auto address1 = base+0x37100;
	static inline auto address2 = base+0x37260;
	static inline auto address3 = base+0x37ca0;
	static inline auto address4 = base+0x37ab0;

	dupable static getFunctionOf(SetupPickupTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupPickupTriggerPopup, onItemIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupPickupTriggerPopup, onNextItemID, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupPickupTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(SetupPickupTriggerPopup, updateItemID, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	static getWrapperOf(SetupPickupTriggerPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupPickupTriggerPopup, onItemIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onItemIDArrow(p0);
	}

	getWrapperOf(SetupPickupTriggerPopup, onNextItemID, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onNextItemID(p0);
	}

	getWrapperOf(SetupPickupTriggerPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupPickupTriggerPopup, updateItemID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateItemID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupPickupTriggerPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupPickupTriggerPopup::onItemIDArrow) != (der1)(&D::onItemIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onItemIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupPickupTriggerPopup::onNextItemID) != (der2)(&D::onNextItemID)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::onNextItemIDWrapper)));
		}

		if constexpr((mem3)(&$SetupPickupTriggerPopup::textChanged) != (der3)(&D::textChanged)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::textChangedWrapper)));
		}

		if constexpr((mem4)(&$SetupPickupTriggerPopup::updateItemID) != (der4)(&D::updateItemID)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::updateItemIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupShakePopup : SetupShakePopup, InterfaceBase {
	$SetupShakePopup(const $SetupShakePopup& c) : SetupShakePopup(c) {}
	$SetupShakePopup() = delete;
	setInterfaceStaticTypesOf(0, SetupShakePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	static inline auto address0 = base+0x3adc00;

	dupable static getFunctionOf(SetupShakePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	static getWrapperOf(SetupShakePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupShakePopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupSpawnPopup : SetupSpawnPopup, InterfaceBase {
	$SetupSpawnPopup(const $SetupSpawnPopup& c) : SetupSpawnPopup(c) {}
	$SetupSpawnPopup() = delete;
	setInterfaceStaticTypesOf(0, SetupSpawnPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupSpawnPopup, createToggleButton, , 6, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*);
	setInterfaceTypesOf(2, SetupSpawnPopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(3, SetupSpawnPopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(4, SetupSpawnPopup, updateTargetID, , 0);
	static inline auto address0 = base+0x139790;
	static inline auto address1 = base+0x13b0e0;
	static inline auto address2 = base+0x13ad80;
	static inline auto address3 = base+0x13b990;
	static inline auto address4 = base+0x13b770;

	dupable static getFunctionOf(SetupSpawnPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupSpawnPopup, createToggleButton, , 6, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*) {
		return reinterpret_cast<fun1>(address1)(this, p0, p1, p2, p3, p4, p5);
	}

	dupable getFunctionOf(SetupSpawnPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupSpawnPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(SetupSpawnPopup, updateTargetID, , 0) {
		return reinterpret_cast<fun4>(address4)(this);
	}

	static getWrapperOf(SetupSpawnPopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupSpawnPopup, createToggleButton, , 6, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::createToggleButton(p0, p1, p2, p3, p4, p5);
	}

	getWrapperOf(SetupSpawnPopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupSpawnPopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupSpawnPopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupSpawnPopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupSpawnPopup::createToggleButton) != (der1)(&D::createToggleButton)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createToggleButtonWrapper)));
		}

		if constexpr((mem2)(&$SetupSpawnPopup::onTargetIDArrow) != (der2)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem3)(&$SetupSpawnPopup::textChanged) != (der3)(&D::textChanged)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::textChangedWrapper)));
		}

		if constexpr((mem4)(&$SetupSpawnPopup::updateTargetID) != (der4)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SetupTouchTogglePopup : SetupTouchTogglePopup, InterfaceBase {
	$SetupTouchTogglePopup(const $SetupTouchTogglePopup& c) : SetupTouchTogglePopup(c) {}
	$SetupTouchTogglePopup() = delete;
	setInterfaceStaticTypesOf(0, SetupTouchTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*);
	setInterfaceTypesOf(1, SetupTouchTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*);
	setInterfaceTypesOf(2, SetupTouchTogglePopup, textChanged, , 1, CCTextInputNode*);
	setInterfaceTypesOf(3, SetupTouchTogglePopup, updateTargetID, , 0);
	static inline auto address0 = base+0x1576a0;
	static inline auto address1 = base+0x158b60;
	static inline auto address2 = base+0x1596a0;
	static inline auto address3 = base+0x159480;

	dupable static getFunctionOf(SetupTouchTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return reinterpret_cast<fun0>(address0)(p0, p1);
	}

	dupable getFunctionOf(SetupTouchTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SetupTouchTogglePopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable getFunctionOf(SetupTouchTogglePopup, updateTargetID, , 0) {
		return reinterpret_cast<fun3>(address3)(this);
	}

	static getWrapperOf(SetupTouchTogglePopup, create, , 2, EffectGameObject*, cocos2d::CCArray*) {
		return D::create(p0, p1);
	}

	getWrapperOf(SetupTouchTogglePopup, onTargetIDArrow, , 1, cocos2d::CCObject*) {
		return reinterpret_cast<D*>(this)->D::onTargetIDArrow(p0);
	}

	getWrapperOf(SetupTouchTogglePopup, textChanged, , 1, CCTextInputNode*) {
		return reinterpret_cast<D*>(this)->D::textChanged(p0);
	}

	getWrapperOf(SetupTouchTogglePopup, updateTargetID, , 0) {
		return reinterpret_cast<D*>(this)->D::updateTargetID();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SetupTouchTogglePopup::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SetupTouchTogglePopup::onTargetIDArrow) != (der1)(&D::onTargetIDArrow)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::onTargetIDArrowWrapper)));
		}

		if constexpr((mem2)(&$SetupTouchTogglePopup::textChanged) != (der2)(&D::textChanged)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::textChangedWrapper)));
		}

		if constexpr((mem3)(&$SetupTouchTogglePopup::updateTargetID) != (der3)(&D::updateTargetID)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updateTargetIDWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SimplePlayer : SimplePlayer, InterfaceBase {
	$SimplePlayer(const $SimplePlayer& c) : SimplePlayer(c) {}
	$SimplePlayer() = delete;
	setInterfaceStaticTypesOf(0, SimplePlayer, create, , 1, int);
	setInterfaceTypesOf(1, SimplePlayer, setSecondColor, , 1, cocos2d::_ccColor3B const&);
	setInterfaceTypesOf(2, SimplePlayer, updateColors, , 0);
	setInterfaceTypesOf(3, SimplePlayer, updatePlayerFrame, , 2, int, IconType);
	static inline auto address0 = base+0x1b6140;
	static inline auto address1 = base+0x1bace0;
	static inline auto address2 = base+0x1ba1f0;
	static inline auto address3 = base+0x1b62f0;

	dupable static getFunctionOf(SimplePlayer, create, , 1, int) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	dupable getFunctionOf(SimplePlayer, setSecondColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SimplePlayer, updateColors, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(SimplePlayer, updatePlayerFrame, , 2, int, IconType) {
		return reinterpret_cast<fun3>(address3)(this, p0, p1);
	}

	static getWrapperOf(SimplePlayer, create, , 1, int) {
		return D::create(p0);
	}

	getWrapperOf(SimplePlayer, setSecondColor, , 1, cocos2d::_ccColor3B const&) {
		return reinterpret_cast<D*>(this)->D::setSecondColor(p0);
	}

	getWrapperOf(SimplePlayer, updateColors, , 0) {
		return reinterpret_cast<D*>(this)->D::updateColors();
	}

	getWrapperOf(SimplePlayer, updatePlayerFrame, , 2, int, IconType) {
		return reinterpret_cast<D*>(this)->D::updatePlayerFrame(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SimplePlayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$SimplePlayer::setSecondColor) != (der1)(&D::setSecondColor)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setSecondColorWrapper)));
		}

		if constexpr((mem2)(&$SimplePlayer::updateColors) != (der2)(&D::updateColors)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::updateColorsWrapper)));
		}

		if constexpr((mem3)(&$SimplePlayer::updatePlayerFrame) != (der3)(&D::updatePlayerFrame)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::updatePlayerFrameWrapper)));
		}

		return true;
	}
};

template<class D>
struct $Slider : Slider, InterfaceBase {
	$Slider(const $Slider& c) : Slider(c) {}
	$Slider() = delete;
	setInterfaceStaticTypesOf(0, Slider, create, , 7, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	setInterfaceStaticTypesOf(1, Slider, create, , 3, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, float);
	setInterfaceTypesOf(2, Slider, getValue, , 0);
	setInterfaceTypesOf(3, Slider, setBarVisibility, , 1, bool);
	setInterfaceTypesOf(4, Slider, setValue, , 1, float);
	static inline auto address0 = base+0x18dd80;
	static inline auto address1 = base+0x18dc40;
	static inline auto address2 = base+0x18e0c0;
	static inline auto address3 = base+0x18e280;
	static inline auto address4 = base+0x18e170;

	dupable static getFunctionOf(Slider, create, , 7, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2, p3, p4, p5, p6);
	}

	dupable static getFunctionOf(Slider, create, , 3, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, float) {
		return reinterpret_cast<fun1>(address1)(p0, p1, p2);
	}

	dupable getFunctionOf(Slider, getValue, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(Slider, setBarVisibility, , 1, bool) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(Slider, setValue, , 1, float) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	static getWrapperOf(Slider, create, , 7, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float) {
		return D::create(p0, p1, p2, p3, p4, p5, p6);
	}

	static getWrapperOf(Slider, create, , 3, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, float) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(Slider, getValue, , 0) {
		return reinterpret_cast<D*>(this)->D::getValue();
	}

	getWrapperOf(Slider, setBarVisibility, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::setBarVisibility(p0);
	}

	getWrapperOf(Slider, setValue, , 1, float) {
		return reinterpret_cast<D*>(this)->D::setValue(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$Slider::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$Slider::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$Slider::getValue) != (der2)(&D::getValue)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::getValueWrapper)));
		}

		if constexpr((mem3)(&$Slider::setBarVisibility) != (der3)(&D::setBarVisibility)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::setBarVisibilityWrapper)));
		}

		if constexpr((mem4)(&$Slider::setValue) != (der4)(&D::setValue)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::setValueWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SliderThumb : SliderThumb, InterfaceBase {
	$SliderThumb(const $SliderThumb& c) : SliderThumb(c) {}
	$SliderThumb() = delete;
	setInterfaceTypesOf(0, SliderThumb, getValue, , 0);
	static inline auto address0 = base+0x18ce80;

	dupable getFunctionOf(SliderThumb, getValue, , 0) {
		return reinterpret_cast<fun0>(address0)(this);
	}

	getWrapperOf(SliderThumb, getValue, , 0) {
		return reinterpret_cast<D*>(this)->D::getValue();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SliderThumb::getValue) != (der0)(&D::getValue)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::getValueWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SongInfoObject : SongInfoObject, InterfaceBase {
	$SongInfoObject(const $SongInfoObject& c) : SongInfoObject(c) {}
	$SongInfoObject() = delete;
	setInterfaceTypesOf(1, SongInfoObject, encodeWithCoder, , 1, DS_Dictionary*);
	setInterfaceTypesOf(2, SongInfoObject, canEncode, , 0);
	static inline auto address0 = base+0x2f2040;
	static inline auto address1 = base+0x2f2c70;
	static inline auto address2 = base+0x2f2da0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(SongInfoObject, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(SongInfoObject, canEncode, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(SongInfoObject, encodeWithCoder, , 1, DS_Dictionary*) {
		return reinterpret_cast<D*>(this)->D::encodeWithCoder(p0);
	}

	getWrapperOf(SongInfoObject, canEncode, , 0) {
		return reinterpret_cast<D*>(this)->D::canEncode();
	}

public:
	static bool _apply() {

		if constexpr(&$SongInfoObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$SongInfoObject::encodeWithCoder) != (der1)(&D::encodeWithCoder)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::encodeWithCoderWrapper)));
		}

		if ((mem2)(&$SongInfoObject::canEncode) != (der2)(&D::canEncode)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::canEncodeWrapper)));
		}

		return true;
	}
};

template<class D>
struct $SpawnTriggerAction : SpawnTriggerAction, InterfaceBase {
	$SpawnTriggerAction(const $SpawnTriggerAction& c) : SpawnTriggerAction(c) {}
	$SpawnTriggerAction() = delete;
	setInterfaceStaticTypesOf(0, SpawnTriggerAction, createFromString, , 1, gd::string);
	static inline auto address0 = base+0x17bf50;

	dupable static getFunctionOf(SpawnTriggerAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(SpawnTriggerAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$SpawnTriggerAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $TableView : TableView, InterfaceBase {
	$TableView(const $TableView& c) : TableView(c) {}
	$TableView() = delete;
	setInterfaceStaticTypesOf(0, TableView, create, , 3, TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect);
	setInterfaceTypesOf(1, TableView, reloadData, , 0);
	static inline auto address0 = base+0x37eb30;
	static inline auto address1 = base+0x37f970;

	dupable static getFunctionOf(TableView, create, , 3, TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect) {
		return reinterpret_cast<fun0>(address0)(p0, p1, p2);
	}

	dupable getFunctionOf(TableView, reloadData, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	static getWrapperOf(TableView, create, , 3, TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect) {
		return D::create(p0, p1, p2);
	}

	getWrapperOf(TableView, reloadData, , 0) {
		return reinterpret_cast<D*>(this)->D::reloadData();
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$TableView::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$TableView::reloadData) != (der1)(&D::reloadData)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::reloadDataWrapper)));
		}

		return true;
	}
};

template<class D>
struct $TableViewCell : TableViewCell, InterfaceBase {
	$TableViewCell(const $TableViewCell& c) : TableViewCell(c) {}
	$TableViewCell() = delete;
	static inline auto address0 = base+0x383de0;

	dupable void constructor(char const* p0, float p1, float p2) {
		reinterpret_cast<void(*)(decltype(this), char const*, float, float)>(address0)(this, p0, p1, p2);
	}

	void constructorWrapper(char const* p0, float p1, float p2) {
		reinterpret_cast<D*>(this)->D::constructor(p0, p1, p2);
	}

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $TableViewDataSource : TableViewDataSource, InterfaceBase {
	$TableViewDataSource(const $TableViewDataSource& c) : TableViewDataSource(c) {}
	$TableViewDataSource() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $TableViewDelegate : TableViewDelegate, InterfaceBase {
	$TableViewDelegate(const $TableViewDelegate& c) : TableViewDelegate(c) {}
	$TableViewDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $TextArea : TextArea, InterfaceBase {
	$TextArea(const $TextArea& c) : TextArea(c) {}
	$TextArea() = delete;
	setInterfaceTypesOf(1, TextArea, draw, , 0);
	setInterfaceTypesOf(2, TextArea, setOpacity, , 1, unsigned char);
	setInterfaceStaticTypesOf(3, TextArea, create, , 7, gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static inline auto address0 = base+0x19faa0;
	static inline auto address1 = base+0x19f890;
	static inline auto address2 = base+0x19f760;
	static inline auto address3 = base+0x19eb40;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable getFunctionOf(TextArea, draw, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(TextArea, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<fun2>(address2)(this, p0);
	}

	dupable static getFunctionOf(TextArea, create, , 7, gd::string, char const*, float, float, cocos2d::CCPoint, float, bool) {
		return reinterpret_cast<fun3>(address3)(p0, p1, p2, p3, p4, p5, p6);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	getWrapperOf(TextArea, draw, , 0) {
		return reinterpret_cast<D*>(this)->D::draw();
	}

	getWrapperOf(TextArea, setOpacity, , 1, unsigned char) {
		return reinterpret_cast<D*>(this)->D::setOpacity(p0);
	}

	static getWrapperOf(TextArea, create, , 7, gd::string, char const*, float, float, cocos2d::CCPoint, float, bool) {
		return D::create(p0, p1, p2, p3, p4, p5, p6);
	}

public:
	static bool _apply() {

		if constexpr(&$TextArea::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if ((mem1)(&$TextArea::draw) != (der1)(&D::draw)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfVirtual((der1)(&D::drawWrapper)));
		}

		if ((mem2)(&$TextArea::setOpacity) != (der2)(&D::setOpacity)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::setOpacityWrapper)));
		}

		if constexpr((mem3)(&$TextArea::create) != (der3)(&D::create)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::createWrapper)));
		}

		return true;
	}
};

template<class D>
struct $TextInputDelegate : TextInputDelegate, InterfaceBase {
	$TextInputDelegate(const $TextInputDelegate& c) : TextInputDelegate(c) {}
	$TextInputDelegate() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $ToggleTriggerAction : ToggleTriggerAction, InterfaceBase {
	$ToggleTriggerAction(const $ToggleTriggerAction& c) : ToggleTriggerAction(c) {}
	$ToggleTriggerAction() = delete;
	setInterfaceStaticTypesOf(0, ToggleTriggerAction, createFromString, , 1, gd::string);
	static inline auto address0 = base+0x1765e0;

	dupable static getFunctionOf(ToggleTriggerAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(ToggleTriggerAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$ToggleTriggerAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $TopArtistsLayer : TopArtistsLayer, InterfaceBase {
	$TopArtistsLayer(const $TopArtistsLayer& c) : TopArtistsLayer(c) {}
	$TopArtistsLayer() = delete;
	setInterfaceStaticTypesOf(0, TopArtistsLayer, create, , 0);
	setInterfaceTypesOf(1, TopArtistsLayer, setupLeaderboard, , 1, cocos2d::CCArray*);
	setInterfaceTypesOf(2, TopArtistsLayer, init, , 0);
	setInterfaceTypesOf(3, TopArtistsLayer, loadPage, , 1, int);
	setInterfaceTypesOf(4, TopArtistsLayer, setupPageInfo, , 2, gd::string, char const*);
	static inline auto address0 = base+0x192a90;
	static inline auto address1 = base+0x193420;
	static inline auto address2 = base+0x192c30;
	static inline auto address3 = base+0x193b60;
	static inline auto address4 = base+0x193730;

	dupable static getFunctionOf(TopArtistsLayer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(TopArtistsLayer, setupLeaderboard, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<fun1>(address1)(this, p0);
	}

	dupable getFunctionOf(TopArtistsLayer, init, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(TopArtistsLayer, loadPage, , 1, int) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(TopArtistsLayer, setupPageInfo, , 2, gd::string, char const*) {
		return reinterpret_cast<fun4>(address4)(this, p0, p1);
	}

	static getWrapperOf(TopArtistsLayer, create, , 0) {
		return D::create();
	}

	getWrapperOf(TopArtistsLayer, setupLeaderboard, , 1, cocos2d::CCArray*) {
		return reinterpret_cast<D*>(this)->D::setupLeaderboard(p0);
	}

	getWrapperOf(TopArtistsLayer, init, , 0) {
		return reinterpret_cast<D*>(this)->D::init();
	}

	getWrapperOf(TopArtistsLayer, loadPage, , 1, int) {
		return reinterpret_cast<D*>(this)->D::loadPage(p0);
	}

	getWrapperOf(TopArtistsLayer, setupPageInfo, , 2, gd::string, char const*) {
		return reinterpret_cast<D*>(this)->D::setupPageInfo(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$TopArtistsLayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$TopArtistsLayer::setupLeaderboard) != (der1)(&D::setupLeaderboard)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::setupLeaderboardWrapper)));
		}

		if ((mem2)(&$TopArtistsLayer::init) != (der2)(&D::init)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfVirtual((der2)(&D::initWrapper)));
		}

		if constexpr((mem3)(&$TopArtistsLayer::loadPage) != (der3)(&D::loadPage)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::loadPageWrapper)));
		}

		if constexpr((mem4)(&$TopArtistsLayer::setupPageInfo) != (der4)(&D::setupPageInfo)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::setupPageInfoWrapper)));
		}

		return true;
	}
};

template<class D>
struct $TouchToggleAction : TouchToggleAction, InterfaceBase {
	$TouchToggleAction(const $TouchToggleAction& c) : TouchToggleAction(c) {}
	$TouchToggleAction() = delete;
	setInterfaceStaticTypesOf(0, TouchToggleAction, createFromString, , 1, gd::string);
	static inline auto address0 = base+0x177e10;

	dupable static getFunctionOf(TouchToggleAction, createFromString, , 1, gd::string) {
		return reinterpret_cast<fun0>(address0)(p0);
	}

	static getWrapperOf(TouchToggleAction, createFromString, , 1, gd::string) {
		return D::createFromString(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$TouchToggleAction::createFromString) != (der0)(&D::createFromString)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createFromStringWrapper)));
		}

		return true;
	}
};

template<class D>
struct $UILayer : UILayer, InterfaceBase {
	$UILayer(const $UILayer& c) : UILayer(c) {}
	$UILayer() = delete;
	setInterfaceStaticTypesOf(0, UILayer, create, , 0);
	setInterfaceTypesOf(1, UILayer, disableMenu, , 0);
	setInterfaceTypesOf(2, UILayer, enableMenu, , 0);
	setInterfaceTypesOf(3, UILayer, pCommand, , 1, cocos2d::CCNode*);
	setInterfaceTypesOf(4, UILayer, toggleCheckpointsMenu, , 1, bool);
	static inline auto address0 = base+0x27fd10;
	static inline auto address1 = base+0x280960;
	static inline auto address2 = base+0x280940;
	static inline auto address3 = base+0x280830;
	static inline auto address4 = base+0x280430;

	dupable static getFunctionOf(UILayer, create, , 0) {
		return reinterpret_cast<fun0>(address0)();
	}

	dupable getFunctionOf(UILayer, disableMenu, , 0) {
		return reinterpret_cast<fun1>(address1)(this);
	}

	dupable getFunctionOf(UILayer, enableMenu, , 0) {
		return reinterpret_cast<fun2>(address2)(this);
	}

	dupable getFunctionOf(UILayer, pCommand, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<fun3>(address3)(this, p0);
	}

	dupable getFunctionOf(UILayer, toggleCheckpointsMenu, , 1, bool) {
		return reinterpret_cast<fun4>(address4)(this, p0);
	}

	static getWrapperOf(UILayer, create, , 0) {
		return D::create();
	}

	getWrapperOf(UILayer, disableMenu, , 0) {
		return reinterpret_cast<D*>(this)->D::disableMenu();
	}

	getWrapperOf(UILayer, enableMenu, , 0) {
		return reinterpret_cast<D*>(this)->D::enableMenu();
	}

	getWrapperOf(UILayer, pCommand, , 1, cocos2d::CCNode*) {
		return reinterpret_cast<D*>(this)->D::pCommand(p0);
	}

	getWrapperOf(UILayer, toggleCheckpointsMenu, , 1, bool) {
		return reinterpret_cast<D*>(this)->D::toggleCheckpointsMenu(p0);
	}

public:
	static bool _apply() {

		if constexpr((mem0)(&$UILayer::create) != (der0)(&D::create)) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual((der0)(&D::createWrapper)));
		}

		if constexpr((mem1)(&$UILayer::disableMenu) != (der1)(&D::disableMenu)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::disableMenuWrapper)));
		}

		if constexpr((mem2)(&$UILayer::enableMenu) != (der2)(&D::enableMenu)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::enableMenuWrapper)));
		}

		if constexpr((mem3)(&$UILayer::pCommand) != (der3)(&D::pCommand)) {
			modContainer.registerHookEnable(address3, FunctionScrapper::addressOfNonVirtual((der3)(&D::pCommandWrapper)));
		}

		if constexpr((mem4)(&$UILayer::toggleCheckpointsMenu) != (der4)(&D::toggleCheckpointsMenu)) {
			modContainer.registerHookEnable(address4, FunctionScrapper::addressOfNonVirtual((der4)(&D::toggleCheckpointsMenuWrapper)));
		}

		return true;
	}
};

template<class D>
struct $UndoCommand : UndoCommand, InterfaceBase {
	$UndoCommand(const $UndoCommand& c) : UndoCommand(c) {}
	$UndoCommand() = delete;

public:
	static bool _apply() {

		return true;
	}
};

template<class D>
struct $UndoObject : UndoObject, InterfaceBase {
	$UndoObject(const $UndoObject& c) : UndoObject(c) {}
	$UndoObject() = delete;
	setInterfaceStaticTypesOf(1, UndoObject, create, , 2, GameObject*, UndoCommand);
	setInterfaceStaticTypesOf(2, UndoObject, createWithArray, , 2, cocos2d::CCArray*, UndoCommand);
	static inline auto address0 = base+0xa2fd0;
	static inline auto address1 = base+0x94ea0;
	static inline auto address2 = base+0x96ee0;

	dupable void destructor() {
		reinterpret_cast<void(*)(decltype(this))>(address0)(this);
	}

	dupable static getFunctionOf(UndoObject, create, , 2, GameObject*, UndoCommand) {
		return reinterpret_cast<fun1>(address1)(p0, p1);
	}

	dupable static getFunctionOf(UndoObject, createWithArray, , 2, cocos2d::CCArray*, UndoCommand) {
		return reinterpret_cast<fun2>(address2)(p0, p1);
	}

	void destructorWrapper() {
		reinterpret_cast<D*>(this)->D::destructor();
	}

	static getWrapperOf(UndoObject, create, , 2, GameObject*, UndoCommand) {
		return D::create(p0, p1);
	}

	static getWrapperOf(UndoObject, createWithArray, , 2, cocos2d::CCArray*, UndoCommand) {
		return D::createWithArray(p0, p1);
	}

public:
	static bool _apply() {

		if constexpr(&$UndoObject::destructor != &D::destructor) {
			modContainer.registerHookEnable(address0, FunctionScrapper::addressOfNonVirtual(&D::destructorWrapper));
		}

		if constexpr((mem1)(&$UndoObject::create) != (der1)(&D::create)) {
			modContainer.registerHookEnable(address1, FunctionScrapper::addressOfNonVirtual((der1)(&D::createWrapper)));
		}

		if constexpr((mem2)(&$UndoObject::createWithArray) != (der2)(&D::createWithArray)) {
			modContainer.registerHookEnable(address2, FunctionScrapper::addressOfNonVirtual((der2)(&D::createWithArrayWrapper)));
		}

		return true;
	}
};

#undef dl
#undef dv
} // namespace Cacao::interfaces
