// 
// Copyright camila314 & alk1m123 2021. 
// Autogenerated using a python script
//
#pragma once
#include <Base/InterfaceBase.hpp>
#define rcast reinterpret_cast

template<class D>
class $AppDelegate : public NullAppDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$AppDelegate() {}

    using c0 = void($AppDelegate::*)();
    using d0 = void(D::*)();
    using f0 = void(*)($AppDelegate*);
    inline void bgScale() {
        return reinterpret_cast<f0>(base+0x3aaab0)(this);
    }

    using c1 = bool($AppDelegate::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($AppDelegate*);
    inline bool applicationDidFinishLaunching() {
        return reinterpret_cast<f1>(base+0x3aa900)(this);
    }

    using c2 = void($AppDelegate::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($AppDelegate*);
    inline void applicationDidEnterBackground() {
        return reinterpret_cast<f2>(base+0x3aabe0)(this);
    }

    using c3 = void($AppDelegate::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($AppDelegate*);
    inline void applicationWillEnterForeground() {
        return reinterpret_cast<f3>(base+0x3aac80)(this);
    }

    using c4 = bool($AppDelegate::*)();
    using d4 = bool(D::*)();
    using f4 = bool(*)($AppDelegate*);
    inline bool applicationWillBecomeActive() {
        return reinterpret_cast<f4>(base+0x3aab30)(this);
    }

    using c5 = bool($AppDelegate::*)();
    using d5 = bool(D::*)();
    using f5 = bool(*)($AppDelegate*);
    inline bool applicationWillResignActive() {
        return reinterpret_cast<f5>(base+0x3aab50)(this);
    }

    using c6 = void($AppDelegate::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($AppDelegate*);
    inline void trySaveGame() {
        return reinterpret_cast<f6>(base+0x3aaf10)(this);
    }

    using c7 = void($AppDelegate::*)(cocos2d::CCScene*);
    using d7 = void(D::*)(cocos2d::CCScene*);
    using f7 = void(*)($AppDelegate*, cocos2d::CCScene*);
    inline void willSwitchToScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<f7>(base+0x3aaf40)(this, p0);
    }

    using c8 = AppDelegate*(*)();
    using d8 = AppDelegate*(*)();
    using f8 = AppDelegate*(*)();
    inline static AppDelegate* get() {
        return reinterpret_cast<f8>(base+0x3aab10)();
    }

    inline $AppDelegate(bool) {}
    inline $AppDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$AppDelegate::bgScale} != (d0){&D::bgScale})
            m->registerHook(base+0x3aaab0, extract(i, (d0){&D::bgScale}));

        if ((c1){&$AppDelegate::applicationDidFinishLaunching} != (d1){&D::applicationDidFinishLaunching})
            m->registerHook(base+0x3aa900, extract(i, (d1){&D::applicationDidFinishLaunching}));

        if ((c2){&$AppDelegate::applicationDidEnterBackground} != (d2){&D::applicationDidEnterBackground})
            m->registerHook(base+0x3aabe0, extract(i, (d2){&D::applicationDidEnterBackground}));

        if ((c3){&$AppDelegate::applicationWillEnterForeground} != (d3){&D::applicationWillEnterForeground})
            m->registerHook(base+0x3aac80, extract(i, (d3){&D::applicationWillEnterForeground}));

        if ((c4){&$AppDelegate::applicationWillBecomeActive} != (d4){&D::applicationWillBecomeActive})
            m->registerHook(base+0x3aab30, extract(i, (d4){&D::applicationWillBecomeActive}));

        if ((c5){&$AppDelegate::applicationWillResignActive} != (d5){&D::applicationWillResignActive})
            m->registerHook(base+0x3aab50, extract(i, (d5){&D::applicationWillResignActive}));

        if ((c6){&$AppDelegate::trySaveGame} != (d6){&D::trySaveGame})
            m->registerHook(base+0x3aaf10, extract(i, (d6){&D::trySaveGame}));

        if ((c7){&$AppDelegate::willSwitchToScene} != (d7){&D::willSwitchToScene})
            m->registerHook(base+0x3aaf40, extract(i, (d7){&D::willSwitchToScene}));

        if ((c8){&$AppDelegate::get} != (d8){&D::get})
            m->registerHook(base+0x3aab10, extract((d8){&D::get}));
    }
};

template<class D>
class $CCCircleWaveDelegate : public NullCCCircleWaveDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCCircleWaveDelegate() {}

    inline $CCCircleWaveDelegate(bool) {}
    inline $CCCircleWaveDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $TableViewDelegate : public NullTableViewDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$TableViewDelegate() {}

    inline $TableViewDelegate(bool) {}
    inline $TableViewDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $TableViewDataSource : public NullTableViewDataSource, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$TableViewDataSource() {}

    inline $TableViewDataSource(bool) {}
    inline $TableViewDataSource() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $CCScrollLayerExtDelegate : public NullCCScrollLayerExtDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCScrollLayerExtDelegate() {}

    inline $CCScrollLayerExtDelegate(bool) {}
    inline $CCScrollLayerExtDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $GJSpecialColorSelectDelegate : public NullGJSpecialColorSelectDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$GJSpecialColorSelectDelegate() {}

    inline $GJSpecialColorSelectDelegate(bool) {}
    inline $GJSpecialColorSelectDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $TextInputDelegate : public NullTextInputDelegate, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$TextInputDelegate() {}

    inline $TextInputDelegate(bool) {}
    inline $TextInputDelegate() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $FLAlertLayerProtocol : public NullFLAlertLayerProtocol, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$FLAlertLayerProtocol() {}

    inline $FLAlertLayerProtocol(bool) {}
    inline $FLAlertLayerProtocol() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

template<class D>
class $CCSpritePlus : public NullCCSpritePlus, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCSpritePlus() {}

    using c0 = bool($CCSpritePlus::*)(char const*);
    using d0 = bool(D::*)(char const*);
    using f0 = bool(*)($CCSpritePlus*, char const*);
    inline bool initWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<f0>(base+0x248670)(this, p0);
    }

    inline $CCSpritePlus(bool) {}
    inline $CCSpritePlus() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCSpritePlus::initWithSpriteFrameName} != (d0){&D::initWithSpriteFrameName})
            m->registerHook(base+0x248670, extract(i, (d0){&D::initWithSpriteFrameName}));
    }
};

template<class D>
class $CCMoveCNode : public NullCCMoveCNode, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCMoveCNode() {}

    using c0 = CCMoveCNode*(*)();
    using d0 = CCMoveCNode*(*)();
    using f0 = CCMoveCNode*(*)();
    inline static CCMoveCNode* create() {
        return reinterpret_cast<f0>(base+0x1842a0)();
    }

    using c1 = bool($CCMoveCNode::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($CCMoveCNode*);
    inline bool init() {
        return reinterpret_cast<f1>(base+0x18b3d0)(this);
    }

    inline $CCMoveCNode(bool) {}
    inline $CCMoveCNode() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCMoveCNode::create} != (d0){&D::create})
            m->registerHook(base+0x1842a0, extract((d0){&D::create}));

        if ((c1){&$CCMoveCNode::init} != (d1){&D::init})
            m->registerHook(base+0x18b3d0, extract(i, (d1){&D::init}));
    }
};

template<class D>
class $CCNodeContainer : public NullCCNodeContainer, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCNodeContainer() {}

    using c0 = CCNodeContainer*(*)();
    using d0 = CCNodeContainer*(*)();
    using f0 = CCNodeContainer*(*)();
    inline static CCNodeContainer* create() {
        return reinterpret_cast<f0>(base+0xb1090)();
    }

    using c1 = bool($CCNodeContainer::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($CCNodeContainer*);
    inline bool init() {
        return reinterpret_cast<f1>(base+0xba950)(this);
    }

    using c2 = void($CCNodeContainer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCNodeContainer*);
    inline void visit() {
        return reinterpret_cast<f2>(base+0xba960)(this);
    }

    inline $CCNodeContainer(bool) {}
    inline $CCNodeContainer() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCNodeContainer::create} != (d0){&D::create})
            m->registerHook(base+0xb1090, extract((d0){&D::create}));

        if ((c1){&$CCNodeContainer::init} != (d1){&D::init})
            m->registerHook(base+0xba950, extract(i, (d1){&D::init}));

        if ((c2){&$CCNodeContainer::visit} != (d2){&D::visit})
            m->registerHook(base+0xba960, extract(i, (d2){&D::visit}));
    }
};

template<class D>
class $CCAnimatedSprite : public NullCCAnimatedSprite, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCAnimatedSprite() {}

    using c0 = void($CCAnimatedSprite::*)(gd::string);
    using d0 = void(D::*)(gd::string);
    using f0 = void(*)($CCAnimatedSprite*, gd::string);
    inline void runAnimation(gd::string p0) {
        return reinterpret_cast<f0>(base+0x1a6430)(this, p0);
    }

    using c1 = void($CCAnimatedSprite::*)(gd::string, float);
    using d1 = void(D::*)(gd::string, float);
    using f1 = void(*)($CCAnimatedSprite*, gd::string, float);
    inline void tweenToAnimation(gd::string p0, float p1) {
        return reinterpret_cast<f1>(base+0x1a65b0)(this, p0, p1);
    }

    inline $CCAnimatedSprite(bool) {}
    inline $CCAnimatedSprite() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCAnimatedSprite::runAnimation} != (d0){&D::runAnimation})
            m->registerHook(base+0x1a6430, extract(i, (d0){&D::runAnimation}));

        if ((c1){&$CCAnimatedSprite::tweenToAnimation} != (d1){&D::tweenToAnimation})
            m->registerHook(base+0x1a65b0, extract(i, (d1){&D::tweenToAnimation}));
    }
};

template<class D>
class $CCBlockLayer : public NullCCBlockLayer, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCBlockLayer() {}

    using c0 = void($CCBlockLayer::*)();
    using d0 = void(D::*)();
    using f0 = void(*)($CCBlockLayer*);
    inline void disableUI() {
        return reinterpret_cast<f0>(base+0x2a5a80)(this);
    }

    using c1 = void($CCBlockLayer::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($CCBlockLayer*);
    inline void draw() {
        return reinterpret_cast<f1>(base+0x2a5c20)(this);
    }

    using c2 = void($CCBlockLayer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCBlockLayer*);
    inline void enableUI() {
        return reinterpret_cast<f2>(base+0x2a5a90)(this);
    }

    using c3 = void($CCBlockLayer::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($CCBlockLayer*);
    inline void enterAnimFinished() {
        return reinterpret_cast<f3>(base+0x2a5bb0)(this);
    }

    using c4 = void($CCBlockLayer::*)();
    using d4 = void(D::*)();
    using f4 = void(*)($CCBlockLayer*);
    inline void enterLayer() {
        return reinterpret_cast<f4>(base+0x2a5aa0)(this);
    }

    using c5 = void($CCBlockLayer::*)();
    using d5 = void(D::*)();
    using f5 = void(*)($CCBlockLayer*);
    inline void exitLayer() {
        return reinterpret_cast<f5>(base+0x2a5b40)(this);
    }

    using c6 = void($CCBlockLayer::*)(bool);
    using d6 = void(D::*)(bool);
    using f6 = void(*)($CCBlockLayer*, bool);
    inline void hideLayer(bool p0) {
        return reinterpret_cast<f6>(base+0x2a5ba0)(this, p0);
    }

    using c7 = bool($CCBlockLayer::*)();
    using d7 = bool(D::*)();
    using f7 = bool(*)($CCBlockLayer*);
    inline bool init() {
        return reinterpret_cast<f7>(base+0x2a59c0)(this);
    }

    using c8 = void($CCBlockLayer::*)();
    using d8 = void(D::*)();
    using f8 = void(*)($CCBlockLayer*);
    inline void layerHidden() {
        return reinterpret_cast<f8>(base+0x2a5be0)(this);
    }

    using c9 = void($CCBlockLayer::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($CCBlockLayer*);
    inline void layerVisible() {
        return reinterpret_cast<f9>(base+0x2a5bc0)(this);
    }

    using c10 = void($CCBlockLayer::*)();
    using d10 = void(D::*)();
    using f10 = void(*)($CCBlockLayer*);
    inline void registerWithTouchDispatcher() {
        return reinterpret_cast<f10>(base+0x2a5ad0)(this);
    }

    using c11 = void($CCBlockLayer::*)(bool);
    using d11 = void(D::*)(bool);
    using f11 = void(*)($CCBlockLayer*, bool);
    inline void showLayer(bool p0) {
        return reinterpret_cast<f11>(base+0x2a5b90)(this, p0);
    }

    inline $CCBlockLayer(bool) {}
    inline $CCBlockLayer() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCBlockLayer::disableUI} != (d0){&D::disableUI})
            m->registerHook(base+0x2a5a80, extract(i, (d0){&D::disableUI}));

        if ((c1){&$CCBlockLayer::draw} != (d1){&D::draw})
            m->registerHook(base+0x2a5c20, extract(i, (d1){&D::draw}));

        if ((c2){&$CCBlockLayer::enableUI} != (d2){&D::enableUI})
            m->registerHook(base+0x2a5a90, extract(i, (d2){&D::enableUI}));

        if ((c3){&$CCBlockLayer::enterAnimFinished} != (d3){&D::enterAnimFinished})
            m->registerHook(base+0x2a5bb0, extract(i, (d3){&D::enterAnimFinished}));

        if ((c4){&$CCBlockLayer::enterLayer} != (d4){&D::enterLayer})
            m->registerHook(base+0x2a5aa0, extract(i, (d4){&D::enterLayer}));

        if ((c5){&$CCBlockLayer::exitLayer} != (d5){&D::exitLayer})
            m->registerHook(base+0x2a5b40, extract(i, (d5){&D::exitLayer}));

        if ((c6){&$CCBlockLayer::hideLayer} != (d6){&D::hideLayer})
            m->registerHook(base+0x2a5ba0, extract(i, (d6){&D::hideLayer}));

        if ((c7){&$CCBlockLayer::init} != (d7){&D::init})
            m->registerHook(base+0x2a59c0, extract(i, (d7){&D::init}));

        if ((c8){&$CCBlockLayer::layerHidden} != (d8){&D::layerHidden})
            m->registerHook(base+0x2a5be0, extract(i, (d8){&D::layerHidden}));

        if ((c9){&$CCBlockLayer::layerVisible} != (d9){&D::layerVisible})
            m->registerHook(base+0x2a5bc0, extract(i, (d9){&D::layerVisible}));

        if ((c10){&$CCBlockLayer::registerWithTouchDispatcher} != (d10){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2a5ad0, extract(i, (d10){&D::registerWithTouchDispatcher}));

        if ((c11){&$CCBlockLayer::showLayer} != (d11){&D::showLayer})
            m->registerHook(base+0x2a5b90, extract(i, (d11){&D::showLayer}));
    }
};

template<class D>
class $CCCircleWave : public NullCCCircleWave, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCCircleWave() {}

    using c0 = CCCircleWave*(*)(float, float, float, bool);
    using d0 = CCCircleWave*(*)(float, float, float, bool);
    using f0 = CCCircleWave*(*)(float, float, float, bool);
    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        return reinterpret_cast<f0>(base+0xbd270)(p0, p1, p2, p3);
    }

    using c1 = CCCircleWave*(*)(float, float, float, bool, bool);
    using d1 = CCCircleWave*(*)(float, float, float, bool, bool);
    using f1 = CCCircleWave*(*)(float, float, float, bool, bool);
    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<f1>(base+0xbd290)(p0, p1, p2, p3, p4);
    }

    using c2 = bool($CCCircleWave::*)(float, float, float, bool, bool);
    using d2 = bool(D::*)(float, float, float, bool, bool);
    using f2 = bool(*)($CCCircleWave*, float, float, float, bool, bool);
    inline bool init(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<f2>(base+0xbd380)(this, p0, p1, p2, p3, p4);
    }

    using c3 = void($CCCircleWave::*)(cocos2d::CCNode*, bool);
    using d3 = void(D::*)(cocos2d::CCNode*, bool);
    using f3 = void(*)($CCCircleWave*, cocos2d::CCNode*, bool);
    inline void followObject(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<f3>(base+0xbd670)(this, p0, p1);
    }

    using c4 = void($CCCircleWave::*)(float);
    using d4 = void(D::*)(float);
    using f4 = void(*)($CCCircleWave*, float);
    inline void updatePosition(float p0) {
        return reinterpret_cast<f4>(base+0xbd630)(this, p0);
    }

    inline $CCCircleWave(bool) {}
    inline $CCCircleWave() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCCircleWave::create} != (d0){&D::create})
            m->registerHook(base+0xbd270, extract((d0){&D::create}));

        if ((c1){&$CCCircleWave::create} != (d1){&D::create})
            m->registerHook(base+0xbd290, extract((d1){&D::create}));

        if ((c2){&$CCCircleWave::init} != (d2){&D::init})
            m->registerHook(base+0xbd380, extract(i, (d2){&D::init}));

        if ((c3){&$CCCircleWave::followObject} != (d3){&D::followObject})
            m->registerHook(base+0xbd670, extract(i, (d3){&D::followObject}));

        if ((c4){&$CCCircleWave::updatePosition} != (d4){&D::updatePosition})
            m->registerHook(base+0xbd630, extract(i, (d4){&D::updatePosition}));
    }
};

template<class D>
class $CCLightFlash : public NullCCLightFlash, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCLightFlash() {}

    using c0 = CCLightFlash*(*)();
    using d0 = CCLightFlash*(*)();
    using f0 = CCLightFlash*(*)();
    inline static CCLightFlash* create() {
        return reinterpret_cast<f0>(base+0x295870)();
    }

    using c1 = void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    using d1 = void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    using f1 = void(*)($CCLightFlash*, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    inline void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        return reinterpret_cast<f1>(base+0x295900)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    inline $CCLightFlash(bool) {}
    inline $CCLightFlash() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCLightFlash::create} != (d0){&D::create})
            m->registerHook(base+0x295870, extract((d0){&D::create}));

        if ((c1){&$CCLightFlash::playEffect} != (d1){&D::playEffect})
            m->registerHook(base+0x295900, extract(i, (d1){&D::playEffect}));
    }
};

template<class D>
class $CCMenuItemSpriteExtra : public NullCCMenuItemSpriteExtra, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCMenuItemSpriteExtra() {}

    using c0 = CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using d0 = CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using f0 = CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        return reinterpret_cast<f0>(base+0x1253c0)(p0, p1, p2, p3);
    }

    using c1 = void($CCMenuItemSpriteExtra::*)(float);
    using d1 = void(D::*)(float);
    using f1 = void(*)($CCMenuItemSpriteExtra*, float);
    inline void setSizeMult(float p0) {
        return reinterpret_cast<f1>(base+0x1255e0)(this, p0);
    }

    using c3 = bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using d3 = bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using f3 = bool(*)($CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline bool init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        return reinterpret_cast<f3>(base+0x125450)(this, p0, p1, p2, p3);
    }

    inline $CCMenuItemSpriteExtra(bool) {}
    inline $CCMenuItemSpriteExtra() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCMenuItemSpriteExtra::create} != (d0){&D::create})
            m->registerHook(base+0x1253c0, extract((d0){&D::create}));

        if ((c1){&$CCMenuItemSpriteExtra::setSizeMult} != (d1){&D::setSizeMult})
            m->registerHook(base+0x1255e0, extract(i, (d1){&D::setSizeMult}));

        if ((c3){&$CCMenuItemSpriteExtra::init} != (d3){&D::init})
            m->registerHook(base+0x125450, extract(i, (d3){&D::init}));
    }
};

template<class D>
class $CCMenuItemToggler : public NullCCMenuItemToggler, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCMenuItemToggler() {}

    using c0 = CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using d0 = CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using f0 = CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        return reinterpret_cast<f0>(base+0x38400)(p0, p1, p2, p3);
    }

    using c1 = void($CCMenuItemToggler::*)(float);
    using d1 = void(D::*)(float);
    using f1 = void(*)($CCMenuItemToggler*, float);
    inline void setSizeMult(float p0) {
        return reinterpret_cast<f1>(base+0x38a40)(this, p0);
    }

    inline $CCMenuItemToggler(bool) {}
    inline $CCMenuItemToggler() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCMenuItemToggler::create} != (d0){&D::create})
            m->registerHook(base+0x38400, extract((d0){&D::create}));

        if ((c1){&$CCMenuItemToggler::setSizeMult} != (d1){&D::setSizeMult})
            m->registerHook(base+0x38a40, extract(i, (d1){&D::setSizeMult}));
    }
};

template<class D>
class $CCScrollLayerExt : public NullCCScrollLayerExt, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCScrollLayerExt() {}

    using c1 = void($CCScrollLayerExt::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($CCScrollLayerExt*);
    inline void visit() {
        return reinterpret_cast<f1>(base+0x236550)(this);
    }

    using c2 = bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d2 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f2 = bool(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f2>(base+0x235ef0)(this, p0, p1);
    }

    using c3 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d3 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f3 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f3>(base+0x236300)(this, p0, p1);
    }

    using c4 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d4 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f4 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f4>(base+0x236020)(this, p0, p1);
    }

    using c5 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d5 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f5 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f5>(base+0x2362a0)(this, p0, p1);
    }

    using c6 = void($CCScrollLayerExt::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($CCScrollLayerExt*);
    inline void registerWithTouchDispatcher() {
        return reinterpret_cast<f6>(base+0x235eb0)(this);
    }

    using c7 = void($CCScrollLayerExt::*)(cocos2d::CCRect);
    using d7 = void(D::*)(cocos2d::CCRect);
    using f7 = void(*)($CCScrollLayerExt*, cocos2d::CCRect);
    inline void preVisitWithClippingRect(cocos2d::CCRect p0) {
        return reinterpret_cast<f7>(base+0x2366a0)(this, p0);
    }

    using c8 = void($CCScrollLayerExt::*)();
    using d8 = void(D::*)();
    using f8 = void(*)($CCScrollLayerExt*);
    inline void postVisit() {
        return reinterpret_cast<f8>(base+0x236720)(this);
    }

    using c9 = void($CCScrollLayerExt::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($CCScrollLayerExt*);
    inline void moveToTop() {
        return reinterpret_cast<f9>(base+0x235870)(this);
    }

    using c10 = void($CCScrollLayerExt::*)(float);
    using d10 = void(D::*)(float);
    using f10 = void(*)($CCScrollLayerExt*, float);
    inline void moveToTopWithOffset(float p0) {
        return reinterpret_cast<f10>(base+0x2357d0)(this, p0);
    }

    inline $CCScrollLayerExt(bool) {}
    inline $CCScrollLayerExt() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c1){&$CCScrollLayerExt::visit} != (d1){&D::visit})
            m->registerHook(base+0x236550, extract(i, (d1){&D::visit}));

        if ((c2){&$CCScrollLayerExt::ccTouchBegan} != (d2){&D::ccTouchBegan})
            m->registerHook(base+0x235ef0, extract(i, (d2){&D::ccTouchBegan}));

        if ((c3){&$CCScrollLayerExt::ccTouchMoved} != (d3){&D::ccTouchMoved})
            m->registerHook(base+0x236300, extract(i, (d3){&D::ccTouchMoved}));

        if ((c4){&$CCScrollLayerExt::ccTouchEnded} != (d4){&D::ccTouchEnded})
            m->registerHook(base+0x236020, extract(i, (d4){&D::ccTouchEnded}));

        if ((c5){&$CCScrollLayerExt::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            m->registerHook(base+0x2362a0, extract(i, (d5){&D::ccTouchCancelled}));

        if ((c6){&$CCScrollLayerExt::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x235eb0, extract(i, (d6){&D::registerWithTouchDispatcher}));

        if ((c7){&$CCScrollLayerExt::preVisitWithClippingRect} != (d7){&D::preVisitWithClippingRect})
            m->registerHook(base+0x2366a0, extract(i, (d7){&D::preVisitWithClippingRect}));

        if ((c8){&$CCScrollLayerExt::postVisit} != (d8){&D::postVisit})
            m->registerHook(base+0x236720, extract(i, (d8){&D::postVisit}));

        if ((c9){&$CCScrollLayerExt::moveToTop} != (d9){&D::moveToTop})
            m->registerHook(base+0x235870, extract(i, (d9){&D::moveToTop}));

        if ((c10){&$CCScrollLayerExt::moveToTopWithOffset} != (d10){&D::moveToTopWithOffset})
            m->registerHook(base+0x2357d0, extract(i, (d10){&D::moveToTopWithOffset}));
    }
};

template<class D>
class $FLAlertLayer : public NullFLAlertLayer, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$FLAlertLayer() {}

    using c1 = void($FLAlertLayer::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($FLAlertLayer*);
    inline void onEnter() {
        return reinterpret_cast<f1>(base+0x25f350)(this);
    }

    using c2 = bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d2 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f2 = bool(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f2>(base+0x25ee40)(this, p0, p1);
    }

    using c3 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d3 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f3 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f3>(base+0x25f0a0)(this, p0, p1);
    }

    using c4 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d4 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f4 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f4>(base+0x25ef60)(this, p0, p1);
    }

    using c5 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d5 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f5 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f5>(base+0x25f020)(this, p0, p1);
    }

    using c6 = void($FLAlertLayer::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($FLAlertLayer*);
    inline void registerWithTouchDispatcher() {
        return reinterpret_cast<f6>(base+0x25f2e0)(this);
    }

    using c7 = void($FLAlertLayer::*)();
    using d7 = void(D::*)();
    using f7 = void(*)($FLAlertLayer*);
    inline void keyBackClicked() {
        return reinterpret_cast<f7>(base+0x25ed90)(this);
    }

    using c8 = void($FLAlertLayer::*)(cocos2d::enumKeyCodes);
    using d8 = void(D::*)(cocos2d::enumKeyCodes);
    using f8 = void(*)($FLAlertLayer*, cocos2d::enumKeyCodes);
    inline void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<f8>(base+0x25ece0)(this, p0);
    }

    using c9 = void($FLAlertLayer::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($FLAlertLayer*);
    inline void show() {
        return reinterpret_cast<f9>(base+0x25f120)(this);
    }

    using c10 = bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using d10 = bool(D::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using f10 = bool(*)($FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    inline bool init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<f10>(base+0x25e1b0)(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    using c11 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
    using d11 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
    using f11 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5) {
        return reinterpret_cast<f11>(base+0x25e0e0)(p0, p1, p2, p3, p4, p5);
    }

    using c12 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using d12 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using f12 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<f12>(base+0x25dec0)(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $FLAlertLayer(bool) {}
    inline $FLAlertLayer() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c1){&$FLAlertLayer::onEnter} != (d1){&D::onEnter})
            m->registerHook(base+0x25f350, extract(i, (d1){&D::onEnter}));

        if ((c2){&$FLAlertLayer::ccTouchBegan} != (d2){&D::ccTouchBegan})
            m->registerHook(base+0x25ee40, extract(i, (d2){&D::ccTouchBegan}));

        if ((c3){&$FLAlertLayer::ccTouchMoved} != (d3){&D::ccTouchMoved})
            m->registerHook(base+0x25f0a0, extract(i, (d3){&D::ccTouchMoved}));

        if ((c4){&$FLAlertLayer::ccTouchEnded} != (d4){&D::ccTouchEnded})
            m->registerHook(base+0x25ef60, extract(i, (d4){&D::ccTouchEnded}));

        if ((c5){&$FLAlertLayer::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            m->registerHook(base+0x25f020, extract(i, (d5){&D::ccTouchCancelled}));

        if ((c6){&$FLAlertLayer::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25f2e0, extract(i, (d6){&D::registerWithTouchDispatcher}));

        if ((c7){&$FLAlertLayer::keyBackClicked} != (d7){&D::keyBackClicked})
            m->registerHook(base+0x25ed90, extract(i, (d7){&D::keyBackClicked}));

        if ((c8){&$FLAlertLayer::keyDown} != (d8){&D::keyDown})
            m->registerHook(base+0x25ece0, extract(i, (d8){&D::keyDown}));

        if ((c9){&$FLAlertLayer::show} != (d9){&D::show})
            m->registerHook(base+0x25f120, extract(i, (d9){&D::show}));

        if ((c10){&$FLAlertLayer::init} != (d10){&D::init})
            m->registerHook(base+0x25e1b0, extract(i, (d10){&D::init}));

        if ((c11){&$FLAlertLayer::create} != (d11){&D::create})
            m->registerHook(base+0x25e0e0, extract((d11){&D::create}));

        if ((c12){&$FLAlertLayer::create} != (d12){&D::create})
            m->registerHook(base+0x25dec0, extract((d12){&D::create}));
    }
};

template<class D>
class $MenuLayer : public NullMenuLayer, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$MenuLayer() {}

    using c1 = bool($MenuLayer::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($MenuLayer*);
    inline bool init() {
        return reinterpret_cast<f1>(base+0x1d14b0)(this);
    }

    using c2 = void($MenuLayer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($MenuLayer*);
    inline void keyBackClicked() {
        return reinterpret_cast<f2>(base+0x1d3160)(this);
    }

    using c3 = void($MenuLayer::*)(cocos2d::enumKeyCodes);
    using d3 = void(D::*)(cocos2d::enumKeyCodes);
    using f3 = void(*)($MenuLayer*, cocos2d::enumKeyCodes);
    inline void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<f3>(base+0x1d33d0)(this, p0);
    }

    using c4 = void($MenuLayer::*)();
    using d4 = void(D::*)();
    using f4 = void(*)($MenuLayer*);
    inline void googlePlaySignedIn() {
        return reinterpret_cast<f4>(base+0x1d2f30)(this);
    }

    using c5 = void($MenuLayer::*)(FLAlertLayer*, bool);
    using d5 = void(D::*)(FLAlertLayer*, bool);
    using f5 = void(*)($MenuLayer*, FLAlertLayer*, bool);
    inline void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        return reinterpret_cast<f5>(base+0x1d3190)(this, p0, p1);
    }

    using c6 = void($MenuLayer::*)(cocos2d::CCObject*);
    using d6 = void(D::*)(cocos2d::CCObject*);
    using f6 = void(*)($MenuLayer*, cocos2d::CCObject*);
    inline void onMoreGames(cocos2d::CCObject* p0) {
        return reinterpret_cast<f6>(base+0x1d2ad0)(this, p0);
    }

    using c7 = void($MenuLayer::*)(cocos2d::CCObject*);
    using d7 = void(D::*)(cocos2d::CCObject*);
    using f7 = void(*)($MenuLayer*, cocos2d::CCObject*);
    inline void onQuit(cocos2d::CCObject* p0) {
        return reinterpret_cast<f7>(base+0x1d2b40)(this, p0);
    }

    using c8 = void($MenuLayer::*)(bool);
    using d8 = void(D::*)(bool);
    using f8 = void(*)($MenuLayer*, bool);
    inline void scene(bool p0) {
        return reinterpret_cast<f8>(base+0x1d12d0)(this, p0);
    }

    inline $MenuLayer(bool) {}
    inline $MenuLayer() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c1){&$MenuLayer::init} != (d1){&D::init})
            m->registerHook(base+0x1d14b0, extract(i, (d1){&D::init}));

        if ((c2){&$MenuLayer::keyBackClicked} != (d2){&D::keyBackClicked})
            m->registerHook(base+0x1d3160, extract(i, (d2){&D::keyBackClicked}));

        if ((c3){&$MenuLayer::keyDown} != (d3){&D::keyDown})
            m->registerHook(base+0x1d33d0, extract(i, (d3){&D::keyDown}));

        if ((c4){&$MenuLayer::googlePlaySignedIn} != (d4){&D::googlePlaySignedIn})
            m->registerHook(base+0x1d2f30, extract(i, (d4){&D::googlePlaySignedIn}));

        if ((c5){&$MenuLayer::FLAlert_Clicked} != (d5){&D::FLAlert_Clicked})
            m->registerHook(base+0x1d3190, extract(i, (d5){&D::FLAlert_Clicked}));

        if ((c6){&$MenuLayer::onMoreGames} != (d6){&D::onMoreGames})
            m->registerHook(base+0x1d2ad0, extract(i, (d6){&D::onMoreGames}));

        if ((c7){&$MenuLayer::onQuit} != (d7){&D::onQuit})
            m->registerHook(base+0x1d2b40, extract(i, (d7){&D::onQuit}));

        if ((c8){&$MenuLayer::scene} != (d8){&D::scene})
            m->registerHook(base+0x1d12d0, extract(i, (d8){&D::scene}));
    }
};

template<class D>
class $ButtonSprite : public NullButtonSprite, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$ButtonSprite() {}

    using c0 = ButtonSprite*(*)(char const*);
    using d0 = ButtonSprite*(*)(char const*);
    using f0 = ButtonSprite*(*)(char const*);
    inline static ButtonSprite* create(char const* p0) {
        return reinterpret_cast<f0>(base+0x4fa10)(p0);
    }

    using c1 = ButtonSprite*(*)(char const*, int, int, float, bool);
    using d1 = ButtonSprite*(*)(char const*, int, int, float, bool);
    using f1 = ButtonSprite*(*)(char const*, int, int, float, bool);
    inline static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        return reinterpret_cast<f1>(base+0x4fa40)(p0, p1, p2, p3, p4);
    }

    using c2 = void($ButtonSprite::*)(char const*);
    using d2 = void(D::*)(char const*);
    using f2 = void(*)($ButtonSprite*, char const*);
    inline void updateBGImage(char const* p0) {
        return reinterpret_cast<f2>(base+0x502d0)(this, p0);
    }

    using c3 = ButtonSprite*(*)(char const*, float);
    using d3 = ButtonSprite*(*)(char const*, float);
    using f3 = ButtonSprite*(*)(char const*, float);
    inline static ButtonSprite* create(char const* p0, float p1) {
        return reinterpret_cast<f3>(base+0x4fa60)(p0, p1);
    }

    using c4 = ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
    using d4 = ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
    using f4 = ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
    inline static ButtonSprite* create(cocos2d::CCSprite* p0, int p1, int p2, float p3, float p4, bool p5, char const* p6, bool p7) {
        return reinterpret_cast<f4>(base+0x4fa90)(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $ButtonSprite(bool) {}
    inline $ButtonSprite() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$ButtonSprite::create} != (d0){&D::create})
            m->registerHook(base+0x4fa10, extract((d0){&D::create}));

        if ((c1){&$ButtonSprite::create} != (d1){&D::create})
            m->registerHook(base+0x4fa40, extract((d1){&D::create}));

        if ((c2){&$ButtonSprite::updateBGImage} != (d2){&D::updateBGImage})
            m->registerHook(base+0x502d0, extract(i, (d2){&D::updateBGImage}));

        if ((c3){&$ButtonSprite::create} != (d3){&D::create})
            m->registerHook(base+0x4fa60, extract((d3){&D::create}));

        if ((c4){&$ButtonSprite::create} != (d4){&D::create})
            m->registerHook(base+0x4fa90, extract((d4){&D::create}));
    }
};

template<class D>
class $CCTextInputNode : public NullCCTextInputNode, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CCTextInputNode() {}

    using c0 = CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*);
    using d0 = CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*);
    using f0 = CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*);
    inline static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<f0>(base+0x5cfb0)(p0, p1, p2, p3, p4, p5);
    }

    using c1 = gd::string($CCTextInputNode::*)();
    using d1 = gd::string(D::*)();
    using f1 = gd::string(*)($CCTextInputNode*);
    inline gd::string getString() {
        return reinterpret_cast<f1>(base+0x5d6f0)(this);
    }

    using c2 = void($CCTextInputNode::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCTextInputNode*);
    inline void refreshLabel() {
        return reinterpret_cast<f2>(base+0x5d730)(this);
    }

    using c3 = void($CCTextInputNode::*)(gd::string);
    using d3 = void(D::*)(gd::string);
    using f3 = void(*)($CCTextInputNode*, gd::string);
    inline void setAllowedChars(gd::string p0) {
        return reinterpret_cast<f3>(base+0x5d360)(this, p0);
    }

    using c4 = void($CCTextInputNode::*)(cocos2d::_ccColor3B);
    using d4 = void(D::*)(cocos2d::_ccColor3B);
    using f4 = void(*)($CCTextInputNode*, cocos2d::_ccColor3B);
    inline void setLabelNormalColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<f4>(base+0x5dab0)(this, p0);
    }

    using c5 = void($CCTextInputNode::*)(cocos2d::_ccColor3B);
    using d5 = void(D::*)(cocos2d::_ccColor3B);
    using f5 = void(*)($CCTextInputNode*, cocos2d::_ccColor3B);
    inline void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<f5>(base+0x5da90)(this, p0);
    }

    using c6 = void($CCTextInputNode::*)(float);
    using d6 = void(D::*)(float);
    using f6 = void(*)($CCTextInputNode*, float);
    inline void setLabelPlaceholderScale(float p0) {
        return reinterpret_cast<f6>(base+0x5da70)(this, p0);
    }

    using c7 = void($CCTextInputNode::*)(float);
    using d7 = void(D::*)(float);
    using f7 = void(*)($CCTextInputNode*, float);
    inline void setMaxLabelScale(float p0) {
        return reinterpret_cast<f7>(base+0x5da30)(this, p0);
    }

    using c8 = void($CCTextInputNode::*)(float);
    using d8 = void(D::*)(float);
    using f8 = void(*)($CCTextInputNode*, float);
    inline void setMaxLabelWidth(float p0) {
        return reinterpret_cast<f8>(base+0x5da50)(this, p0);
    }

    using c9 = void($CCTextInputNode::*)(gd::string);
    using d9 = void(D::*)(gd::string);
    using f9 = void(*)($CCTextInputNode*, gd::string);
    inline void setString(gd::string p0) {
        return reinterpret_cast<f9>(base+0x5d3e0)(this, p0);
    }

    using c10 = void($CCTextInputNode::*)(gd::string);
    using d10 = void(D::*)(gd::string);
    using f10 = void(*)($CCTextInputNode*, gd::string);
    inline void updateLabel(gd::string p0) {
        return reinterpret_cast<f10>(base+0x5d4a0)(this, p0);
    }

    using c11 = void($CCTextInputNode::*)();
    using d11 = void(D::*)();
    using f11 = void(*)($CCTextInputNode*);
    inline void forceOffset() {
        return reinterpret_cast<f11>(base+0x5ec70)(this);
    }

    using c12 = void($CCTextInputNode::*)();
    using d12 = void(D::*)();
    using f12 = void(*)($CCTextInputNode*);
    inline void registerWithTouchDispatcher() {
        return reinterpret_cast<f12>(base+0x5eec0)(this);
    }

    using c13 = bool($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*);
    using d13 = bool(D::*)(float, float, char const*, char const*, int, char const*);
    using f13 = bool(*)($CCTextInputNode*, float, float, char const*, char const*, int, char const*);
    inline bool init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<f13>(base+0x5d180)(this, p0, p1, p2, p3, p4, p5);
    }

    using c14 = void($CCTextInputNode::*)();
    using d14 = void(D::*)();
    using f14 = void(*)($CCTextInputNode*);
    inline void visit() {
        return reinterpret_cast<f14>(base+0x5d380)(this);
    }

    using c15 = bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d15 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f15 = bool(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f15>(base+0x5ec80)(this, p0, p1);
    }

    using c16 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d16 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f16 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f16>(base+0x5ee80)(this, p0, p1);
    }

    using c17 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d17 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f17 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f17>(base+0x5ee60)(this, p0, p1);
    }

    using c18 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d18 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f18 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<f18>(base+0x5eea0)(this, p0, p1);
    }

    using c19 = void($CCTextInputNode::*)();
    using d19 = void(D::*)();
    using f19 = void(*)($CCTextInputNode*);
    inline void textChanged() {
        return reinterpret_cast<f19>(base+0x5dd70)(this);
    }

    using c20 = void($CCTextInputNode::*)(bool);
    using d20 = void(D::*)(bool);
    using f20 = void(*)($CCTextInputNode*, bool);
    inline void onClickTrackNode(bool p0) {
        return reinterpret_cast<f20>(base+0x5dd40)(this, p0);
    }

    using c21 = void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using d21 = void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using f21 = void(*)($CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
    inline void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        return reinterpret_cast<f21>(base+0x5dad0)(this, p0);
    }

    using c22 = void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using d22 = void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using f22 = void(*)($CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
    inline void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        return reinterpret_cast<f22>(base+0x5dc20)(this, p0);
    }

    using c23 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int);
    using d23 = bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int);
    using f23 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int);
    inline bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2) {
        return reinterpret_cast<f23>(base+0x5de50)(this, p0, p1, p2);
    }

    using c24 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*);
    using d24 = bool(D::*)(cocos2d::CCTextFieldTTF*);
    using f24 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*);
    inline bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) {
        return reinterpret_cast<f24>(base+0x5e2c0)(this, p0);
    }

    using c25 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*);
    using d25 = bool(D::*)(cocos2d::CCTextFieldTTF*);
    using f25 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*);
    inline bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) {
        return reinterpret_cast<f25>(base+0x5e610)(this, p0);
    }

    inline $CCTextInputNode(bool) {}
    inline $CCTextInputNode() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CCTextInputNode::create} != (d0){&D::create})
            m->registerHook(base+0x5cfb0, extract((d0){&D::create}));

        if ((c1){&$CCTextInputNode::getString} != (d1){&D::getString})
            m->registerHook(base+0x5d6f0, extract(i, (d1){&D::getString}));

        if ((c2){&$CCTextInputNode::refreshLabel} != (d2){&D::refreshLabel})
            m->registerHook(base+0x5d730, extract(i, (d2){&D::refreshLabel}));

        if ((c3){&$CCTextInputNode::setAllowedChars} != (d3){&D::setAllowedChars})
            m->registerHook(base+0x5d360, extract(i, (d3){&D::setAllowedChars}));

        if ((c4){&$CCTextInputNode::setLabelNormalColor} != (d4){&D::setLabelNormalColor})
            m->registerHook(base+0x5dab0, extract(i, (d4){&D::setLabelNormalColor}));

        if ((c5){&$CCTextInputNode::setLabelPlaceholderColor} != (d5){&D::setLabelPlaceholderColor})
            m->registerHook(base+0x5da90, extract(i, (d5){&D::setLabelPlaceholderColor}));

        if ((c6){&$CCTextInputNode::setLabelPlaceholderScale} != (d6){&D::setLabelPlaceholderScale})
            m->registerHook(base+0x5da70, extract(i, (d6){&D::setLabelPlaceholderScale}));

        if ((c7){&$CCTextInputNode::setMaxLabelScale} != (d7){&D::setMaxLabelScale})
            m->registerHook(base+0x5da30, extract(i, (d7){&D::setMaxLabelScale}));

        if ((c8){&$CCTextInputNode::setMaxLabelWidth} != (d8){&D::setMaxLabelWidth})
            m->registerHook(base+0x5da50, extract(i, (d8){&D::setMaxLabelWidth}));

        if ((c9){&$CCTextInputNode::setString} != (d9){&D::setString})
            m->registerHook(base+0x5d3e0, extract(i, (d9){&D::setString}));

        if ((c10){&$CCTextInputNode::updateLabel} != (d10){&D::updateLabel})
            m->registerHook(base+0x5d4a0, extract(i, (d10){&D::updateLabel}));

        if ((c11){&$CCTextInputNode::forceOffset} != (d11){&D::forceOffset})
            m->registerHook(base+0x5ec70, extract(i, (d11){&D::forceOffset}));

        if ((c12){&$CCTextInputNode::registerWithTouchDispatcher} != (d12){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x5eec0, extract(i, (d12){&D::registerWithTouchDispatcher}));

        if ((c13){&$CCTextInputNode::init} != (d13){&D::init})
            m->registerHook(base+0x5d180, extract(i, (d13){&D::init}));

        if ((c14){&$CCTextInputNode::visit} != (d14){&D::visit})
            m->registerHook(base+0x5d380, extract(i, (d14){&D::visit}));

        if ((c15){&$CCTextInputNode::ccTouchBegan} != (d15){&D::ccTouchBegan})
            m->registerHook(base+0x5ec80, extract(i, (d15){&D::ccTouchBegan}));

        if ((c16){&$CCTextInputNode::ccTouchCancelled} != (d16){&D::ccTouchCancelled})
            m->registerHook(base+0x5ee80, extract(i, (d16){&D::ccTouchCancelled}));

        if ((c17){&$CCTextInputNode::ccTouchEnded} != (d17){&D::ccTouchEnded})
            m->registerHook(base+0x5ee60, extract(i, (d17){&D::ccTouchEnded}));

        if ((c18){&$CCTextInputNode::ccTouchMoved} != (d18){&D::ccTouchMoved})
            m->registerHook(base+0x5eea0, extract(i, (d18){&D::ccTouchMoved}));

        if ((c19){&$CCTextInputNode::textChanged} != (d19){&D::textChanged})
            m->registerHook(base+0x5dd70, extract(i, (d19){&D::textChanged}));

        if ((c20){&$CCTextInputNode::onClickTrackNode} != (d20){&D::onClickTrackNode})
            m->registerHook(base+0x5dd40, extract(i, (d20){&D::onClickTrackNode}));

        if ((c21){&$CCTextInputNode::keyboardWillShow} != (d21){&D::keyboardWillShow})
            m->registerHook(base+0x5dad0, extract(i, (d21){&D::keyboardWillShow}));

        if ((c22){&$CCTextInputNode::keyboardWillHide} != (d22){&D::keyboardWillHide})
            m->registerHook(base+0x5dc20, extract(i, (d22){&D::keyboardWillHide}));

        if ((c23){&$CCTextInputNode::onTextFieldInsertText} != (d23){&D::onTextFieldInsertText})
            m->registerHook(base+0x5de50, extract(i, (d23){&D::onTextFieldInsertText}));

        if ((c24){&$CCTextInputNode::onTextFieldAttachWithIME} != (d24){&D::onTextFieldAttachWithIME})
            m->registerHook(base+0x5e2c0, extract(i, (d24){&D::onTextFieldAttachWithIME}));

        if ((c25){&$CCTextInputNode::onTextFieldDetachWithIME} != (d25){&D::onTextFieldDetachWithIME})
            m->registerHook(base+0x5e610, extract(i, (d25){&D::onTextFieldDetachWithIME}));
    }
};

template<class D>
class $TableView : public NullTableView, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$TableView() {}

    using c0 = TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect);
    using d0 = TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect);
    using f0 = TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect);
    inline static TableView* create(TableViewDelegate* p0, TableViewDataSource* p1, cocos2d::CCRect p2) {
        return reinterpret_cast<f0>(base+0x37eb30)(p0, p1, p2);
    }

    using c1 = void($TableView::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($TableView*);
    inline void reloadData() {
        return reinterpret_cast<f1>(base+0x37f970)(this);
    }

    inline $TableView(bool) {}
    inline $TableView() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$TableView::create} != (d0){&D::create})
            m->registerHook(base+0x37eb30, extract((d0){&D::create}));

        if ((c1){&$TableView::reloadData} != (d1){&D::reloadData})
            m->registerHook(base+0x37f970, extract(i, (d1){&D::reloadData}));
    }
};

template<class D>
class $BoomListView : public NullBoomListView, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$BoomListView() {}

    using c0 = BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using d0 = BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using f0 = BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    inline static BoomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        return reinterpret_cast<f0>(base+0x18ecb0)(p0, p1, p2, p3, p4);
    }

    using c1 = bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using d1 = bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using f1 = bool(*)($BoomListView*, cocos2d::CCArray*, float, float, int, BoomListType);
    inline bool init(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        return reinterpret_cast<f1>(base+0x18ee00)(this, p0, p1, p2, p3, p4);
    }

    using c2 = void($BoomListView::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($BoomListView*);
    inline void draw() {
        return reinterpret_cast<f2>(base+0x18f790)(this);
    }

    using c3 = void($BoomListView::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($BoomListView*);
    inline void setupList() {
        return reinterpret_cast<f3>(base+0x18ef90)(this);
    }

    using c4 = void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*);
    using d4 = void(D::*)(CCIndexPath&, TableViewCell*, TableView*);
    using f4 = void(*)($BoomListView*, CCIndexPath&, TableViewCell*, TableView*);
    inline void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        return reinterpret_cast<f4>(base+0x18f030)(this, p0, p1, p2);
    }

    using c5 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d5 = void(D::*)(CCIndexPath&, TableView*);
    using f5 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        return reinterpret_cast<f5>(base+0x18f070)(this, p0, p1);
    }

    using c6 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d6 = void(D::*)(CCIndexPath&, TableView*);
    using f6 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        return reinterpret_cast<f6>(base+0x18f090)(this, p0, p1);
    }

    using c7 = int($BoomListView::*)(unsigned int, TableView*);
    using d7 = int(D::*)(unsigned int, TableView*);
    using f7 = int(*)($BoomListView*, unsigned int, TableView*);
    inline int numberOfRowsInSection(unsigned int p0, TableView* p1) {
        return reinterpret_cast<f7>(base+0x18f0b0)(this, p0, p1);
    }

    using c8 = void($BoomListView::*)(TableView*);
    using d8 = void(D::*)(TableView*);
    using f8 = void(*)($BoomListView*, TableView*);
    inline void numberOfSectionsInTableView(TableView* p0) {
        return reinterpret_cast<f8>(base+0x18f0e0)(this, p0);
    }

    using c9 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d9 = void(D::*)(CCIndexPath&, TableView*);
    using f9 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        return reinterpret_cast<f9>(base+0x18f100)(this, p0, p1);
    }

    using c10 = void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&);
    using d10 = void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&);
    using f10 = void(*)($BoomListView*, TableView*, TableViewCellEditingStyle, CCIndexPath&);
    inline void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {
        return reinterpret_cast<f10>(base+0x18f770)(this, p0, p1, p2);
    }

    using c11 = void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*);
    using d11 = void(D::*)(CCIndexPath&, TableViewCell*, TableView*);
    using f11 = void(*)($BoomListView*, CCIndexPath&, TableViewCell*, TableView*);
    inline void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        return reinterpret_cast<f11>(base+0x18f050)(this, p0, p1, p2);
    }

    using c12 = TableViewCell*($BoomListView::*)(char const*);
    using d12 = TableViewCell*(D::*)(char const*);
    using f12 = TableViewCell*(*)($BoomListView*, char const*);
    inline TableViewCell* getListCell(char const* p0) {
        return reinterpret_cast<f12>(base+0x18f200)(this, p0);
    }

    using c13 = void($BoomListView::*)(TableViewCell*, int);
    using d13 = void(D::*)(TableViewCell*, int);
    using f13 = void(*)($BoomListView*, TableViewCell*, int);
    inline void loadCell(TableViewCell* p0, int p1) {
        return reinterpret_cast<f13>(base+0x18f4a0)(this, p0, p1);
    }

    inline $BoomListView(bool) {}
    inline $BoomListView() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$BoomListView::create} != (d0){&D::create})
            m->registerHook(base+0x18ecb0, extract((d0){&D::create}));

        if ((c1){&$BoomListView::init} != (d1){&D::init})
            m->registerHook(base+0x18ee00, extract(i, (d1){&D::init}));

        if ((c2){&$BoomListView::draw} != (d2){&D::draw})
            m->registerHook(base+0x18f790, extract(i, (d2){&D::draw}));

        if ((c3){&$BoomListView::setupList} != (d3){&D::setupList})
            m->registerHook(base+0x18ef90, extract(i, (d3){&D::setupList}));

        if ((c4){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (d4){&D::TableViewWillDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x18f030, extract(i, (d4){&D::TableViewWillDisplayCellForRowAtIndexPath}));

        if ((c5){&$BoomListView::cellHeightForRowAtIndexPath} != (d5){&D::cellHeightForRowAtIndexPath})
            m->registerHook(base+0x18f070, extract(i, (d5){&D::cellHeightForRowAtIndexPath}));

        if ((c6){&$BoomListView::didSelectRowAtIndexPath} != (d6){&D::didSelectRowAtIndexPath})
            m->registerHook(base+0x18f090, extract(i, (d6){&D::didSelectRowAtIndexPath}));

        if ((c7){&$BoomListView::numberOfRowsInSection} != (d7){&D::numberOfRowsInSection})
            m->registerHook(base+0x18f0b0, extract(i, (d7){&D::numberOfRowsInSection}));

        if ((c8){&$BoomListView::numberOfSectionsInTableView} != (d8){&D::numberOfSectionsInTableView})
            m->registerHook(base+0x18f0e0, extract(i, (d8){&D::numberOfSectionsInTableView}));

        if ((c9){&$BoomListView::cellForRowAtIndexPath} != (d9){&D::cellForRowAtIndexPath})
            m->registerHook(base+0x18f100, extract(i, (d9){&D::cellForRowAtIndexPath}));

        if ((c10){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            m->registerHook(base+0x18f770, extract(i, (d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath}));

        if ((c11){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (d11){&D::TableViewWillReloadCellForRowAtIndexPath})
            m->registerHook(base+0x18f050, extract(i, (d11){&D::TableViewWillReloadCellForRowAtIndexPath}));

        if ((c12){&$BoomListView::getListCell} != (d12){&D::getListCell})
            m->registerHook(base+0x18f200, extract(i, (d12){&D::getListCell}));

        if ((c13){&$BoomListView::loadCell} != (d13){&D::loadCell})
            m->registerHook(base+0x18f4a0, extract(i, (d13){&D::loadCell}));
    }
};

template<class D>
class $CustomListView : public NullCustomListView, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$CustomListView() {}

    using c0 = CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using d0 = CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using f0 = CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    inline static CustomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        return reinterpret_cast<f0>(base+0x10d410)(p0, p1, p2, p3, p4);
    }

    using c1 = void($CustomListView::*)(char const*);
    using d1 = void(D::*)(char const*);
    using f1 = void(*)($CustomListView*, char const*);
    inline void getListCell(char const* p0) {
        return reinterpret_cast<f1>(base+0x10d560)(this, p0);
    }

    using c2 = void($CustomListView::*)(TableViewCell*, int);
    using d2 = void(D::*)(TableViewCell*, int);
    using f2 = void(*)($CustomListView*, TableViewCell*, int);
    inline void loadCell(TableViewCell* p0, int p1) {
        return reinterpret_cast<f2>(base+0x10e610)(this, p0, p1);
    }

    using c3 = void($CustomListView::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($CustomListView*);
    inline void setupList() {
        return reinterpret_cast<f3>(base+0x116e70)(this);
    }

    inline $CustomListView(bool) {}
    inline $CustomListView() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;

        if ((c0){&$CustomListView::create} != (d0){&D::create})
            m->registerHook(base+0x10d410, extract((d0){&D::create}));

        if ((c1){&$CustomListView::getListCell} != (d1){&D::getListCell})
            m->registerHook(base+0x10d560, extract(i, (d1){&D::getListCell}));

        if ((c2){&$CustomListView::loadCell} != (d2){&D::loadCell})
            m->registerHook(base+0x10e610, extract(i, (d2){&D::loadCell}));

        if ((c3){&$CustomListView::setupList} != (d3){&D::setupList})
            m->registerHook(base+0x116e70, extract(i, (d3){&D::setupList}));
    }
};

template<class D>
class $TableViewCell : public NullTableViewCell, public $CacBase {
public:
    static inline bool lock = false;
    inline ~$TableViewCell() {}

    inline $TableViewCell(bool) {}
    inline $TableViewCell() {
        if (lock) return;
        lock = true;
        // i wanted to delete i but sadly the destructor isn't hooked yet soooo
        auto i = new D();
        lock = false;
    }
};

#undef rcast
