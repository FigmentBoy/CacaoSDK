// 
// Copyright camila314 & alk1m123 2021. 
// Autogenerated using a python script
//
#pragma once
#include <Base/InterfaceBase.hpp>
#define rcast reinterpret_cast

template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
public:
    inline ~$AppDelegate() {}

    using c0 = void($AppDelegate::*)();
    using d0 = void(D::*)();
    using f0 = void(*)($AppDelegate*);
    inline void bgScale() {
        if ((c0){&$AppDelegate::bgScale} != (d0){&D::bgScale})
            return rcast<f0>(m->getOriginal(rcast<func_t&>((d0){&D::bgScale})))(this);
        return AppDelegate::bgScale();
    }

    using c1 = bool($AppDelegate::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($AppDelegate*);
    inline bool applicationDidFinishLaunching() {
        if ((c1){&$AppDelegate::applicationDidFinishLaunching} != (d1){&D::applicationDidFinishLaunching})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::applicationDidFinishLaunching})))(this);
        return AppDelegate::applicationDidFinishLaunching();
    }

    using c2 = void($AppDelegate::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($AppDelegate*);
    inline void applicationDidEnterBackground() {
        if ((c2){&$AppDelegate::applicationDidEnterBackground} != (d2){&D::applicationDidEnterBackground})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::applicationDidEnterBackground})))(this);
        return AppDelegate::applicationDidEnterBackground();
    }

    using c3 = void($AppDelegate::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($AppDelegate*);
    inline void applicationWillEnterForeground() {
        if ((c3){&$AppDelegate::applicationWillEnterForeground} != (d3){&D::applicationWillEnterForeground})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::applicationWillEnterForeground})))(this);
        return AppDelegate::applicationWillEnterForeground();
    }

    using c4 = bool($AppDelegate::*)();
    using d4 = bool(D::*)();
    using f4 = bool(*)($AppDelegate*);
    inline bool applicationWillBecomeActive() {
        if ((c4){&$AppDelegate::applicationWillBecomeActive} != (d4){&D::applicationWillBecomeActive})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::applicationWillBecomeActive})))(this);
        return AppDelegate::applicationWillBecomeActive();
    }

    using c5 = bool($AppDelegate::*)();
    using d5 = bool(D::*)();
    using f5 = bool(*)($AppDelegate*);
    inline bool applicationWillResignActive() {
        if ((c5){&$AppDelegate::applicationWillResignActive} != (d5){&D::applicationWillResignActive})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::applicationWillResignActive})))(this);
        return AppDelegate::applicationWillResignActive();
    }

    using c6 = void($AppDelegate::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($AppDelegate*);
    inline void trySaveGame() {
        if ((c6){&$AppDelegate::trySaveGame} != (d6){&D::trySaveGame})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::trySaveGame})))(this);
        return AppDelegate::trySaveGame();
    }

    using c7 = void($AppDelegate::*)(cocos2d::CCScene*);
    using d7 = void(D::*)(cocos2d::CCScene*);
    using f7 = void(*)($AppDelegate*, cocos2d::CCScene*);
    inline void willSwitchToScene(cocos2d::CCScene* p0) {
        if ((c7){&$AppDelegate::willSwitchToScene} != (d7){&D::willSwitchToScene})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::willSwitchToScene})))(this, p0);
        return AppDelegate::willSwitchToScene(p0);
    }

    using c8 = AppDelegate*(*)();
    inline static AppDelegate* get() {
        if ((c8){&$AppDelegate::get} != (c8){&D::get})
            return rcast<c8>(m->getOriginal(rcast<func_t&>((c8){&D::get})))();
        return AppDelegate::get();
    }

    inline $AppDelegate(bool) {}
    inline $AppDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$AppDelegate::bgScale} != (d0){&D::bgScale})
            m->registerHook(base+0x3aaab0, extract((d0){&D::bgScale}));

        if ((c1){&$AppDelegate::applicationDidFinishLaunching} != (d1){&D::applicationDidFinishLaunching})
            m->registerHook(base+0x3aa900, extract_virtual(V, (d1){&D::applicationDidFinishLaunching}));

        if ((c2){&$AppDelegate::applicationDidEnterBackground} != (d2){&D::applicationDidEnterBackground})
            m->registerHook(base+0x3aabe0, extract_virtual(V, (d2){&D::applicationDidEnterBackground}));

        if ((c3){&$AppDelegate::applicationWillEnterForeground} != (d3){&D::applicationWillEnterForeground})
            m->registerHook(base+0x3aac80, extract_virtual(V, (d3){&D::applicationWillEnterForeground}));

        if ((c4){&$AppDelegate::applicationWillBecomeActive} != (d4){&D::applicationWillBecomeActive})
            m->registerHook(base+0x3aab30, extract_virtual(V, (d4){&D::applicationWillBecomeActive}));

        if ((c5){&$AppDelegate::applicationWillResignActive} != (d5){&D::applicationWillResignActive})
            m->registerHook(base+0x3aab50, extract_virtual(V, (d5){&D::applicationWillResignActive}));

        if ((c6){&$AppDelegate::trySaveGame} != (d6){&D::trySaveGame})
            m->registerHook(base+0x3aaf10, extract_virtual(V, (d6){&D::trySaveGame}));

        if ((c7){&$AppDelegate::willSwitchToScene} != (d7){&D::willSwitchToScene})
            m->registerHook(base+0x3aaf40, extract_virtual(V, (d7){&D::willSwitchToScene}));

        if ((c8){&$AppDelegate::get} != (c8){&D::get})
            m->registerHook(base+0x3aab10, (c8){&D::get});
    }
};

template<class D>
class $CCCircleWaveDelegate : public CCCircleWaveDelegate, public $CacBase {
public:
    inline ~$CCCircleWaveDelegate() {}

    inline $CCCircleWaveDelegate(bool) {}
    inline $CCCircleWaveDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TableViewDelegate : public TableViewDelegate, public $CacBase {
public:
    inline ~$TableViewDelegate() {}

    inline $TableViewDelegate(bool) {}
    inline $TableViewDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TableViewDataSource : public TableViewDataSource, public $CacBase {
public:
    inline ~$TableViewDataSource() {}

    inline $TableViewDataSource(bool) {}
    inline $TableViewDataSource() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $CCScrollLayerExtDelegate : public CCScrollLayerExtDelegate, public $CacBase {
public:
    inline ~$CCScrollLayerExtDelegate() {}

    inline $CCScrollLayerExtDelegate(bool) {}
    inline $CCScrollLayerExtDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $GJSpecialColorSelectDelegate : public GJSpecialColorSelectDelegate, public $CacBase {
public:
    inline ~$GJSpecialColorSelectDelegate() {}

    inline $GJSpecialColorSelectDelegate(bool) {}
    inline $GJSpecialColorSelectDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
public:
    inline ~$TextInputDelegate() {}

    inline $TextInputDelegate(bool) {}
    inline $TextInputDelegate() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $FLAlertLayerProtocol : public FLAlertLayerProtocol, public $CacBase {
public:
    inline ~$FLAlertLayerProtocol() {}

    inline $FLAlertLayerProtocol(bool) {}
    inline $FLAlertLayerProtocol() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
public:
    inline ~$CCSpritePlus() {}

    using c0 = bool($CCSpritePlus::*)(char const*);
    using d0 = bool(D::*)(char const*);
    using f0 = bool(*)($CCSpritePlus*, char const*);
    inline bool initWithSpriteFrameName(char const* p0) {
        if ((c0){&$CCSpritePlus::initWithSpriteFrameName} != (d0){&D::initWithSpriteFrameName})
            return rcast<f0>(m->getOriginal(rcast<func_t&>((d0){&D::initWithSpriteFrameName})))(this, p0);
        return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    inline $CCSpritePlus(bool) {}
    inline $CCSpritePlus() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCSpritePlus::initWithSpriteFrameName} != (d0){&D::initWithSpriteFrameName})
            m->registerHook(base+0x248670, extract((d0){&D::initWithSpriteFrameName}));
    }
};

template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
public:
    inline ~$CCMoveCNode() {}

    using c0 = CCMoveCNode*(*)();
    inline static CCMoveCNode* create() {
        if ((c0){&$CCMoveCNode::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))();
        return CCMoveCNode::create();
    }

    using c1 = bool($CCMoveCNode::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($CCMoveCNode*);
    inline bool init() {
        if ((c1){&$CCMoveCNode::init} != (d1){&D::init})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::init})))(this);
        return CCMoveCNode::init();
    }

    inline $CCMoveCNode(bool) {}
    inline $CCMoveCNode() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCMoveCNode::create} != (c0){&D::create})
            m->registerHook(base+0x1842a0, (c0){&D::create});

        if ((c1){&$CCMoveCNode::init} != (d1){&D::init})
            m->registerHook(base+0x18b3d0, extract((d1){&D::init}));
    }
};

template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
public:
    inline ~$CCNodeContainer() {}

    using c0 = CCNodeContainer*(*)();
    inline static CCNodeContainer* create() {
        if ((c0){&$CCNodeContainer::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))();
        return CCNodeContainer::create();
    }

    using c1 = bool($CCNodeContainer::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($CCNodeContainer*);
    inline bool init() {
        if ((c1){&$CCNodeContainer::init} != (d1){&D::init})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::init})))(this);
        return CCNodeContainer::init();
    }

    using c2 = void($CCNodeContainer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCNodeContainer*);
    inline void visit() {
        if ((c2){&$CCNodeContainer::visit} != (d2){&D::visit})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::visit})))(this);
        return CCNodeContainer::visit();
    }

    inline $CCNodeContainer(bool) {}
    inline $CCNodeContainer() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCNodeContainer::create} != (c0){&D::create})
            m->registerHook(base+0xb1090, (c0){&D::create});

        if ((c1){&$CCNodeContainer::init} != (d1){&D::init})
            m->registerHook(base+0xba950, extract((d1){&D::init}));

        if ((c2){&$CCNodeContainer::visit} != (d2){&D::visit})
            m->registerHook(base+0xba960, extract((d2){&D::visit}));
    }
};

template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
public:
    inline ~$CCAnimatedSprite() {}

    using c0 = void($CCAnimatedSprite::*)(gd::string);
    using d0 = void(D::*)(gd::string);
    using f0 = void(*)($CCAnimatedSprite*, gd::string);
    inline void runAnimation(gd::string p0) {
        if ((c0){&$CCAnimatedSprite::runAnimation} != (d0){&D::runAnimation})
            return rcast<f0>(m->getOriginal(rcast<func_t&>((d0){&D::runAnimation})))(this, p0);
        return CCAnimatedSprite::runAnimation(p0);
    }

    using c1 = void($CCAnimatedSprite::*)(gd::string, float);
    using d1 = void(D::*)(gd::string, float);
    using f1 = void(*)($CCAnimatedSprite*, gd::string, float);
    inline void tweenToAnimation(gd::string p0, float p1) {
        if ((c1){&$CCAnimatedSprite::tweenToAnimation} != (d1){&D::tweenToAnimation})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::tweenToAnimation})))(this, p0, p1);
        return CCAnimatedSprite::tweenToAnimation(p0, p1);
    }

    inline $CCAnimatedSprite(bool) {}
    inline $CCAnimatedSprite() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCAnimatedSprite::runAnimation} != (d0){&D::runAnimation})
            m->registerHook(base+0x1a6430, extract((d0){&D::runAnimation}));

        if ((c1){&$CCAnimatedSprite::tweenToAnimation} != (d1){&D::tweenToAnimation})
            m->registerHook(base+0x1a65b0, extract((d1){&D::tweenToAnimation}));
    }
};

template<class D>
class $CCBlockLayer : public CCBlockLayer, public $CacBase {
public:
    inline ~$CCBlockLayer() {}

    using c0 = void($CCBlockLayer::*)();
    using d0 = void(D::*)();
    using f0 = void(*)($CCBlockLayer*);
    inline void disableUI() {
        if ((c0){&$CCBlockLayer::disableUI} != (d0){&D::disableUI})
            return rcast<f0>(m->getOriginal(rcast<func_t&>((d0){&D::disableUI})))(this);
        return CCBlockLayer::disableUI();
    }

    using c1 = void($CCBlockLayer::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($CCBlockLayer*);
    inline void draw() {
        if ((c1){&$CCBlockLayer::draw} != (d1){&D::draw})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::draw})))(this);
        return CCBlockLayer::draw();
    }

    using c2 = void($CCBlockLayer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCBlockLayer*);
    inline void enableUI() {
        if ((c2){&$CCBlockLayer::enableUI} != (d2){&D::enableUI})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::enableUI})))(this);
        return CCBlockLayer::enableUI();
    }

    using c3 = void($CCBlockLayer::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($CCBlockLayer*);
    inline void enterAnimFinished() {
        if ((c3){&$CCBlockLayer::enterAnimFinished} != (d3){&D::enterAnimFinished})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::enterAnimFinished})))(this);
        return CCBlockLayer::enterAnimFinished();
    }

    using c4 = void($CCBlockLayer::*)();
    using d4 = void(D::*)();
    using f4 = void(*)($CCBlockLayer*);
    inline void enterLayer() {
        if ((c4){&$CCBlockLayer::enterLayer} != (d4){&D::enterLayer})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::enterLayer})))(this);
        return CCBlockLayer::enterLayer();
    }

    using c5 = void($CCBlockLayer::*)();
    using d5 = void(D::*)();
    using f5 = void(*)($CCBlockLayer*);
    inline void exitLayer() {
        if ((c5){&$CCBlockLayer::exitLayer} != (d5){&D::exitLayer})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::exitLayer})))(this);
        return CCBlockLayer::exitLayer();
    }

    using c6 = void($CCBlockLayer::*)(bool);
    using d6 = void(D::*)(bool);
    using f6 = void(*)($CCBlockLayer*, bool);
    inline void hideLayer(bool p0) {
        if ((c6){&$CCBlockLayer::hideLayer} != (d6){&D::hideLayer})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::hideLayer})))(this, p0);
        return CCBlockLayer::hideLayer(p0);
    }

    using c7 = bool($CCBlockLayer::*)();
    using d7 = bool(D::*)();
    using f7 = bool(*)($CCBlockLayer*);
    inline bool init() {
        if ((c7){&$CCBlockLayer::init} != (d7){&D::init})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::init})))(this);
        return CCBlockLayer::init();
    }

    using c8 = void($CCBlockLayer::*)();
    using d8 = void(D::*)();
    using f8 = void(*)($CCBlockLayer*);
    inline void layerHidden() {
        if ((c8){&$CCBlockLayer::layerHidden} != (d8){&D::layerHidden})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::layerHidden})))(this);
        return CCBlockLayer::layerHidden();
    }

    using c9 = void($CCBlockLayer::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($CCBlockLayer*);
    inline void layerVisible() {
        if ((c9){&$CCBlockLayer::layerVisible} != (d9){&D::layerVisible})
            return rcast<f9>(m->getOriginal(rcast<func_t&>((d9){&D::layerVisible})))(this);
        return CCBlockLayer::layerVisible();
    }

    using c10 = void($CCBlockLayer::*)();
    using d10 = void(D::*)();
    using f10 = void(*)($CCBlockLayer*);
    inline void registerWithTouchDispatcher() {
        if ((c10){&$CCBlockLayer::registerWithTouchDispatcher} != (d10){&D::registerWithTouchDispatcher})
            return rcast<f10>(m->getOriginal(rcast<func_t&>((d10){&D::registerWithTouchDispatcher})))(this);
        return CCBlockLayer::registerWithTouchDispatcher();
    }

    using c11 = void($CCBlockLayer::*)(bool);
    using d11 = void(D::*)(bool);
    using f11 = void(*)($CCBlockLayer*, bool);
    inline void showLayer(bool p0) {
        if ((c11){&$CCBlockLayer::showLayer} != (d11){&D::showLayer})
            return rcast<f11>(m->getOriginal(rcast<func_t&>((d11){&D::showLayer})))(this, p0);
        return CCBlockLayer::showLayer(p0);
    }

    inline $CCBlockLayer(bool) {}
    inline $CCBlockLayer() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCBlockLayer::disableUI} != (d0){&D::disableUI})
            m->registerHook(base+0x2a5a80, extract((d0){&D::disableUI}));

        if ((c1){&$CCBlockLayer::draw} != (d1){&D::draw})
            m->registerHook(base+0x2a5c20, extract((d1){&D::draw}));

        if ((c2){&$CCBlockLayer::enableUI} != (d2){&D::enableUI})
            m->registerHook(base+0x2a5a90, extract((d2){&D::enableUI}));

        if ((c3){&$CCBlockLayer::enterAnimFinished} != (d3){&D::enterAnimFinished})
            m->registerHook(base+0x2a5bb0, extract((d3){&D::enterAnimFinished}));

        if ((c4){&$CCBlockLayer::enterLayer} != (d4){&D::enterLayer})
            m->registerHook(base+0x2a5aa0, extract((d4){&D::enterLayer}));

        if ((c5){&$CCBlockLayer::exitLayer} != (d5){&D::exitLayer})
            m->registerHook(base+0x2a5b40, extract((d5){&D::exitLayer}));

        if ((c6){&$CCBlockLayer::hideLayer} != (d6){&D::hideLayer})
            m->registerHook(base+0x2a5ba0, extract((d6){&D::hideLayer}));

        if ((c7){&$CCBlockLayer::init} != (d7){&D::init})
            m->registerHook(base+0x2a59c0, extract((d7){&D::init}));

        if ((c8){&$CCBlockLayer::layerHidden} != (d8){&D::layerHidden})
            m->registerHook(base+0x2a5be0, extract((d8){&D::layerHidden}));

        if ((c9){&$CCBlockLayer::layerVisible} != (d9){&D::layerVisible})
            m->registerHook(base+0x2a5bc0, extract((d9){&D::layerVisible}));

        if ((c10){&$CCBlockLayer::registerWithTouchDispatcher} != (d10){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2a5ad0, extract((d10){&D::registerWithTouchDispatcher}));

        if ((c11){&$CCBlockLayer::showLayer} != (d11){&D::showLayer})
            m->registerHook(base+0x2a5b90, extract((d11){&D::showLayer}));
    }
};

template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
public:
    inline ~$CCCircleWave() {}

    using c0 = CCCircleWave*(*)(float, float, float, bool);
    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        if ((c0){&$CCCircleWave::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3);
        return CCCircleWave::create(p0, p1, p2, p3);
    }

    using c1 = CCCircleWave*(*)(float, float, float, bool, bool);
    inline static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        if ((c1){&$CCCircleWave::create} != (c1){&D::create})
            return rcast<c1>(m->getOriginal(rcast<func_t&>((c1){&D::create})))(p0, p1, p2, p3, p4);
        return CCCircleWave::create(p0, p1, p2, p3, p4);
    }

    using c2 = bool($CCCircleWave::*)(float, float, float, bool, bool);
    using d2 = bool(D::*)(float, float, float, bool, bool);
    using f2 = bool(*)($CCCircleWave*, float, float, float, bool, bool);
    inline bool init(float p0, float p1, float p2, bool p3, bool p4) {
        if ((c2){&$CCCircleWave::init} != (d2){&D::init})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::init})))(this, p0, p1, p2, p3, p4);
        return CCCircleWave::init(p0, p1, p2, p3, p4);
    }

    using c3 = void($CCCircleWave::*)(cocos2d::CCNode*, bool);
    using d3 = void(D::*)(cocos2d::CCNode*, bool);
    using f3 = void(*)($CCCircleWave*, cocos2d::CCNode*, bool);
    inline void followObject(cocos2d::CCNode* p0, bool p1) {
        if ((c3){&$CCCircleWave::followObject} != (d3){&D::followObject})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::followObject})))(this, p0, p1);
        return CCCircleWave::followObject(p0, p1);
    }

    using c4 = void($CCCircleWave::*)(float);
    using d4 = void(D::*)(float);
    using f4 = void(*)($CCCircleWave*, float);
    inline void updatePosition(float p0) {
        if ((c4){&$CCCircleWave::updatePosition} != (d4){&D::updatePosition})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::updatePosition})))(this, p0);
        return CCCircleWave::updatePosition(p0);
    }

    inline $CCCircleWave(bool) {}
    inline $CCCircleWave() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCCircleWave::create} != (c0){&D::create})
            m->registerHook(base+0xbd270, (c0){&D::create});

        if ((c1){&$CCCircleWave::create} != (c1){&D::create})
            m->registerHook(base+0xbd290, (c1){&D::create});

        if ((c2){&$CCCircleWave::init} != (d2){&D::init})
            m->registerHook(base+0xbd380, extract((d2){&D::init}));

        if ((c3){&$CCCircleWave::followObject} != (d3){&D::followObject})
            m->registerHook(base+0xbd670, extract((d3){&D::followObject}));

        if ((c4){&$CCCircleWave::updatePosition} != (d4){&D::updatePosition})
            m->registerHook(base+0xbd630, extract((d4){&D::updatePosition}));
    }
};

template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
public:
    inline ~$CCLightFlash() {}

    using c0 = CCLightFlash*(*)();
    inline static CCLightFlash* create() {
        if ((c0){&$CCLightFlash::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))();
        return CCLightFlash::create();
    }

    using c1 = void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    using d1 = void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    using f1 = void(*)($CCLightFlash*, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
    inline void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        if ((c1){&$CCLightFlash::playEffect} != (d1){&D::playEffect})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::playEffect})))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
        return CCLightFlash::playEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    inline $CCLightFlash(bool) {}
    inline $CCLightFlash() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCLightFlash::create} != (c0){&D::create})
            m->registerHook(base+0x295870, (c0){&D::create});

        if ((c1){&$CCLightFlash::playEffect} != (d1){&D::playEffect})
            m->registerHook(base+0x295900, extract((d1){&D::playEffect}));
    }
};

template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
public:
    inline ~$CCMenuItemSpriteExtra() {}

    using c0 = CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((c0){&$CCMenuItemSpriteExtra::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3);
        return CCMenuItemSpriteExtra::create(p0, p1, p2, p3);
    }

    using c1 = void($CCMenuItemSpriteExtra::*)(float);
    using d1 = void(D::*)(float);
    using f1 = void(*)($CCMenuItemSpriteExtra*, float);
    inline void setSizeMult(float p0) {
        if ((c1){&$CCMenuItemSpriteExtra::setSizeMult} != (d1){&D::setSizeMult})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::setSizeMult})))(this, p0);
        return CCMenuItemSpriteExtra::setSizeMult(p0);
    }

    using c3 = bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using d3 = bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    using f3 = bool(*)($CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline bool init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((c3){&$CCMenuItemSpriteExtra::init} != (d3){&D::init})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::init})))(this, p0, p1, p2, p3);
        return CCMenuItemSpriteExtra::init(p0, p1, p2, p3);
    }

    inline $CCMenuItemSpriteExtra(bool) {}
    inline $CCMenuItemSpriteExtra() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCMenuItemSpriteExtra::create} != (c0){&D::create})
            m->registerHook(base+0x1253c0, (c0){&D::create});

        if ((c1){&$CCMenuItemSpriteExtra::setSizeMult} != (d1){&D::setSizeMult})
            m->registerHook(base+0x1255e0, extract((d1){&D::setSizeMult}));

        if ((c3){&$CCMenuItemSpriteExtra::init} != (d3){&D::init})
            m->registerHook(base+0x125450, extract((d3){&D::init}));
    }
};

template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
public:
    inline ~$CCMenuItemToggler() {}

    using c0 = CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
    inline static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((c0){&$CCMenuItemToggler::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3);
        return CCMenuItemToggler::create(p0, p1, p2, p3);
    }

    using c1 = void($CCMenuItemToggler::*)(float);
    using d1 = void(D::*)(float);
    using f1 = void(*)($CCMenuItemToggler*, float);
    inline void setSizeMult(float p0) {
        if ((c1){&$CCMenuItemToggler::setSizeMult} != (d1){&D::setSizeMult})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::setSizeMult})))(this, p0);
        return CCMenuItemToggler::setSizeMult(p0);
    }

    inline $CCMenuItemToggler(bool) {}
    inline $CCMenuItemToggler() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCMenuItemToggler::create} != (c0){&D::create})
            m->registerHook(base+0x38400, (c0){&D::create});

        if ((c1){&$CCMenuItemToggler::setSizeMult} != (d1){&D::setSizeMult})
            m->registerHook(base+0x38a40, extract((d1){&D::setSizeMult}));
    }
};

template<class D>
class $CCScrollLayerExt : public CCScrollLayerExt, public $CacBase {
public:
    inline ~$CCScrollLayerExt() {}

    using c1 = void($CCScrollLayerExt::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($CCScrollLayerExt*);
    inline void visit() {
        if ((c1){&$CCScrollLayerExt::visit} != (d1){&D::visit})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::visit})))(this);
        return CCScrollLayerExt::visit();
    }

    using c2 = bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d2 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f2 = bool(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c2){&$CCScrollLayerExt::ccTouchBegan} != (d2){&D::ccTouchBegan})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::ccTouchBegan})))(this, p0, p1);
        return CCScrollLayerExt::ccTouchBegan(p0, p1);
    }

    using c3 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d3 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f3 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c3){&$CCScrollLayerExt::ccTouchMoved} != (d3){&D::ccTouchMoved})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::ccTouchMoved})))(this, p0, p1);
        return CCScrollLayerExt::ccTouchMoved(p0, p1);
    }

    using c4 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d4 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f4 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c4){&$CCScrollLayerExt::ccTouchEnded} != (d4){&D::ccTouchEnded})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::ccTouchEnded})))(this, p0, p1);
        return CCScrollLayerExt::ccTouchEnded(p0, p1);
    }

    using c5 = void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d5 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f5 = void(*)($CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c5){&$CCScrollLayerExt::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::ccTouchCancelled})))(this, p0, p1);
        return CCScrollLayerExt::ccTouchCancelled(p0, p1);
    }

    using c6 = void($CCScrollLayerExt::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($CCScrollLayerExt*);
    inline void registerWithTouchDispatcher() {
        if ((c6){&$CCScrollLayerExt::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::registerWithTouchDispatcher})))(this);
        return CCScrollLayerExt::registerWithTouchDispatcher();
    }

    using c7 = void($CCScrollLayerExt::*)(cocos2d::CCRect);
    using d7 = void(D::*)(cocos2d::CCRect);
    using f7 = void(*)($CCScrollLayerExt*, cocos2d::CCRect);
    inline void preVisitWithClippingRect(cocos2d::CCRect p0) {
        if ((c7){&$CCScrollLayerExt::preVisitWithClippingRect} != (d7){&D::preVisitWithClippingRect})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::preVisitWithClippingRect})))(this, p0);
        return CCScrollLayerExt::preVisitWithClippingRect(p0);
    }

    using c8 = void($CCScrollLayerExt::*)();
    using d8 = void(D::*)();
    using f8 = void(*)($CCScrollLayerExt*);
    inline void postVisit() {
        if ((c8){&$CCScrollLayerExt::postVisit} != (d8){&D::postVisit})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::postVisit})))(this);
        return CCScrollLayerExt::postVisit();
    }

    using c9 = void($CCScrollLayerExt::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($CCScrollLayerExt*);
    inline void moveToTop() {
        if ((c9){&$CCScrollLayerExt::moveToTop} != (d9){&D::moveToTop})
            return rcast<f9>(m->getOriginal(rcast<func_t&>((d9){&D::moveToTop})))(this);
        return CCScrollLayerExt::moveToTop();
    }

    using c10 = void($CCScrollLayerExt::*)(float);
    using d10 = void(D::*)(float);
    using f10 = void(*)($CCScrollLayerExt*, float);
    inline void moveToTopWithOffset(float p0) {
        if ((c10){&$CCScrollLayerExt::moveToTopWithOffset} != (d10){&D::moveToTopWithOffset})
            return rcast<f10>(m->getOriginal(rcast<func_t&>((d10){&D::moveToTopWithOffset})))(this, p0);
        return CCScrollLayerExt::moveToTopWithOffset(p0);
    }

    inline $CCScrollLayerExt(bool) {}
    inline $CCScrollLayerExt() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c1){&$CCScrollLayerExt::visit} != (d1){&D::visit})
            m->registerHook(base+0x236550, extract_virtual(V, (d1){&D::visit}));

        if ((c2){&$CCScrollLayerExt::ccTouchBegan} != (d2){&D::ccTouchBegan})
            m->registerHook(base+0x235ef0, extract_virtual(V, (d2){&D::ccTouchBegan}));

        if ((c3){&$CCScrollLayerExt::ccTouchMoved} != (d3){&D::ccTouchMoved})
            m->registerHook(base+0x236300, extract_virtual(V, (d3){&D::ccTouchMoved}));

        if ((c4){&$CCScrollLayerExt::ccTouchEnded} != (d4){&D::ccTouchEnded})
            m->registerHook(base+0x236020, extract_virtual(V, (d4){&D::ccTouchEnded}));

        if ((c5){&$CCScrollLayerExt::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            m->registerHook(base+0x2362a0, extract_virtual(V, (d5){&D::ccTouchCancelled}));

        if ((c6){&$CCScrollLayerExt::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x235eb0, extract_virtual(V, (d6){&D::registerWithTouchDispatcher}));

        if ((c7){&$CCScrollLayerExt::preVisitWithClippingRect} != (d7){&D::preVisitWithClippingRect})
            m->registerHook(base+0x2366a0, extract_virtual(V, (d7){&D::preVisitWithClippingRect}));

        if ((c8){&$CCScrollLayerExt::postVisit} != (d8){&D::postVisit})
            m->registerHook(base+0x236720, extract_virtual(V, (d8){&D::postVisit}));

        if ((c9){&$CCScrollLayerExt::moveToTop} != (d9){&D::moveToTop})
            m->registerHook(base+0x235870, extract((d9){&D::moveToTop}));

        if ((c10){&$CCScrollLayerExt::moveToTopWithOffset} != (d10){&D::moveToTopWithOffset})
            m->registerHook(base+0x2357d0, extract((d10){&D::moveToTopWithOffset}));
    }
};

template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
public:
    inline ~$FLAlertLayer() {}

    using c1 = void($FLAlertLayer::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($FLAlertLayer*);
    inline void onEnter() {
        if ((c1){&$FLAlertLayer::onEnter} != (d1){&D::onEnter})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::onEnter})))(this);
        return FLAlertLayer::onEnter();
    }

    using c2 = bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d2 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f2 = bool(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c2){&$FLAlertLayer::ccTouchBegan} != (d2){&D::ccTouchBegan})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::ccTouchBegan})))(this, p0, p1);
        return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    using c3 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d3 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f3 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c3){&$FLAlertLayer::ccTouchMoved} != (d3){&D::ccTouchMoved})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::ccTouchMoved})))(this, p0, p1);
        return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    using c4 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d4 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f4 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c4){&$FLAlertLayer::ccTouchEnded} != (d4){&D::ccTouchEnded})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::ccTouchEnded})))(this, p0, p1);
        return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    using c5 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d5 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f5 = void(*)($FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c5){&$FLAlertLayer::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::ccTouchCancelled})))(this, p0, p1);
        return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    using c6 = void($FLAlertLayer::*)();
    using d6 = void(D::*)();
    using f6 = void(*)($FLAlertLayer*);
    inline void registerWithTouchDispatcher() {
        if ((c6){&$FLAlertLayer::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::registerWithTouchDispatcher})))(this);
        return FLAlertLayer::registerWithTouchDispatcher();
    }

    using c7 = void($FLAlertLayer::*)();
    using d7 = void(D::*)();
    using f7 = void(*)($FLAlertLayer*);
    inline void keyBackClicked() {
        if ((c7){&$FLAlertLayer::keyBackClicked} != (d7){&D::keyBackClicked})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::keyBackClicked})))(this);
        return FLAlertLayer::keyBackClicked();
    }

    using c8 = void($FLAlertLayer::*)(cocos2d::enumKeyCodes);
    using d8 = void(D::*)(cocos2d::enumKeyCodes);
    using f8 = void(*)($FLAlertLayer*, cocos2d::enumKeyCodes);
    inline void keyDown(cocos2d::enumKeyCodes p0) {
        if ((c8){&$FLAlertLayer::keyDown} != (d8){&D::keyDown})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::keyDown})))(this, p0);
        return FLAlertLayer::keyDown(p0);
    }

    using c9 = void($FLAlertLayer::*)();
    using d9 = void(D::*)();
    using f9 = void(*)($FLAlertLayer*);
    inline void show() {
        if ((c9){&$FLAlertLayer::show} != (d9){&D::show})
            return rcast<f9>(m->getOriginal(rcast<func_t&>((d9){&D::show})))(this);
        return FLAlertLayer::show();
    }

    using c10 = bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using d10 = bool(D::*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    using f10 = bool(*)($FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    inline bool init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((c10){&$FLAlertLayer::init} != (d10){&D::init})
            return rcast<f10>(m->getOriginal(rcast<func_t&>((d10){&D::init})))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        return FLAlertLayer::init(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    using c11 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5) {
        if ((c11){&$FLAlertLayer::create} != (c11){&D::create})
            return rcast<c11>(m->getOriginal(rcast<func_t&>((c11){&D::create})))(p0, p1, p2, p3, p4, p5);
        return FLAlertLayer::create(p0, p1, p2, p3, p4, p5);
    }

    using c12 = FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float);
    inline static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((c12){&$FLAlertLayer::create} != (c12){&D::create})
            return rcast<c12>(m->getOriginal(rcast<func_t&>((c12){&D::create})))(p0, p1, p2, p3, p4, p5, p6, p7);
        return FLAlertLayer::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $FLAlertLayer(bool) {}
    inline $FLAlertLayer() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c1){&$FLAlertLayer::onEnter} != (d1){&D::onEnter})
            m->registerHook(base+0x25f350, extract_virtual(V, (d1){&D::onEnter}));

        if ((c2){&$FLAlertLayer::ccTouchBegan} != (d2){&D::ccTouchBegan})
            m->registerHook(base+0x25ee40, extract_virtual(V, (d2){&D::ccTouchBegan}));

        if ((c3){&$FLAlertLayer::ccTouchMoved} != (d3){&D::ccTouchMoved})
            m->registerHook(base+0x25f0a0, extract_virtual(V, (d3){&D::ccTouchMoved}));

        if ((c4){&$FLAlertLayer::ccTouchEnded} != (d4){&D::ccTouchEnded})
            m->registerHook(base+0x25ef60, extract_virtual(V, (d4){&D::ccTouchEnded}));

        if ((c5){&$FLAlertLayer::ccTouchCancelled} != (d5){&D::ccTouchCancelled})
            m->registerHook(base+0x25f020, extract_virtual(V, (d5){&D::ccTouchCancelled}));

        if ((c6){&$FLAlertLayer::registerWithTouchDispatcher} != (d6){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25f2e0, extract_virtual(V, (d6){&D::registerWithTouchDispatcher}));

        if ((c7){&$FLAlertLayer::keyBackClicked} != (d7){&D::keyBackClicked})
            m->registerHook(base+0x25ed90, extract_virtual(V, (d7){&D::keyBackClicked}));

        if ((c8){&$FLAlertLayer::keyDown} != (d8){&D::keyDown})
            m->registerHook(base+0x25ece0, extract_virtual(V, (d8){&D::keyDown}));

        if ((c9){&$FLAlertLayer::show} != (d9){&D::show})
            m->registerHook(base+0x25f120, extract_virtual(V, (d9){&D::show}));

        if ((c10){&$FLAlertLayer::init} != (d10){&D::init})
            m->registerHook(base+0x25e1b0, extract((d10){&D::init}));

        if ((c11){&$FLAlertLayer::create} != (c11){&D::create})
            m->registerHook(base+0x25e0e0, (c11){&D::create});

        if ((c12){&$FLAlertLayer::create} != (c12){&D::create})
            m->registerHook(base+0x25dec0, (c12){&D::create});
    }
};

template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
public:
    inline ~$MenuLayer() {}

    using c1 = bool($MenuLayer::*)();
    using d1 = bool(D::*)();
    using f1 = bool(*)($MenuLayer*);
    inline bool init() {
        if ((c1){&$MenuLayer::init} != (d1){&D::init})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::init})))(this);
        return MenuLayer::init();
    }

    using c2 = void($MenuLayer::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($MenuLayer*);
    inline void keyBackClicked() {
        if ((c2){&$MenuLayer::keyBackClicked} != (d2){&D::keyBackClicked})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::keyBackClicked})))(this);
        return MenuLayer::keyBackClicked();
    }

    using c3 = void($MenuLayer::*)(cocos2d::enumKeyCodes);
    using d3 = void(D::*)(cocos2d::enumKeyCodes);
    using f3 = void(*)($MenuLayer*, cocos2d::enumKeyCodes);
    inline void keyDown(cocos2d::enumKeyCodes p0) {
        if ((c3){&$MenuLayer::keyDown} != (d3){&D::keyDown})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::keyDown})))(this, p0);
        return MenuLayer::keyDown(p0);
    }

    using c4 = void($MenuLayer::*)();
    using d4 = void(D::*)();
    using f4 = void(*)($MenuLayer*);
    inline void googlePlaySignedIn() {
        if ((c4){&$MenuLayer::googlePlaySignedIn} != (d4){&D::googlePlaySignedIn})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::googlePlaySignedIn})))(this);
        return MenuLayer::googlePlaySignedIn();
    }

    using c5 = void($MenuLayer::*)(FLAlertLayer*, bool);
    using d5 = void(D::*)(FLAlertLayer*, bool);
    using f5 = void(*)($MenuLayer*, FLAlertLayer*, bool);
    inline void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((c5){&$MenuLayer::FLAlert_Clicked} != (d5){&D::FLAlert_Clicked})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::FLAlert_Clicked})))(this, p0, p1);
        return MenuLayer::FLAlert_Clicked(p0, p1);
    }

    using c6 = void($MenuLayer::*)(cocos2d::CCObject*);
    using d6 = void(D::*)(cocos2d::CCObject*);
    using f6 = void(*)($MenuLayer*, cocos2d::CCObject*);
    inline void onMoreGames(cocos2d::CCObject* p0) {
        if ((c6){&$MenuLayer::onMoreGames} != (d6){&D::onMoreGames})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::onMoreGames})))(this, p0);
        return MenuLayer::onMoreGames(p0);
    }

    using c7 = void($MenuLayer::*)(cocos2d::CCObject*);
    using d7 = void(D::*)(cocos2d::CCObject*);
    using f7 = void(*)($MenuLayer*, cocos2d::CCObject*);
    inline void onQuit(cocos2d::CCObject* p0) {
        if ((c7){&$MenuLayer::onQuit} != (d7){&D::onQuit})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::onQuit})))(this, p0);
        return MenuLayer::onQuit(p0);
    }

    using c8 = void($MenuLayer::*)(bool);
    using d8 = void(D::*)(bool);
    using f8 = void(*)($MenuLayer*, bool);
    inline void scene(bool p0) {
        if ((c8){&$MenuLayer::scene} != (d8){&D::scene})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::scene})))(this, p0);
        return MenuLayer::scene(p0);
    }

    inline $MenuLayer(bool) {}
    inline $MenuLayer() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c1){&$MenuLayer::init} != (d1){&D::init})
            m->registerHook(base+0x1d14b0, extract_virtual(V, (d1){&D::init}));

        if ((c2){&$MenuLayer::keyBackClicked} != (d2){&D::keyBackClicked})
            m->registerHook(base+0x1d3160, extract_virtual(V, (d2){&D::keyBackClicked}));

        if ((c3){&$MenuLayer::keyDown} != (d3){&D::keyDown})
            m->registerHook(base+0x1d33d0, extract_virtual(V, (d3){&D::keyDown}));

        if ((c4){&$MenuLayer::googlePlaySignedIn} != (d4){&D::googlePlaySignedIn})
            m->registerHook(base+0x1d2f30, extract_virtual(V, (d4){&D::googlePlaySignedIn}));

        if ((c5){&$MenuLayer::FLAlert_Clicked} != (d5){&D::FLAlert_Clicked})
            m->registerHook(base+0x1d3190, extract_virtual(V, (d5){&D::FLAlert_Clicked}));

        if ((c6){&$MenuLayer::onMoreGames} != (d6){&D::onMoreGames})
            m->registerHook(base+0x1d2ad0, extract((d6){&D::onMoreGames}));

        if ((c7){&$MenuLayer::onQuit} != (d7){&D::onQuit})
            m->registerHook(base+0x1d2b40, extract((d7){&D::onQuit}));

        if ((c8){&$MenuLayer::scene} != (d8){&D::scene})
            m->registerHook(base+0x1d12d0, extract((d8){&D::scene}));
    }
};

template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
public:
    inline ~$ButtonSprite() {}

    using c0 = ButtonSprite*(*)(char const*);
    inline static ButtonSprite* create(char const* p0) {
        if ((c0){&$ButtonSprite::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0);
        return ButtonSprite::create(p0);
    }

    using c1 = ButtonSprite*(*)(char const*, int, int, float, bool);
    inline static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        if ((c1){&$ButtonSprite::create} != (c1){&D::create})
            return rcast<c1>(m->getOriginal(rcast<func_t&>((c1){&D::create})))(p0, p1, p2, p3, p4);
        return ButtonSprite::create(p0, p1, p2, p3, p4);
    }

    using c2 = void($ButtonSprite::*)(char const*);
    using d2 = void(D::*)(char const*);
    using f2 = void(*)($ButtonSprite*, char const*);
    inline void updateBGImage(char const* p0) {
        if ((c2){&$ButtonSprite::updateBGImage} != (d2){&D::updateBGImage})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::updateBGImage})))(this, p0);
        return ButtonSprite::updateBGImage(p0);
    }

    using c3 = ButtonSprite*(*)(char const*, float);
    inline static ButtonSprite* create(char const* p0, float p1) {
        if ((c3){&$ButtonSprite::create} != (c3){&D::create})
            return rcast<c3>(m->getOriginal(rcast<func_t&>((c3){&D::create})))(p0, p1);
        return ButtonSprite::create(p0, p1);
    }

    using c4 = ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
    inline static ButtonSprite* create(cocos2d::CCSprite* p0, int p1, int p2, float p3, float p4, bool p5, char const* p6, bool p7) {
        if ((c4){&$ButtonSprite::create} != (c4){&D::create})
            return rcast<c4>(m->getOriginal(rcast<func_t&>((c4){&D::create})))(p0, p1, p2, p3, p4, p5, p6, p7);
        return ButtonSprite::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    inline $ButtonSprite(bool) {}
    inline $ButtonSprite() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$ButtonSprite::create} != (c0){&D::create})
            m->registerHook(base+0x4fa10, (c0){&D::create});

        if ((c1){&$ButtonSprite::create} != (c1){&D::create})
            m->registerHook(base+0x4fa40, (c1){&D::create});

        if ((c2){&$ButtonSprite::updateBGImage} != (d2){&D::updateBGImage})
            m->registerHook(base+0x502d0, extract((d2){&D::updateBGImage}));

        if ((c3){&$ButtonSprite::create} != (c3){&D::create})
            m->registerHook(base+0x4fa60, (c3){&D::create});

        if ((c4){&$ButtonSprite::create} != (c4){&D::create})
            m->registerHook(base+0x4fa90, (c4){&D::create});
    }
};

template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
public:
    inline ~$CCTextInputNode() {}

    using c0 = CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*);
    inline static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((c0){&$CCTextInputNode::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3, p4, p5);
        return CCTextInputNode::create(p0, p1, p2, p3, p4, p5);
    }

    using c1 = gd::string($CCTextInputNode::*)();
    using d1 = gd::string(D::*)();
    using f1 = gd::string(*)($CCTextInputNode*);
    inline gd::string getString() {
        if ((c1){&$CCTextInputNode::getString} != (d1){&D::getString})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::getString})))(this);
        return CCTextInputNode::getString();
    }

    using c2 = void($CCTextInputNode::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($CCTextInputNode*);
    inline void refreshLabel() {
        if ((c2){&$CCTextInputNode::refreshLabel} != (d2){&D::refreshLabel})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::refreshLabel})))(this);
        return CCTextInputNode::refreshLabel();
    }

    using c3 = void($CCTextInputNode::*)(gd::string);
    using d3 = void(D::*)(gd::string);
    using f3 = void(*)($CCTextInputNode*, gd::string);
    inline void setAllowedChars(gd::string p0) {
        if ((c3){&$CCTextInputNode::setAllowedChars} != (d3){&D::setAllowedChars})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::setAllowedChars})))(this, p0);
        return CCTextInputNode::setAllowedChars(p0);
    }

    using c4 = void($CCTextInputNode::*)(cocos2d::_ccColor3B);
    using d4 = void(D::*)(cocos2d::_ccColor3B);
    using f4 = void(*)($CCTextInputNode*, cocos2d::_ccColor3B);
    inline void setLabelNormalColor(cocos2d::_ccColor3B p0) {
        if ((c4){&$CCTextInputNode::setLabelNormalColor} != (d4){&D::setLabelNormalColor})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::setLabelNormalColor})))(this, p0);
        return CCTextInputNode::setLabelNormalColor(p0);
    }

    using c5 = void($CCTextInputNode::*)(cocos2d::_ccColor3B);
    using d5 = void(D::*)(cocos2d::_ccColor3B);
    using f5 = void(*)($CCTextInputNode*, cocos2d::_ccColor3B);
    inline void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        if ((c5){&$CCTextInputNode::setLabelPlaceholderColor} != (d5){&D::setLabelPlaceholderColor})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::setLabelPlaceholderColor})))(this, p0);
        return CCTextInputNode::setLabelPlaceholderColor(p0);
    }

    using c6 = void($CCTextInputNode::*)(float);
    using d6 = void(D::*)(float);
    using f6 = void(*)($CCTextInputNode*, float);
    inline void setLabelPlaceholderScale(float p0) {
        if ((c6){&$CCTextInputNode::setLabelPlaceholderScale} != (d6){&D::setLabelPlaceholderScale})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::setLabelPlaceholderScale})))(this, p0);
        return CCTextInputNode::setLabelPlaceholderScale(p0);
    }

    using c7 = void($CCTextInputNode::*)(float);
    using d7 = void(D::*)(float);
    using f7 = void(*)($CCTextInputNode*, float);
    inline void setMaxLabelScale(float p0) {
        if ((c7){&$CCTextInputNode::setMaxLabelScale} != (d7){&D::setMaxLabelScale})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::setMaxLabelScale})))(this, p0);
        return CCTextInputNode::setMaxLabelScale(p0);
    }

    using c8 = void($CCTextInputNode::*)(float);
    using d8 = void(D::*)(float);
    using f8 = void(*)($CCTextInputNode*, float);
    inline void setMaxLabelWidth(float p0) {
        if ((c8){&$CCTextInputNode::setMaxLabelWidth} != (d8){&D::setMaxLabelWidth})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::setMaxLabelWidth})))(this, p0);
        return CCTextInputNode::setMaxLabelWidth(p0);
    }

    using c9 = void($CCTextInputNode::*)(gd::string);
    using d9 = void(D::*)(gd::string);
    using f9 = void(*)($CCTextInputNode*, gd::string);
    inline void setString(gd::string p0) {
        if ((c9){&$CCTextInputNode::setString} != (d9){&D::setString})
            return rcast<f9>(m->getOriginal(rcast<func_t&>((d9){&D::setString})))(this, p0);
        return CCTextInputNode::setString(p0);
    }

    using c10 = void($CCTextInputNode::*)(gd::string);
    using d10 = void(D::*)(gd::string);
    using f10 = void(*)($CCTextInputNode*, gd::string);
    inline void updateLabel(gd::string p0) {
        if ((c10){&$CCTextInputNode::updateLabel} != (d10){&D::updateLabel})
            return rcast<f10>(m->getOriginal(rcast<func_t&>((d10){&D::updateLabel})))(this, p0);
        return CCTextInputNode::updateLabel(p0);
    }

    using c11 = void($CCTextInputNode::*)();
    using d11 = void(D::*)();
    using f11 = void(*)($CCTextInputNode*);
    inline void forceOffset() {
        if ((c11){&$CCTextInputNode::forceOffset} != (d11){&D::forceOffset})
            return rcast<f11>(m->getOriginal(rcast<func_t&>((d11){&D::forceOffset})))(this);
        return CCTextInputNode::forceOffset();
    }

    using c12 = void($CCTextInputNode::*)();
    using d12 = void(D::*)();
    using f12 = void(*)($CCTextInputNode*);
    inline void registerWithTouchDispatcher() {
        if ((c12){&$CCTextInputNode::registerWithTouchDispatcher} != (d12){&D::registerWithTouchDispatcher})
            return rcast<f12>(m->getOriginal(rcast<func_t&>((d12){&D::registerWithTouchDispatcher})))(this);
        return CCTextInputNode::registerWithTouchDispatcher();
    }

    using c13 = bool($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*);
    using d13 = bool(D::*)(float, float, char const*, char const*, int, char const*);
    using f13 = bool(*)($CCTextInputNode*, float, float, char const*, char const*, int, char const*);
    inline bool init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((c13){&$CCTextInputNode::init} != (d13){&D::init})
            return rcast<f13>(m->getOriginal(rcast<func_t&>((d13){&D::init})))(this, p0, p1, p2, p3, p4, p5);
        return CCTextInputNode::init(p0, p1, p2, p3, p4, p5);
    }

    using c14 = void($CCTextInputNode::*)();
    using d14 = void(D::*)();
    using f14 = void(*)($CCTextInputNode*);
    inline void visit() {
        if ((c14){&$CCTextInputNode::visit} != (d14){&D::visit})
            return rcast<f14>(m->getOriginal(rcast<func_t&>((d14){&D::visit})))(this);
        return CCTextInputNode::visit();
    }

    using c15 = bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d15 = bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f15 = bool(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c15){&$CCTextInputNode::ccTouchBegan} != (d15){&D::ccTouchBegan})
            return rcast<f15>(m->getOriginal(rcast<func_t&>((d15){&D::ccTouchBegan})))(this, p0, p1);
        return CCTextInputNode::ccTouchBegan(p0, p1);
    }

    using c16 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d16 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f16 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c16){&$CCTextInputNode::ccTouchCancelled} != (d16){&D::ccTouchCancelled})
            return rcast<f16>(m->getOriginal(rcast<func_t&>((d16){&D::ccTouchCancelled})))(this, p0, p1);
        return CCTextInputNode::ccTouchCancelled(p0, p1);
    }

    using c17 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d17 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f17 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c17){&$CCTextInputNode::ccTouchEnded} != (d17){&D::ccTouchEnded})
            return rcast<f17>(m->getOriginal(rcast<func_t&>((d17){&D::ccTouchEnded})))(this, p0, p1);
        return CCTextInputNode::ccTouchEnded(p0, p1);
    }

    using c18 = void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using d18 = void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
    using f18 = void(*)($CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
    inline void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((c18){&$CCTextInputNode::ccTouchMoved} != (d18){&D::ccTouchMoved})
            return rcast<f18>(m->getOriginal(rcast<func_t&>((d18){&D::ccTouchMoved})))(this, p0, p1);
        return CCTextInputNode::ccTouchMoved(p0, p1);
    }

    using c19 = void($CCTextInputNode::*)();
    using d19 = void(D::*)();
    using f19 = void(*)($CCTextInputNode*);
    inline void textChanged() {
        if ((c19){&$CCTextInputNode::textChanged} != (d19){&D::textChanged})
            return rcast<f19>(m->getOriginal(rcast<func_t&>((d19){&D::textChanged})))(this);
        return CCTextInputNode::textChanged();
    }

    using c20 = void($CCTextInputNode::*)(bool);
    using d20 = void(D::*)(bool);
    using f20 = void(*)($CCTextInputNode*, bool);
    inline void onClickTrackNode(bool p0) {
        if ((c20){&$CCTextInputNode::onClickTrackNode} != (d20){&D::onClickTrackNode})
            return rcast<f20>(m->getOriginal(rcast<func_t&>((d20){&D::onClickTrackNode})))(this, p0);
        return CCTextInputNode::onClickTrackNode(p0);
    }

    using c21 = void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using d21 = void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using f21 = void(*)($CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
    inline void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((c21){&$CCTextInputNode::keyboardWillShow} != (d21){&D::keyboardWillShow})
            return rcast<f21>(m->getOriginal(rcast<func_t&>((d21){&D::keyboardWillShow})))(this, p0);
        return CCTextInputNode::keyboardWillShow(p0);
    }

    using c22 = void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using d22 = void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&);
    using f22 = void(*)($CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
    inline void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((c22){&$CCTextInputNode::keyboardWillHide} != (d22){&D::keyboardWillHide})
            return rcast<f22>(m->getOriginal(rcast<func_t&>((d22){&D::keyboardWillHide})))(this, p0);
        return CCTextInputNode::keyboardWillHide(p0);
    }

    using c23 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int);
    using d23 = bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int);
    using f23 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int);
    inline bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2) {
        if ((c23){&$CCTextInputNode::onTextFieldInsertText} != (d23){&D::onTextFieldInsertText})
            return rcast<f23>(m->getOriginal(rcast<func_t&>((d23){&D::onTextFieldInsertText})))(this, p0, p1, p2);
        return CCTextInputNode::onTextFieldInsertText(p0, p1, p2);
    }

    using c24 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*);
    using d24 = bool(D::*)(cocos2d::CCTextFieldTTF*);
    using f24 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*);
    inline bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((c24){&$CCTextInputNode::onTextFieldAttachWithIME} != (d24){&D::onTextFieldAttachWithIME})
            return rcast<f24>(m->getOriginal(rcast<func_t&>((d24){&D::onTextFieldAttachWithIME})))(this, p0);
        return CCTextInputNode::onTextFieldAttachWithIME(p0);
    }

    using c25 = bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*);
    using d25 = bool(D::*)(cocos2d::CCTextFieldTTF*);
    using f25 = bool(*)($CCTextInputNode*, cocos2d::CCTextFieldTTF*);
    inline bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((c25){&$CCTextInputNode::onTextFieldDetachWithIME} != (d25){&D::onTextFieldDetachWithIME})
            return rcast<f25>(m->getOriginal(rcast<func_t&>((d25){&D::onTextFieldDetachWithIME})))(this, p0);
        return CCTextInputNode::onTextFieldDetachWithIME(p0);
    }

    inline $CCTextInputNode(bool) {}
    inline $CCTextInputNode() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CCTextInputNode::create} != (c0){&D::create})
            m->registerHook(base+0x5cfb0, (c0){&D::create});

        if ((c1){&$CCTextInputNode::getString} != (d1){&D::getString})
            m->registerHook(base+0x5d6f0, extract((d1){&D::getString}));

        if ((c2){&$CCTextInputNode::refreshLabel} != (d2){&D::refreshLabel})
            m->registerHook(base+0x5d730, extract((d2){&D::refreshLabel}));

        if ((c3){&$CCTextInputNode::setAllowedChars} != (d3){&D::setAllowedChars})
            m->registerHook(base+0x5d360, extract((d3){&D::setAllowedChars}));

        if ((c4){&$CCTextInputNode::setLabelNormalColor} != (d4){&D::setLabelNormalColor})
            m->registerHook(base+0x5dab0, extract((d4){&D::setLabelNormalColor}));

        if ((c5){&$CCTextInputNode::setLabelPlaceholderColor} != (d5){&D::setLabelPlaceholderColor})
            m->registerHook(base+0x5da90, extract((d5){&D::setLabelPlaceholderColor}));

        if ((c6){&$CCTextInputNode::setLabelPlaceholderScale} != (d6){&D::setLabelPlaceholderScale})
            m->registerHook(base+0x5da70, extract((d6){&D::setLabelPlaceholderScale}));

        if ((c7){&$CCTextInputNode::setMaxLabelScale} != (d7){&D::setMaxLabelScale})
            m->registerHook(base+0x5da30, extract((d7){&D::setMaxLabelScale}));

        if ((c8){&$CCTextInputNode::setMaxLabelWidth} != (d8){&D::setMaxLabelWidth})
            m->registerHook(base+0x5da50, extract((d8){&D::setMaxLabelWidth}));

        if ((c9){&$CCTextInputNode::setString} != (d9){&D::setString})
            m->registerHook(base+0x5d3e0, extract((d9){&D::setString}));

        if ((c10){&$CCTextInputNode::updateLabel} != (d10){&D::updateLabel})
            m->registerHook(base+0x5d4a0, extract((d10){&D::updateLabel}));

        if ((c11){&$CCTextInputNode::forceOffset} != (d11){&D::forceOffset})
            m->registerHook(base+0x5ec70, extract((d11){&D::forceOffset}));

        if ((c12){&$CCTextInputNode::registerWithTouchDispatcher} != (d12){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x5eec0, extract_virtual(V, (d12){&D::registerWithTouchDispatcher}));

        if ((c13){&$CCTextInputNode::init} != (d13){&D::init})
            m->registerHook(base+0x5d180, extract((d13){&D::init}));

        if ((c14){&$CCTextInputNode::visit} != (d14){&D::visit})
            m->registerHook(base+0x5d380, extract_virtual(V, (d14){&D::visit}));

        if ((c15){&$CCTextInputNode::ccTouchBegan} != (d15){&D::ccTouchBegan})
            m->registerHook(base+0x5ec80, extract_virtual(V, (d15){&D::ccTouchBegan}));

        if ((c16){&$CCTextInputNode::ccTouchCancelled} != (d16){&D::ccTouchCancelled})
            m->registerHook(base+0x5ee80, extract_virtual(V, (d16){&D::ccTouchCancelled}));

        if ((c17){&$CCTextInputNode::ccTouchEnded} != (d17){&D::ccTouchEnded})
            m->registerHook(base+0x5ee60, extract_virtual(V, (d17){&D::ccTouchEnded}));

        if ((c18){&$CCTextInputNode::ccTouchMoved} != (d18){&D::ccTouchMoved})
            m->registerHook(base+0x5eea0, extract_virtual(V, (d18){&D::ccTouchMoved}));

        if ((c19){&$CCTextInputNode::textChanged} != (d19){&D::textChanged})
            m->registerHook(base+0x5dd70, extract_virtual(V, (d19){&D::textChanged}));

        if ((c20){&$CCTextInputNode::onClickTrackNode} != (d20){&D::onClickTrackNode})
            m->registerHook(base+0x5dd40, extract_virtual(V, (d20){&D::onClickTrackNode}));

        if ((c21){&$CCTextInputNode::keyboardWillShow} != (d21){&D::keyboardWillShow})
            m->registerHook(base+0x5dad0, extract_virtual(V, (d21){&D::keyboardWillShow}));

        if ((c22){&$CCTextInputNode::keyboardWillHide} != (d22){&D::keyboardWillHide})
            m->registerHook(base+0x5dc20, extract_virtual(V, (d22){&D::keyboardWillHide}));

        if ((c23){&$CCTextInputNode::onTextFieldInsertText} != (d23){&D::onTextFieldInsertText})
            m->registerHook(base+0x5de50, extract_virtual(V, (d23){&D::onTextFieldInsertText}));

        if ((c24){&$CCTextInputNode::onTextFieldAttachWithIME} != (d24){&D::onTextFieldAttachWithIME})
            m->registerHook(base+0x5e2c0, extract_virtual(V, (d24){&D::onTextFieldAttachWithIME}));

        if ((c25){&$CCTextInputNode::onTextFieldDetachWithIME} != (d25){&D::onTextFieldDetachWithIME})
            m->registerHook(base+0x5e610, extract_virtual(V, (d25){&D::onTextFieldDetachWithIME}));
    }
};

template<class D>
class $TableView : public TableView, public $CacBase {
public:
    inline ~$TableView() {}

    using c0 = TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect);
    inline static TableView* create(TableViewDelegate* p0, TableViewDataSource* p1, cocos2d::CCRect p2) {
        if ((c0){&$TableView::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2);
        return TableView::create(p0, p1, p2);
    }

    using c1 = void($TableView::*)();
    using d1 = void(D::*)();
    using f1 = void(*)($TableView*);
    inline void reloadData() {
        if ((c1){&$TableView::reloadData} != (d1){&D::reloadData})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::reloadData})))(this);
        return TableView::reloadData();
    }

    inline $TableView(bool) {}
    inline $TableView() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$TableView::create} != (c0){&D::create})
            m->registerHook(base+0x37eb30, (c0){&D::create});

        if ((c1){&$TableView::reloadData} != (d1){&D::reloadData})
            m->registerHook(base+0x37f970, extract((d1){&D::reloadData}));
    }
};

template<class D>
class $BoomListView : public BoomListView, public $CacBase {
public:
    inline ~$BoomListView() {}

    using c0 = BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    inline static BoomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((c0){&$BoomListView::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3, p4);
        return BoomListView::create(p0, p1, p2, p3, p4);
    }

    using c1 = bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using d1 = bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType);
    using f1 = bool(*)($BoomListView*, cocos2d::CCArray*, float, float, int, BoomListType);
    inline bool init(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((c1){&$BoomListView::init} != (d1){&D::init})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::init})))(this, p0, p1, p2, p3, p4);
        return BoomListView::init(p0, p1, p2, p3, p4);
    }

    using c2 = void($BoomListView::*)();
    using d2 = void(D::*)();
    using f2 = void(*)($BoomListView*);
    inline void draw() {
        if ((c2){&$BoomListView::draw} != (d2){&D::draw})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::draw})))(this);
        return BoomListView::draw();
    }

    using c3 = void($BoomListView::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($BoomListView*);
    inline void setupList() {
        if ((c3){&$BoomListView::setupList} != (d3){&D::setupList})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::setupList})))(this);
        return BoomListView::setupList();
    }

    using c4 = void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*);
    using d4 = void(D::*)(CCIndexPath&, TableViewCell*, TableView*);
    using f4 = void(*)($BoomListView*, CCIndexPath&, TableViewCell*, TableView*);
    inline void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((c4){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (d4){&D::TableViewWillDisplayCellForRowAtIndexPath})
            return rcast<f4>(m->getOriginal(rcast<func_t&>((d4){&D::TableViewWillDisplayCellForRowAtIndexPath})))(this, p0, p1, p2);
        return BoomListView::TableViewWillDisplayCellForRowAtIndexPath(p0, p1, p2);
    }

    using c5 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d5 = void(D::*)(CCIndexPath&, TableView*);
    using f5 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((c5){&$BoomListView::cellHeightForRowAtIndexPath} != (d5){&D::cellHeightForRowAtIndexPath})
            return rcast<f5>(m->getOriginal(rcast<func_t&>((d5){&D::cellHeightForRowAtIndexPath})))(this, p0, p1);
        return BoomListView::cellHeightForRowAtIndexPath(p0, p1);
    }

    using c6 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d6 = void(D::*)(CCIndexPath&, TableView*);
    using f6 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((c6){&$BoomListView::didSelectRowAtIndexPath} != (d6){&D::didSelectRowAtIndexPath})
            return rcast<f6>(m->getOriginal(rcast<func_t&>((d6){&D::didSelectRowAtIndexPath})))(this, p0, p1);
        return BoomListView::didSelectRowAtIndexPath(p0, p1);
    }

    using c7 = int($BoomListView::*)(unsigned int, TableView*);
    using d7 = int(D::*)(unsigned int, TableView*);
    using f7 = int(*)($BoomListView*, unsigned int, TableView*);
    inline int numberOfRowsInSection(unsigned int p0, TableView* p1) {
        if ((c7){&$BoomListView::numberOfRowsInSection} != (d7){&D::numberOfRowsInSection})
            return rcast<f7>(m->getOriginal(rcast<func_t&>((d7){&D::numberOfRowsInSection})))(this, p0, p1);
        return BoomListView::numberOfRowsInSection(p0, p1);
    }

    using c8 = void($BoomListView::*)(TableView*);
    using d8 = void(D::*)(TableView*);
    using f8 = void(*)($BoomListView*, TableView*);
    inline void numberOfSectionsInTableView(TableView* p0) {
        if ((c8){&$BoomListView::numberOfSectionsInTableView} != (d8){&D::numberOfSectionsInTableView})
            return rcast<f8>(m->getOriginal(rcast<func_t&>((d8){&D::numberOfSectionsInTableView})))(this, p0);
        return BoomListView::numberOfSectionsInTableView(p0);
    }

    using c9 = void($BoomListView::*)(CCIndexPath&, TableView*);
    using d9 = void(D::*)(CCIndexPath&, TableView*);
    using f9 = void(*)($BoomListView*, CCIndexPath&, TableView*);
    inline void cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((c9){&$BoomListView::cellForRowAtIndexPath} != (d9){&D::cellForRowAtIndexPath})
            return rcast<f9>(m->getOriginal(rcast<func_t&>((d9){&D::cellForRowAtIndexPath})))(this, p0, p1);
        return BoomListView::cellForRowAtIndexPath(p0, p1);
    }

    using c10 = void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&);
    using d10 = void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&);
    using f10 = void(*)($BoomListView*, TableView*, TableViewCellEditingStyle, CCIndexPath&);
    inline void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {
        if ((c10){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            return rcast<f10>(m->getOriginal(rcast<func_t&>((d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})))(this, p0, p1, p2);
        return BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2);
    }

    using c11 = void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*);
    using d11 = void(D::*)(CCIndexPath&, TableViewCell*, TableView*);
    using f11 = void(*)($BoomListView*, CCIndexPath&, TableViewCell*, TableView*);
    inline void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((c11){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (d11){&D::TableViewWillReloadCellForRowAtIndexPath})
            return rcast<f11>(m->getOriginal(rcast<func_t&>((d11){&D::TableViewWillReloadCellForRowAtIndexPath})))(this, p0, p1, p2);
        return BoomListView::TableViewWillReloadCellForRowAtIndexPath(p0, p1, p2);
    }

    using c12 = TableViewCell*($BoomListView::*)(char const*);
    using d12 = TableViewCell*(D::*)(char const*);
    using f12 = TableViewCell*(*)($BoomListView*, char const*);
    inline TableViewCell* getListCell(char const* p0) {
        if ((c12){&$BoomListView::getListCell} != (d12){&D::getListCell})
            return rcast<f12>(m->getOriginal(rcast<func_t&>((d12){&D::getListCell})))(this, p0);
        return BoomListView::getListCell(p0);
    }

    using c13 = void($BoomListView::*)(TableViewCell*, int);
    using d13 = void(D::*)(TableViewCell*, int);
    using f13 = void(*)($BoomListView*, TableViewCell*, int);
    inline void loadCell(TableViewCell* p0, int p1) {
        if ((c13){&$BoomListView::loadCell} != (d13){&D::loadCell})
            return rcast<f13>(m->getOriginal(rcast<func_t&>((d13){&D::loadCell})))(this, p0, p1);
        return BoomListView::loadCell(p0, p1);
    }

    inline $BoomListView(bool) {}
    inline $BoomListView() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$BoomListView::create} != (c0){&D::create})
            m->registerHook(base+0x18ecb0, (c0){&D::create});

        if ((c1){&$BoomListView::init} != (d1){&D::init})
            m->registerHook(base+0x18ee00, extract((d1){&D::init}));

        if ((c2){&$BoomListView::draw} != (d2){&D::draw})
            m->registerHook(base+0x18f790, extract((d2){&D::draw}));

        if ((c3){&$BoomListView::setupList} != (d3){&D::setupList})
            m->registerHook(base+0x18ef90, extract_virtual(V, (d3){&D::setupList}));

        if ((c4){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (d4){&D::TableViewWillDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x18f030, extract_virtual(V, (d4){&D::TableViewWillDisplayCellForRowAtIndexPath}));

        if ((c5){&$BoomListView::cellHeightForRowAtIndexPath} != (d5){&D::cellHeightForRowAtIndexPath})
            m->registerHook(base+0x18f070, extract_virtual(V, (d5){&D::cellHeightForRowAtIndexPath}));

        if ((c6){&$BoomListView::didSelectRowAtIndexPath} != (d6){&D::didSelectRowAtIndexPath})
            m->registerHook(base+0x18f090, extract_virtual(V, (d6){&D::didSelectRowAtIndexPath}));

        if ((c7){&$BoomListView::numberOfRowsInSection} != (d7){&D::numberOfRowsInSection})
            m->registerHook(base+0x18f0b0, extract_virtual(V, (d7){&D::numberOfRowsInSection}));

        if ((c8){&$BoomListView::numberOfSectionsInTableView} != (d8){&D::numberOfSectionsInTableView})
            m->registerHook(base+0x18f0e0, extract_virtual(V, (d8){&D::numberOfSectionsInTableView}));

        if ((c9){&$BoomListView::cellForRowAtIndexPath} != (d9){&D::cellForRowAtIndexPath})
            m->registerHook(base+0x18f100, extract_virtual(V, (d9){&D::cellForRowAtIndexPath}));

        if ((c10){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            m->registerHook(base+0x18f770, extract_virtual(V, (d10){&D::TableViewCommitCellEditingStyleForRowAtIndexPath}));

        if ((c11){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (d11){&D::TableViewWillReloadCellForRowAtIndexPath})
            m->registerHook(base+0x18f050, extract_virtual(V, (d11){&D::TableViewWillReloadCellForRowAtIndexPath}));

        if ((c12){&$BoomListView::getListCell} != (d12){&D::getListCell})
            m->registerHook(base+0x18f200, extract_virtual(V, (d12){&D::getListCell}));

        if ((c13){&$BoomListView::loadCell} != (d13){&D::loadCell})
            m->registerHook(base+0x18f4a0, extract_virtual(V, (d13){&D::loadCell}));
    }
};

template<class D>
class $CustomListView : public CustomListView, public $CacBase {
public:
    inline ~$CustomListView() {}

    using c0 = CustomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType);
    inline static CustomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((c0){&$CustomListView::create} != (c0){&D::create})
            return rcast<c0>(m->getOriginal(rcast<func_t&>((c0){&D::create})))(p0, p1, p2, p3, p4);
        return CustomListView::create(p0, p1, p2, p3, p4);
    }

    using c1 = void($CustomListView::*)(char const*);
    using d1 = void(D::*)(char const*);
    using f1 = void(*)($CustomListView*, char const*);
    inline void getListCell(char const* p0) {
        if ((c1){&$CustomListView::getListCell} != (d1){&D::getListCell})
            return rcast<f1>(m->getOriginal(rcast<func_t&>((d1){&D::getListCell})))(this, p0);
        return CustomListView::getListCell(p0);
    }

    using c2 = void($CustomListView::*)(TableViewCell*, int);
    using d2 = void(D::*)(TableViewCell*, int);
    using f2 = void(*)($CustomListView*, TableViewCell*, int);
    inline void loadCell(TableViewCell* p0, int p1) {
        if ((c2){&$CustomListView::loadCell} != (d2){&D::loadCell})
            return rcast<f2>(m->getOriginal(rcast<func_t&>((d2){&D::loadCell})))(this, p0, p1);
        return CustomListView::loadCell(p0, p1);
    }

    using c3 = void($CustomListView::*)();
    using d3 = void(D::*)();
    using f3 = void(*)($CustomListView*);
    inline void setupList() {
        if ((c3){&$CustomListView::setupList} != (d3){&D::setupList})
            return rcast<f3>(m->getOriginal(rcast<func_t&>((d3){&D::setupList})))(this);
        return CustomListView::setupList();
    }

    inline $CustomListView(bool) {}
    inline $CustomListView() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});

        if ((c0){&$CustomListView::create} != (c0){&D::create})
            m->registerHook(base+0x10d410, (c0){&D::create});

        if ((c1){&$CustomListView::getListCell} != (d1){&D::getListCell})
            m->registerHook(base+0x10d560, extract((d1){&D::getListCell}));

        if ((c2){&$CustomListView::loadCell} != (d2){&D::loadCell})
            m->registerHook(base+0x10e610, extract((d2){&D::loadCell}));

        if ((c3){&$CustomListView::setupList} != (d3){&D::setupList})
            m->registerHook(base+0x116e70, extract((d3){&D::setupList}));
    }
};

template<class D>
class $TableViewCell : public TableViewCell, public $CacBase {
public:
    inline ~$TableViewCell() {}

    inline $TableViewCell(bool) {}
    inline $TableViewCell() {
        auto i = new D();
        auto V = *rcast<uintptr_t*>(i);
        delete i;
        m->registerHook(extract_destructor(V), +[](){});
    }
};

#undef rcast
