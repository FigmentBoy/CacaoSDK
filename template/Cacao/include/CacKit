//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif
#define CAC_HOOKS void __cacinj() __attribute__((constructor)); void __cacinj() {
#define END_CAC_HOOKS \
    for(auto& i : __cackit::glob) {i->apply_hooks();};m->enable();}

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};


class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}
 

template <class $Derived>
class $AnimatedGameObject : public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef AnimatedGameObject* __thistype;

    virtual void playAnimation(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
    }

    virtual void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0xc8450))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::playAnimation} != (void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation})
            m->registerHook(getBase()+0xc93d0, extract_virtual(this, (void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation}));

        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateChildSpriteColor} != (void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor})
            m->registerHook(getBase()+0xc8450, extract_virtual(this, (void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor}));
    }
};


template <class $Derived>
class $AudioEffectsLayer : public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef AudioEffectsLayer* __thistype;

    virtual void audioStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x271f40))(this, p0);
    }

    virtual void create(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x271a00))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::audioStep} != (void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep})
            m->registerHook(getBase()+0x271f40, extract_virtual(this, (void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep}));

        if ((void($Derived::*)(std::string)){&$Derived::create} != (void($AudioEffectsLayer::*)(std::string)){&$AudioEffectsLayer::create})
            m->registerHook(getBase()+0x271a00, extract_virtual(this, (void($AudioEffectsLayer::*)(std::string)){&$AudioEffectsLayer::create}));
    }
};


template <class $Derived>
class $ButtonSprite : public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ButtonSprite* __thistype;

    virtual void updateBGImage(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x502d0))(this, p0);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x4fa10))(this, p0);
    }

    virtual void create(char const* p0, int p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, int, float, bool)>(m->getOriginal(getBase()+0x4fa40))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::updateBGImage} != (void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage})
            m->registerHook(getBase()+0x502d0, extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage}));

        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($ButtonSprite::*)(char const*)){&$ButtonSprite::create})
            m->registerHook(getBase()+0x4fa10, extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::create}));

        if ((void($Derived::*)(char const*, int, int, float, bool)){&$Derived::create} != (void($ButtonSprite::*)(char const*, int, int, float, bool)){&$ButtonSprite::create})
            m->registerHook(getBase()+0x4fa40, extract_virtual(this, (void($ButtonSprite::*)(char const*, int, int, float, bool)){&$ButtonSprite::create}));
    }
};


template <class $Derived>
class $CCAnimatedSprite : public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimatedSprite* __thistype;

    virtual void runAnimation(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
    }

    virtual void tweenToAnimation(std::string p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::runAnimation} != (void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation})
            m->registerHook(getBase()+0x1a6430, extract_virtual(this, (void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation}));

        if ((void($Derived::*)(std::string, float)){&$Derived::tweenToAnimation} != (void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation})
            m->registerHook(getBase()+0x1a65b0, extract_virtual(this, (void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation}));
    }
};


template <class $Derived>
class $CCCircleWave : public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCircleWave* __thistype;

    virtual void create(float p0, float p1, float p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool)>(m->getOriginal(getBase()+0xbd270))(this, p0, p1, p2, p3);
    }

    virtual void create(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool, bool)>(m->getOriginal(getBase()+0xbd290))(this, p0, p1, p2, p3, p4);
    }

    virtual void followObject(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
    }

    virtual void updatePosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xbd630))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, float, float, bool)){&$Derived::create} != (void($CCCircleWave::*)(float, float, float, bool)){&$CCCircleWave::create})
            m->registerHook(getBase()+0xbd270, extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool)){&$CCCircleWave::create}));

        if ((void($Derived::*)(float, float, float, bool, bool)){&$Derived::create} != (void($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::create})
            m->registerHook(getBase()+0xbd290, extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::create}));

        if ((void($Derived::*)(cocos2d::CCNode*, bool)){&$Derived::followObject} != (void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject})
            m->registerHook(getBase()+0xbd670, extract_virtual(this, (void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject}));

        if ((void($Derived::*)(float)){&$Derived::updatePosition} != (void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition})
            m->registerHook(getBase()+0xbd630, extract_virtual(this, (void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition}));
    }
};


template <class $Derived>
class $CCLightFlash : public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLightFlash* __thistype;

    virtual void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$Derived::playEffect} != (void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect})
            m->registerHook(getBase()+0x295900, extract_virtual(this, (void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect}));
    }
};


template <class $Derived>
class $CCMenuItemToggler : public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemToggler* __thistype;

    virtual void toggle(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x38950))(this, p0);
    }

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x38a40))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x38400))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool)){&$Derived::toggle} != (void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle})
            m->registerHook(getBase()+0x38950, extract_virtual(this, (void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle}));

        if ((void($Derived::*)(float)){&$Derived::setSizeMult} != (void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult})
            m->registerHook(getBase()+0x38a40, extract_virtual(this, (void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult}));

        if ((void($Derived::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$Derived::create} != (void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create})
            m->registerHook(getBase()+0x38400, extract_virtual(this, (void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create}));
    }
};


template <class $Derived>
class $CCSpritePlus : public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpritePlus* __thistype;

    virtual void initWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x248670))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::initWithSpriteFrameName} != (void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName})
            m->registerHook(getBase()+0x248670, extract_virtual(this, (void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName}));
    }
};


template <class $Derived>
class $CCTextInputNode : public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTextInputNode* __thistype;

    virtual void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x5da90))(this, p0);
    }

    virtual void setLabelPlaceholderScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da70))(this, p0);
    }

    virtual void setString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
    }

    virtual void create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<void(*)(decltype(this), float, float, char const*, char const*, int, char const*)>(m->getOriginal(getBase()+0x5cfb0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void setAllowedChars(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d360))(this, p0);
    }

    virtual void setMaxLabelScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da30))(this, p0);
    }

    virtual void setMaxLabelWidth(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da50))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::setLabelPlaceholderColor} != (void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor})
            m->registerHook(getBase()+0x5da90, extract_virtual(this, (void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor}));

        if ((void($Derived::*)(float)){&$Derived::setLabelPlaceholderScale} != (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale})
            m->registerHook(getBase()+0x5da70, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale}));

        if ((void($Derived::*)(std::string)){&$Derived::setString} != (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString})
            m->registerHook(getBase()+0x5d3e0, extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString}));

        if ((void($Derived::*)(float, float, char const*, char const*, int, char const*)){&$Derived::create} != (void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create})
            m->registerHook(getBase()+0x5cfb0, extract_virtual(this, (void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create}));

        if ((void($Derived::*)(std::string)){&$Derived::setAllowedChars} != (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars})
            m->registerHook(getBase()+0x5d360, extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars}));

        if ((void($Derived::*)(float)){&$Derived::setMaxLabelScale} != (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale})
            m->registerHook(getBase()+0x5da30, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale}));

        if ((void($Derived::*)(float)){&$Derived::setMaxLabelWidth} != (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth})
            m->registerHook(getBase()+0x5da50, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth}));
    }
};


template <class $Derived>
class $CollisionBlockPopup : public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CollisionBlockPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x130010))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create})
            m->registerHook(getBase()+0x130010, extract_virtual(this, (void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create}));
    }
};


template <class $Derived>
class $CollisionTriggerAction : public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CollisionTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x176ee0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString})
            m->registerHook(getBase()+0x176ee0, extract_virtual(this, (void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString}));
    }
};


template <class $Derived>
class $ColorAction : public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorAction* __thistype;

    virtual void setupFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0x17f310))(this, p0);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17f270))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCDictionary*)){&$Derived::setupFromDict} != (void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict})
            m->registerHook(getBase()+0x17f310, extract_virtual(this, (void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict}));

        if ((void($Derived::*)(std::string)){&$Derived::setupFromString} != (void($ColorAction::*)(std::string)){&$ColorAction::setupFromString})
            m->registerHook(getBase()+0x17f270, extract_virtual(this, (void($ColorAction::*)(std::string)){&$ColorAction::setupFromString}));
    }
};


template <class $Derived>
class $ColorChannelSprite : public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorChannelSprite* __thistype;

    virtual void updateValues(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(ColorAction*)){&$Derived::updateValues} != (void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues})
            m->registerHook(getBase()+0x16e2e0, extract_virtual(this, (void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues}));
    }
};


template <class $Derived>
class $ColorSelectPopup : public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorSelectPopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x423320))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41eb70))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
    }

    virtual void onDefault(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
    }

    virtual void onMultiTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422680))(this, p0);
    }

    virtual void onPlayerColor1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422500))(this, p0);
    }

    virtual void onPlayerColor2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
    }

    virtual void onSpawnedByTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
    }

    virtual void onToggleHSVMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
    }

    virtual void onTouchTriggered(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
    }

    virtual void sliderChanged(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::colorValueChanged} != (void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged})
            m->registerHook(getBase()+0x423320, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create})
            m->registerHook(getBase()+0x41eb70, extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$Derived::init} != (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init})
            m->registerHook(getBase()+0x41ee70, extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onDefault} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault})
            m->registerHook(getBase()+0x4220e0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onMultiTrigger} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger})
            m->registerHook(getBase()+0x422680, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onPlayerColor1} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1})
            m->registerHook(getBase()+0x422500, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onPlayerColor2} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2})
            m->registerHook(getBase()+0x4225c0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onSpawnedByTrigger} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger})
            m->registerHook(getBase()+0x4227f0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onToggleHSVMode} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode})
            m->registerHook(getBase()+0x4227b0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onTouchTriggered} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered})
            m->registerHook(getBase()+0x4228b0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::sliderChanged} != (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged})
            m->registerHook(getBase()+0x421ca0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged}));
    }
};


template <class $Derived>
class $CountTriggerAction : public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CountTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1754f0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString})
            m->registerHook(getBase()+0x1754f0, extract_virtual(this, (void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString}));
    }
};


template <class $Derived>
class $CustomizeObjectLayer : public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CustomizeObjectLayer* __thistype;

    virtual void colorSelectClosed(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xe1050))(this, p0);
    }

    virtual void create(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd340))(this, p0, p1);
    }

    virtual void init(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1430))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::colorSelectClosed} != (void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed})
            m->registerHook(getBase()+0xe1050, extract_virtual(this, (void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed}));

        if ((void($Derived::*)(GameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create})
            m->registerHook(getBase()+0xdd340, extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create}));

        if ((void($Derived::*)(GameObject*, cocos2d::CCArray*)){&$Derived::init} != (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init})
            m->registerHook(getBase()+0xdd560, extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textChanged} != (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged})
            m->registerHook(getBase()+0xe1470, extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textInputClosed} != (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed})
            m->registerHook(getBase()+0xe1430, extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed}));
    }
};


template <class $Derived>
class $DialogLayer : public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DialogLayer* __thistype;

    virtual void create(DialogObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), DialogObject*, int)>(m->getOriginal(getBase()+0x2047c0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(DialogObject*, int)){&$Derived::create} != (void($DialogLayer::*)(DialogObject*, int)){&$DialogLayer::create})
            m->registerHook(getBase()+0x2047c0, extract_virtual(this, (void($DialogLayer::*)(DialogObject*, int)){&$DialogLayer::create}));
    }
};


template <class $Derived>
class $DialogObject : public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DialogObject* __thistype;

    virtual void create(std::string p0, std::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, std::string, int, float, bool, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x204410))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$Derived::create} != (void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create})
            m->registerHook(getBase()+0x204410, extract_virtual(this, (void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create}));
    }
};


template <class $Derived>
class $DrawGridLayer : public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DrawGridLayer* __thistype;

    virtual void addPlayer2Point(cocos2d::CCPoint p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
    }

    virtual void addPlayerPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0x920c0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCPoint, bool)){&$Derived::addPlayer2Point} != (void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point})
            m->registerHook(getBase()+0xa25b0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point}));

        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::addPlayerPoint} != (void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint})
            m->registerHook(getBase()+0xa39c0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint}));

        if ((void($Derived::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$Derived::create} != (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create})
            m->registerHook(getBase()+0x920c0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create}));
    }
};


template <class $Derived>
class $EditorOptionsLayer : public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorOptionsLayer* __thistype;

    virtual void onButtonsPerRow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x147b30))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onButtonsPerRow} != (void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow})
            m->registerHook(getBase()+0x147b30, extract_virtual(this, (void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow}));
    }
};


template <class $Derived>
class $EditorUI : public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorUI* __thistype;

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8a80))(this, p0);
    }

    virtual void editObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x195a0))(this, p0);
    }

    virtual void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
    }

    virtual void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
    }

    virtual void scaleChanged(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x25490))(this, p0);
    }

    virtual void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
    }

    virtual void disableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
    }

    virtual void enableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
    }

    virtual CreateMenuItem* getCreateBtn(int p0, int p1) {
        return reinterpret_cast<CreateMenuItem*(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
    }

    virtual void onDuplicate(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
    }

    virtual void pasteObjects(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x232d0))(this, p0);
    }

    virtual void redoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
    }

    virtual void selectObjects(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
    }

    virtual void undoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb830))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(LevelEditorLayer*)){&$Derived::create} != (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create})
            m->registerHook(getBase()+0x8a80, extract_virtual(this, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::editObject} != (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject})
            m->registerHook(getBase()+0x195a0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject}));

        if ((void($Derived::*)(cocos2d::CCArray*, bool)){&$Derived::getGroupCenter} != (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter})
            m->registerHook(getBase()+0x23470, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter}));

        if ((void($Derived::*)(GameObject*, cocos2d::CCPoint)){&$Derived::moveObject} != (void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject})
            m->registerHook(getBase()+0x24b10, extract_virtual(this, (void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject}));

        if ((void($Derived::*)(float)){&$Derived::scaleChanged} != (void($EditorUI::*)(float)){&$EditorUI::scaleChanged})
            m->registerHook(getBase()+0x25490, extract_virtual(this, (void($EditorUI::*)(float)){&$EditorUI::scaleChanged}));

        if ((void($Derived::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$Derived::scaleObjects} != (void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects})
            m->registerHook(getBase()+0x252e0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects}));

        if ((void($Derived::*)(CreateMenuItem*)){&$Derived::disableButton} != (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton})
            m->registerHook(getBase()+0x1c0f0, extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton}));

        if ((void($Derived::*)(CreateMenuItem*)){&$Derived::enableButton} != (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton})
            m->registerHook(getBase()+0x1bff0, extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton}));

        if ((CreateMenuItem*($Derived::*)(int, int)){&$Derived::getCreateBtn} != (CreateMenuItem*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn})
            m->registerHook(getBase()+0x1f6c0, extract_virtual(this, (CreateMenuItem*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onDuplicate} != (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate})
            m->registerHook(getBase()+0x18ba0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate}));

        if ((void($Derived::*)(std::string)){&$Derived::pasteObjects} != (void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects})
            m->registerHook(getBase()+0x232d0, extract_virtual(this, (void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::redoLastAction} != (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction})
            m->registerHook(getBase()+0xb8e0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction}));

        if ((void($Derived::*)(cocos2d::CCArray*, bool)){&$Derived::selectObjects} != (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects})
            m->registerHook(getBase()+0x23940, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::undoLastAction} != (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction})
            m->registerHook(getBase()+0xb830, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction}));
    }
};


template <class $Derived>
class $EffectGameObject : public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EffectGameObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xc9790))(this, p0);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($EffectGameObject::*)(char const*)){&$EffectGameObject::create})
            m->registerHook(getBase()+0xc9790, extract_virtual(this, (void($EffectGameObject::*)(char const*)){&$EffectGameObject::create}));

        if ((void($Derived::*)(GJBaseGameLayer*)){&$Derived::triggerObject} != (void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject})
            m->registerHook(getBase()+0xc9870, extract_virtual(this, (void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject}));
    }
};


template <class $Derived>
class $EndPortalObject : public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EndPortalObject* __thistype;

    virtual void updateColors(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateColors} != (void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors})
            m->registerHook(getBase()+0x1dacb0, extract_virtual(this, (void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors}));
    }
};


template <class $Derived>
class $FMODAudioEngine : public $CacBase {
 public:
    $FMODAudioEngine() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef FMODAudioEngine* __thistype;

    virtual void fadeBackgroundMusic(bool p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, float)>(m->getOriginal(getBase()+0x20fd50))(this, p0, p1);
    }

    virtual void setBackgroundMusicTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x20fe10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool, float)){&$Derived::fadeBackgroundMusic} != (void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic})
            m->registerHook(getBase()+0x20fd50, extract_virtual(this, (void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic}));

        if ((void($Derived::*)(float)){&$Derived::setBackgroundMusicTime} != (void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime})
            m->registerHook(getBase()+0x20fe10, extract_virtual(this, (void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime}));
    }
};


template <class $Derived>
class $GJBaseGameLayer : public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJBaseGameLayer* __thistype;

    virtual void addObjectCounter(LabelGameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
    }

    virtual void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
    }

    virtual void addToGroups(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
    }

    virtual void addToSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
    }

    virtual void atlasValue(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
    }

    virtual void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
    }

    virtual void collectItem(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
    }

    virtual void collectedObject(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void damagingObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb6140))(this, p0);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
    }

    virtual void getGroundHeightForMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6630))(this, p0);
    }

    virtual void getGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
    }

    virtual void getMoveDeltaForObjects(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
    }

    virtual void getOptimizedGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7940))(this, p0);
    }

    virtual void getStaticGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
    }

    virtual void isGroupDisabledForObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
    }

    virtual void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
    }

    virtual void loadUpToPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xba680))(this, p0);
    }

    virtual void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
    }

    virtual void objectTriggered(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
    }

    virtual void parentForZLayer(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
    }

    virtual void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
    }

    virtual void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
    }

    virtual void processMoveActionsStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
    }

    virtual void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
    }

    virtual void processPlayerFollowActions(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
    }

    virtual void pushButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
    }

    virtual void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
    }

    virtual void releaseButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
    }

    virtual void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
    }

    virtual void removeFromGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
    }

    virtual void removeObjectFromSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
    }

    virtual void reorderObjectSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
    }

    virtual void resetGroupCounters(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba300))(this, p0);
    }

    virtual void sectionForPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb6120))(this, p0);
    }

    virtual void spawnGroupTriggered(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
    }

    virtual void staticObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
    }

    virtual void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
    }

    virtual void togglePlayerVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba910))(this, p0);
    }

    virtual void triggerMoveCommand(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateCounters(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
    }

    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
    }

    virtual void updateLayerCapacity(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0xb1680))(this, p0);
    }

    virtual void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
    }

    virtual void updateOBB2(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
    }

    virtual void spawnGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7050))(this, p0);
    }

    virtual void toggleGroupTriggered(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(LabelGameObject*, int)){&$Derived::addObjectCounter} != (void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter})
            m->registerHook(getBase()+0xb9eb0, extract_virtual(this, (void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter}));

        if ((void($Derived::*)(GameObject*, int, bool)){&$Derived::addToGroup} != (void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup})
            m->registerHook(getBase()+0xb77f0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup}));

        if ((void($Derived::*)(GameObject*, bool)){&$Derived::addToGroups} != (void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups})
            m->registerHook(getBase()+0xb7780, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups}));

        if ((void($Derived::*)(GameObject*)){&$Derived::addToSection} != (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection})
            m->registerHook(getBase()+0xb7b70, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection}));

        if ((void($Derived::*)(int)){&$Derived::atlasValue} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue})
            m->registerHook(getBase()+0xb21e0, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue}));

        if ((void($Derived::*)(PlayerObject*, GameObject*)){&$Derived::bumpPlayer} != (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer})
            m->registerHook(getBase()+0xb6860, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer}));

        if ((void($Derived::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$Derived::calculateColorValues} != (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues})
            m->registerHook(getBase()+0xba9a0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues}));

        if ((void($Derived::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$Derived::calculateOpacityValues} != (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues})
            m->registerHook(getBase()+0xb5be0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues}));

        if ((void($Derived::*)(int, int)){&$Derived::collectItem} != (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem})
            m->registerHook(getBase()+0xb9e20, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem}));

        if ((void($Derived::*)(EffectGameObject*)){&$Derived::collectedObject} != (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject})
            m->registerHook(getBase()+0xb9b60, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject}));

        if ((void($Derived::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$Derived::createMoveCommand} != (void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand})
            m->registerHook(getBase()+0xb73a0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand}));

        if ((void($Derived::*)(cocos2d::CCRect)){&$Derived::damagingObjectsInRect} != (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect})
            m->registerHook(getBase()+0xb6140, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect}));

        if ((void($Derived::*)(PlayerObject*, bool, bool)){&$Derived::flipGravity} != (void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity})
            m->registerHook(getBase()+0xba990, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity}));

        if ((void($Derived::*)(int)){&$Derived::getGroundHeightForMode} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode})
            m->registerHook(getBase()+0xb6630, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode}));

        if ((void($Derived::*)(int)){&$Derived::getGroup} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup})
            m->registerHook(getBase()+0xb6f20, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup}));

        if ((void($Derived::*)(int, int)){&$Derived::getMoveDeltaForObjects} != (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects})
            m->registerHook(getBase()+0xb6db0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects}));

        if ((void($Derived::*)(int)){&$Derived::getOptimizedGroup} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup})
            m->registerHook(getBase()+0xb7940, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup}));

        if ((void($Derived::*)(int)){&$Derived::getStaticGroup} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup})
            m->registerHook(getBase()+0xb79a0, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup}));

        if ((void($Derived::*)(GameObject*)){&$Derived::isGroupDisabledForObject} != (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject})
            m->registerHook(getBase()+0xb5cc0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject}));

        if ((void($Derived::*)(GameObject*, cocos2d::CCArray*)){&$Derived::isGroupDisabledForObjectFull} != (void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull})
            m->registerHook(getBase()+0xb5de0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull}));

        if ((void($Derived::*)(float)){&$Derived::loadUpToPosition} != (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition})
            m->registerHook(getBase()+0xba680, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition}));

        if ((void($Derived::*)(GameObject*, GameObject*)){&$Derived::objectIntersectsCircle} != (void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle})
            m->registerHook(getBase()+0xb66e0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle}));

        if ((void($Derived::*)(EffectGameObject*)){&$Derived::objectTriggered} != (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered})
            m->registerHook(getBase()+0xb71b0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered}));

        if ((void($Derived::*)(int, int)){&$Derived::objectsCollided} != (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided})
            m->registerHook(getBase()+0xb6d90, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided}));

        if ((void($Derived::*)(int, bool, int)){&$Derived::parentForZLayer} != (void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer})
            m->registerHook(getBase()+0xb55d0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer}));

        if ((void($Derived::*)(PlayerObject*, GameObject*)){&$Derived::playerTouchedRing} != (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing})
            m->registerHook(getBase()+0xb69e0, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing}));

        if ((void($Derived::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$Derived::processColorObject} != (void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject})
            m->registerHook(getBase()+0xb5a90, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject}));

        if ((void($Derived::*)(float)){&$Derived::processMoveActionsStep} != (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep})
            m->registerHook(getBase()+0xb7ea0, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$Derived::processOpacityObject} != (void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject})
            m->registerHook(getBase()+0xb5ae0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject}));

        if ((void($Derived::*)(float)){&$Derived::processPlayerFollowActions} != (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions})
            m->registerHook(getBase()+0xb8b50, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions}));

        if ((void($Derived::*)(int, bool)){&$Derived::pushButton} != (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton})
            m->registerHook(getBase()+0xb9920, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton}));

        if ((void($Derived::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$Derived::rectIntersectsCircle} != (void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle})
            m->registerHook(getBase()+0xb6470, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle}));

        if ((void($Derived::*)(int, bool)){&$Derived::releaseButton} != (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton})
            m->registerHook(getBase()+0xb9a00, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton}));

        if ((void($Derived::*)(GameObject*, int)){&$Derived::removeFromGroup} != (void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup})
            m->registerHook(getBase()+0xb7a60, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup}));

        if ((void($Derived::*)(GameObject*)){&$Derived::removeFromGroups} != (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups})
            m->registerHook(getBase()+0xb7a00, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups}));

        if ((void($Derived::*)(GameObject*)){&$Derived::removeObjectFromSection} != (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection})
            m->registerHook(getBase()+0xb7e00, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection}));

        if ((void($Derived::*)(GameObject*)){&$Derived::reorderObjectSection} != (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection})
            m->registerHook(getBase()+0xb7cb0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection}));

        if ((void($Derived::*)(bool)){&$Derived::resetGroupCounters} != (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters})
            m->registerHook(getBase()+0xba300, extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters}));

        if ((void($Derived::*)(float)){&$Derived::sectionForPos} != (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos})
            m->registerHook(getBase()+0xb6120, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos}));

        if ((void($Derived::*)(int, float, int)){&$Derived::spawnGroupTriggered} != (void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered})
            m->registerHook(getBase()+0xb7020, extract_virtual(this, (void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered}));

        if ((void($Derived::*)(cocos2d::CCRect)){&$Derived::staticObjectsInRect} != (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect})
            m->registerHook(getBase()+0xb5f90, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect}));

        if ((void($Derived::*)(int, int, int, bool, int)){&$Derived::testInstantCountTrigger} != (void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger})
            m->registerHook(getBase()+0xb9ae0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger}));

        if ((void($Derived::*)(int, bool)){&$Derived::toggleGroup} != (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup})
            m->registerHook(getBase()+0xb75f0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup}));

        if ((void($Derived::*)(bool)){&$Derived::togglePlayerVisibility} != (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility})
            m->registerHook(getBase()+0xba910, extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility}));

        if ((void($Derived::*)(EffectGameObject*)){&$Derived::triggerMoveCommand} != (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand})
            m->registerHook(getBase()+0xb7290, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$Derived::updateColor} != (void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor})
            m->registerHook(getBase()+0xb7420, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor}));

        if ((void($Derived::*)(int, int)){&$Derived::updateCounters} != (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters})
            m->registerHook(getBase()+0xb9bc0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters}));

        if ((void($Derived::*)(cocos2d::CCArray*)){&$Derived::updateDisabledObjectsLastPos} != (void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos})
            m->registerHook(getBase()+0xb95b0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos}));

        if ((void($Derived::*)(std::string)){&$Derived::updateLayerCapacity} != (void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity})
            m->registerHook(getBase()+0xb1680, extract_virtual(this, (void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity}));

        if ((void($Derived::*)(int, int, int, int)){&$Derived::updateLegacyLayerCapacity} != (void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity})
            m->registerHook(getBase()+0xb1590, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity}));

        if ((void($Derived::*)(cocos2d::CCRect)){&$Derived::updateOBB2} != (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2})
            m->registerHook(getBase()+0xb63f0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2}));

        if ((void($Derived::*)(int)){&$Derived::spawnGroup} != (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup})
            m->registerHook(getBase()+0xb7050, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup}));

        if ((void($Derived::*)(int, bool)){&$Derived::toggleGroupTriggered} != (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered})
            m->registerHook(getBase()+0xb75a0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered}));
    }
};


template <class $Derived>
class $GJDropDownLayer : public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJDropDownLayer* __thistype;

    virtual void init(char const* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, float)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x352530))(this, p0);
    }

    virtual void exitLayer(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x352670))(this, p0);
    }

    virtual void hideLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
    }

    virtual void showLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*, float)){&$Derived::init} != (void($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init})
            m->registerHook(getBase()+0x352100, extract_virtual(this, (void($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init}));

        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($GJDropDownLayer::*)(char const*)){&$GJDropDownLayer::create})
            m->registerHook(getBase()+0x352530, extract_virtual(this, (void($GJDropDownLayer::*)(char const*)){&$GJDropDownLayer::create}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::exitLayer} != (void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer})
            m->registerHook(getBase()+0x352670, extract_virtual(this, (void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer}));

        if ((void($Derived::*)(bool)){&$Derived::hideLayer} != (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer})
            m->registerHook(getBase()+0x3527b0, extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer}));

        if ((void($Derived::*)(bool)){&$Derived::showLayer} != (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer})
            m->registerHook(getBase()+0x3526c0, extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer}));
    }
};


template <class $Derived>
class $GJEffectManager : public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJEffectManager* __thistype;

    virtual void activeColorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
    }

    virtual void activeOpacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e10))(this, p0);
    }

    virtual void addAllInheritedColorActions(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
    }

    virtual void addGroupPulseEffect(PulseEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), PulseEffectAction*)>(m->getOriginal(getBase()+0x184c10))(this, p0);
    }

    virtual void calculateInheritedColor(int p0, ColorAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, ColorAction*)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
    }

    virtual void calculateLightBGColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x185b90))(this, p0);
    }

    virtual void colorActionChanged(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
    }

    virtual void colorExists(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181da0))(this, p0);
    }

    virtual void colorForEffect(cocos2d::_ccColor3B p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
    }

    virtual void colorForGroupID(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
    }

    virtual void colorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
    }

    virtual void colorForPulseEffect(cocos2d::_ccColor3B const& p0, PulseEffectAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, PulseEffectAction*)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
    }

    virtual void countChangedForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
    }

    virtual void countForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a10))(this, p0);
    }

    virtual void createFollowCommand(float p0, float p1, float p2, int p3, int p4, bool p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, int, int, bool, int)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void createPlayerFollowCommand(float p0, float p1, int p2, float p3, float p4, int p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, float, int, int)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createRotateCommand(int p0, float p1, int p2, int p3, int p4, float p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int, int, int, float, bool, int)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void getColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180b00))(this, p0);
    }

    virtual void getColorSprite(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180d00))(this, p0);
    }

    virtual void getMixedColor(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
    }

    virtual void getOpacityActionForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
    }

    virtual void handleObjectCollision(bool p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
    }

    virtual void hasBeenTriggered(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
    }

    virtual void hasPulseEffectForGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184f60))(this, p0);
    }

    virtual void isGroupEnabled(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
    }

    virtual void keyForGroupIDColor(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
    }

    virtual void loadState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x188db0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
    }

    virtual void opacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180c80))(this, p0);
    }

    virtual void opacityModForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184740))(this, p0);
    }

    virtual void playerButton(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
    }

    virtual void prepareMoveActions(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
    }

    virtual void registerCollisionTrigger(int p0, int p1, int p2, bool p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, bool, int)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void removeColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181d60))(this, p0);
    }

    virtual void runCountTrigger(int p0, int p1, bool p2, int p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool, int, bool, int)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runDeathTrigger(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
    }

    virtual void runOpacityActionOnGroup(int p0, float p1, float p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, float, float, int)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
    }

    virtual void runPulseEffect(int p0, bool p1, float p2, float p3, float p4, PulseEffectType p5, cocos2d::_ccColor3B p6, cocos2d::_ccHSVValue p7, int p8, bool p9, bool p10, bool p11, int p12) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    virtual void runTouchTriggerCommand(int p0, bool p1, TouchTriggerType p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, TouchTriggerType, bool, int)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
    }

    virtual void setColorAction(ColorAction* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*, int)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
    }

    virtual void setFollowing(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x186290))(this, p0);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e40))(this, p0);
    }

    virtual void spawnGroup(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
    }

    virtual void stopActionsForTrigger(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0x183150))(this, p0);
    }

    virtual void stopMoveActionsForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
    }

    virtual void storeTriggeredID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185380))(this, p0);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
    }

    virtual void traverseInheritanceChain(InheritanceNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*)>(m->getOriginal(getBase()+0x181850))(this, p0);
    }

    virtual void updateColorAction(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x184560))(this, p0);
    }

    virtual void updateColorEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181f40))(this, p0);
    }

    virtual void updateColors(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
    }

    virtual void updateEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181df0))(this, p0);
    }

    virtual void updateOpacityAction(OpacityEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction*)>(m->getOriginal(getBase()+0x184780))(this, p0);
    }

    virtual void updateOpacityEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
    }

    virtual void updatePulseEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182130))(this, p0);
    }

    virtual void updateSpawnTriggers(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182510))(this, p0);
    }

    virtual void wasFollowing(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
    }

    virtual void wouldCreateLoop(InheritanceNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*, int)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::activeColorForIndex} != (void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex})
            m->registerHook(getBase()+0x180cb0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex}));

        if ((void($Derived::*)(int)){&$Derived::activeOpacityForIndex} != (void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex})
            m->registerHook(getBase()+0x180e10, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex}));

        if ((void($Derived::*)(cocos2d::CCArray*)){&$Derived::addAllInheritedColorActions} != (void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions})
            m->registerHook(getBase()+0x1817a0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions}));

        if ((void($Derived::*)(PulseEffectAction*)){&$Derived::addGroupPulseEffect} != (void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect})
            m->registerHook(getBase()+0x184c10, extract_virtual(this, (void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect}));

        if ((void($Derived::*)(int, ColorAction*)){&$Derived::calculateInheritedColor} != (void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor})
            m->registerHook(getBase()+0x1818f0, extract_virtual(this, (void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor}));

        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::calculateLightBGColor} != (void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor})
            m->registerHook(getBase()+0x185b90, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor}));

        if ((void($Derived::*)(ColorAction*)){&$Derived::colorActionChanged} != (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged})
            m->registerHook(getBase()+0x181dc0, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged}));

        if ((void($Derived::*)(int)){&$Derived::colorExists} != (void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists})
            m->registerHook(getBase()+0x181da0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$Derived::colorForEffect} != (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect})
            m->registerHook(getBase()+0x182650, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect}));

        if ((void($Derived::*)(int, cocos2d::_ccColor3B const&, bool)){&$Derived::colorForGroupID} != (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID})
            m->registerHook(getBase()+0x184f90, extract_virtual(this, (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID}));

        if ((void($Derived::*)(int)){&$Derived::colorForIndex} != (void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex})
            m->registerHook(getBase()+0x180ad0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$Derived::colorForPulseEffect} != (void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect})
            m->registerHook(getBase()+0x181bf0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect}));

        if ((void($Derived::*)(int)){&$Derived::countChangedForItem} != (void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem})
            m->registerHook(getBase()+0x185a40, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem}));

        if ((void($Derived::*)(int)){&$Derived::countForItem} != (void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem})
            m->registerHook(getBase()+0x185a10, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem}));

        if ((void($Derived::*)(float, float, float, int, int, bool, int)){&$Derived::createFollowCommand} != (void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand})
            m->registerHook(getBase()+0x182ed0, extract_virtual(this, (void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand}));

        if ((void($Derived::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$Derived::createMoveCommand} != (void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand})
            m->registerHook(getBase()+0x182cc0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand}));

        if ((void($Derived::*)(float, float, int, float, float, int, int)){&$Derived::createPlayerFollowCommand} != (void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand})
            m->registerHook(getBase()+0x182fe0, extract_virtual(this, (void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand}));

        if ((void($Derived::*)(int, float, int, int, int, float, bool, int)){&$Derived::createRotateCommand} != (void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand})
            m->registerHook(getBase()+0x182df0, extract_virtual(this, (void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand}));

        if ((void($Derived::*)(int)){&$Derived::getColorAction} != (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction})
            m->registerHook(getBase()+0x180b00, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction}));

        if ((void($Derived::*)(int)){&$Derived::getColorSprite} != (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite})
            m->registerHook(getBase()+0x180d00, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$Derived::getMixedColor} != (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor})
            m->registerHook(getBase()+0x185d30, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor}));

        if ((void($Derived::*)(int)){&$Derived::getOpacityActionForGroup} != (void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup})
            m->registerHook(getBase()+0x1845b0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup}));

        if ((void($Derived::*)(bool, int, int)){&$Derived::handleObjectCollision} != (void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision})
            m->registerHook(getBase()+0x1828f0, extract_virtual(this, (void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision}));

        if ((void($Derived::*)(int)){&$Derived::hasBeenTriggered} != (void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered})
            m->registerHook(getBase()+0x1853b0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered}));

        if ((void($Derived::*)(int)){&$Derived::hasPulseEffectForGroupID} != (void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID})
            m->registerHook(getBase()+0x184f60, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID}));

        if ((void($Derived::*)(int)){&$Derived::isGroupEnabled} != (void($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled})
            m->registerHook(getBase()+0x1853d0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled}));

        if ((void($Derived::*)(int, cocos2d::_ccColor3B const&, bool)){&$Derived::keyForGroupIDColor} != (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor})
            m->registerHook(getBase()+0x184c90, extract_virtual(this, (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor}));

        if ((void($Derived::*)(std::string)){&$Derived::loadState} != (void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState})
            m->registerHook(getBase()+0x188db0, extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState}));

        if ((void($Derived::*)(int, int)){&$Derived::objectsCollided} != (void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided})
            m->registerHook(getBase()+0x182a00, extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided}));

        if ((void($Derived::*)(int)){&$Derived::opacityForIndex} != (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex})
            m->registerHook(getBase()+0x180c80, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex}));

        if ((void($Derived::*)(int)){&$Derived::opacityModForGroup} != (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup})
            m->registerHook(getBase()+0x184740, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup}));

        if ((void($Derived::*)(bool, bool)){&$Derived::playerButton} != (void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton})
            m->registerHook(getBase()+0x1855a0, extract_virtual(this, (void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton}));

        if ((void($Derived::*)(float, bool)){&$Derived::prepareMoveActions} != (void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions})
            m->registerHook(getBase()+0x183660, extract_virtual(this, (void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions}));

        if ((void($Derived::*)(int, int, int, bool, bool, int)){&$Derived::registerCollisionTrigger} != (void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger})
            m->registerHook(getBase()+0x182b70, extract_virtual(this, (void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger}));

        if ((void($Derived::*)(int)){&$Derived::removeColorAction} != (void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction})
            m->registerHook(getBase()+0x181d60, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction}));

        if ((void($Derived::*)(int, int, bool, int, bool, int)){&$Derived::runCountTrigger} != (void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger})
            m->registerHook(getBase()+0x1858d0, extract_virtual(this, (void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger}));

        if ((void($Derived::*)(int, bool, int)){&$Derived::runDeathTrigger} != (void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger})
            m->registerHook(getBase()+0x1857a0, extract_virtual(this, (void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger}));

        if ((void($Derived::*)(int, float, float, int)){&$Derived::runOpacityActionOnGroup} != (void($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup})
            m->registerHook(getBase()+0x1845d0, extract_virtual(this, (void($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup}));

        if ((void($Derived::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$Derived::runPulseEffect} != (void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect})
            m->registerHook(getBase()+0x184890, extract_virtual(this, (void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect}));

        if ((void($Derived::*)(int, bool, TouchTriggerType, bool, int)){&$Derived::runTouchTriggerCommand} != (void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand})
            m->registerHook(getBase()+0x185460, extract_virtual(this, (void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand}));

        if ((void($Derived::*)(ColorAction*, int)){&$Derived::setColorAction} != (void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction})
            m->registerHook(getBase()+0x181d00, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction}));

        if ((void($Derived::*)(int, int, bool)){&$Derived::setFollowing} != (void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing})
            m->registerHook(getBase()+0x185e00, extract_virtual(this, (void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing}));

        if ((void($Derived::*)(std::string)){&$Derived::setupFromString} != (void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString})
            m->registerHook(getBase()+0x186290, extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString}));

        if ((void($Derived::*)(int)){&$Derived::shouldBlend} != (void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend})
            m->registerHook(getBase()+0x180e40, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend}));

        if ((void($Derived::*)(int, float, int)){&$Derived::spawnGroup} != (void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup})
            m->registerHook(getBase()+0x1852a0, extract_virtual(this, (void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup}));

        if ((void($Derived::*)(EffectGameObject*)){&$Derived::stopActionsForTrigger} != (void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger})
            m->registerHook(getBase()+0x183150, extract_virtual(this, (void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger}));

        if ((void($Derived::*)(int)){&$Derived::stopMoveActionsForGroup} != (void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup})
            m->registerHook(getBase()+0x1830e0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup}));

        if ((void($Derived::*)(int)){&$Derived::storeTriggeredID} != (void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID})
            m->registerHook(getBase()+0x185380, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID}));

        if ((void($Derived::*)(int, bool)){&$Derived::toggleGroup} != (void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup})
            m->registerHook(getBase()+0x182c80, extract_virtual(this, (void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup}));

        if ((void($Derived::*)(InheritanceNode*)){&$Derived::traverseInheritanceChain} != (void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain})
            m->registerHook(getBase()+0x181850, extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain}));

        if ((void($Derived::*)(ColorAction*)){&$Derived::updateColorAction} != (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction})
            m->registerHook(getBase()+0x184560, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction}));

        if ((void($Derived::*)(float)){&$Derived::updateColorEffects} != (void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects})
            m->registerHook(getBase()+0x181f40, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$Derived::updateColors} != (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors})
            m->registerHook(getBase()+0x180a40, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors}));

        if ((void($Derived::*)(float)){&$Derived::updateEffects} != (void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects})
            m->registerHook(getBase()+0x181df0, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects}));

        if ((void($Derived::*)(OpacityEffectAction*)){&$Derived::updateOpacityAction} != (void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction})
            m->registerHook(getBase()+0x184780, extract_virtual(this, (void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction}));

        if ((void($Derived::*)(float)){&$Derived::updateOpacityEffects} != (void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects})
            m->registerHook(getBase()+0x1823e0, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects}));

        if ((void($Derived::*)(float)){&$Derived::updatePulseEffects} != (void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects})
            m->registerHook(getBase()+0x182130, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects}));

        if ((void($Derived::*)(float)){&$Derived::updateSpawnTriggers} != (void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers})
            m->registerHook(getBase()+0x182510, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers}));

        if ((void($Derived::*)(int, int)){&$Derived::wasFollowing} != (void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing})
            m->registerHook(getBase()+0x185e60, extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing}));

        if ((void($Derived::*)(InheritanceNode*, int)){&$Derived::wouldCreateLoop} != (void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop})
            m->registerHook(getBase()+0x181820, extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop}));
    }
};


template <class $Derived>
class $GJFollowCommandLayer : public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x16a550))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create})
            m->registerHook(getBase()+0x16a550, extract_virtual(this, (void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create}));
    }
};


template <class $Derived>
class $GJGameLevel : public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJGameLevel* __thistype;

    virtual void getCoinKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
    }

    virtual void savePercentage(int p0, bool p1, int p2, int p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, int, bool)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::getCoinKey} != (void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey})
            m->registerHook(getBase()+0x2ce360, extract_virtual(this, (void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey}));

        if ((void($Derived::*)(int, bool, int, int, bool)){&$Derived::savePercentage} != (void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage})
            m->registerHook(getBase()+0x2db700, extract_virtual(this, (void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage}));
    }
};


template <class $Derived>
class $GJGroundLayer : public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJGroundLayer* __thistype;

    virtual void create(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x355c00))(this, p0, p1);
    }

    virtual void updateGround01Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356640))(this, p0);
    }

    virtual void updateGround02Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356710))(this, p0);
    }

    virtual void updateGroundPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int, int)){&$Derived::create} != (void($GJGroundLayer::*)(int, int)){&$GJGroundLayer::create})
            m->registerHook(getBase()+0x355c00, extract_virtual(this, (void($GJGroundLayer::*)(int, int)){&$GJGroundLayer::create}));

        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateGround01Color} != (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color})
            m->registerHook(getBase()+0x356640, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color}));

        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateGround02Color} != (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color})
            m->registerHook(getBase()+0x356710, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color}));

        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::updateGroundPos} != (void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos})
            m->registerHook(getBase()+0x3566c0, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos}));
    }
};


template <class $Derived>
class $GJMoveCommandLayer : public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJMoveCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36f8a0))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
    }

    virtual void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x373350))(this, p0);
    }

    virtual void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374430))(this, p0);
    }

    virtual void textInputReturn(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374c10))(this, p0);
    }

    virtual void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
    }

    virtual void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create})
            m->registerHook(getBase()+0x36f8a0, extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::init} != (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init})
            m->registerHook(getBase()+0x36fac0, extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onUpdateGroupID} != (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID})
            m->registerHook(getBase()+0x373350, extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onUpdateGroupID2} != (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2})
            m->registerHook(getBase()+0x3734c0, extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textChanged} != (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged})
            m->registerHook(getBase()+0x374470, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textInputClosed} != (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed})
            m->registerHook(getBase()+0x374430, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textInputReturn} != (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn})
            m->registerHook(getBase()+0x374c10, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn}));

        if ((void($Derived::*)(CCTextInputNode*, float)){&$Derived::textInputShouldOffset} != (void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset})
            m->registerHook(getBase()+0x374b50, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset}));

        if ((void($Derived::*)(ConfigureValuePopup*, float)){&$Derived::valuePopupClosed} != (void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed})
            m->registerHook(getBase()+0x373c20, extract_virtual(this, (void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed}));
    }
};


template <class $Derived>
class $GJPFollowCommandLayer : public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJPFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1aea20))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create})
            m->registerHook(getBase()+0x1aea20, extract_virtual(this, (void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create}));
    }
};


template <class $Derived>
class $GJRobotSprite : public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJRobotSprite* __thistype;

    virtual void updateColor02(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
    }

    virtual void updateFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateColor02} != (void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02})
            m->registerHook(getBase()+0x34bbd0, extract_virtual(this, (void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02}));

        if ((void($Derived::*)(int)){&$Derived::updateFrame} != (void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame})
            m->registerHook(getBase()+0x34bdd0, extract_virtual(this, (void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame}));
    }
};


template <class $Derived>
class $GJRotateCommandLayer : public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJRotateCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1ba0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create})
            m->registerHook(getBase()+0x1ba0, extract_virtual(this, (void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create}));
    }
};


template <class $Derived>
class $GManager : public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GManager* __thistype;

    virtual void saveData(DS_Dictionary* p0, std::string p1) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*, std::string)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
    }

    virtual void saveGMTo(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(DS_Dictionary*, std::string)){&$Derived::saveData} != (void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData})
            m->registerHook(getBase()+0x26f4b0, extract_virtual(this, (void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData}));

        if ((void($Derived::*)(std::string)){&$Derived::saveGMTo} != (void($GManager::*)(std::string)){&$GManager::saveGMTo})
            m->registerHook(getBase()+0x26f3b0, extract_virtual(this, (void($GManager::*)(std::string)){&$GManager::saveGMTo}));
    }
};


template <class $Derived>
class $GameManager : public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameManager* __thistype;

    virtual _ccColor3B colorForIdx(int p0) {
        return reinterpret_cast<_ccColor3B(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
    }

    virtual void fadeInMusic(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
    }

    virtual void getBGTexture(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
    }

    virtual void getFontFile(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
    }

    virtual int getGameVariable(char const* p0) {
        return reinterpret_cast<int(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
    }

    virtual void getIntGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
    }

    virtual void getUGV(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
    }

    virtual void loadDeathEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
    }

    virtual void loadFont(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
    }

    virtual void reportPercentageForLevel(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
    }

    virtual void setUGV(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
    }

    virtual void reloadAll(bool p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
    }

    virtual int setGameVariable(char const* p0, bool p1) {
        return reinterpret_cast<int(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((_ccColor3B($Derived::*)(int)){&$Derived::colorForIdx} != (_ccColor3B($GameManager::*)(int)){&$GameManager::colorForIdx})
            m->registerHook(getBase()+0x1cbc80, extract_virtual(this, (_ccColor3B($GameManager::*)(int)){&$GameManager::colorForIdx}));

        if ((void($Derived::*)(char const*)){&$Derived::fadeInMusic} != (void($GameManager::*)(char const*)){&$GameManager::fadeInMusic})
            m->registerHook(getBase()+0x1c2ff0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::fadeInMusic}));

        if ((void($Derived::*)(int)){&$Derived::getBGTexture} != (void($GameManager::*)(int)){&$GameManager::getBGTexture})
            m->registerHook(getBase()+0x1cca00, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getBGTexture}));

        if ((void($Derived::*)(int)){&$Derived::getFontFile} != (void($GameManager::*)(int)){&$GameManager::getFontFile})
            m->registerHook(getBase()+0x1cc5f0, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getFontFile}));

        if ((int($Derived::*)(char const*)){&$Derived::getGameVariable} != (int($GameManager::*)(char const*)){&$GameManager::getGameVariable})
            m->registerHook(getBase()+0x1cccd0, extract_virtual(this, (int($GameManager::*)(char const*)){&$GameManager::getGameVariable}));

        if ((void($Derived::*)(char const*)){&$Derived::getIntGameVariable} != (void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable})
            m->registerHook(getBase()+0x1cd1d0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable}));

        if ((void($Derived::*)(char const*)){&$Derived::getUGV} != (void($GameManager::*)(char const*)){&$GameManager::getUGV})
            m->registerHook(getBase()+0x1ccfa0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getUGV}));

        if ((void($Derived::*)(int)){&$Derived::loadDeathEffect} != (void($GameManager::*)(int)){&$GameManager::loadDeathEffect})
            m->registerHook(getBase()+0x1cc690, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadDeathEffect}));

        if ((void($Derived::*)(int)){&$Derived::loadFont} != (void($GameManager::*)(int)){&$GameManager::loadFont})
            m->registerHook(getBase()+0x1cc550, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadFont}));

        if ((void($Derived::*)(int, int, bool)){&$Derived::reportPercentageForLevel} != (void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel})
            m->registerHook(getBase()+0x1c5b00, extract_virtual(this, (void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel}));

        if ((void($Derived::*)(char const*, bool)){&$Derived::setUGV} != (void($GameManager::*)(char const*, bool)){&$GameManager::setUGV})
            m->registerHook(getBase()+0x1cce50, extract_virtual(this, (void($GameManager::*)(char const*, bool)){&$GameManager::setUGV}));

        if ((void($Derived::*)(bool, bool, bool)){&$Derived::reloadAll} != (void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll})
            m->registerHook(getBase()+0x1d08a0, extract_virtual(this, (void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll}));

        if ((int($Derived::*)(char const*, bool)){&$Derived::setGameVariable} != (int($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable})
            m->registerHook(getBase()+0x1cca80, extract_virtual(this, (int($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable}));
    }
};


template <class $Derived>
class $GameObject : public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameObject* __thistype;

    virtual void activatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a20))(this, p0);
    }

    virtual void addColorSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
    }

    virtual void addMainSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
    }

    virtual void addToGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
    }

    virtual void addToTempOffset(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
    }

    virtual void colorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
    }

    virtual void copyGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
    }

    virtual void createWithFrame(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2f5490))(this, p0);
    }

    virtual void createWithKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2f4ce0))(this, p0);
    }

    virtual void deactivateObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
    }

    virtual void getActiveColorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
    }

    virtual void getBallFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
    }

    virtual int getGroupID(int p0) {
        return reinterpret_cast<int(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
    }

    virtual void getObjectRect(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
    }

    virtual void getObjectRect2(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
    }

    virtual void hasBeenActivatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a50))(this, p0);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
    }

    virtual void objectFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x33b720))(this, p0, p1);
    }

    virtual void removeFromGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
    }

    virtual void setChildColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341f20))(this, p0);
    }

    virtual void setDefaultMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
    }

    virtual void setDidUpdateLastPosition(bool const& p0) {
        return reinterpret_cast<void(*)(decltype(this), bool const&)>(m->getOriginal(getBase()+0x343a30))(this, p0);
    }

    virtual void setGlowColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
    }

    virtual void setGlowOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x336200))(this, p0);
    }

    virtual void setLastPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
    }

    virtual void setMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x342e70))(this, p0);
    }

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341c90))(this, p0);
    }

    virtual void setObjectRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
    }

    virtual void setOrientedRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc200))(this, p0);
    }

    virtual void setRScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335e10))(this, p0);
    }

    virtual void setRScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
    }

    virtual void setRScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335d60))(this, p0);
    }

    virtual void setSectionIdx(int const& p0) {
        return reinterpret_cast<void(*)(decltype(this), int const&)>(m->getOriginal(getBase()+0x343a10))(this, p0);
    }

    virtual void setStartPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
    }

    virtual void setType(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0xdc220))(this, p0);
    }

    virtual void triggerActivated(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x336990))(this, p0);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
    }

    virtual void updateCustomScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
    }

    virtual void updateSyncedAnimation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x337f00))(this, p0);
    }

    virtual void selectObject(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x341f90))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x335850))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GameObject*)){&$Derived::activatedByPlayer} != (void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer})
            m->registerHook(getBase()+0x342a20, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer}));

        if ((void($Derived::*)(bool)){&$Derived::addColorSpriteToParent} != (void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent})
            m->registerHook(getBase()+0x2fb470, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent}));

        if ((void($Derived::*)(bool)){&$Derived::addMainSpriteToParent} != (void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent})
            m->registerHook(getBase()+0x33a5b0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent}));

        if ((void($Derived::*)(int)){&$Derived::addToGroup} != (void($GameObject::*)(int)){&$GameObject::addToGroup})
            m->registerHook(getBase()+0x33ad00, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::addToGroup}));

        if ((void($Derived::*)(float, float)){&$Derived::addToTempOffset} != (void($GameObject::*)(float, float)){&$GameObject::addToTempOffset})
            m->registerHook(getBase()+0x335700, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::addToTempOffset}));

        if ((void($Derived::*)(int, bool)){&$Derived::colorForMode} != (void($GameObject::*)(int, bool)){&$GameObject::colorForMode})
            m->registerHook(getBase()+0x343460, extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::colorForMode}));

        if ((void($Derived::*)(GameObject*)){&$Derived::copyGroups} != (void($GameObject::*)(GameObject*)){&$GameObject::copyGroups})
            m->registerHook(getBase()+0x33ae30, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::copyGroups}));

        if ((void($Derived::*)(char const*)){&$Derived::createWithFrame} != (void($GameObject::*)(char const*)){&$GameObject::createWithFrame})
            m->registerHook(getBase()+0x2f5490, extract_virtual(this, (void($GameObject::*)(char const*)){&$GameObject::createWithFrame}));

        if ((void($Derived::*)(int)){&$Derived::createWithKey} != (void($GameObject::*)(int)){&$GameObject::createWithKey})
            m->registerHook(getBase()+0x2f4ce0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::createWithKey}));

        if ((void($Derived::*)(bool)){&$Derived::deactivateObject} != (void($GameObject::*)(bool)){&$GameObject::deactivateObject})
            m->registerHook(getBase()+0x2fb8f0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::deactivateObject}));

        if ((void($Derived::*)(int, bool)){&$Derived::getActiveColorForMode} != (void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode})
            m->registerHook(getBase()+0x343860, extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode}));

        if ((void($Derived::*)(int)){&$Derived::getBallFrame} != (void($GameObject::*)(int)){&$GameObject::getBallFrame})
            m->registerHook(getBase()+0x341bf0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::getBallFrame}));

        if ((int($Derived::*)(int)){&$Derived::getGroupID} != (int($GameObject::*)(int)){&$GameObject::getGroupID})
            m->registerHook(getBase()+0x33ae10, extract_virtual(this, (int($GameObject::*)(int)){&$GameObject::getGroupID}));

        if ((void($Derived::*)(float, float)){&$Derived::getObjectRect} != (void($GameObject::*)(float, float)){&$GameObject::getObjectRect})
            m->registerHook(getBase()+0x3352d0, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect}));

        if ((void($Derived::*)(float, float)){&$Derived::getObjectRect2} != (void($GameObject::*)(float, float)){&$GameObject::getObjectRect2})
            m->registerHook(getBase()+0x3354e0, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect2}));

        if ((void($Derived::*)(GameObject*)){&$Derived::hasBeenActivatedByPlayer} != (void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer})
            m->registerHook(getBase()+0x342a50, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer}));

        if ((void($Derived::*)(cocos2d::CCTexture2D*)){&$Derived::initWithTexture} != (void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture})
            m->registerHook(getBase()+0x2f56a0, extract_virtual(this, (void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture}));

        if ((void($Derived::*)(std::string, bool)){&$Derived::objectFromString} != (void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString})
            m->registerHook(getBase()+0x33b720, extract_virtual(this, (void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString}));

        if ((void($Derived::*)(int)){&$Derived::removeFromGroup} != (void($GameObject::*)(int)){&$GameObject::removeFromGroup})
            m->registerHook(getBase()+0x33ada0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::removeFromGroup}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setChildColor} != (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor})
            m->registerHook(getBase()+0x341f20, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor}));

        if ((void($Derived::*)(int)){&$Derived::setDefaultMainColorMode} != (void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode})
            m->registerHook(getBase()+0x304fc0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode}));

        if ((void($Derived::*)(bool const&)){&$Derived::setDidUpdateLastPosition} != (void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a30, extract_virtual(this, (void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setGlowColor} != (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor})
            m->registerHook(getBase()+0x341ed0, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor}));

        if ((void($Derived::*)(unsigned char)){&$Derived::setGlowOpacity} != (void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity})
            m->registerHook(getBase()+0x336200, extract_virtual(this, (void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setLastPosition} != (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition})
            m->registerHook(getBase()+0x3439e0, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition}));

        if ((void($Derived::*)(int)){&$Derived::setMainColorMode} != (void($GameObject::*)(int)){&$GameObject::setMainColorMode})
            m->registerHook(getBase()+0x342e70, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setMainColorMode}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setObjectColor} != (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor})
            m->registerHook(getBase()+0x341c90, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor}));

        if ((void($Derived::*)(bool)){&$Derived::setObjectRectDirty} != (void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty})
            m->registerHook(getBase()+0xdc1e0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty}));

        if ((void($Derived::*)(bool)){&$Derived::setOrientedRectDirty} != (void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty})
            m->registerHook(getBase()+0xdc200, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty}));

        if ((void($Derived::*)(float)){&$Derived::setRScale} != (void($GameObject::*)(float)){&$GameObject::setRScale})
            m->registerHook(getBase()+0x335e10, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScale}));

        if ((void($Derived::*)(float)){&$Derived::setRScaleX} != (void($GameObject::*)(float)){&$GameObject::setRScaleX})
            m->registerHook(getBase()+0x335cb0, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleX}));

        if ((void($Derived::*)(float)){&$Derived::setRScaleY} != (void($GameObject::*)(float)){&$GameObject::setRScaleY})
            m->registerHook(getBase()+0x335d60, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleY}));

        if ((void($Derived::*)(int const&)){&$Derived::setSectionIdx} != (void($GameObject::*)(int const&)){&$GameObject::setSectionIdx})
            m->registerHook(getBase()+0x343a10, extract_virtual(this, (void($GameObject::*)(int const&)){&$GameObject::setSectionIdx}));

        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::setStartPos} != (void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos})
            m->registerHook(getBase()+0x2fa520, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos}));

        if ((void($Derived::*)(GameObjectType)){&$Derived::setType} != (void($GameObject::*)(GameObjectType)){&$GameObject::setType})
            m->registerHook(getBase()+0xdc220, extract_virtual(this, (void($GameObject::*)(GameObjectType)){&$GameObject::setType}));

        if ((void($Derived::*)(float)){&$Derived::triggerActivated} != (void($GameObject::*)(float)){&$GameObject::triggerActivated})
            m->registerHook(getBase()+0x336990, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::triggerActivated}));

        if ((void($Derived::*)(GJBaseGameLayer*)){&$Derived::triggerObject} != (void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject})
            m->registerHook(getBase()+0x2fa8f0, extract_virtual(this, (void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject}));

        if ((void($Derived::*)(float)){&$Derived::updateCustomScale} != (void($GameObject::*)(float)){&$GameObject::updateCustomScale})
            m->registerHook(getBase()+0x335eb0, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateCustomScale}));

        if ((void($Derived::*)(float)){&$Derived::updateSyncedAnimation} != (void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation})
            m->registerHook(getBase()+0x337f00, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation}));

        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::selectObject} != (void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject})
            m->registerHook(getBase()+0x341f90, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setPosition} != (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition})
            m->registerHook(getBase()+0x335850, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition}));
    }
};


template <class $Derived>
class $GameSoundManager : public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameSoundManager* __thistype;

    virtual void playBackgroundMusic(std::string p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, bool)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
    }

    virtual void playEffect(std::string p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float, float, float)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string, bool, bool)){&$Derived::playBackgroundMusic} != (void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic})
            m->registerHook(getBase()+0x362070, extract_virtual(this, (void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic}));

        if ((void($Derived::*)(std::string, float, float, float)){&$Derived::playEffect} != (void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect})
            m->registerHook(getBase()+0x3623d0, extract_virtual(this, (void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect}));
    }
};


template <class $Derived>
class $GameStatsManager : public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameStatsManager* __thistype;

    virtual void awardCurrencyForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43600))(this, p0);
    }

    virtual void awardDiamondsForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43c60))(this, p0);
    }

    virtual void getSecretCoinKey(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x429f0))(this, p0);
    }

    virtual void getStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d310))(this, p0);
    }

    virtual void hasPendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42730))(this, p0);
    }

    virtual void hasSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x40730))(this, p0);
    }

    virtual void hasUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x427e0))(this, p0);
    }

    virtual void incrementStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
    }

    virtual void incrementStat(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
    }

    virtual void storePendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42940))(this, p0);
    }

    virtual void storeSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42a10))(this, p0);
    }

    virtual void storeUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42890))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GJGameLevel*)){&$Derived::awardCurrencyForLevel} != (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel})
            m->registerHook(getBase()+0x43600, extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel}));

        if ((void($Derived::*)(GJGameLevel*)){&$Derived::awardDiamondsForLevel} != (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel})
            m->registerHook(getBase()+0x43c60, extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel}));

        if ((void($Derived::*)(char const*)){&$Derived::getSecretCoinKey} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey})
            m->registerHook(getBase()+0x429f0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey}));

        if ((void($Derived::*)(char const*)){&$Derived::getStat} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat})
            m->registerHook(getBase()+0x3d310, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat}));

        if ((void($Derived::*)(char const*)){&$Derived::hasPendingUserCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin})
            m->registerHook(getBase()+0x42730, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin}));

        if ((void($Derived::*)(char const*)){&$Derived::hasSecretCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin})
            m->registerHook(getBase()+0x40730, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin}));

        if ((void($Derived::*)(char const*)){&$Derived::hasUserCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin})
            m->registerHook(getBase()+0x427e0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin}));

        if ((void($Derived::*)(char const*)){&$Derived::incrementStat} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat})
            m->registerHook(getBase()+0x3d6d0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat}));

        if ((void($Derived::*)(char const*, int)){&$Derived::incrementStat} != (void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat})
            m->registerHook(getBase()+0x3d6e0, extract_virtual(this, (void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat}));

        if ((void($Derived::*)(char const*)){&$Derived::storePendingUserCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin})
            m->registerHook(getBase()+0x42940, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin}));

        if ((void($Derived::*)(char const*)){&$Derived::storeSecretCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin})
            m->registerHook(getBase()+0x42a10, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin}));

        if ((void($Derived::*)(char const*)){&$Derived::storeUserCoin} != (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin})
            m->registerHook(getBase()+0x42890, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin}));
    }
};


template <class $Derived>
class $GameToolbox : public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameToolbox* __thistype;

    virtual void multipliedColorValue(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x28cb90))(this, p0, p1, p2);
    }

    virtual void stringSetupToDict(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d700))(this, p0, p1);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, float, float, float)>(m->getOriginal(getBase()+0x28c930))(this, p0, p1, p2, p3);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x28c950))(this, p0, p1);
    }

    virtual void stringSetupToMap(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d4c0))(this, p0, p1);
    }

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x28bdd0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$Derived::multipliedColorValue} != (void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue})
            m->registerHook(getBase()+0x28cb90, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue}));

        if ((void($Derived::*)(std::string, char const*)){&$Derived::stringSetupToDict} != (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict})
            m->registerHook(getBase()+0x28d700, extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&, float, float, float)){&$Derived::transformColor} != (void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor})
            m->registerHook(getBase()+0x28c930, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$Derived::transformColor} != (void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor})
            m->registerHook(getBase()+0x28c950, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor}));

        if ((void($Derived::*)(std::string, char const*)){&$Derived::stringSetupToMap} != (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap})
            m->registerHook(getBase()+0x28d4c0, extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap}));

        if ((void($Derived::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$Derived::createToggleButton} != (void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton})
            m->registerHook(getBase()+0x28bdd0, extract_virtual(this, (void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton}));
    }
};


template <class $Derived>
class $GravityEffectSprite : public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GravityEffectSprite* __thistype;

    virtual void updateSpritesColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::updateSpritesColor} != (void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor})
            m->registerHook(getBase()+0x7ce30, extract_virtual(this, (void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor}));
    }
};


template <class $Derived>
class $GroupCommandObject : public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GroupCommandObject* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x16ece0))(this, p0);
    }

    virtual void easeToText(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
    }

    virtual void getEasedAction(cocos2d::CCActionInterval* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, int, float)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
    }

    virtual void runMoveCommand(cocos2d::CCPoint p0, float p1, int p2, float p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, int, float, bool, bool)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runRotateCommand(float p0, float p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, bool)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString})
            m->registerHook(getBase()+0x16ece0, extract_virtual(this, (void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString}));

        if ((void($Derived::*)(int)){&$Derived::easeToText} != (void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText})
            m->registerHook(getBase()+0x16ecb0, extract_virtual(this, (void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText}));

        if ((void($Derived::*)(cocos2d::CCActionInterval*, int, float)){&$Derived::getEasedAction} != (void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction})
            m->registerHook(getBase()+0x16e7b0, extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction}));

        if ((void($Derived::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$Derived::runMoveCommand} != (void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand})
            m->registerHook(getBase()+0x16e640, extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand}));

        if ((void($Derived::*)(float, float, int, float, bool)){&$Derived::runRotateCommand} != (void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand})
            m->registerHook(getBase()+0x16e8f0, extract_virtual(this, (void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand}));
    }
};


template <class $Derived>
class $HardStreak : public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef HardStreak* __thistype;

    virtual void addPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x5c950))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::addPoint} != (void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint})
            m->registerHook(getBase()+0x5c950, extract_virtual(this, (void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint}));
    }
};


template <class $Derived>
class $LabelGameObject : public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LabelGameObject* __thistype;

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setObjectColor} != (void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor})
            m->registerHook(getBase()+0xdbca0, extract_virtual(this, (void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor}));
    }
};


template <class $Derived>
class $LevelEditorLayer : public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelEditorLayer* __thistype;

    virtual void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x92230))(this, p0);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x91010))(this, p0);
    }

    virtual void objectMoved(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x999f0))(this, p0);
    }

    virtual void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
    }

    virtual void stopTriggersInGroup(int p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
    }

    virtual void toggleGroupPreview(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
    }

    virtual void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
    }

    virtual GameObject* addObjectFromString(std::string p0) {
        return reinterpret_cast<GameObject*(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x94640))(this, p0);
    }

    virtual void createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
    }

    virtual void createObjectsFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
    }

    virtual int getNextFreeGroupID(cocos2d::CCArray* p0) {
        return reinterpret_cast<int(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
    }

    virtual void handleAction(bool p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
    }

    virtual void removeObject(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, float, float, float)){&$Derived::activateTriggerEffect} != (void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect})
            m->registerHook(getBase()+0x9b520, extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect}));

        if ((void($Derived::*)(GameObject*, float, bool)){&$Derived::animateInDualGround} != (void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround})
            m->registerHook(getBase()+0xa2780, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround}));

        if ((void($Derived::*)(PlayerObject*, float)){&$Derived::checkCollisions} != (void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions})
            m->registerHook(getBase()+0x9e620, extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions}));

        if ((void($Derived::*)(std::string)){&$Derived::createObjectsFromSetup} != (void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup})
            m->registerHook(getBase()+0x92230, extract_virtual(this, (void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup}));

        if ((void($Derived::*)(GJGameLevel*)){&$Derived::init} != (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init})
            m->registerHook(getBase()+0x91010, extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init}));

        if ((void($Derived::*)(GameObject*)){&$Derived::objectMoved} != (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved})
            m->registerHook(getBase()+0x999f0, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved}));

        if ((void($Derived::*)(EffectGameObject*, int, float, float, bool)){&$Derived::runColorEffect} != (void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect})
            m->registerHook(getBase()+0x9bd30, extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect}));

        if ((void($Derived::*)(LevelSettingsObject*)){&$Derived::setupLevelStart} != (void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart})
            m->registerHook(getBase()+0xa0ca0, extract_virtual(this, (void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart}));

        if ((void($Derived::*)(int, float)){&$Derived::stopTriggersInGroup} != (void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup})
            m->registerHook(getBase()+0x9c030, extract_virtual(this, (void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup}));

        if ((void($Derived::*)(GameObject*, bool, PlayerObject*, bool)){&$Derived::toggleDualMode} != (void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode})
            m->registerHook(getBase()+0xa0200, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode}));

        if ((void($Derived::*)(int, bool)){&$Derived::toggleGroupPreview} != (void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview})
            m->registerHook(getBase()+0x9bea0, extract_virtual(this, (void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview}));

        if ((void($Derived::*)(GJEffectManager*, GJEffectManager*)){&$Derived::transferDefaultColors} != (void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors})
            m->registerHook(getBase()+0x9ab50, extract_virtual(this, (void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors}));

        if ((void($Derived::*)(float)){&$Derived::update} != (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update})
            m->registerHook(getBase()+0xa1b70, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update}));

        if ((void($Derived::*)(PlayerObject*, int, bool)){&$Derived::updateDualGround} != (void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround})
            m->registerHook(getBase()+0xa1a60, extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround}));

        if ((GameObject*($Derived::*)(std::string)){&$Derived::addObjectFromString} != (GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString})
            m->registerHook(getBase()+0x94640, extract_virtual(this, (GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString}));

        if ((void($Derived::*)(int, cocos2d::CCPoint, bool)){&$Derived::createObject} != (void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject})
            m->registerHook(getBase()+0x957c0, extract_virtual(this, (void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject}));

        if ((void($Derived::*)(std::string, bool)){&$Derived::createObjectsFromString} != (void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString})
            m->registerHook(getBase()+0x94730, extract_virtual(this, (void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString}));

        if ((int($Derived::*)(cocos2d::CCArray*)){&$Derived::getNextFreeGroupID} != (int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID})
            m->registerHook(getBase()+0x9a1b0, extract_virtual(this, (int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID}));

        if ((void($Derived::*)(bool, cocos2d::CCArray*)){&$Derived::handleAction} != (void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction})
            m->registerHook(getBase()+0x97020, extract_virtual(this, (void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction}));

        if ((void($Derived::*)(GameObject*, bool)){&$Derived::removeObject} != (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject})
            m->registerHook(getBase()+0x96890, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject}));
    }
};


template <class $Derived>
class $LevelSettingsLayer : public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelSettingsLayer* __thistype;

    virtual void create(LevelSettingsObject* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa7c30))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(LevelSettingsObject*, LevelEditorLayer*)){&$Derived::create} != (void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create})
            m->registerHook(getBase()+0xa7c30, extract_virtual(this, (void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create}));
    }
};


template <class $Derived>
class $LevelSettingsObject : public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelSettingsObject* __thistype;

    virtual void objectFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa5810))(this, p0);
    }

    virtual void objectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x945a0))(this, p0);
    }

    virtual void setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCDictionary*)){&$Derived::objectFromDict} != (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict})
            m->registerHook(getBase()+0xa5810, extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict}));

        if ((void($Derived::*)(std::string)){&$Derived::objectFromString} != (void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString})
            m->registerHook(getBase()+0x945a0, extract_virtual(this, (void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString}));

        if ((void($Derived::*)(cocos2d::CCDictionary*)){&$Derived::setupColorsFromLegacyMode} != (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode})
            m->registerHook(getBase()+0xa6a30, extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode}));
    }
};


template <class $Derived>
class $LevelTools : public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelTools* __thistype;

    virtual void getAudioString(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x293880))(this, p0);
    }

    virtual void verifyLevelIntegrity(std::string p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, int)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
    }

    virtual void xPosForTime(float p0, cocos2d::CCArray* p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCArray*, int)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::getAudioString} != (void($LevelTools::*)(int)){&$LevelTools::getAudioString})
            m->registerHook(getBase()+0x293880, extract_virtual(this, (void($LevelTools::*)(int)){&$LevelTools::getAudioString}));

        if ((void($Derived::*)(std::string, int)){&$Derived::verifyLevelIntegrity} != (void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity})
            m->registerHook(getBase()+0x294360, extract_virtual(this, (void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity}));

        if ((void($Derived::*)(float, cocos2d::CCArray*, int)){&$Derived::xPosForTime} != (void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime})
            m->registerHook(getBase()+0x293d90, extract_virtual(this, (void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime}));
    }
};


template <class $Derived>
class $MenuGameLayer : public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MenuGameLayer* __thistype;

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::update} != (void($MenuGameLayer::*)(float)){&$MenuGameLayer::update})
            m->registerHook(getBase()+0x28fa70, extract_virtual(this, (void($MenuGameLayer::*)(float)){&$MenuGameLayer::update}));
    }
};


template <class $Derived>
class $MusicDownloadManager : public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MusicDownloadManager* __thistype;

    virtual void incrementPriorityForSong(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::incrementPriorityForSong} != (void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong})
            m->registerHook(getBase()+0x2ef750, extract_virtual(this, (void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong}));
    }
};


template <class $Derived>
class $OBB2D : public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef OBB2D* __thistype;

    virtual void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
    }

    virtual void create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a890))(this, p0, p1, p2, p3);
    }

    virtual void overlaps1Way(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCPoint, float, float, float)){&$Derived::calculateWithCenter} != (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter})
            m->registerHook(getBase()+0x35a9c0, extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter}));

        if ((void($Derived::*)(cocos2d::CCPoint, float, float, float)){&$Derived::create} != (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create})
            m->registerHook(getBase()+0x35a890, extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create}));

        if ((void($Derived::*)(OBB2D*)){&$Derived::overlaps1Way} != (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way})
            m->registerHook(getBase()+0x35b0d0, extract_virtual(this, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way}));
    }
};


template <class $Derived>
class $ObjectToolbox : public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ObjectToolbox* __thistype;

    virtual c_string intKeyToFrame(int p0) {
        return reinterpret_cast<c_string(*)(decltype(this), int)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
    }

    void apply_hooks() override {
        if ((c_string($Derived::*)(int)){&$Derived::intKeyToFrame} != (c_string($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame})
            m->registerHook(getBase()+0x4173b0, extract_virtual(this, (c_string($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame}));
    }
};


template <class $Derived>
class $OpacityEffectAction : public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef OpacityEffectAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x178c10))(this, p0);
    }

    virtual void step(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x178b90))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString})
            m->registerHook(getBase()+0x178c10, extract_virtual(this, (void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString}));

        if ((void($Derived::*)(float)){&$Derived::step} != (void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step})
            m->registerHook(getBase()+0x178b90, extract_virtual(this, (void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step}));
    }
};


template <class $Derived>
class $PauseLayer : public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PauseLayer* __thistype;

    virtual void create(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x20b1e0))(this, p0);
    }

    virtual void onEdit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x20c630))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool)){&$Derived::create} != (void($PauseLayer::*)(bool)){&$PauseLayer::create})
            m->registerHook(getBase()+0x20b1e0, extract_virtual(this, (void($PauseLayer::*)(bool)){&$PauseLayer::create}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onEdit} != (void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit})
            m->registerHook(getBase()+0x20c630, extract_virtual(this, (void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit}));
    }
};


template <class $Derived>
class $PlayLayer : public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayLayer* __thistype;

    virtual void addCircle(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
    }

    virtual void addObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x70e50))(this, p0);
    }

    virtual void addToGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77680))(this, p0);
    }

    virtual void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
    }

    virtual void animateInGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
    }

    virtual void animateOutGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6f350))(this, p0);
    }

    virtual void applyEnterEffect(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c310))(this, p0);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void cameraMoveX(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
    }

    virtual void cameraMoveY(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
    }

    virtual void claimParticle(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
    }

    virtual void colorObject(int p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
    }

    virtual void create(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b590))(this, p0);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x6d130))(this, p0);
    }

    virtual void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
    }

    virtual void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
    }

    virtual void enterDualMode(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
    }

    virtual void exitBirdMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
    }

    virtual void exitDartMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
    }

    virtual void exitFlyMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
    }

    virtual void exitRobotMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de20))(this, p0);
    }

    virtual void exitRollMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de60))(this, p0);
    }

    virtual void exitSpiderMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de40))(this, p0);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
    }

    virtual void getOtherPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
    }

    virtual void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
    }

    virtual void getParticleKey2(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x767b0))(this, p0);
    }

    virtual void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
    }

    virtual void hasItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
    }

    virtual void hasUniqueCoin(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77510))(this, p0);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void loadFromCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7f000))(this, p0);
    }

    virtual void loadSavedObjectsState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
    }

    virtual void moveCameraToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x7c980))(this, p0);
    }

    virtual void pauseGame(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x802d0))(this, p0);
    }

    virtual void pickupItem(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
    }

    virtual void playAnimationCommand(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
    }

    virtual void playEndAnimationToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x759a0))(this, p0);
    }

    virtual void playExitDualEffect(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
    }

    virtual void playFlashEffect(float p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
    }

    virtual void playGravityEffect(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
    }

    virtual void playSpeedParticle(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77030))(this, p0);
    }

    virtual void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
    }

    virtual void recordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
    }

    virtual void registerActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77620))(this, p0);
    }

    virtual void registerStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777b0))(this, p0);
    }

    virtual void removeFromGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77750))(this, p0);
    }

    virtual void saveRecordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
    }

    virtual void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b500))(this, p0);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0x6f560))(this, p0);
    }

    virtual void setupReplay(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
    }

    virtual void shakeCamera(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x771b0))(this, p0);
    }

    virtual void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
    }

    virtual void storeCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
    }

    virtual void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
    }

    virtual void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
    }

    virtual void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
    }

    virtual void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
    }

    virtual void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d120))(this, p0);
    }

    virtual void timeForXPos2(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
    }

    virtual void toggleBGEffectVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
    }

    virtual void toggleFlipped(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
    }

    virtual void toggleGhostEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
    }

    virtual void toggleGlitter(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x70e00))(this, p0);
    }

    virtual void togglePracticeMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
    }

    virtual void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
    }

    virtual void unregisterActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77660))(this, p0);
    }

    virtual void unregisterStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777f0))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77900))(this, p0);
    }

    virtual void updateCamera(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
    }

    virtual void updateReplay(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x78b60))(this, p0);
    }

    virtual void updateTimeMod(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
    }

    virtual void willSwitchToMode(int p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
    }

    virtual void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d140))(this, p0);
    }

    virtual void circleWaveWillBeRemoved(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e110))(this, p0);
    }

    virtual void currencyWillExit(CurrencyRewardLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(getBase()+0x7e070))(this, p0);
    }

    virtual void dialogClosed(DialogLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(CCCircleWave*)){&$Derived::addCircle} != (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle})
            m->registerHook(getBase()+0x7e0f0, extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle}));

        if ((void($Derived::*)(GameObject*)){&$Derived::addObject} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject})
            m->registerHook(getBase()+0x70e50, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject}));

        if ((void($Derived::*)(GameObject*)){&$Derived::addToGroupOld} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld})
            m->registerHook(getBase()+0x77680, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld}));

        if ((void($Derived::*)(GameObject*)){&$Derived::addToSpeedObjects} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects})
            m->registerHook(getBase()+0x7cfc0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects}));

        if ((void($Derived::*)(GameObject*, float, bool)){&$Derived::animateInDualGround} != (void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround})
            m->registerHook(getBase()+0x7d710, extract_virtual(this, (void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround}));

        if ((void($Derived::*)(bool)){&$Derived::animateInGround} != (void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround})
            m->registerHook(getBase()+0x7d9d0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround}));

        if ((void($Derived::*)(bool)){&$Derived::animateOutGround} != (void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround})
            m->registerHook(getBase()+0x6f350, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround}));

        if ((void($Derived::*)(GameObject*)){&$Derived::applyEnterEffect} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect})
            m->registerHook(getBase()+0x7c310, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect}));

        if ((void($Derived::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$Derived::calculateColorValues} != (void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues})
            m->registerHook(getBase()+0x7aa10, extract_virtual(this, (void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues}));

        if ((void($Derived::*)(float, float, float)){&$Derived::cameraMoveX} != (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX})
            m->registerHook(getBase()+0x7cbe0, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX}));

        if ((void($Derived::*)(float, float, float)){&$Derived::cameraMoveY} != (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY})
            m->registerHook(getBase()+0x7cc60, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY}));

        if ((void($Derived::*)(PlayerObject*, float)){&$Derived::checkCollisions} != (void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions})
            m->registerHook(getBase()+0x78c90, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions}));

        if ((void($Derived::*)(std::string)){&$Derived::claimParticle} != (void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle})
            m->registerHook(getBase()+0x76ba0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle}));

        if ((void($Derived::*)(int, cocos2d::_ccColor3B)){&$Derived::colorObject} != (void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject})
            m->registerHook(getBase()+0x77810, extract_virtual(this, (void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject}));

        if ((void($Derived::*)(GJGameLevel*)){&$Derived::create} != (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::create})
            m->registerHook(getBase()+0x6b590, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::create}));

        if ((void($Derived::*)(std::string)){&$Derived::createObjectsFromSetup} != (void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup})
            m->registerHook(getBase()+0x6d130, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup}));

        if ((void($Derived::*)(int, char const*, int, cocos2d::tCCPositionType)){&$Derived::createParticle} != (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle})
            m->registerHook(getBase()+0x76800, extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle}));

        if ((void($Derived::*)(PlayerObject*, GameObject*)){&$Derived::destroyPlayer} != (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer})
            m->registerHook(getBase()+0x7ab80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer}));

        if ((void($Derived::*)(GameObject*, bool)){&$Derived::enterDualMode} != (void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode})
            m->registerHook(getBase()+0x7d6a0, extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitBirdMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode})
            m->registerHook(getBase()+0x7dd80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitDartMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode})
            m->registerHook(getBase()+0x7ddd0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitFlyMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode})
            m->registerHook(getBase()+0x7dcf0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitRobotMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode})
            m->registerHook(getBase()+0x7de20, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitRollMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode})
            m->registerHook(getBase()+0x7de60, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::exitSpiderMode} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode})
            m->registerHook(getBase()+0x7de40, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode}));

        if ((void($Derived::*)(PlayerObject*, bool, bool)){&$Derived::flipGravity} != (void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity})
            m->registerHook(getBase()+0x7cd10, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::getOtherPlayer} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer})
            m->registerHook(getBase()+0x7dcc0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer}));

        if ((void($Derived::*)(int, char const*, int, cocos2d::tCCPositionType)){&$Derived::getParticleKey} != (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey})
            m->registerHook(getBase()+0x764d0, extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey}));

        if ((void($Derived::*)(std::string)){&$Derived::getParticleKey2} != (void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2})
            m->registerHook(getBase()+0x767b0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2}));

        if ((void($Derived::*)(cocos2d::CCPoint, float, float, float)){&$Derived::getRelativeMod} != (void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod})
            m->registerHook(getBase()+0x7c2a0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod}));

        if ((void($Derived::*)(int)){&$Derived::hasItem} != (void($PlayLayer::*)(int)){&$PlayLayer::hasItem})
            m->registerHook(getBase()+0x7cee0, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::hasItem}));

        if ((void($Derived::*)(GameObject*)){&$Derived::hasUniqueCoin} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin})
            m->registerHook(getBase()+0x77510, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin}));

        if ((void($Derived::*)(GJGameLevel*)){&$Derived::init} != (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init})
            m->registerHook(getBase()+0x6b5f0, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init}));

        if ((void($Derived::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$Derived::lightningFlash} != (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash})
            m->registerHook(getBase()+0x75bf0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash}));

        if ((void($Derived::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$Derived::lightningFlash} != (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash})
            m->registerHook(getBase()+0x75cc0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash}));

        if ((void($Derived::*)(CheckpointObject*)){&$Derived::loadFromCheckpoint} != (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint})
            m->registerHook(getBase()+0x7f000, extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint}));

        if ((void($Derived::*)(std::string)){&$Derived::loadSavedObjectsState} != (void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState})
            m->registerHook(getBase()+0x7f3d0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState}));

        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::moveCameraToPos} != (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos})
            m->registerHook(getBase()+0x7c980, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos}));

        if ((void($Derived::*)(bool)){&$Derived::pauseGame} != (void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame})
            m->registerHook(getBase()+0x802d0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame}));

        if ((void($Derived::*)(GameObject*)){&$Derived::pickupItem} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem})
            m->registerHook(getBase()+0x7c1d0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem}));

        if ((void($Derived::*)(int, int)){&$Derived::playAnimationCommand} != (void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand})
            m->registerHook(getBase()+0x75930, extract_virtual(this, (void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand}));

        if ((void($Derived::*)(cocos2d::CCPoint)){&$Derived::playEndAnimationToPos} != (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos})
            m->registerHook(getBase()+0x759a0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::playExitDualEffect} != (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect})
            m->registerHook(getBase()+0x7d1d0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect}));

        if ((void($Derived::*)(float, int, float)){&$Derived::playFlashEffect} != (void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect})
            m->registerHook(getBase()+0x75e50, extract_virtual(this, (void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect}));

        if ((void($Derived::*)(bool)){&$Derived::playGravityEffect} != (void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect})
            m->registerHook(getBase()+0x7b5a0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect}));

        if ((void($Derived::*)(float)){&$Derived::playSpeedParticle} != (void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle})
            m->registerHook(getBase()+0x77030, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle}));

        if ((void($Derived::*)(PlayerObject*, GameObject*)){&$Derived::playerWillSwitchMode} != (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode})
            m->registerHook(getBase()+0x7b820, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode}));

        if ((void($Derived::*)(bool, PlayerObject*)){&$Derived::recordAction} != (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction})
            m->registerHook(getBase()+0x7e190, extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction}));

        if ((void($Derived::*)(GameObject*)){&$Derived::registerActiveObject} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject})
            m->registerHook(getBase()+0x77620, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject}));

        if ((void($Derived::*)(GameObject*)){&$Derived::registerStateObject} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject})
            m->registerHook(getBase()+0x777b0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject}));

        if ((void($Derived::*)(GameObject*)){&$Derived::removeFromGroupOld} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld})
            m->registerHook(getBase()+0x77750, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld}));

        if ((void($Derived::*)(bool, PlayerObject*)){&$Derived::saveRecordAction} != (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction})
            m->registerHook(getBase()+0x78750, extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction}));

        if ((void($Derived::*)(GJGameLevel*)){&$Derived::scene} != (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene})
            m->registerHook(getBase()+0x6b500, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene}));

        if ((void($Derived::*)(LevelSettingsObject*)){&$Derived::setupLevelStart} != (void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart})
            m->registerHook(getBase()+0x6f560, extract_virtual(this, (void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart}));

        if ((void($Derived::*)(std::string)){&$Derived::setupReplay} != (void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay})
            m->registerHook(getBase()+0x7e1e0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay}));

        if ((void($Derived::*)(float, float, float)){&$Derived::shakeCamera} != (void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera})
            m->registerHook(getBase()+0x744a0, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera}));

        if ((void($Derived::*)(int)){&$Derived::shouldBlend} != (void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend})
            m->registerHook(getBase()+0x771b0, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend}));

        if ((void($Derived::*)(bool, int, int, bool, bool, bool)){&$Derived::showNewBest} != (void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest})
            m->registerHook(getBase()+0x74580, extract_virtual(this, (void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest}));

        if ((void($Derived::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$Derived::spawnParticle} != (void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle})
            m->registerHook(getBase()+0x76330, extract_virtual(this, (void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle}));

        if ((void($Derived::*)(CheckpointObject*)){&$Derived::storeCheckpoint} != (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint})
            m->registerHook(getBase()+0x7ef10, extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint}));

        if ((void($Derived::*)(PlayerObject*, GameObject*, bool, int)){&$Derived::switchToFlyMode} != (void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode})
            m->registerHook(getBase()+0x7baf0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode}));

        if ((void($Derived::*)(PlayerObject*, GameObject*, bool)){&$Derived::switchToRobotMode} != (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode})
            m->registerHook(getBase()+0x7bc80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode}));

        if ((void($Derived::*)(PlayerObject*, GameObject*, bool)){&$Derived::switchToRollMode} != (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode})
            m->registerHook(getBase()+0x7bbe0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode}));

        if ((void($Derived::*)(PlayerObject*, GameObject*, bool)){&$Derived::switchToSpiderMode} != (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode})
            m->registerHook(getBase()+0x7bd20, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode}));

        if ((void($Derived::*)(float)){&$Derived::timeForXPos} != (void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos})
            m->registerHook(getBase()+0x7d120, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos}));

        if ((void($Derived::*)(float, bool)){&$Derived::timeForXPos2} != (void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2})
            m->registerHook(getBase()+0x293eb0, extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2}));

        if ((void($Derived::*)(bool)){&$Derived::toggleBGEffectVisibility} != (void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility})
            m->registerHook(getBase()+0x7fe80, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility}));

        if ((void($Derived::*)(GameObject*, bool, PlayerObject*, bool)){&$Derived::toggleDualMode} != (void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode})
            m->registerHook(getBase()+0x7bf90, extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode}));

        if ((void($Derived::*)(bool, bool)){&$Derived::toggleFlipped} != (void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped})
            m->registerHook(getBase()+0x7bdc0, extract_virtual(this, (void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped}));

        if ((void($Derived::*)(int)){&$Derived::toggleGhostEffect} != (void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect})
            m->registerHook(getBase()+0x7fe40, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect}));

        if ((void($Derived::*)(bool)){&$Derived::toggleGlitter} != (void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter})
            m->registerHook(getBase()+0x70e00, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter}));

        if ((void($Derived::*)(bool)){&$Derived::togglePracticeMode} != (void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode})
            m->registerHook(getBase()+0x7f9e0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode}));

        if ((void($Derived::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$Derived::unclaimParticle} != (void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle})
            m->registerHook(getBase()+0x76e00, extract_virtual(this, (void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle}));

        if ((void($Derived::*)(GameObject*)){&$Derived::unregisterActiveObject} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject})
            m->registerHook(getBase()+0x77660, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject}));

        if ((void($Derived::*)(GameObject*)){&$Derived::unregisterStateObject} != (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject})
            m->registerHook(getBase()+0x777f0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject}));

        if ((void($Derived::*)(float)){&$Derived::update} != (void($PlayLayer::*)(float)){&$PlayLayer::update})
            m->registerHook(getBase()+0x77900, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::update}));

        if ((void($Derived::*)(float)){&$Derived::updateCamera} != (void($PlayLayer::*)(float)){&$PlayLayer::updateCamera})
            m->registerHook(getBase()+0x6e2b0, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateCamera}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$Derived::updateColor} != (void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor})
            m->registerHook(getBase()+0x7c7f0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor}));

        if ((void($Derived::*)(PlayerObject*, int, bool)){&$Derived::updateDualGround} != (void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround})
            m->registerHook(getBase()+0x7caa0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround}));

        if ((void($Derived::*)(float)){&$Derived::updateReplay} != (void($PlayLayer::*)(float)){&$PlayLayer::updateReplay})
            m->registerHook(getBase()+0x78b60, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateReplay}));

        if ((void($Derived::*)(float, bool)){&$Derived::updateTimeMod} != (void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod})
            m->registerHook(getBase()+0x786f0, extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod}));

        if ((void($Derived::*)(float, char const*)){&$Derived::updateTweenAction} != (void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction})
            m->registerHook(getBase()+0x7ffb0, extract_virtual(this, (void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction}));

        if ((void($Derived::*)(int, PlayerObject*)){&$Derived::willSwitchToMode} != (void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode})
            m->registerHook(getBase()+0x7b9e0, extract_virtual(this, (void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode}));

        if ((void($Derived::*)(float)){&$Derived::xPosForTime} != (void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime})
            m->registerHook(getBase()+0x7d140, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime}));

        if ((void($Derived::*)(CCCircleWave*)){&$Derived::circleWaveWillBeRemoved} != (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved})
            m->registerHook(getBase()+0x7e110, extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved}));

        if ((void($Derived::*)(CurrencyRewardLayer*)){&$Derived::currencyWillExit} != (void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit})
            m->registerHook(getBase()+0x7e070, extract_virtual(this, (void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit}));

        if ((void($Derived::*)(DialogLayer*)){&$Derived::dialogClosed} != (void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed})
            m->registerHook(getBase()+0x7e0b0, extract_virtual(this, (void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed}));
    }
};


template <class $Derived>
class $PlayerObject : public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayerObject* __thistype;

    virtual void addToTouchedRings(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22b800))(this, p0);
    }

    virtual void boostPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
    }

    virtual void bumpPlayer(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
    }

    virtual void buttonDown(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
    }

    virtual void checkSnapJumpToObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
    }

    virtual void collidedWithObject(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
    }

    virtual void collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
    }

    virtual void collidedWithSlope(float p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, bool)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
    }

    virtual void convertToClosestRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21c860))(this, p0);
    }

    virtual void copyAttributes(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
    }

    virtual void create(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x217260))(this, p0, p1, p2);
    }

    virtual void deactivateStreak(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218b30))(this, p0);
    }

    virtual void fadeOutStreak2(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x225890))(this, p0);
    }

    virtual void flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
    }

    virtual void flipGravity(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
    }

    virtual void getOldPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a830))(this, p0);
    }

    virtual void hitGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x220a30))(this, p0);
    }

    virtual void init(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
    }

    virtual void isBoostValid(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d650))(this, p0);
    }

    virtual void isSafeFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
    }

    virtual void isSafeMode(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
    }

    virtual void isSafeSpiderFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221be0))(this, p0);
    }

    virtual void loadFromCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e420))(this, p0);
    }

    virtual void playerDestroyed(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
    }

    virtual void postCollision(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
    }

    virtual void preSlopeCollision(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
    }

    virtual void propellPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
    }

    virtual void pushButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
    }

    virtual void pushPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
    }

    virtual void releaseButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
    }

    virtual void ringJump(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
    }

    virtual void runBallRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
    }

    virtual void runRotateAction(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c570))(this, p0);
    }

    virtual void saveToCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
    }

    virtual void setFlipX(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e720))(this, p0);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e870))(this, p0);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e830))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x219610))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
    }

    virtual void spawnFromPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
    }

    virtual void spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
    }

    virtual void spiderTestJump(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21b160))(this, p0);
    }

    virtual void startDashing(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x221d70))(this, p0);
    }

    virtual void stopRotation(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c830))(this, p0);
    }

    virtual void storeCollision(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
    }

    virtual void switchedToMode(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
    }

    virtual void testForMoving(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
    }

    virtual void toggleBirdMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224070))(this, p0);
    }

    virtual void toggleDartMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
    }

    virtual void toggleFlyMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223820))(this, p0);
    }

    virtual void toggleGhostEffect(GhostType p0) {
        return reinterpret_cast<void(*)(decltype(this), GhostType)>(m->getOriginal(getBase()+0x225000))(this, p0);
    }

    virtual void togglePlayerScale(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
    }

    virtual void toggleRobotMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223c70))(this, p0);
    }

    virtual void toggleRollMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223b20))(this, p0);
    }

    virtual void toggleSpiderMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224830))(this, p0);
    }

    virtual void toggleVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
    }

    virtual void touchedObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22e660))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
    }

    virtual void updateCheckpointMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218980))(this, p0);
    }

    virtual void updateCollide(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
    }

    virtual void updateCollideBottom(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
    }

    virtual void updateCollideTop(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
    }

    virtual void updateJump(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x219680))(this, p0);
    }

    virtual void updatePlayerBirdFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
    }

    virtual void updatePlayerDartFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c260))(this, p0);
    }

    virtual void updatePlayerFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c470))(this, p0);
    }

    virtual void updatePlayerRobotFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d620))(this, p0);
    }

    virtual void updatePlayerRollFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
    }

    virtual void updatePlayerShipFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
    }

    virtual void updatePlayerSpiderFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d650))(this, p0);
    }

    virtual void updatePlayerSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218440))(this, p0);
    }

    virtual void updateRotation(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
    }

    virtual void updateRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
    }

    virtual void updateShipRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221310))(this, p0);
    }

    virtual void updateShipSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218510))(this, p0);
    }

    virtual void updateSlopeRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221030))(this, p0);
    }

    virtual void updateSlopeYVelocity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e920))(this, p0);
    }

    virtual void updateSpecial(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a790))(this, p0);
    }

    virtual void updateTimeMod(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
    }

    virtual void animationFinished(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x22d400))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GameObject*)){&$Derived::addToTouchedRings} != (void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings})
            m->registerHook(getBase()+0x22b800, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings}));

        if ((void($Derived::*)(float)){&$Derived::boostPlayer} != (void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer})
            m->registerHook(getBase()+0x21d6b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer}));

        if ((void($Derived::*)(float, int)){&$Derived::bumpPlayer} != (void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer})
            m->registerHook(getBase()+0x22d890, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer}));

        if ((void($Derived::*)(PlayerButton)){&$Derived::buttonDown} != (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown})
            m->registerHook(getBase()+0x22b7e0, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown}));

        if ((void($Derived::*)(GameObject*)){&$Derived::checkSnapJumpToObject} != (void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject})
            m->registerHook(getBase()+0x2217f0, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject}));

        if ((void($Derived::*)(float, GameObject*)){&$Derived::collidedWithObject} != (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject})
            m->registerHook(getBase()+0x21d880, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject}));

        if ((void($Derived::*)(float, GameObject*, cocos2d::CCRect)){&$Derived::collidedWithObject} != (void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject})
            m->registerHook(getBase()+0x21f0b0, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject}));

        if ((void($Derived::*)(float, GameObject*, bool)){&$Derived::collidedWithSlope} != (void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope})
            m->registerHook(getBase()+0x21d8d0, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope}));

        if ((void($Derived::*)(float)){&$Derived::convertToClosestRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation})
            m->registerHook(getBase()+0x21c860, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::copyAttributes} != (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes})
            m->registerHook(getBase()+0x22dc70, extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes}));

        if ((void($Derived::*)(int, int, cocos2d::CCLayer*)){&$Derived::create} != (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create})
            m->registerHook(getBase()+0x217260, extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create}));

        if ((void($Derived::*)(bool)){&$Derived::deactivateStreak} != (void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak})
            m->registerHook(getBase()+0x218b30, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak}));

        if ((void($Derived::*)(float)){&$Derived::fadeOutStreak2} != (void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2})
            m->registerHook(getBase()+0x225890, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2}));

        if ((void($Derived::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$Derived::flashPlayer} != (void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer})
            m->registerHook(getBase()+0x221c80, extract_virtual(this, (void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer}));

        if ((void($Derived::*)(bool, bool)){&$Derived::flipGravity} != (void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity})
            m->registerHook(getBase()+0x21c090, extract_virtual(this, (void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity}));

        if ((void($Derived::*)(float)){&$Derived::getOldPosition} != (void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition})
            m->registerHook(getBase()+0x21a830, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition}));

        if ((void($Derived::*)(bool)){&$Derived::hitGround} != (void($PlayerObject::*)(bool)){&$PlayerObject::hitGround})
            m->registerHook(getBase()+0x220a30, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::hitGround}));

        if ((void($Derived::*)(int, int, cocos2d::CCLayer*)){&$Derived::init} != (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init})
            m->registerHook(getBase()+0x2172e0, extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init}));

        if ((void($Derived::*)(float)){&$Derived::isBoostValid} != (void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid})
            m->registerHook(getBase()+0x21d650, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid}));

        if ((void($Derived::*)(float)){&$Derived::isSafeFlip} != (void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip})
            m->registerHook(getBase()+0x2209f0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip}));

        if ((void($Derived::*)(float)){&$Derived::isSafeMode} != (void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode})
            m->registerHook(getBase()+0x2209b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode}));

        if ((void($Derived::*)(float)){&$Derived::isSafeSpiderFlip} != (void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip})
            m->registerHook(getBase()+0x221be0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip}));

        if ((void($Derived::*)(PlayerCheckpoint*)){&$Derived::loadFromCheckpoint} != (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint})
            m->registerHook(getBase()+0x22e420, extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint}));

        if ((void($Derived::*)(bool)){&$Derived::playerDestroyed} != (void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed})
            m->registerHook(getBase()+0x2256d0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed}));

        if ((void($Derived::*)(float)){&$Derived::postCollision} != (void($PlayerObject::*)(float)){&$PlayerObject::postCollision})
            m->registerHook(getBase()+0x21cd10, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::postCollision}));

        if ((void($Derived::*)(float, GameObject*)){&$Derived::preSlopeCollision} != (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision})
            m->registerHook(getBase()+0x21ec80, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision}));

        if ((void($Derived::*)(float)){&$Derived::propellPlayer} != (void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer})
            m->registerHook(getBase()+0x22d8e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer}));

        if ((void($Derived::*)(PlayerButton)){&$Derived::pushButton} != (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton})
            m->registerHook(getBase()+0x22aa00, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton}));

        if ((void($Derived::*)(float)){&$Derived::pushPlayer} != (void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer})
            m->registerHook(getBase()+0x22dbb0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer}));

        if ((void($Derived::*)(PlayerButton)){&$Derived::releaseButton} != (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton})
            m->registerHook(getBase()+0x22b6f0, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton}));

        if ((void($Derived::*)(GameObject*)){&$Derived::ringJump} != (void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump})
            m->registerHook(getBase()+0x22abf0, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump}));

        if ((void($Derived::*)(float)){&$Derived::runBallRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation})
            m->registerHook(getBase()+0x21ca10, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation}));

        if ((void($Derived::*)(bool)){&$Derived::runRotateAction} != (void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction})
            m->registerHook(getBase()+0x21c570, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction}));

        if ((void($Derived::*)(PlayerCheckpoint*)){&$Derived::saveToCheckpoint} != (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint})
            m->registerHook(getBase()+0x22e2f0, extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint}));

        if ((void($Derived::*)(bool)){&$Derived::setFlipX} != (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX})
            m->registerHook(getBase()+0x22e720, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX}));

        if ((void($Derived::*)(bool)){&$Derived::setFlipY} != (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY})
            m->registerHook(getBase()+0x22e7b0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setPosition} != (void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition})
            m->registerHook(getBase()+0x22c8b0, extract_virtual(this, (void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition}));

        if ((void($Derived::*)(float)){&$Derived::setRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::setRotation})
            m->registerHook(getBase()+0x22e6e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setRotation}));

        if ((void($Derived::*)(float)){&$Derived::setScale} != (void($PlayerObject::*)(float)){&$PlayerObject::setScale})
            m->registerHook(getBase()+0x22e870, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScale}));

        if ((void($Derived::*)(float)){&$Derived::setScaleX} != (void($PlayerObject::*)(float)){&$PlayerObject::setScaleX})
            m->registerHook(getBase()+0x22e7f0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleX}));

        if ((void($Derived::*)(float)){&$Derived::setScaleY} != (void($PlayerObject::*)(float)){&$PlayerObject::setScaleY})
            m->registerHook(getBase()+0x22e830, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleY}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setSecondColor} != (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor})
            m->registerHook(getBase()+0x219610, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor}));

        if ((void($Derived::*)(bool)){&$Derived::setVisible} != (void($PlayerObject::*)(bool)){&$PlayerObject::setVisible})
            m->registerHook(getBase()+0x22e8b0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setVisible}));

        if ((void($Derived::*)(PlayerObject*)){&$Derived::spawnFromPlayer} != (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer})
            m->registerHook(getBase()+0x22dde0, extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer}));

        if ((void($Derived::*)(cocos2d::_ccColor3B, float)){&$Derived::spawnPortalCircle} != (void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle})
            m->registerHook(getBase()+0x225350, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle}));

        if ((void($Derived::*)(bool)){&$Derived::spiderTestJump} != (void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump})
            m->registerHook(getBase()+0x21b160, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump}));

        if ((void($Derived::*)(GameObject*)){&$Derived::startDashing} != (void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing})
            m->registerHook(getBase()+0x221d70, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing}));

        if ((void($Derived::*)(bool)){&$Derived::stopRotation} != (void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation})
            m->registerHook(getBase()+0x21c830, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation}));

        if ((void($Derived::*)(bool, int)){&$Derived::storeCollision} != (void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision})
            m->registerHook(getBase()+0x21cc60, extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision}));

        if ((void($Derived::*)(GameObjectType)){&$Derived::switchedToMode} != (void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode})
            m->registerHook(getBase()+0x22b9a0, extract_virtual(this, (void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode}));

        if ((void($Derived::*)(float, GameObject*)){&$Derived::testForMoving} != (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving})
            m->registerHook(getBase()+0x21eb70, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving}));

        if ((void($Derived::*)(bool)){&$Derived::toggleBirdMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode})
            m->registerHook(getBase()+0x224070, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode}));

        if ((void($Derived::*)(bool)){&$Derived::toggleDartMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode})
            m->registerHook(getBase()+0x2243f0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode}));

        if ((void($Derived::*)(bool)){&$Derived::toggleFlyMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode})
            m->registerHook(getBase()+0x223820, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode}));

        if ((void($Derived::*)(GhostType)){&$Derived::toggleGhostEffect} != (void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect})
            m->registerHook(getBase()+0x225000, extract_virtual(this, (void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect}));

        if ((void($Derived::*)(bool)){&$Derived::togglePlayerScale} != (void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale})
            m->registerHook(getBase()+0x224bd0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale}));

        if ((void($Derived::*)(bool)){&$Derived::toggleRobotMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode})
            m->registerHook(getBase()+0x223c70, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode}));

        if ((void($Derived::*)(bool)){&$Derived::toggleRollMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode})
            m->registerHook(getBase()+0x223b20, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode}));

        if ((void($Derived::*)(bool)){&$Derived::toggleSpiderMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode})
            m->registerHook(getBase()+0x224830, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode}));

        if ((void($Derived::*)(bool)){&$Derived::toggleVisibility} != (void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility})
            m->registerHook(getBase()+0x21abf0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility}));

        if ((void($Derived::*)(GameObject*)){&$Derived::touchedObject} != (void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject})
            m->registerHook(getBase()+0x22e660, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject}));

        if ((void($Derived::*)(float)){&$Derived::update} != (void($PlayerObject::*)(float)){&$PlayerObject::update})
            m->registerHook(getBase()+0x218bf0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::update}));

        if ((void($Derived::*)(bool)){&$Derived::updateCheckpointMode} != (void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode})
            m->registerHook(getBase()+0x218980, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode}));

        if ((void($Derived::*)(bool, int)){&$Derived::updateCollide} != (void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide})
            m->registerHook(getBase()+0x220f10, extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide}));

        if ((void($Derived::*)(float, int)){&$Derived::updateCollideBottom} != (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom})
            m->registerHook(getBase()+0x221790, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom}));

        if ((void($Derived::*)(float, int)){&$Derived::updateCollideTop} != (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop})
            m->registerHook(getBase()+0x221c20, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop}));

        if ((void($Derived::*)(float)){&$Derived::updateJump} != (void($PlayerObject::*)(float)){&$PlayerObject::updateJump})
            m->registerHook(getBase()+0x219680, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateJump}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerBirdFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame})
            m->registerHook(getBase()+0x22bfe0, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerDartFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame})
            m->registerHook(getBase()+0x22c260, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame})
            m->registerHook(getBase()+0x22c470, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerRobotFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame})
            m->registerHook(getBase()+0x22d620, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerRollFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame})
            m->registerHook(getBase()+0x22c6a0, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerShipFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame})
            m->registerHook(getBase()+0x22ba40, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame}));

        if ((void($Derived::*)(int)){&$Derived::updatePlayerSpiderFrame} != (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame})
            m->registerHook(getBase()+0x22d650, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame}));

        if ((void($Derived::*)(std::string)){&$Derived::updatePlayerSpriteExtra} != (void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra})
            m->registerHook(getBase()+0x218440, extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra}));

        if ((void($Derived::*)(float, float)){&$Derived::updateRotation} != (void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation})
            m->registerHook(getBase()+0x221230, extract_virtual(this, (void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation}));

        if ((void($Derived::*)(float)){&$Derived::updateRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::updateRotation})
            m->registerHook(getBase()+0x2214b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateRotation}));

        if ((void($Derived::*)(float)){&$Derived::updateShipRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation})
            m->registerHook(getBase()+0x221310, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation}));

        if ((void($Derived::*)(std::string)){&$Derived::updateShipSpriteExtra} != (void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra})
            m->registerHook(getBase()+0x218510, extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra}));

        if ((void($Derived::*)(float)){&$Derived::updateSlopeRotation} != (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation})
            m->registerHook(getBase()+0x221030, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation}));

        if ((void($Derived::*)(float)){&$Derived::updateSlopeYVelocity} != (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity})
            m->registerHook(getBase()+0x22e920, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity}));

        if ((void($Derived::*)(float)){&$Derived::updateSpecial} != (void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial})
            m->registerHook(getBase()+0x21a790, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial}));

        if ((void($Derived::*)(float)){&$Derived::updateTimeMod} != (void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod})
            m->registerHook(getBase()+0x2185e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod}));

        if ((void($Derived::*)(char const*)){&$Derived::animationFinished} != (void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished})
            m->registerHook(getBase()+0x22e9d0, extract_virtual(this, (void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setColor} != (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor})
            m->registerHook(getBase()+0x22cdf0, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor}));

        if ((void($Derived::*)(unsigned char)){&$Derived::setOpacity} != (void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity})
            m->registerHook(getBase()+0x22d400, extract_virtual(this, (void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity}));
    }
};


template <class $Derived>
class $PulseEffectAction : public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PulseEffectAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x179e90))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString})
            m->registerHook(getBase()+0x179e90, extract_virtual(this, (void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString}));
    }
};


template <class $Derived>
class $SetIDLayer : public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetIDLayer* __thistype;

    virtual void create(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x168f20))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GameObject*)){&$Derived::create} != (void($SetIDLayer::*)(GameObject*)){&$SetIDLayer::create})
            m->registerHook(getBase()+0x168f20, extract_virtual(this, (void($SetIDLayer::*)(GameObject*)){&$SetIDLayer::create}));
    }
};


template <class $Derived>
class $SetTargetIDLayer : public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetTargetIDLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1, std::string p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, std::string)>(m->getOriginal(getBase()+0x159d20))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$Derived::create} != (void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create})
            m->registerHook(getBase()+0x159d20, extract_virtual(this, (void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create}));
    }
};


template <class $Derived>
class $SetupAnimationPopup : public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupAnimationPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x208b70))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create})
            m->registerHook(getBase()+0x208b70, extract_virtual(this, (void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create}));
    }
};


template <class $Derived>
class $SetupCollisionTriggerPopup : public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupCollisionTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1d6120))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create})
            m->registerHook(getBase()+0x1d6120, extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create}));
    }
};


template <class $Derived>
class $SetupCountTriggerPopup : public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupCountTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x15c6c0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create})
            m->registerHook(getBase()+0x15c6c0, extract_virtual(this, (void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create}));
    }
};


template <class $Derived>
class $SetupInstantCountPopup : public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupInstantCountPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x352c10))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create})
            m->registerHook(getBase()+0x352c10, extract_virtual(this, (void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create}));
    }
};


template <class $Derived>
class $SetupOpacityPopup : public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupOpacityPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x32b70))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create})
            m->registerHook(getBase()+0x32b70, extract_virtual(this, (void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create}));
    }
};


template <class $Derived>
class $SetupPickupTriggerPopup : public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupPickupTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x35e70))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create})
            m->registerHook(getBase()+0x35e70, extract_virtual(this, (void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create}));
    }
};


template <class $Derived>
class $SetupPulsePopup : public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupPulsePopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e6d40))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
    }

    virtual void onSelectPulseMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
    }

    virtual void updateFadeOutLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
    }

    virtual void updateHoldLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eb8d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B)){&$Derived::colorValueChanged} != (void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged})
            m->registerHook(getBase()+0x1ec680, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create})
            m->registerHook(getBase()+0x1e6d40, extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create}));

        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::init} != (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init})
            m->registerHook(getBase()+0x1e7010, extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onSelectPulseMode} != (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode})
            m->registerHook(getBase()+0x1eb020, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode}));

        if ((void($Derived::*)(bool)){&$Derived::updateFadeOutLabel} != (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel})
            m->registerHook(getBase()+0x1eba20, extract_virtual(this, (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel}));

        if ((void($Derived::*)(bool)){&$Derived::updateHoldLabel} != (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateHoldLabel})
            m->registerHook(getBase()+0x1eb8d0, extract_virtual(this, (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateHoldLabel}));
    }
};


template <class $Derived>
class $SetupShakePopup : public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupShakePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x3adc00))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create})
            m->registerHook(getBase()+0x3adc00, extract_virtual(this, (void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create}));
    }
};


template <class $Derived>
class $SetupSpawnPopup : public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupSpawnPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x139790))(this, p0, p1);
    }

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create})
            m->registerHook(getBase()+0x139790, extract_virtual(this, (void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create}));

        if ((void($Derived::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$Derived::createToggleButton} != (void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton})
            m->registerHook(getBase()+0x13b0e0, extract_virtual(this, (void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton}));
    }
};


template <class $Derived>
class $SetupTouchTogglePopup : public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupTouchTogglePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1576a0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(EffectGameObject*, cocos2d::CCArray*)){&$Derived::create} != (void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create})
            m->registerHook(getBase()+0x1576a0, extract_virtual(this, (void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create}));
    }
};


template <class $Derived>
class $SimplePlayer : public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SimplePlayer* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1b6140))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
    }

    virtual void updatePlayerFrame(int p0, IconType p1) {
        return reinterpret_cast<void(*)(decltype(this), int, IconType)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::create} != (void($SimplePlayer::*)(int)){&$SimplePlayer::create})
            m->registerHook(getBase()+0x1b6140, extract_virtual(this, (void($SimplePlayer::*)(int)){&$SimplePlayer::create}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setSecondColor} != (void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor})
            m->registerHook(getBase()+0x1bace0, extract_virtual(this, (void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor}));

        if ((void($Derived::*)(int, IconType)){&$Derived::updatePlayerFrame} != (void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame})
            m->registerHook(getBase()+0x1b62f0, extract_virtual(this, (void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame}));
    }
};


template <class $Derived>
class $SpawnTriggerAction : public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SpawnTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17bf50))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString})
            m->registerHook(getBase()+0x17bf50, extract_virtual(this, (void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString}));
    }
};


template <class $Derived>
class $SpeedObject : public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SpeedObject* __thistype;

    virtual void create(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77450))(this, p0, p1, p2);
    }

    virtual void init(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GameObject*, int, float)){&$Derived::create} != (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::create})
            m->registerHook(getBase()+0x77450, extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::create}));

        if ((void($Derived::*)(GameObject*, int, float)){&$Derived::init} != (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init})
            m->registerHook(getBase()+0x77400, extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init}));
    }
};


template <class $Derived>
class $TeleportPortalObject : public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TeleportPortalObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xdaa50))(this, p0);
    }

    virtual void getTeleportXOff(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xdac20))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($TeleportPortalObject::*)(char const*)){&$TeleportPortalObject::create})
            m->registerHook(getBase()+0xdaa50, extract_virtual(this, (void($TeleportPortalObject::*)(char const*)){&$TeleportPortalObject::create}));

        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::getTeleportXOff} != (void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff})
            m->registerHook(getBase()+0xdac20, extract_virtual(this, (void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff}));
    }
};


template <class $Derived>
class $TextInputDelegate : public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TextInputDelegate* __thistype;

    virtual void allowTextInput(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6210))(this, p0);
    }

    virtual void textInputOpened(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6200))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::allowTextInput} != (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput})
            m->registerHook(getBase()+0x6210, extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput}));

        if ((void($Derived::*)(CCTextInputNode*)){&$Derived::textInputOpened} != (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened})
            m->registerHook(getBase()+0x6200, extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened}));
    }
};


template <class $Derived>
class $ToggleTriggerAction : public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ToggleTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1765e0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString})
            m->registerHook(getBase()+0x1765e0, extract_virtual(this, (void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString}));
    }
};


template <class $Derived>
class $TouchToggleAction : public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TouchToggleAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x177e10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string)){&$Derived::createFromString} != (void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString})
            m->registerHook(getBase()+0x177e10, extract_virtual(this, (void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString}));
    }
};


template <class $Derived>
class $UILayer : public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef UILayer* __thistype;

    virtual void pCommand(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x280830))(this, p0);
    }

    virtual void toggleCheckpointsMenu(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x280430))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::pCommand} != (void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand})
            m->registerHook(getBase()+0x280830, extract_virtual(this, (void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand}));

        if ((void($Derived::*)(bool)){&$Derived::toggleCheckpointsMenu} != (void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu})
            m->registerHook(getBase()+0x280430, extract_virtual(this, (void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu}));
    }
};


template <class $Derived>
class $CCActionTween : public $CacBase {
 public:
    $CCActionTween() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCActionTween* __thistype;

    virtual void create(float p0, char const* p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*, float, float)>(m->getOriginal(getBase()+0x447590))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, char const*, float, float)){&$Derived::create} != (void($CCActionTween::*)(float, char const*, float, float)){&$CCActionTween::create})
            m->registerHook(getBase()+0x447590, extract_virtual(this, (void($CCActionTween::*)(float, char const*, float, float)){&$CCActionTween::create}));
    }
};


template <class $Derived>
class $CCAnimate : public $CacBase {
 public:
    $CCAnimate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimate* __thistype;

    virtual void create(cocos2d::CCAnimation* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAnimation*)>(m->getOriginal(getBase()+0x1f8fc0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCAnimation*)){&$Derived::create} != (void($CCAnimate::*)(cocos2d::CCAnimation*)){&$CCAnimate::create})
            m->registerHook(getBase()+0x1f8fc0, extract_virtual(this, (void($CCAnimate::*)(cocos2d::CCAnimation*)){&$CCAnimate::create}));
    }
};


template <class $Derived>
class $CCAnimation : public $CacBase {
 public:
    $CCAnimation() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimation* __thistype;

    virtual void createWithSpriteFrames(cocos2d::CCArray* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float)>(m->getOriginal(getBase()+0x140df0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCArray*, float)){&$Derived::createWithSpriteFrames} != (void($CCAnimation::*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames})
            m->registerHook(getBase()+0x140df0, extract_virtual(this, (void($CCAnimation::*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames}));
    }
};


template <class $Derived>
class $CCArray : public $CacBase {
 public:
    $CCArray() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCArray* __thistype;

    virtual void addObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419f90))(this, p0);
    }

    virtual void addObjectNew(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a450))(this, p0);
    }

    virtual void addObjectsFromArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41a2d0))(this, p0);
    }

    virtual void createWithObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419d50))(this, p0);
    }

    virtual void fastRemoveObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a520))(this, p0);
    }

    virtual void fastRemoveObjectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a500))(this, p0);
    }

    virtual void fastRemoveObjectAtIndexNew(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a510))(this, p0);
    }

    virtual void objectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a340))(this, p0);
    }

    virtual void removeLastObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x41a470))(this, p0);
    }

    virtual void removeObject(cocos2d::CCObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, bool)>(m->getOriginal(getBase()+0x41a490))(this, p0, p1);
    }

    virtual void removeObjectAtIndex(unsigned int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int, bool)>(m->getOriginal(getBase()+0x41a4b0))(this, p0, p1);
    }

    virtual void stringAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a320))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::addObject} != (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject})
            m->registerHook(getBase()+0x419f90, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::addObjectNew} != (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew})
            m->registerHook(getBase()+0x41a450, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew}));

        if ((void($Derived::*)(cocos2d::CCArray*)){&$Derived::addObjectsFromArray} != (void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray})
            m->registerHook(getBase()+0x41a2d0, extract_virtual(this, (void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::createWithObject} != (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::createWithObject})
            m->registerHook(getBase()+0x419d50, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::createWithObject}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::fastRemoveObject} != (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject})
            m->registerHook(getBase()+0x41a520, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject}));

        if ((void($Derived::*)(unsigned int)){&$Derived::fastRemoveObjectAtIndex} != (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex})
            m->registerHook(getBase()+0x41a500, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex}));

        if ((void($Derived::*)(unsigned int)){&$Derived::fastRemoveObjectAtIndexNew} != (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew})
            m->registerHook(getBase()+0x41a510, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew}));

        if ((void($Derived::*)(unsigned int)){&$Derived::objectAtIndex} != (void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex})
            m->registerHook(getBase()+0x41a340, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex}));

        if ((void($Derived::*)(bool)){&$Derived::removeLastObject} != (void($CCArray::*)(bool)){&$CCArray::removeLastObject})
            m->registerHook(getBase()+0x41a470, extract_virtual(this, (void($CCArray::*)(bool)){&$CCArray::removeLastObject}));

        if ((void($Derived::*)(cocos2d::CCObject*, bool)){&$Derived::removeObject} != (void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject})
            m->registerHook(getBase()+0x41a490, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject}));

        if ((void($Derived::*)(unsigned int, bool)){&$Derived::removeObjectAtIndex} != (void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex})
            m->registerHook(getBase()+0x41a4b0, extract_virtual(this, (void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex}));

        if ((void($Derived::*)(unsigned int)){&$Derived::stringAtIndex} != (void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex})
            m->registerHook(getBase()+0x41a320, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex}));
    }
};


template <class $Derived>
class $CCBezierTo : public $CacBase {
 public:
    $CCBezierTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCBezierTo* __thistype;

    virtual void create(float p0, cocos2d::_ccBezierConfig const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::_ccBezierConfig const&)>(m->getOriginal(getBase()+0x1f6c10))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, cocos2d::_ccBezierConfig const&)){&$Derived::create} != (void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create})
            m->registerHook(getBase()+0x1f6c10, extract_virtual(this, (void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create}));
    }
};


template <class $Derived>
class $CCCallFunc : public $CacBase {
 public:
    $CCCallFunc() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCallFunc* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x454d90))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::create} != (void($CCCallFunc::*)(int)){&$CCCallFunc::create})
            m->registerHook(getBase()+0x454d90, extract_virtual(this, (void($CCCallFunc::*)(int)){&$CCCallFunc::create}));
    }
};


template <class $Derived>
class $CCCopying : public $CacBase {
 public:
    $CCCopying() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCopying* __thistype;

    virtual void copyWithZone(cocos2d::CCZone* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCZone*)>(m->getOriginal(getBase()+0x250c90))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCZone*)){&$Derived::copyWithZone} != (void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone})
            m->registerHook(getBase()+0x250c90, extract_virtual(this, (void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone}));
    }
};


template <class $Derived>
class $CCDelayTime : public $CacBase {
 public:
    $CCDelayTime() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDelayTime* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f4380))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::create} != (void($CCDelayTime::*)(float)){&$CCDelayTime::create})
            m->registerHook(getBase()+0x1f4380, extract_virtual(this, (void($CCDelayTime::*)(float)){&$CCDelayTime::create}));
    }
};


template <class $Derived>
class $CCDictionary : public $CacBase {
 public:
    $CCDictionary() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDictionary* __thistype;

    virtual void objectForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x190870))(this, p0);
    }

    virtual void objectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190bb0))(this, p0);
    }

    virtual void removeObjectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x1921d0))(this, p0);
    }

    virtual void setObject(cocos2d::CCObject* p0, std::string const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string const&)>(m->getOriginal(getBase()+0x190dc0))(this, p0, p1);
    }

    virtual void setObject(cocos2d::CCObject* p0, long p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, long)>(m->getOriginal(getBase()+0x191790))(this, p0, p1);
    }

    virtual void valueForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x1907a0))(this, p0);
    }

    virtual void valueForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190cf0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string const&)){&$Derived::objectForKey} != (void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey})
            m->registerHook(getBase()+0x190870, extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey}));

        if ((void($Derived::*)(long)){&$Derived::objectForKey} != (void($CCDictionary::*)(long)){&$CCDictionary::objectForKey})
            m->registerHook(getBase()+0x190bb0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::objectForKey}));

        if ((void($Derived::*)(long)){&$Derived::removeObjectForKey} != (void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey})
            m->registerHook(getBase()+0x1921d0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey}));

        if ((void($Derived::*)(cocos2d::CCObject*, std::string const&)){&$Derived::setObject} != (void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject})
            m->registerHook(getBase()+0x190dc0, extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject}));

        if ((void($Derived::*)(cocos2d::CCObject*, long)){&$Derived::setObject} != (void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject})
            m->registerHook(getBase()+0x191790, extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject}));

        if ((void($Derived::*)(std::string const&)){&$Derived::valueForKey} != (void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey})
            m->registerHook(getBase()+0x1907a0, extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey}));

        if ((void($Derived::*)(long)){&$Derived::valueForKey} != (void($CCDictionary::*)(long)){&$CCDictionary::valueForKey})
            m->registerHook(getBase()+0x190cf0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::valueForKey}));
    }
};


template <class $Derived>
class $CCDrawNode : public $CacBase {
 public:
    $CCDrawNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDrawNode* __thistype;

    virtual void setBlendFunc(cocos2d::_ccBlendFunc const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc const&)>(m->getOriginal(getBase()+0x379eb0))(this, p0);
    }

    virtual void drawPolygon(cocos2d::CCPoint* p0, unsigned int p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3797f0))(this, p0, p1, p2, p3, p4);
    }

    virtual void drawSegment(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, float p2, cocos2d::_ccColor4F const& p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3792d0))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccBlendFunc const&)){&$Derived::setBlendFunc} != (void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc})
            m->registerHook(getBase()+0x379eb0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc}));

        if ((void($Derived::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$Derived::drawPolygon} != (void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon})
            m->registerHook(getBase()+0x3797f0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon}));

        if ((void($Derived::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$Derived::drawSegment} != (void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment})
            m->registerHook(getBase()+0x3792d0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment}));
    }
};


template <class $Derived>
class $CCEaseElasticOut : public $CacBase {
 public:
    $CCEaseElasticOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseElasticOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a3080))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCActionInterval*, float)){&$Derived::create} != (void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create})
            m->registerHook(getBase()+0x2a3080, extract_virtual(this, (void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create}));
    }
};


template <class $Derived>
class $CCEaseIn : public $CacBase {
 public:
    $CCEaseIn() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseIn* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1960))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCActionInterval*, float)){&$Derived::create} != (void($CCEaseIn::*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create})
            m->registerHook(getBase()+0x2a1960, extract_virtual(this, (void($CCEaseIn::*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create}));
    }
};


template <class $Derived>
class $CCEaseInOut : public $CacBase {
 public:
    $CCEaseInOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseInOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1d80))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCActionInterval*, float)){&$Derived::create} != (void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create})
            m->registerHook(getBase()+0x2a1d80, extract_virtual(this, (void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create}));
    }
};


template <class $Derived>
class $CCEaseOut : public $CacBase {
 public:
    $CCEaseOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1b70))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCActionInterval*, float)){&$Derived::create} != (void($CCEaseOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create})
            m->registerHook(getBase()+0x2a1b70, extract_virtual(this, (void($CCEaseOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create}));
    }
};


template <class $Derived>
class $CCFadeOut : public $CacBase {
 public:
    $CCFadeOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCFadeOut* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f7d80))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::create} != (void($CCFadeOut::*)(float)){&$CCFadeOut::create})
            m->registerHook(getBase()+0x1f7d80, extract_virtual(this, (void($CCFadeOut::*)(float)){&$CCFadeOut::create}));
    }
};


template <class $Derived>
class $CCFadeTo : public $CacBase {
 public:
    $CCFadeTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCFadeTo* __thistype;

    virtual void create(float p0, unsigned char p1) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char)>(m->getOriginal(getBase()+0x1f7ff0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, unsigned char)){&$Derived::create} != (void($CCFadeTo::*)(float, unsigned char)){&$CCFadeTo::create})
            m->registerHook(getBase()+0x1f7ff0, extract_virtual(this, (void($CCFadeTo::*)(float, unsigned char)){&$CCFadeTo::create}));
    }
};


template <class $Derived>
class $CCKeyboardDelegate : public $CacBase {
 public:
    $CCKeyboardDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCKeyboardDelegate* __thistype;

    virtual void keyUp(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x61a0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::enumKeyCodes)){&$Derived::keyUp} != (void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp})
            m->registerHook(getBase()+0x61a0, extract_virtual(this, (void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp}));
    }
};


template <class $Derived>
class $CCLabelBMFont : public $CacBase {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLabelBMFont* __thistype;

    virtual void create(char const* p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, char const*)>(m->getOriginal(getBase()+0x347660))(this, p0, p1);
    }

    virtual void limitLabelWidth(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x34a6e0))(this, p0, p1, p2);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x34a5d0))(this, p0);
    }

    virtual void setString(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x3489e0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*, char const*)){&$Derived::create} != (void($CCLabelBMFont::*)(char const*, char const*)){&$CCLabelBMFont::create})
            m->registerHook(getBase()+0x347660, extract_virtual(this, (void($CCLabelBMFont::*)(char const*, char const*)){&$CCLabelBMFont::create}));

        if ((void($Derived::*)(float, float, float)){&$Derived::limitLabelWidth} != (void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth})
            m->registerHook(getBase()+0x34a6e0, extract_virtual(this, (void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth}));

        if ((void($Derived::*)(float)){&$Derived::setScale} != (void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale})
            m->registerHook(getBase()+0x34a5d0, extract_virtual(this, (void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale}));

        if ((void($Derived::*)(char const*, bool)){&$Derived::setString} != (void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString})
            m->registerHook(getBase()+0x3489e0, extract_virtual(this, (void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString}));
    }
};


template <class $Derived>
class $CCLayer : public $CacBase {
 public:
    $CCLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayer* __thistype;

    virtual void registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, bool)>(m->getOriginal(getBase()+0x272bd0))(this, p0, p1, p2, p3);
    }

    virtual void setAccelerometerEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272e30))(this, p0);
    }

    virtual void setAccelerometerInterval(double p0) {
        return reinterpret_cast<void(*)(decltype(this), double)>(m->getOriginal(getBase()+0x272e70))(this, p0);
    }

    virtual void setKeyboardEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x273020))(this, p0);
    }

    virtual void setKeypadEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272f80))(this, p0);
    }

    virtual void setMouseEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2730a0))(this, p0);
    }

    virtual void setTouchEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272cf0))(this, p0);
    }

    virtual void setTouchMode(cocos2d::ccTouchesMode p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccTouchesMode)>(m->getOriginal(getBase()+0x272d60))(this, p0);
    }

    virtual void setTouchPriority(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x272db0))(this, p0);
    }

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2734d0))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273650))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2735d0))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273550))(this, p0, p1);
    }

    virtual void ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2736d0))(this, p0, p1);
    }

    virtual void ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273850))(this, p0, p1);
    }

    virtual void ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2737d0))(this, p0, p1);
    }

    virtual void ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273750))(this, p0, p1);
    }

    virtual void didAccelerate(cocos2d::CCAcceleration* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAcceleration*)>(m->getOriginal(getBase()+0x272ea0))(this, p0);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x273280))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int, bool, int, bool)){&$Derived::registerScriptTouchHandler} != (void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler})
            m->registerHook(getBase()+0x272bd0, extract_virtual(this, (void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler}));

        if ((void($Derived::*)(bool)){&$Derived::setAccelerometerEnabled} != (void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled})
            m->registerHook(getBase()+0x272e30, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled}));

        if ((void($Derived::*)(double)){&$Derived::setAccelerometerInterval} != (void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval})
            m->registerHook(getBase()+0x272e70, extract_virtual(this, (void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval}));

        if ((void($Derived::*)(bool)){&$Derived::setKeyboardEnabled} != (void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled})
            m->registerHook(getBase()+0x273020, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setKeypadEnabled} != (void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled})
            m->registerHook(getBase()+0x272f80, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setMouseEnabled} != (void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled})
            m->registerHook(getBase()+0x2730a0, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setTouchEnabled} != (void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled})
            m->registerHook(getBase()+0x272cf0, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled}));

        if ((void($Derived::*)(cocos2d::ccTouchesMode)){&$Derived::setTouchMode} != (void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode})
            m->registerHook(getBase()+0x272d60, extract_virtual(this, (void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode}));

        if ((void($Derived::*)(int)){&$Derived::setTouchPriority} != (void($CCLayer::*)(int)){&$CCLayer::setTouchPriority})
            m->registerHook(getBase()+0x272db0, extract_virtual(this, (void($CCLayer::*)(int)){&$CCLayer::setTouchPriority}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchBegan} != (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan})
            m->registerHook(getBase()+0x2734d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchCancelled} != (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled})
            m->registerHook(getBase()+0x273650, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchEnded} != (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded})
            m->registerHook(getBase()+0x2735d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchMoved} != (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved})
            m->registerHook(getBase()+0x273550, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved}));

        if ((void($Derived::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$Derived::ccTouchesBegan} != (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan})
            m->registerHook(getBase()+0x2736d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan}));

        if ((void($Derived::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$Derived::ccTouchesCancelled} != (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled})
            m->registerHook(getBase()+0x273850, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled}));

        if ((void($Derived::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$Derived::ccTouchesEnded} != (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded})
            m->registerHook(getBase()+0x2737d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded}));

        if ((void($Derived::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$Derived::ccTouchesMoved} != (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved})
            m->registerHook(getBase()+0x273750, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved}));

        if ((void($Derived::*)(cocos2d::CCAcceleration*)){&$Derived::didAccelerate} != (void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate})
            m->registerHook(getBase()+0x272ea0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate}));

        if ((void($Derived::*)(cocos2d::enumKeyCodes)){&$Derived::keyDown} != (void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown})
            m->registerHook(getBase()+0x273280, extract_virtual(this, (void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown}));
    }
};


template <class $Derived>
class $CCLayerColor : public $CacBase {
 public:
    $CCLayerColor() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayerColor* __thistype;

    virtual void initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x274850))(this, p0, p1, p2);
    }

    virtual void initWithColor(cocos2d::_ccColor4B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&)>(m->getOriginal(getBase()+0x2749a0))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2749f0))(this, p0);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x2744a0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x274c20))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x274db0))(this, p0);
    }

    virtual void create(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x2745e0))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor4B const&, float, float)){&$Derived::initWithColor} != (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor})
            m->registerHook(getBase()+0x274850, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor}));

        if ((void($Derived::*)(cocos2d::_ccColor4B const&)){&$Derived::initWithColor} != (void($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor})
            m->registerHook(getBase()+0x2749a0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor}));

        if ((void($Derived::*)(cocos2d::CCSize const&)){&$Derived::setContentSize} != (void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize})
            m->registerHook(getBase()+0x2749f0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize}));

        if ((void($Derived::*)(cocos2d::_ccBlendFunc)){&$Derived::setBlendFunc} != (void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc})
            m->registerHook(getBase()+0x2744a0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setColor} != (void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor})
            m->registerHook(getBase()+0x274c20, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor}));

        if ((void($Derived::*)(unsigned char)){&$Derived::setOpacity} != (void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity})
            m->registerHook(getBase()+0x274db0, extract_virtual(this, (void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity}));

        if ((void($Derived::*)(cocos2d::_ccColor4B const&, float, float)){&$Derived::create} != (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create})
            m->registerHook(getBase()+0x2745e0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create}));
    }
};


template <class $Derived>
class $CCMouseDelegate : public $CacBase {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMouseDelegate* __thistype;

    virtual void scrollWheel(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x61d0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, float)){&$Derived::scrollWheel} != (void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel})
            m->registerHook(getBase()+0x61d0, extract_virtual(this, (void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel}));
    }
};


template <class $Derived>
class $CCMoveBy : public $CacBase {
 public:
    $CCMoveBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMoveBy* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f50e0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, cocos2d::CCPoint const&)){&$Derived::create} != (void($CCMoveBy::*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create})
            m->registerHook(getBase()+0x1f50e0, extract_virtual(this, (void($CCMoveBy::*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create}));
    }
};


template <class $Derived>
class $CCMoveTo : public $CacBase {
 public:
    $CCMoveTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMoveTo* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f54d0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, cocos2d::CCPoint const&)){&$Derived::create} != (void($CCMoveTo::*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create})
            m->registerHook(getBase()+0x1f54d0, extract_virtual(this, (void($CCMoveTo::*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create}));
    }
};


template <class $Derived>
class $CCNode : public $CacBase {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNode* __thistype;

    virtual void _setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x122990))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1232a0))(this, p0, p1, p2);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1233b0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x1233d0))(this, p0);
    }

    virtual void addComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a40))(this, p0);
    }

    virtual void convertToNodeSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124750))(this, p0);
    }

    virtual void convertToWorldSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124790))(this, p0);
    }

    virtual void getActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ee0))(this, p0);
    }

    virtual cocos2d::CCNode* getChildByTag(int p0) {
        return reinterpret_cast<cocos2d::CCNode*(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123220))(this, p0);
    }

    virtual void getPosition(float* p0, float* p1) {
        return reinterpret_cast<void(*)(decltype(this), float*, float*)>(m->getOriginal(getBase()+0x122b90))(this, p0, p1);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122f00))(this, p0);
    }

    virtual void registerScriptHandler(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123d90))(this, p0);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123620))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x123460))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x123480))(this, p0, p1);
    }

    virtual void removeChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1235a0))(this, p0);
    }

    virtual void removeChildByTag(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x1235c0))(this, p0, p1);
    }

    virtual void removeComponent(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x124a60))(this, p0);
    }

    virtual void removeComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a80))(this, p0);
    }

    virtual void removeFromParentAndCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123410))(this, p0);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x123760))(this, p0, p1);
    }

    virtual void runAction(cocos2d::CCAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAction*)>(m->getOriginal(getBase()+0x123e60))(this, p0);
    }

    virtual void setActionManager(cocos2d::CCActionManager* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionManager*)>(m->getOriginal(getBase()+0x123e00))(this, p0);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122d90))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x122e50))(this, p0);
    }

    virtual void setGLServerState(cocos2d::ccGLServerState p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccGLServerState)>(m->getOriginal(getBase()+0x122fa0))(this, p0);
    }

    virtual void setGrid(cocos2d::CCGridBase* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGridBase*)>(m->getOriginal(getBase()+0x122d10))(this, p0);
    }

    virtual void setOrderOfArrival(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x122f60))(this, p0);
    }

    virtual void setParent(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x122ee0))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122b70))(this, p0);
    }

    virtual void setPosition(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ba0))(this, p0, p1);
    }

    virtual void setPositionX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c00))(this, p0);
    }

    virtual void setPositionY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c40))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a10))(this, p0);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a60))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a90))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122ac0))(this, p0);
    }

    virtual void setScale(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ae0))(this, p0, p1);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b10))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b40))(this, p0);
    }

    virtual void setScheduler(cocos2d::CCScheduler* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScheduler*)>(m->getOriginal(getBase()+0x123f20))(this, p0);
    }

    virtual void setShaderProgram(cocos2d::CCGLProgram* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGLProgram*)>(m->getOriginal(getBase()+0x122ff0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122930))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122960))(this, p0);
    }

    virtual void setUserData(void* p0) {
        return reinterpret_cast<void(*)(decltype(this), void*)>(m->getOriginal(getBase()+0x122f40))(this, p0);
    }

    virtual void setUserObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x122fb0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1229f0))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122d60))(this, p0);
    }

    virtual void setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1229a0))(this, p0);
    }

    virtual void stopActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ec0))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1241a0))(this, p0);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x1249c0))(this, p0, p1);
    }

    virtual void schedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x1240b0))(this, p0);
    }

    virtual void schedule(Cacao::CC_SCHED p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, float)>(m->getOriginal(getBase()+0x124120))(this, p0, p1);
    }

    virtual void unschedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x124180))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::_setZOrder} != (void($CCNode::*)(int)){&$CCNode::_setZOrder})
            m->registerHook(getBase()+0x122990, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::_setZOrder}));

        if ((void($Derived::*)(cocos2d::CCNode*, int, int)){&$Derived::addChild} != (void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild})
            m->registerHook(getBase()+0x1232a0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild}));

        if ((void($Derived::*)(cocos2d::CCNode*, int)){&$Derived::addChild} != (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild})
            m->registerHook(getBase()+0x1233b0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild}));

        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::addChild} != (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild})
            m->registerHook(getBase()+0x1233d0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild}));

        if ((void($Derived::*)(cocos2d::CCComponent*)){&$Derived::addComponent} != (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent})
            m->registerHook(getBase()+0x124a40, extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::convertToNodeSpace} != (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace})
            m->registerHook(getBase()+0x124750, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::convertToWorldSpace} != (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace})
            m->registerHook(getBase()+0x124790, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace}));

        if ((void($Derived::*)(int)){&$Derived::getActionByTag} != (void($CCNode::*)(int)){&$CCNode::getActionByTag})
            m->registerHook(getBase()+0x123ee0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::getActionByTag}));

        if ((cocos2d::CCNode*($Derived::*)(int)){&$Derived::getChildByTag} != (cocos2d::CCNode*($CCNode::*)(int)){&$CCNode::getChildByTag})
            m->registerHook(getBase()+0x123220, extract_virtual(this, (cocos2d::CCNode*($CCNode::*)(int)){&$CCNode::getChildByTag}));

        if ((void($Derived::*)(float*, float*)){&$Derived::getPosition} != (void($CCNode::*)(float*, float*)){&$CCNode::getPosition})
            m->registerHook(getBase()+0x122b90, extract_virtual(this, (void($CCNode::*)(float*, float*)){&$CCNode::getPosition}));

        if ((void($Derived::*)(bool)){&$Derived::ignoreAnchorPointForPosition} != (void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition})
            m->registerHook(getBase()+0x122f00, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition}));

        if ((void($Derived::*)(int)){&$Derived::registerScriptHandler} != (void($CCNode::*)(int)){&$CCNode::registerScriptHandler})
            m->registerHook(getBase()+0x123d90, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::registerScriptHandler}));

        if ((void($Derived::*)(bool)){&$Derived::removeAllChildrenWithCleanup} != (void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup})
            m->registerHook(getBase()+0x123620, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup}));

        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::removeChild} != (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild})
            m->registerHook(getBase()+0x123460, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild}));

        if ((void($Derived::*)(cocos2d::CCNode*, bool)){&$Derived::removeChild} != (void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild})
            m->registerHook(getBase()+0x123480, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild}));

        if ((void($Derived::*)(int)){&$Derived::removeChildByTag} != (void($CCNode::*)(int)){&$CCNode::removeChildByTag})
            m->registerHook(getBase()+0x1235a0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::removeChildByTag}));

        if ((void($Derived::*)(int, bool)){&$Derived::removeChildByTag} != (void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag})
            m->registerHook(getBase()+0x1235c0, extract_virtual(this, (void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag}));

        if ((void($Derived::*)(char const*)){&$Derived::removeComponent} != (void($CCNode::*)(char const*)){&$CCNode::removeComponent})
            m->registerHook(getBase()+0x124a60, extract_virtual(this, (void($CCNode::*)(char const*)){&$CCNode::removeComponent}));

        if ((void($Derived::*)(cocos2d::CCComponent*)){&$Derived::removeComponent} != (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent})
            m->registerHook(getBase()+0x124a80, extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent}));

        if ((void($Derived::*)(bool)){&$Derived::removeFromParentAndCleanup} != (void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup})
            m->registerHook(getBase()+0x123410, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup}));

        if ((void($Derived::*)(cocos2d::CCNode*, int)){&$Derived::reorderChild} != (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild})
            m->registerHook(getBase()+0x123760, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild}));

        if ((void($Derived::*)(cocos2d::CCAction*)){&$Derived::runAction} != (void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction})
            m->registerHook(getBase()+0x123e60, extract_virtual(this, (void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction}));

        if ((void($Derived::*)(cocos2d::CCActionManager*)){&$Derived::setActionManager} != (void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager})
            m->registerHook(getBase()+0x123e00, extract_virtual(this, (void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setAnchorPoint} != (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint})
            m->registerHook(getBase()+0x122d90, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint}));

        if ((void($Derived::*)(cocos2d::CCSize const&)){&$Derived::setContentSize} != (void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize})
            m->registerHook(getBase()+0x122e50, extract_virtual(this, (void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize}));

        if ((void($Derived::*)(cocos2d::ccGLServerState)){&$Derived::setGLServerState} != (void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState})
            m->registerHook(getBase()+0x122fa0, extract_virtual(this, (void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState}));

        if ((void($Derived::*)(cocos2d::CCGridBase*)){&$Derived::setGrid} != (void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid})
            m->registerHook(getBase()+0x122d10, extract_virtual(this, (void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid}));

        if ((void($Derived::*)(unsigned int)){&$Derived::setOrderOfArrival} != (void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival})
            m->registerHook(getBase()+0x122f60, extract_virtual(this, (void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival}));

        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::setParent} != (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent})
            m->registerHook(getBase()+0x122ee0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setPosition} != (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition})
            m->registerHook(getBase()+0x122b70, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition}));

        if ((void($Derived::*)(float, float)){&$Derived::setPosition} != (void($CCNode::*)(float, float)){&$CCNode::setPosition})
            m->registerHook(getBase()+0x122ba0, extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setPosition}));

        if ((void($Derived::*)(float)){&$Derived::setPositionX} != (void($CCNode::*)(float)){&$CCNode::setPositionX})
            m->registerHook(getBase()+0x122c00, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionX}));

        if ((void($Derived::*)(float)){&$Derived::setPositionY} != (void($CCNode::*)(float)){&$CCNode::setPositionY})
            m->registerHook(getBase()+0x122c40, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionY}));

        if ((void($Derived::*)(float)){&$Derived::setRotation} != (void($CCNode::*)(float)){&$CCNode::setRotation})
            m->registerHook(getBase()+0x122a10, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotation}));

        if ((void($Derived::*)(float)){&$Derived::setRotationX} != (void($CCNode::*)(float)){&$CCNode::setRotationX})
            m->registerHook(getBase()+0x122a60, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationX}));

        if ((void($Derived::*)(float)){&$Derived::setRotationY} != (void($CCNode::*)(float)){&$CCNode::setRotationY})
            m->registerHook(getBase()+0x122a90, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationY}));

        if ((void($Derived::*)(float)){&$Derived::setScale} != (void($CCNode::*)(float)){&$CCNode::setScale})
            m->registerHook(getBase()+0x122ac0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScale}));

        if ((void($Derived::*)(float, float)){&$Derived::setScale} != (void($CCNode::*)(float, float)){&$CCNode::setScale})
            m->registerHook(getBase()+0x122ae0, extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setScale}));

        if ((void($Derived::*)(float)){&$Derived::setScaleX} != (void($CCNode::*)(float)){&$CCNode::setScaleX})
            m->registerHook(getBase()+0x122b10, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleX}));

        if ((void($Derived::*)(float)){&$Derived::setScaleY} != (void($CCNode::*)(float)){&$CCNode::setScaleY})
            m->registerHook(getBase()+0x122b40, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleY}));

        if ((void($Derived::*)(cocos2d::CCScheduler*)){&$Derived::setScheduler} != (void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler})
            m->registerHook(getBase()+0x123f20, extract_virtual(this, (void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler}));

        if ((void($Derived::*)(cocos2d::CCGLProgram*)){&$Derived::setShaderProgram} != (void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram})
            m->registerHook(getBase()+0x122ff0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram}));

        if ((void($Derived::*)(float)){&$Derived::setSkewX} != (void($CCNode::*)(float)){&$CCNode::setSkewX})
            m->registerHook(getBase()+0x122930, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewX}));

        if ((void($Derived::*)(float)){&$Derived::setSkewY} != (void($CCNode::*)(float)){&$CCNode::setSkewY})
            m->registerHook(getBase()+0x122960, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewY}));

        if ((void($Derived::*)(void*)){&$Derived::setUserData} != (void($CCNode::*)(void*)){&$CCNode::setUserData})
            m->registerHook(getBase()+0x122f40, extract_virtual(this, (void($CCNode::*)(void*)){&$CCNode::setUserData}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::setUserObject} != (void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject})
            m->registerHook(getBase()+0x122fb0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject}));

        if ((void($Derived::*)(float)){&$Derived::setVertexZ} != (void($CCNode::*)(float)){&$CCNode::setVertexZ})
            m->registerHook(getBase()+0x1229f0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setVertexZ}));

        if ((void($Derived::*)(bool)){&$Derived::setVisible} != (void($CCNode::*)(bool)){&$CCNode::setVisible})
            m->registerHook(getBase()+0x122d60, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::setVisible}));

        if ((void($Derived::*)(int)){&$Derived::setZOrder} != (void($CCNode::*)(int)){&$CCNode::setZOrder})
            m->registerHook(getBase()+0x1229a0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::setZOrder}));

        if ((void($Derived::*)(int)){&$Derived::stopActionByTag} != (void($CCNode::*)(int)){&$CCNode::stopActionByTag})
            m->registerHook(getBase()+0x123ec0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::stopActionByTag}));

        if ((void($Derived::*)(float)){&$Derived::update} != (void($CCNode::*)(float)){&$CCNode::update})
            m->registerHook(getBase()+0x1241a0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::update}));

        if ((void($Derived::*)(float, char const*)){&$Derived::updateTweenAction} != (void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction})
            m->registerHook(getBase()+0x1249c0, extract_virtual(this, (void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction}));

        if ((void($Derived::*)(Cacao::CC_SCHED)){&$Derived::schedule} != (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule})
            m->registerHook(getBase()+0x1240b0, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule}));

        if ((void($Derived::*)(Cacao::CC_SCHED, float)){&$Derived::schedule} != (void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule})
            m->registerHook(getBase()+0x124120, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule}));

        if ((void($Derived::*)(Cacao::CC_SCHED)){&$Derived::unschedule} != (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule})
            m->registerHook(getBase()+0x124180, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule}));
    }
};


template <class $Derived>
class $CCObject : public $CacBase {
 public:
    $CCObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCObject* __thistype;

    virtual void acceptVisitor(cocos2d::CCDataVisitor& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDataVisitor&)>(m->getOriginal(getBase()+0x250f30))(this, p0);
    }

    virtual void encodeWithCoder(DS_Dictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(getBase()+0x250f70))(this, p0);
    }

    virtual void isEqual(cocos2d::CCObject const* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject const*)>(m->getOriginal(getBase()+0x250f20))(this, p0);
    }

    virtual void setTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x250f60))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCDataVisitor&)){&$Derived::acceptVisitor} != (void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor})
            m->registerHook(getBase()+0x250f30, extract_virtual(this, (void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor}));

        if ((void($Derived::*)(DS_Dictionary*)){&$Derived::encodeWithCoder} != (void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder})
            m->registerHook(getBase()+0x250f70, extract_virtual(this, (void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder}));

        if ((void($Derived::*)(cocos2d::CCObject const*)){&$Derived::isEqual} != (void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual})
            m->registerHook(getBase()+0x250f20, extract_virtual(this, (void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual}));

        if ((void($Derived::*)(int)){&$Derived::setTag} != (void($CCObject::*)(int)){&$CCObject::setTag})
            m->registerHook(getBase()+0x250f60, extract_virtual(this, (void($CCObject::*)(int)){&$CCObject::setTag}));
    }
};


template <class $Derived>
class $CCParticleSystemQuad : public $CacBase {
 public:
    $CCParticleSystemQuad() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCParticleSystemQuad* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x36b000))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($CCParticleSystemQuad::*)(char const*)){&$CCParticleSystemQuad::create})
            m->registerHook(getBase()+0x36b000, extract_virtual(this, (void($CCParticleSystemQuad::*)(char const*)){&$CCParticleSystemQuad::create}));
    }
};


template <class $Derived>
class $CCRepeatForever : public $CacBase {
 public:
    $CCRepeatForever() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRepeatForever* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*)>(m->getOriginal(getBase()+0x1f3920))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCActionInterval*)){&$Derived::create} != (void($CCRepeatForever::*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create})
            m->registerHook(getBase()+0x1f3920, extract_virtual(this, (void($CCRepeatForever::*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create}));
    }
};


template <class $Derived>
class $CCRotateBy : public $CacBase {
 public:
    $CCRotateBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRotateBy* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f4c50))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, float)){&$Derived::create} != (void($CCRotateBy::*)(float, float)){&$CCRotateBy::create})
            m->registerHook(getBase()+0x1f4c50, extract_virtual(this, (void($CCRotateBy::*)(float, float)){&$CCRotateBy::create}));
    }
};


template <class $Derived>
class $CCScaleTo : public $CacBase {
 public:
    $CCScaleTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScaleTo* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f6ff0))(this, p0, p1);
    }

    virtual void create(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x1f70f0))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, float)){&$Derived::create} != (void($CCScaleTo::*)(float, float)){&$CCScaleTo::create})
            m->registerHook(getBase()+0x1f6ff0, extract_virtual(this, (void($CCScaleTo::*)(float, float)){&$CCScaleTo::create}));

        if ((void($Derived::*)(float, float, float)){&$Derived::create} != (void($CCScaleTo::*)(float, float, float)){&$CCScaleTo::create})
            m->registerHook(getBase()+0x1f70f0, extract_virtual(this, (void($CCScaleTo::*)(float, float, float)){&$CCScaleTo::create}));
    }
};


template <class $Derived>
class $CCSprite : public $CacBase {
 public:
    $CCSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSprite* __thistype;

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x134190))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1341a0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1341b0))(this, p0, p1, p2);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132a80))(this, p0);
    }

    virtual void createWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132dc0))(this, p0);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134b60))(this, p0);
    }

    virtual void initWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x133180))(this, p0);
    }

    virtual void initWithFile(char const* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133210))(this, p0, p1);
    }

    virtual void initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x133270))(this, p0);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(getBase()+0x132f10))(this, p0, p1, p2);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1330f0))(this, p0, p1);
    }

    virtual void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x1356d0))(this, p0);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134340))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x134300))(this, p0, p1);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x134270))(this, p0, p1);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134af0))(this, p0);
    }

    virtual void setBatchNode(cocos2d::CCSpriteBatchNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteBatchNode*)>(m->getOriginal(getBase()+0x135920))(this, p0);
    }

    virtual void setChildOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x134f50))(this, p0);
    }

    virtual void setDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x505c0))(this, p0);
    }

    virtual void setDirtyRecursively(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1345b0))(this, p0);
    }

    virtual void setDisplayFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x135610))(this, p0);
    }

    virtual void setDisplayFrameWithAnimationName(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x135680))(this, p0, p1);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134c30))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134650))(this, p0);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134740))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1347b0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134820))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134890))(this, p0);
    }

    virtual void setTextureCoords(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133910))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133560))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&, bool, cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x133580))(this, p0, p1, p2);
    }

    virtual void setVertexRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1338f0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134a80))(this, p0);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x50590))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x135200))(this, p0);
    }

    virtual void setTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x135a90))(this, p0);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x135370))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x1354c0))(this, p0);
    }

    virtual void createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x132cb0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCNode*)){&$Derived::addChild} != (void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild})
            m->registerHook(getBase()+0x134190, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild}));

        if ((void($Derived::*)(cocos2d::CCNode*, int)){&$Derived::addChild} != (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild})
            m->registerHook(getBase()+0x1341a0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild}));

        if ((void($Derived::*)(cocos2d::CCNode*, int, int)){&$Derived::addChild} != (void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild})
            m->registerHook(getBase()+0x1341b0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild}));

        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($CCSprite::*)(char const*)){&$CCSprite::create})
            m->registerHook(getBase()+0x132a80, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::create}));

        if ((void($Derived::*)(char const*)){&$Derived::createWithSpriteFrameName} != (void($CCSprite::*)(char const*)){&$CCSprite::createWithSpriteFrameName})
            m->registerHook(getBase()+0x132dc0, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::createWithSpriteFrameName}));

        if ((void($Derived::*)(bool)){&$Derived::ignoreAnchorPointForPosition} != (void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition})
            m->registerHook(getBase()+0x134b60, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition}));

        if ((void($Derived::*)(char const*)){&$Derived::initWithFile} != (void($CCSprite::*)(char const*)){&$CCSprite::initWithFile})
            m->registerHook(getBase()+0x133180, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::initWithFile}));

        if ((void($Derived::*)(char const*, cocos2d::CCRect const&)){&$Derived::initWithFile} != (void($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile})
            m->registerHook(getBase()+0x133210, extract_virtual(this, (void($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile}));

        if ((void($Derived::*)(cocos2d::CCSpriteFrame*)){&$Derived::initWithSpriteFrame} != (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame})
            m->registerHook(getBase()+0x133270, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame}));

        if ((void($Derived::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$Derived::initWithTexture} != (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture})
            m->registerHook(getBase()+0x132f10, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture}));

        if ((void($Derived::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$Derived::initWithTexture} != (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture})
            m->registerHook(getBase()+0x1330f0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture}));

        if ((void($Derived::*)(cocos2d::CCSpriteFrame*)){&$Derived::isFrameDisplayed} != (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed})
            m->registerHook(getBase()+0x1356d0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed}));

        if ((void($Derived::*)(bool)){&$Derived::removeAllChildrenWithCleanup} != (void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup})
            m->registerHook(getBase()+0x134340, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup}));

        if ((void($Derived::*)(cocos2d::CCNode*, bool)){&$Derived::removeChild} != (void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild})
            m->registerHook(getBase()+0x134300, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild}));

        if ((void($Derived::*)(cocos2d::CCNode*, int)){&$Derived::reorderChild} != (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild})
            m->registerHook(getBase()+0x134270, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setAnchorPoint} != (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint})
            m->registerHook(getBase()+0x134af0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint}));

        if ((void($Derived::*)(cocos2d::CCSpriteBatchNode*)){&$Derived::setBatchNode} != (void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode})
            m->registerHook(getBase()+0x135920, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode}));

        if ((void($Derived::*)(unsigned char)){&$Derived::setChildOpacity} != (void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity})
            m->registerHook(getBase()+0x134f50, extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity}));

        if ((void($Derived::*)(bool)){&$Derived::setDirty} != (void($CCSprite::*)(bool)){&$CCSprite::setDirty})
            m->registerHook(getBase()+0x505c0, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirty}));

        if ((void($Derived::*)(bool)){&$Derived::setDirtyRecursively} != (void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively})
            m->registerHook(getBase()+0x1345b0, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively}));

        if ((void($Derived::*)(cocos2d::CCSpriteFrame*)){&$Derived::setDisplayFrame} != (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame})
            m->registerHook(getBase()+0x135610, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame}));

        if ((void($Derived::*)(char const*, int)){&$Derived::setDisplayFrameWithAnimationName} != (void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName})
            m->registerHook(getBase()+0x135680, extract_virtual(this, (void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName}));

        if ((void($Derived::*)(bool)){&$Derived::setFlipY} != (void($CCSprite::*)(bool)){&$CCSprite::setFlipY})
            m->registerHook(getBase()+0x134c30, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setFlipY}));

        if ((void($Derived::*)(cocos2d::CCPoint const&)){&$Derived::setPosition} != (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition})
            m->registerHook(getBase()+0x134650, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition}));

        if ((void($Derived::*)(float)){&$Derived::setRotationX} != (void($CCSprite::*)(float)){&$CCSprite::setRotationX})
            m->registerHook(getBase()+0x134740, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationX}));

        if ((void($Derived::*)(float)){&$Derived::setRotationY} != (void($CCSprite::*)(float)){&$CCSprite::setRotationY})
            m->registerHook(getBase()+0x1347b0, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationY}));

        if ((void($Derived::*)(float)){&$Derived::setSkewX} != (void($CCSprite::*)(float)){&$CCSprite::setSkewX})
            m->registerHook(getBase()+0x134820, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewX}));

        if ((void($Derived::*)(float)){&$Derived::setSkewY} != (void($CCSprite::*)(float)){&$CCSprite::setSkewY})
            m->registerHook(getBase()+0x134890, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewY}));

        if ((void($Derived::*)(cocos2d::CCRect const&)){&$Derived::setTextureCoords} != (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords})
            m->registerHook(getBase()+0x133910, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords}));

        if ((void($Derived::*)(cocos2d::CCRect const&)){&$Derived::setTextureRect} != (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect})
            m->registerHook(getBase()+0x133560, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect}));

        if ((void($Derived::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$Derived::setTextureRect} != (void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect})
            m->registerHook(getBase()+0x133580, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect}));

        if ((void($Derived::*)(cocos2d::CCRect const&)){&$Derived::setVertexRect} != (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect})
            m->registerHook(getBase()+0x1338f0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect}));

        if ((void($Derived::*)(float)){&$Derived::setVertexZ} != (void($CCSprite::*)(float)){&$CCSprite::setVertexZ})
            m->registerHook(getBase()+0x134a80, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setVertexZ}));

        if ((void($Derived::*)(cocos2d::_ccBlendFunc)){&$Derived::setBlendFunc} != (void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc})
            m->registerHook(getBase()+0x50590, extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc}));

        if ((void($Derived::*)(bool)){&$Derived::setOpacityModifyRGB} != (void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB})
            m->registerHook(getBase()+0x135200, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB}));

        if ((void($Derived::*)(cocos2d::CCTexture2D*)){&$Derived::setTexture} != (void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture})
            m->registerHook(getBase()+0x135a90, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::updateDisplayedColor} != (void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor})
            m->registerHook(getBase()+0x135370, extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor}));

        if ((void($Derived::*)(unsigned char)){&$Derived::updateDisplayedOpacity} != (void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity})
            m->registerHook(getBase()+0x1354c0, extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity}));

        if ((void($Derived::*)(cocos2d::CCSpriteFrame*)){&$Derived::createWithSpriteFrame} != (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame})
            m->registerHook(getBase()+0x132cb0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame}));
    }
};


template <class $Derived>
class $CCSpriteBatchNode : public $CacBase {
 public:
    $CCSpriteBatchNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpriteBatchNode* __thistype;

    virtual void createWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, unsigned int)>(m->getOriginal(getBase()+0xbb310))(this, p0, p1);
    }

    virtual void increaseAtlasCapacity(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0xbc670))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCTexture2D*, unsigned int)){&$Derived::createWithTexture} != (void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture})
            m->registerHook(getBase()+0xbb310, extract_virtual(this, (void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture}));

        if ((void($Derived::*)(unsigned int)){&$Derived::increaseAtlasCapacity} != (void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity})
            m->registerHook(getBase()+0xbc670, extract_virtual(this, (void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity}));
    }
};


template <class $Derived>
class $CCSpriteFrameCache : public $CacBase {
 public:
    $CCSpriteFrameCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpriteFrameCache* __thistype;

    virtual void spriteFrameByName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x19a7e0))(this, p0);
    }

    virtual void addSpriteFramesWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x199a10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*)){&$Derived::spriteFrameByName} != (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName})
            m->registerHook(getBase()+0x19a7e0, extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName}));

        if ((void($Derived::*)(char const*)){&$Derived::addSpriteFramesWithFile} != (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile})
            m->registerHook(getBase()+0x199a10, extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile}));
    }
};


template <class $Derived>
class $CCTexture2D : public $CacBase {
 public:
    $CCTexture2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTexture2D* __thistype;

    virtual void setTexParameters(cocos2d::_ccTexParams* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccTexParams*)>(m->getOriginal(getBase()+0x247980))(this, p0);
    }

    virtual void initWithImage(cocos2d::CCImage* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCImage*)>(m->getOriginal(getBase()+0x246940))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccTexParams*)){&$Derived::setTexParameters} != (void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters})
            m->registerHook(getBase()+0x247980, extract_virtual(this, (void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters}));

        if ((void($Derived::*)(cocos2d::CCImage*)){&$Derived::initWithImage} != (void($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage})
            m->registerHook(getBase()+0x246940, extract_virtual(this, (void($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage}));
    }
};


template <class $Derived>
class $CCTextureCache : public $CacBase {
 public:
    $CCTextureCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTextureCache* __thistype;

    virtual void addImage(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x358120))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*, bool)){&$Derived::addImage} != (void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage})
            m->registerHook(getBase()+0x358120, extract_virtual(this, (void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage}));
    }
};


template <class $Derived>
class $CCTouchDispatcher : public $CacBase {
 public:
    $CCTouchDispatcher() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTouchDispatcher* __thistype;

    virtual void decrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f70))(this, p0);
    }

    virtual void incrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f60))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int)){&$Derived::decrementForcePrio} != (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio})
            m->registerHook(getBase()+0x280f70, extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio}));

        if ((void($Derived::*)(int)){&$Derived::incrementForcePrio} != (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio})
            m->registerHook(getBase()+0x280f60, extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio}));
    }
};


template <class $Derived>
class $ZipUtils : public $CacBase {
 public:
    $ZipUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ZipUtils* __thistype;

    virtual void decompressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xea380))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string, bool, int)){&$Derived::decompressString} != (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString})
            m->registerHook(getBase()+0xea380, extract_virtual(this, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString}));
    }
};


template <class $Derived>
class $CCControlColourPicker : public $CacBase {
 public:
    $CCControlColourPicker() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCControlColourPicker* __thistype;

    virtual void setColorValue(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1aac10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::setColorValue} != (void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue})
            m->registerHook(getBase()+0x1aac10, extract_virtual(this, (void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue}));
    }
};


template <class $Derived>
class $CCControlUtils : public $CacBase {
 public:
    $CCControlUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCControlUtils* __thistype;

    virtual void HSVfromRGB(cocos2d::extension::RGBA p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::RGBA)>(m->getOriginal(getBase()+0x1e6750))(this, p0);
    }

    virtual void RGBfromHSV(cocos2d::extension::HSV p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::HSV)>(m->getOriginal(getBase()+0x1e6850))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::extension::RGBA)){&$Derived::HSVfromRGB} != (void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB})
            m->registerHook(getBase()+0x1e6750, extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB}));

        if ((void($Derived::*)(cocos2d::extension::HSV)){&$Derived::RGBfromHSV} != (void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV})
            m->registerHook(getBase()+0x1e6850, extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV}));
    }
};


template <class $Derived>
class $CCScale9Sprite : public $CacBase {
 public:
    $CCScale9Sprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScale9Sprite* __thistype;

    virtual void create(char const* p0, cocos2d::CCRect p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x212ef0))(this, p0, p1);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2130d0))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2127c0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(char const*, cocos2d::CCRect)){&$Derived::create} != (void($CCScale9Sprite::*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create})
            m->registerHook(getBase()+0x212ef0, extract_virtual(this, (void($CCScale9Sprite::*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create}));

        if ((void($Derived::*)(char const*)){&$Derived::create} != (void($CCScale9Sprite::*)(char const*)){&$CCScale9Sprite::create})
            m->registerHook(getBase()+0x2130d0, extract_virtual(this, (void($CCScale9Sprite::*)(char const*)){&$CCScale9Sprite::create}));

        if ((void($Derived::*)(cocos2d::CCSize const&)){&$Derived::setContentSize} != (void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize})
            m->registerHook(getBase()+0x2127c0, extract_virtual(this, (void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize}));
    }
};


template <class $Derived>
class $FLAlertLayer : public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef FLAlertLayer* __thistype;

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(getBase()+0x25e0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25dec0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchBegan} != (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan})
            m->registerHook(getBase()+0x25ee40, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchCancelled} != (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled})
            m->registerHook(getBase()+0x25f020, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchEnded} != (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded})
            m->registerHook(getBase()+0x25ef60, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded}));

        if ((void($Derived::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Derived::ccTouchMoved} != (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved})
            m->registerHook(getBase()+0x25f0a0, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved}));

        if ((void($Derived::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$Derived::create} != (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create})
            m->registerHook(getBase()+0x25e0e0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create}));

        if ((void($Derived::*)(cocos2d::enumKeyCodes)){&$Derived::keyDown} != (void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown})
            m->registerHook(getBase()+0x25ece0, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown}));

        if ((void($Derived::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$Derived::create} != (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create})
            m->registerHook(getBase()+0x25dec0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create}));

        if ((void($Derived::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$Derived::init} != (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init})
            m->registerHook(getBase()+0x25e1b0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init}));
    }
};


template <class $Derived>
class $CCLayerRGBA : public $CacBase {
 public:
    $CCLayerRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayerRGBA* __thistype;

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274250))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274210))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6180))(this, p0);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x2740b0))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x273f20))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool)){&$Derived::setCascadeColorEnabled} != (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled})
            m->registerHook(getBase()+0x274250, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setCascadeOpacityEnabled} != (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled})
            m->registerHook(getBase()+0x274210, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setOpacityModifyRGB} != (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB})
            m->registerHook(getBase()+0x6180, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB}));

        if ((void($Derived::*)(cocos2d::_ccColor3B const&)){&$Derived::updateDisplayedColor} != (void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor})
            m->registerHook(getBase()+0x2740b0, extract_virtual(this, (void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor}));

        if ((void($Derived::*)(unsigned char)){&$Derived::updateDisplayedOpacity} != (void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity})
            m->registerHook(getBase()+0x273f20, extract_virtual(this, (void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity}));
    }
};


template <class $Derived>
class $CCNodeRGBA : public $CacBase {
 public:
    $CCNodeRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNodeRGBA* __thistype;

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125340))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125000))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool)){&$Derived::setCascadeColorEnabled} != (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled})
            m->registerHook(getBase()+0x125340, extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled}));

        if ((void($Derived::*)(bool)){&$Derived::setCascadeOpacityEnabled} != (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled})
            m->registerHook(getBase()+0x125000, extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled}));
    }
};


template <class $Derived>
class $CCMenuItemSpriteExtra : public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemSpriteExtra* __thistype;

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1253c0))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::setSizeMult} != (void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult})
            m->registerHook(getBase()+0x1255e0, extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult}));

        if ((void($Derived::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$Derived::create} != (void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create})
            m->registerHook(getBase()+0x1253c0, extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create}));
    }
};


template <class $Derived>
class $EditButtonBar : public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditButtonBar* __thistype;

    virtual void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCArray*, int, int, bool)){&$Derived::loadFromItems} != (void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems})
            m->registerHook(getBase()+0x351010, extract_virtual(this, (void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems}));
    }
};


template <class $Derived>
class $EditorPauseLayer : public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorPauseLayer* __thistype;

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x13c680))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(LevelEditorLayer*)){&$Derived::create} != (void($EditorPauseLayer::*)(LevelEditorLayer*)){&$EditorPauseLayer::create})
            m->registerHook(getBase()+0x13c680, extract_virtual(this, (void($EditorPauseLayer::*)(LevelEditorLayer*)){&$EditorPauseLayer::create}));
    }
};


template <class $Derived>
class $GJSearchObject : public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJSearchObject* __thistype;

    virtual void create(SearchType p0, std::string p1, std::string p2, std::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, int p17, int p18) {
        return reinterpret_cast<void(*)(decltype(this), SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)>(m->getOriginal(getBase()+0x2dee30))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    virtual void create(SearchType p0) {
        return reinterpret_cast<void(*)(decltype(this), SearchType)>(m->getOriginal(getBase()+0x2df120))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$Derived::create} != (void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create})
            m->registerHook(getBase()+0x2dee30, extract_virtual(this, (void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create}));

        if ((void($Derived::*)(SearchType)){&$Derived::create} != (void($GJSearchObject::*)(SearchType)){&$GJSearchObject::create})
            m->registerHook(getBase()+0x2df120, extract_virtual(this, (void($GJSearchObject::*)(SearchType)){&$GJSearchObject::create}));
    }
};


template <class $Derived>
class $InfoLayer : public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef InfoLayer* __thistype;

    virtual void loadPage(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
    }

    virtual void onRefreshComments(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x459b60))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int, bool)){&$Derived::loadPage} != (void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage})
            m->registerHook(getBase()+0x458fb0, extract_virtual(this, (void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onRefreshComments} != (void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments})
            m->registerHook(getBase()+0x459b60, extract_virtual(this, (void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments}));
    }
};


template <class $Derived>
class $LevelBrowserLayer : public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelBrowserLayer* __thistype;

    virtual void scene(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x2511d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(GJSearchObject*)){&$Derived::scene} != (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene})
            m->registerHook(getBase()+0x2511d0, extract_virtual(this, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene}));
    }
};


template <class $Derived>
class $MenuLayer : public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MenuLayer* __thistype;

    virtual void onQuit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
    }

    virtual void onMoreGames(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onQuit} != (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit})
            m->registerHook(getBase()+0x1d2b40, extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::onMoreGames} != (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames})
            m->registerHook(getBase()+0x1d2ad0, extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames}));
    }
};


template <class $Derived>
class $Slider : public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef Slider* __thistype;

    virtual void setBarVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x18e280))(this, p0);
    }

    virtual void setValue(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x18e170))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, float)>(m->getOriginal(getBase()+0x18dc40))(this, p0, p1, p2);
    }

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)>(m->getOriginal(getBase()+0x18dd80))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(bool)){&$Derived::setBarVisibility} != (void($Slider::*)(bool)){&$Slider::setBarVisibility})
            m->registerHook(getBase()+0x18e280, extract_virtual(this, (void($Slider::*)(bool)){&$Slider::setBarVisibility}));

        if ((void($Derived::*)(float)){&$Derived::setValue} != (void($Slider::*)(float)){&$Slider::setValue})
            m->registerHook(getBase()+0x18e170, extract_virtual(this, (void($Slider::*)(float)){&$Slider::setValue}));

        if ((void($Derived::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Derived::create} != (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create})
            m->registerHook(getBase()+0x18dc40, extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create}));

        if ((void($Derived::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Derived::create} != (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create})
            m->registerHook(getBase()+0x18dd80, extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create}));
    }
};


template <class $Derived>
class $TextArea : public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TextArea* __thistype;

    virtual void create(std::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*, float, float, cocos2d::CCPoint, float, bool)>(m->getOriginal(getBase()+0x19eb40))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$Derived::create} != (void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create})
            m->registerHook(getBase()+0x19eb40, extract_virtual(this, (void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create}));
    }
};


template <class $Derived>
class $CCDirector : public $CacBase {
 public:
    $CCDirector() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDirector* __thistype;

    virtual void pushScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a620))(this, p0);
    }

    virtual void replaceScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a6d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCScene*)){&$Derived::pushScene} != (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene})
            m->registerHook(getBase()+0x24a620, extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene}));

        if ((void($Derived::*)(cocos2d::CCScene*)){&$Derived::replaceScene} != (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene})
            m->registerHook(getBase()+0x24a6d0, extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene}));
    }
};


template <class $Derived>
class $CCImage : public $CacBase {
 public:
    $CCImage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCImage* __thistype;

    virtual void initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), void*, int, cocos2d::CCImage::EImageFormat, int, int, int)>(m->getOriginal(getBase()+0x24fcb0))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$Derived::initWithImageData} != (void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData})
            m->registerHook(getBase()+0x24fcb0, extract_virtual(this, (void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData}));
    }
};


template <class $Derived>
class $CCMenu : public $CacBase {
 public:
    $CCMenu() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenu* __thistype;

    virtual void alignItemsHorizontallyWithPadding(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x4393e0))(this, p0);
    }

    virtual void createWithArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x4387e0))(this, p0);
    }

    virtual void createWithItem(cocos2d::CCMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCMenuItem*)>(m->getOriginal(getBase()+0x438b80))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float)){&$Derived::alignItemsHorizontallyWithPadding} != (void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding})
            m->registerHook(getBase()+0x4393e0, extract_virtual(this, (void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding}));

        if ((void($Derived::*)(cocos2d::CCArray*)){&$Derived::createWithArray} != (void($CCMenu::*)(cocos2d::CCArray*)){&$CCMenu::createWithArray})
            m->registerHook(getBase()+0x4387e0, extract_virtual(this, (void($CCMenu::*)(cocos2d::CCArray*)){&$CCMenu::createWithArray}));

        if ((void($Derived::*)(cocos2d::CCMenuItem*)){&$Derived::createWithItem} != (void($CCMenu::*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem})
            m->registerHook(getBase()+0x438b80, extract_virtual(this, (void($CCMenu::*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem}));
    }
};


template <class $Derived>
class $CCRenderTexture : public $CacBase {
 public:
    $CCRenderTexture() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRenderTexture* __thistype;

    virtual void create(int p0, int p1, cocos2d::CCTexture2DPixelFormat p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCTexture2DPixelFormat)>(m->getOriginal(getBase()+0x35c720))(this, p0, p1, p2);
    }

    virtual void newCCImage(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x35d7d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$Derived::create} != (void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create})
            m->registerHook(getBase()+0x35c720, extract_virtual(this, (void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create}));

        if ((void($Derived::*)(bool)){&$Derived::newCCImage} != (void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage})
            m->registerHook(getBase()+0x35d7d0, extract_virtual(this, (void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage}));
    }
};


template <class $Derived>
class $CCScheduler : public $CacBase {
 public:
    $CCScheduler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScheduler* __thistype;

    virtual void scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, int, bool)>(m->getOriginal(getBase()+0x2438d0))(this, p0, p1, p2);
    }

    virtual void unscheduleAllForTarget(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x243e40))(this, p0);
    }

    virtual void scheduleSelector(Cacao::CC_SCHED p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)>(m->getOriginal(getBase()+0x242b20))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCObject*, int, bool)){&$Derived::scheduleUpdateForTarget} != (void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget})
            m->registerHook(getBase()+0x2438d0, extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget}));

        if ((void($Derived::*)(cocos2d::CCObject*)){&$Derived::unscheduleAllForTarget} != (void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget})
            m->registerHook(getBase()+0x243e40, extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget}));

        if ((void($Derived::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$Derived::scheduleSelector} != (void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector})
            m->registerHook(getBase()+0x242b20, extract_virtual(this, (void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector}));
    }
};


template <class $Derived>
class $CCTintTo : public $CacBase {
 public:
    $CCTintTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTintTo* __thistype;

    virtual void create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char, unsigned char, unsigned char)>(m->getOriginal(getBase()+0x1f82a0))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, unsigned char, unsigned char, unsigned char)){&$Derived::create} != (void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create})
            m->registerHook(getBase()+0x1f82a0, extract_virtual(this, (void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create}));
    }
};


template <class $Derived>
class $CCTransitionFade : public $CacBase {
 public:
    $CCTransitionFade() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTransitionFade* __thistype;

    virtual void create(float p0, cocos2d::CCScene* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCScene*)>(m->getOriginal(getBase()+0x8ea30))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(float, cocos2d::CCScene*)){&$Derived::create} != (void($CCTransitionFade::*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create})
            m->registerHook(getBase()+0x8ea30, extract_virtual(this, (void($CCTransitionFade::*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create}));
    }
};


template <class $Derived>
class $CreateMenuItem : public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CreateMenuItem* __thistype;

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1c580))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($Derived::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$Derived::create} != (void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create})
            m->registerHook(getBase()+0x1c580, extract_virtual(this, (void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create}));
    }
};
