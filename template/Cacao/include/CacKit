//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
using namespace cocos2d::extension;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

#define APPLY_HOOKS() void __apply_hooks() {                \
    __if_exists(inject) {                                   \
        inject();                                           \
    };                                                       \
    for(auto& i : __cackit::glob) i->apply_hooks();         \
    if (__cackit::glob.size() > 0) m->enable();             \
}                                                           \
static int const __cachook = (__apply_hooks(), 0)
#define $apply() APPLY_HOOKS()

#define CONCAT_(x, y) x##y
#define CONCAT(x, y) CONCAT_(x, y)
#define REDIRECT_(base, counter) CONCAT($hook, counter): public base<CONCAT($hook, counter)>
#define $redirect(base) REDIRECT_($##base, __COUNTER__)

typedef char const* c_string;

// deprecated lol
template <class F>
struct GetReturnType;

// deprecated lol
template <class K>
struct RemoveRef;

// deprecated lol
template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

// deprecated lol
template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

// deprecated lol
#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

// "A destructor is used to destroy objects of its class type. The address of a destructor shall not be taken."
// - C++ standard 12.4.2
// Therefore, we shall not take the destructor of the class and replace it with an empty function. ~alk
template <class T>
inline long extract_destructor(T instance) {
    return (*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+8));
};

// Welcome back we missed you
template <typename F, class T>
inline long extract_virtual(T instance, F func) {
    return (*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};

template <typename F>
inline long extract(F func) {
    return (*reinterpret_cast<long*>(&func));
};

class $CacBase {
public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}


template<class D>
class $AnimatedGameObject : public AnimatedGameObject, public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AnimatedGameObject() {}
    typedef AnimatedGameObject* __thistype;

    void playAnimation(int p0) {
        if ((void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation} != (void(D::*)(int)){&D::playAnimation})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
        else return AnimatedGameObject::playAnimation(p0);
    }

    void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0xc8450))(this, p0);
        else return AnimatedGameObject::updateChildSpriteColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation} != (void(D::*)(int)){&D::playAnimation})
            m->registerHook(getBase()+0xc93d0, extract((void(D::*)(int)){&D::playAnimation}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor})
            m->registerHook(getBase()+0xc8450, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor}));
    }
};


template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
 public:
    $AppDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AppDelegate() {}
    typedef AppDelegate* __thistype;

    void bgScale() {
        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aaab0))(this);
        else return AppDelegate::bgScale();
    }

    static AppDelegate* get() {
        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            return reinterpret_cast<AppDelegate*(*)()>(m->getOriginal(getBase()+0x3aab10))();
        else return AppDelegate::get();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            m->registerHook(getBase()+0x3aaab0, extract((void(D::*)()){&D::bgScale}));

        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            m->registerHook(getBase()+0x3aab10, (AppDelegate*(*)()){&D::get});
    }
};


template<class D>
class $AudioEffectsLayer : public AudioEffectsLayer, public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$AudioEffectsLayer() {}
    typedef AudioEffectsLayer* __thistype;

    void audioStep(float p0) {
        if ((void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep} != (void(D::*)(float)){&D::audioStep})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x271f40))(this, p0);
        else return AudioEffectsLayer::audioStep(p0);
    }

    static AudioEffectsLayer* create(std::string p0) {
        if ((AudioEffectsLayer*(*)(std::string)){&$AudioEffectsLayer::create} != (AudioEffectsLayer*(*)(std::string)){&D::create})
            return reinterpret_cast<AudioEffectsLayer*(*)(std::string)>(m->getOriginal(getBase()+0x271a00))(p0);
        else return AudioEffectsLayer::create(p0);
    }

    void resetAudioVars() {
        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars} != (void(D::*)()){&D::resetAudioVars})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x271ee0))(this);
        else return AudioEffectsLayer::resetAudioVars();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep} != (void(D::*)(float)){&D::audioStep})
            m->registerHook(getBase()+0x271f40, extract((void(D::*)(float)){&D::audioStep}));

        if ((AudioEffectsLayer*(*)(std::string)){&$AudioEffectsLayer::create} != (AudioEffectsLayer*(*)(std::string)){&D::create})
            m->registerHook(getBase()+0x271a00, (AudioEffectsLayer*(*)(std::string)){&D::create});

        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars} != (void(D::*)()){&D::resetAudioVars})
            m->registerHook(getBase()+0x271ee0, extract((void(D::*)()){&D::resetAudioVars}));
    }
};


template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ButtonSprite() {}
    typedef ButtonSprite* __thistype;

    static ButtonSprite* create(char const* p0) {
        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*)>(m->getOriginal(getBase()+0x4fa10))(p0);
        else return ButtonSprite::create(p0);
    }

    static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*, int, int, float, bool)>(m->getOriginal(getBase()+0x4fa40))(p0, p1, p2, p3, p4);
        else return ButtonSprite::create(p0, p1, p2, p3, p4);
    }

    void updateBGImage(char const* p0) {
        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x502d0))(this, p0);
        else return ButtonSprite::updateBGImage(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x4fa10, (ButtonSprite*(*)(char const*)){&D::create});

        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            m->registerHook(getBase()+0x4fa40, (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create});

        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            m->registerHook(getBase()+0x502d0, extract((void(D::*)(char const*)){&D::updateBGImage}));
    }
};


template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCAnimatedSprite() {}
    typedef CCAnimatedSprite* __thistype;

    void runAnimation(std::string p0) {
        if ((void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(std::string)){&D::runAnimation})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
        else return CCAnimatedSprite::runAnimation(p0);
    }

    void tweenToAnimation(std::string p0, float p1) {
        if ((void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(std::string, float)){&D::tweenToAnimation})
            return reinterpret_cast<void(*)(decltype(this), std::string, float)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
        else return CCAnimatedSprite::tweenToAnimation(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(std::string)){&D::runAnimation})
            m->registerHook(getBase()+0x1a6430, extract((void(D::*)(std::string)){&D::runAnimation}));

        if ((void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(std::string, float)){&D::tweenToAnimation})
            m->registerHook(getBase()+0x1a65b0, extract((void(D::*)(std::string, float)){&D::tweenToAnimation}));
    }
};


template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCCircleWave() {}
    typedef CCCircleWave* __thistype;

    static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool)>(m->getOriginal(getBase()+0xbd270))(p0, p1, p2, p3);
        else return CCCircleWave::create(p0, p1, p2, p3);
    }

    static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool, bool)>(m->getOriginal(getBase()+0xbd290))(p0, p1, p2, p3, p4);
        else return CCCircleWave::create(p0, p1, p2, p3, p4);
    }

    void followObject(cocos2d::CCNode* p0, bool p1) {
        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
        else return CCCircleWave::followObject(p0, p1);
    }

    void updatePosition(float p0) {
        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xbd630))(this, p0);
        else return CCCircleWave::updatePosition(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            m->registerHook(getBase()+0xbd270, (CCCircleWave*(*)(float, float, float, bool)){&D::create});

        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            m->registerHook(getBase()+0xbd290, (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create});

        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            m->registerHook(getBase()+0xbd670, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::followObject}));

        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            m->registerHook(getBase()+0xbd630, extract((void(D::*)(float)){&D::updatePosition}));
    }
};


template<class D>
class $CCCircleWaveDelegate : public CCCircleWaveDelegate, public $CacBase {
 public:
    $CCCircleWaveDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCCircleWaveDelegate() {}
    typedef CCCircleWaveDelegate* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCLightFlash() {}
    typedef CCLightFlash* __thistype;

    static CCLightFlash* create() {
        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            return reinterpret_cast<CCLightFlash*(*)()>(m->getOriginal(getBase()+0x295870))();
        else return CCLightFlash::create();
    }

    void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        if ((void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
        else return CCLightFlash::playEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            m->registerHook(getBase()+0x295870, (CCLightFlash*(*)()){&D::create});

        if ((void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect})
            m->registerHook(getBase()+0x295900, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect}));
    }
};


template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMenuItemSpriteExtra() {}
    typedef CCMenuItemSpriteExtra* __thistype;

    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_CallFuncO p3) {
        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)>(m->getOriginal(getBase()+0x1253c0))(p0, p1, p2, p3);
        else return CCMenuItemSpriteExtra::create(p0, p1, p2, p3);
    }

    void setSizeMult(float p0) {
        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
        else return CCMenuItemSpriteExtra::setSizeMult(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create})
            m->registerHook(getBase()+0x1253c0, (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create});

        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(getBase()+0x1255e0, extract((void(D::*)(float)){&D::setSizeMult}));
    }
};


template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMenuItemToggler() {}
    typedef CCMenuItemToggler* __thistype;

    static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_CallFuncO p3) {
        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create})
            return reinterpret_cast<CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)>(m->getOriginal(getBase()+0x38400))(p0, p1, p2, p3);
        else return CCMenuItemToggler::create(p0, p1, p2, p3);
    }

    void setSizeMult(float p0) {
        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x38a40))(this, p0);
        else return CCMenuItemToggler::setSizeMult(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create})
            m->registerHook(getBase()+0x38400, (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_CallFuncO)){&D::create});

        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(getBase()+0x38a40, extract((void(D::*)(float)){&D::setSizeMult}));
    }
};


template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
 public:
    $CCMoveCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCMoveCNode() {}
    typedef CCMoveCNode* __thistype;

    static CCMoveCNode* create() {
        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            return reinterpret_cast<CCMoveCNode*(*)()>(m->getOriginal(getBase()+0x1842a0))();
        else return CCMoveCNode::create();
    }

    bool init() {
        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x18b3d0))(this);
        else return CCMoveCNode::init();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            m->registerHook(getBase()+0x1842a0, (CCMoveCNode*(*)()){&D::create});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x18b3d0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
 public:
    $CCNodeContainer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCNodeContainer() {}
    typedef CCNodeContainer* __thistype;

    static CCNodeContainer* create() {
        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            return reinterpret_cast<CCNodeContainer*(*)()>(m->getOriginal(getBase()+0xb1090))();
        else return CCNodeContainer::create();
    }

    bool init() {
        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xba950))(this);
        else return CCNodeContainer::init();
    }

    void visit() {
        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xba960))(this);
        else return CCNodeContainer::visit();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            m->registerHook(getBase()+0xb1090, (CCNodeContainer*(*)()){&D::create});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xba950, extract((bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0xba960, extract((void(D::*)()){&D::visit}));
    }
};


template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCSpritePlus() {}
    typedef CCSpritePlus* __thistype;

    bool initWithSpriteFrameName(char const* p0) {
        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x248670))(this, p0);
        else return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            m->registerHook(getBase()+0x248670, extract((bool(D::*)(char const*)){&D::initWithSpriteFrameName}));
    }
};


template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CCTextInputNode() {}
    typedef CCTextInputNode* __thistype;

    static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            return reinterpret_cast<CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)>(m->getOriginal(getBase()+0x5cfb0))(p0, p1, p2, p3, p4, p5);
        else return CCTextInputNode::create(p0, p1, p2, p3, p4, p5);
    }

    std::string getString() {
        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
        else return CCTextInputNode::getString();
    }

    void refreshLabel() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d730))(this);
        else return CCTextInputNode::refreshLabel();
    }

    void setAllowedChars(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::string)){&D::setAllowedChars})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d360))(this, p0);
        else return CCTextInputNode::setAllowedChars(p0);
    }

    void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x5da90))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderColor(p0);
    }

    void setLabelPlaceholderScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da70))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderScale(p0);
    }

    void setMaxLabelScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da30))(this, p0);
        else return CCTextInputNode::setMaxLabelScale(p0);
    }

    void setMaxLabelWidth(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da50))(this, p0);
        else return CCTextInputNode::setMaxLabelWidth(p0);
    }

    void setString(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString} != (void(D::*)(std::string)){&D::setString})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
        else return CCTextInputNode::setString(p0);
    }

    void updateLabel(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::string)){&D::updateLabel})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d4a0))(this, p0);
        else return CCTextInputNode::updateLabel(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            m->registerHook(getBase()+0x5cfb0, (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create});

        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            m->registerHook(getBase()+0x5d6f0, extract((std::string(D::*)()){&D::getString}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            m->registerHook(getBase()+0x5d730, extract((void(D::*)()){&D::refreshLabel}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::string)){&D::setAllowedChars})
            m->registerHook(getBase()+0x5d360, extract((void(D::*)(std::string)){&D::setAllowedChars}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            m->registerHook(getBase()+0x5da90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            m->registerHook(getBase()+0x5da70, extract((void(D::*)(float)){&D::setLabelPlaceholderScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            m->registerHook(getBase()+0x5da30, extract((void(D::*)(float)){&D::setMaxLabelScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            m->registerHook(getBase()+0x5da50, extract((void(D::*)(float)){&D::setMaxLabelWidth}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString} != (void(D::*)(std::string)){&D::setString})
            m->registerHook(getBase()+0x5d3e0, extract((void(D::*)(std::string)){&D::setString}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::string)){&D::updateLabel})
            m->registerHook(getBase()+0x5d4a0, extract((void(D::*)(std::string)){&D::updateLabel}));
    }
};


template<class D>
class $CheckpointObject : public CheckpointObject, public $CacBase {
 public:
    $CheckpointObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CheckpointObject() {}
    typedef CheckpointObject* __thistype;

    static CheckpointObject* create() {
        if ((CheckpointObject*(*)()){&$CheckpointObject::create} != (CheckpointObject*(*)()){&D::create})
            return reinterpret_cast<CheckpointObject*(*)()>(m->getOriginal(getBase()+0x7e7d0))();
        else return CheckpointObject::create();
    }

    void getObject() {
        if ((void($CheckpointObject::*)()){&$CheckpointObject::getObject} != (void(D::*)()){&D::getObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef50))(this);
        else return CheckpointObject::getObject();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CheckpointObject*(*)()){&$CheckpointObject::create} != (CheckpointObject*(*)()){&D::create})
            m->registerHook(getBase()+0x7e7d0, (CheckpointObject*(*)()){&D::create});

        if ((void($CheckpointObject::*)()){&$CheckpointObject::getObject} != (void(D::*)()){&D::getObject})
            m->registerHook(getBase()+0x7ef50, extract((void(D::*)()){&D::getObject}));
    }
};


template<class D>
class $CollisionBlockPopup : public CollisionBlockPopup, public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CollisionBlockPopup() {}
    typedef CollisionBlockPopup* __thistype;

    static CollisionBlockPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create} != (CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x130010))(p0, p1);
        else return CollisionBlockPopup::create(p0, p1);
    }

    void onNextItemID(cocos2d::CCObject* p0) {
        if ((void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x130e60))(this, p0);
        else return CollisionBlockPopup::onNextItemID(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create} != (CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x130010, (CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            m->registerHook(getBase()+0x130e60, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextItemID}));
    }
};


template<class D>
class $CollisionTriggerAction : public CollisionTriggerAction, public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CollisionTriggerAction() {}
    typedef CollisionTriggerAction* __thistype;

    static CollisionTriggerAction* createFromString(std::string p0) {
        if ((CollisionTriggerAction*(*)(std::string)){&$CollisionTriggerAction::createFromString} != (CollisionTriggerAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<CollisionTriggerAction*(*)(std::string)>(m->getOriginal(getBase()+0x176ee0))(p0);
        else return CollisionTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CollisionTriggerAction*(*)(std::string)){&$CollisionTriggerAction::createFromString} != (CollisionTriggerAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x176ee0, (CollisionTriggerAction*(*)(std::string)){&D::createFromString});
    }
};


template<class D>
class $ColorAction : public ColorAction, public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorAction() {}
    typedef ColorAction* __thistype;

    void getSaveString() {
        if ((void($ColorAction::*)()){&$ColorAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17d080))(this);
        else return ColorAction::getSaveString();
    }

    void setupFromDict(cocos2d::CCDictionary* p0) {
        if ((void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupFromDict})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0x17f310))(this, p0);
        else return ColorAction::setupFromDict(p0);
    }

    void setupFromString(std::string p0) {
        if ((void($ColorAction::*)(std::string)){&$ColorAction::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17f270))(this, p0);
        else return ColorAction::setupFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($ColorAction::*)()){&$ColorAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17d080, extract((void(D::*)()){&D::getSaveString}));

        if ((void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupFromDict})
            m->registerHook(getBase()+0x17f310, extract((void(D::*)(cocos2d::CCDictionary*)){&D::setupFromDict}));

        if ((void($ColorAction::*)(std::string)){&$ColorAction::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            m->registerHook(getBase()+0x17f270, extract((void(D::*)(std::string)){&D::setupFromString}));
    }
};


template<class D>
class $ColorActionSprite : public ColorActionSprite, public $CacBase {
 public:
    $ColorActionSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorActionSprite() {}
    typedef ColorActionSprite* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $ColorChannelSprite : public ColorChannelSprite, public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorChannelSprite() {}
    typedef ColorChannelSprite* __thistype;

    void updateBlending(bool p0) {
        if ((void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending} != (void(D::*)(bool)){&D::updateBlending})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x16e1d0))(this, p0);
        else return ColorChannelSprite::updateBlending(p0);
    }

    void updateCopyLabel(int p0, bool p1) {
        if ((void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel} != (void(D::*)(int, bool)){&D::updateCopyLabel})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x16ded0))(this, p0, p1);
        else return ColorChannelSprite::updateCopyLabel(p0, p1);
    }

    void updateOpacity(float p0) {
        if ((void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity} != (void(D::*)(float)){&D::updateOpacity})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x16e080))(this, p0);
        else return ColorChannelSprite::updateOpacity(p0);
    }

    void updateValues(ColorAction* p0) {
        if ((void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues} != (void(D::*)(ColorAction*)){&D::updateValues})
            return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
        else return ColorChannelSprite::updateValues(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending} != (void(D::*)(bool)){&D::updateBlending})
            m->registerHook(getBase()+0x16e1d0, extract((void(D::*)(bool)){&D::updateBlending}));

        if ((void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel} != (void(D::*)(int, bool)){&D::updateCopyLabel})
            m->registerHook(getBase()+0x16ded0, extract((void(D::*)(int, bool)){&D::updateCopyLabel}));

        if ((void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity} != (void(D::*)(float)){&D::updateOpacity})
            m->registerHook(getBase()+0x16e080, extract((void(D::*)(float)){&D::updateOpacity}));

        if ((void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues} != (void(D::*)(ColorAction*)){&D::updateValues})
            m->registerHook(getBase()+0x16e2e0, extract((void(D::*)(ColorAction*)){&D::updateValues}));
    }
};


template<class D>
class $ColorPickerDelegate : public ColorPickerDelegate, public $CacBase {
 public:
    $ColorPickerDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorPickerDelegate() {}
    typedef ColorPickerDelegate* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $ColorSelectLiveOverlay : public ColorSelectLiveOverlay, public $CacBase {
 public:
    $ColorSelectLiveOverlay() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorSelectLiveOverlay() {}
    typedef ColorSelectLiveOverlay* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $ConfigureValuePopup : public ConfigureValuePopup, public $CacBase {
 public:
    $ConfigureValuePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ConfigureValuePopup() {}
    typedef ConfigureValuePopup* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $CountTriggerAction : public CountTriggerAction, public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CountTriggerAction() {}
    typedef CountTriggerAction* __thistype;

    static CountTriggerAction* createFromString(std::string p0) {
        if ((CountTriggerAction*(*)(std::string)){&$CountTriggerAction::createFromString} != (CountTriggerAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<CountTriggerAction*(*)(std::string)>(m->getOriginal(getBase()+0x1754f0))(p0);
        else return CountTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((CountTriggerAction*(*)(std::string)){&$CountTriggerAction::createFromString} != (CountTriggerAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x1754f0, (CountTriggerAction*(*)(std::string)){&D::createFromString});
    }
};


template<class D>
class $CreateMenuItem : public CreateMenuItem, public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CreateMenuItem() {}
    typedef CreateMenuItem* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $CreatorLayer : public CreatorLayer, public $CacBase {
 public:
    $CreatorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CreatorLayer() {}
    typedef CreatorLayer* __thistype;

    void onMyLevels(cocos2d::CCObject* p0) {
        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onMyLevels})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142b70))(this, p0);
        else return CreatorLayer::onMyLevels(p0);
    }

    void onSavedLevels(cocos2d::CCObject* p0) {
        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onSavedLevels})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142860))(this, p0);
        else return CreatorLayer::onSavedLevels(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onMyLevels})
            m->registerHook(getBase()+0x142b70, extract((void(D::*)(cocos2d::CCObject*)){&D::onMyLevels}));

        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onSavedLevels})
            m->registerHook(getBase()+0x142860, extract((void(D::*)(cocos2d::CCObject*)){&D::onSavedLevels}));
    }
};


template<class D>
class $CurrencyRewardLayer : public CurrencyRewardLayer, public $CacBase {
 public:
    $CurrencyRewardLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CurrencyRewardLayer() {}
    typedef CurrencyRewardLayer* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $CustomizeObjectLayer : public CustomizeObjectLayer, public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$CustomizeObjectLayer() {}
    typedef CustomizeObjectLayer* __thistype;

    void colorSelectClosed(cocos2d::CCNode* p0) {
        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xe1050))(this, p0);
        else return CustomizeObjectLayer::colorSelectClosed(p0);
    }

    static CustomizeObjectLayer* create(GameObject* p0, cocos2d::CCArray* p1) {
        if ((CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create} != (CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd340))(p0, p1);
        else return CustomizeObjectLayer::create(p0, p1);
    }

    bool init(GameObject* p0, cocos2d::CCArray* p1) {
        if ((bool($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init} != (bool(D::*)(GameObject*, cocos2d::CCArray*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
        else return CustomizeObjectLayer::init(p0, p1);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1470))(this, p0);
        else return CustomizeObjectLayer::textChanged(p0);
    }

    void textInputClosed(CCTextInputNode* p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1430))(this, p0);
        else return CustomizeObjectLayer::textInputClosed(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(getBase()+0xe1050, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create} != (CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0xdd340, (CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init} != (bool(D::*)(GameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0xdd560, extract((bool(D::*)(GameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0xe1470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(getBase()+0xe1430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));
    }
};


template<class D>
class $DelayedSpawnNode : public DelayedSpawnNode, public $CacBase {
 public:
    $DelayedSpawnNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DelayedSpawnNode() {}
    typedef DelayedSpawnNode* __thistype;

    static DelayedSpawnNode* create() {
        if ((DelayedSpawnNode*(*)()){&$DelayedSpawnNode::create} != (DelayedSpawnNode*(*)()){&D::create})
            return reinterpret_cast<DelayedSpawnNode*(*)()>(m->getOriginal(getBase()+0x9b360))();
        else return DelayedSpawnNode::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((DelayedSpawnNode*(*)()){&$DelayedSpawnNode::create} != (DelayedSpawnNode*(*)()){&D::create})
            m->registerHook(getBase()+0x9b360, (DelayedSpawnNode*(*)()){&D::create});
    }
};


template<class D>
class $DialogLayer : public DialogLayer, public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DialogLayer() {}
    typedef DialogLayer* __thistype;

    static DialogLayer* create(DialogObject* p0, int p1) {
        if ((DialogLayer*(*)(DialogObject*, int)){&$DialogLayer::create} != (DialogLayer*(*)(DialogObject*, int)){&D::create})
            return reinterpret_cast<DialogLayer*(*)(DialogObject*, int)>(m->getOriginal(getBase()+0x2047c0))(p0, p1);
        else return DialogLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((DialogLayer*(*)(DialogObject*, int)){&$DialogLayer::create} != (DialogLayer*(*)(DialogObject*, int)){&D::create})
            m->registerHook(getBase()+0x2047c0, (DialogLayer*(*)(DialogObject*, int)){&D::create});
    }
};


template<class D>
class $DialogObject : public DialogObject, public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DialogObject() {}
    typedef DialogObject* __thistype;

    static DialogObject* create(std::string p0, std::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) {
        if ((DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create} != (DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&D::create})
            return reinterpret_cast<DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x204410))(p0, p1, p2, p3, p4, p5);
        else return DialogObject::create(p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create} != (DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&D::create})
            m->registerHook(getBase()+0x204410, (DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&D::create});
    }
};


template<class D>
class $DrawGridLayer : public DrawGridLayer, public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$DrawGridLayer() {}
    typedef DrawGridLayer* __thistype;

    void addPlayer2Point(cocos2d::CCPoint p0, bool p1) {
        if ((void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point} != (void(D::*)(cocos2d::CCPoint, bool)){&D::addPlayer2Point})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
        else return DrawGridLayer::addPlayer2Point(p0, p1);
    }

    void addPlayerPoint(cocos2d::CCPoint p0) {
        if ((void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPlayerPoint})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
        else return DrawGridLayer::addPlayerPoint(p0);
    }

    void addToSpeedObjects(GameObject* p0) {
        if ((void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x99900))(this, p0);
        else return DrawGridLayer::addToSpeedObjects(p0);
    }

    static DrawGridLayer* create(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        if ((DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create} != (DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::create})
            return reinterpret_cast<DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0x920c0))(p0, p1);
        else return DrawGridLayer::create(p0, p1);
    }

    bool init(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        if ((bool($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init} != (bool(D::*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa36e0))(this, p0, p1);
        else return DrawGridLayer::init(p0, p1);
    }

    void timeForXPos(float p0) {
        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9b330))(this, p0);
        else return DrawGridLayer::timeForXPos(p0);
    }

    void update(float p0) {
        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa3b30))(this, p0);
        else return DrawGridLayer::update(p0);
    }

    void updateTimeMarkers() {
        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers} != (void(D::*)()){&D::updateTimeMarkers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92950))(this);
        else return DrawGridLayer::updateTimeMarkers();
    }

    void xPosForTime(float p0) {
        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c830))(this, p0);
        else return DrawGridLayer::xPosForTime(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point} != (void(D::*)(cocos2d::CCPoint, bool)){&D::addPlayer2Point})
            m->registerHook(getBase()+0xa25b0, extract((void(D::*)(cocos2d::CCPoint, bool)){&D::addPlayer2Point}));

        if ((void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPlayerPoint})
            m->registerHook(getBase()+0xa39c0, extract((void(D::*)(cocos2d::CCPoint)){&D::addPlayerPoint}));

        if ((void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x99900, extract((void(D::*)(GameObject*)){&D::addToSpeedObjects}));

        if ((DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create} != (DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x920c0, (DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::create});

        if ((bool($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init} != (bool(D::*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::init})
            m->registerHook(getBase()+0xa36e0, extract((bool(D::*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::init}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x9b330, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0xa3b30, extract((void(D::*)(float)){&D::update}));

        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers} != (void(D::*)()){&D::updateTimeMarkers})
            m->registerHook(getBase()+0x92950, extract((void(D::*)()){&D::updateTimeMarkers}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c830, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $EditButtonBar : public EditButtonBar, public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditButtonBar() {}
    typedef EditButtonBar* __thistype;

    void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        if ((void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
        else return EditButtonBar::loadFromItems(p0, p1, p2, p3);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems})
            m->registerHook(getBase()+0x351010, extract((void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems}));
    }
};


template<class D>
class $EditorOptionsLayer : public EditorOptionsLayer, public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorOptionsLayer() {}
    typedef EditorOptionsLayer* __thistype;

    void onButtonsPerRow(cocos2d::CCObject* p0) {
        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow} != (void(D::*)(cocos2d::CCObject*)){&D::onButtonsPerRow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x147b30))(this, p0);
        else return EditorOptionsLayer::onButtonsPerRow(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow} != (void(D::*)(cocos2d::CCObject*)){&D::onButtonsPerRow})
            m->registerHook(getBase()+0x147b30, extract((void(D::*)(cocos2d::CCObject*)){&D::onButtonsPerRow}));
    }
};


template<class D>
class $EditorUI : public EditorUI, public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorUI() {}
    typedef EditorUI* __thistype;

    void constrainGameLayerPosition() {
        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c6d0))(this);
        else return EditorUI::constrainGameLayerPosition();
    }

    void create(LevelEditorLayer* p0) {
        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer*)){&D::create})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8a80))(this, p0);
        else return EditorUI::create(p0);
    }

    void deselectAll() {
        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
        else return EditorUI::deselectAll();
    }

    void onDeselectAll(CCObject* p0) {
        if ((void($EditorUI::*)(CCObject*)){&$EditorUI::onDeselectAll} != (void(D::*)(CCObject*)){&D::onDeselectAll})
            return reinterpret_cast<void(*)(decltype(this), CCObject*)>(m->getOriginal(getBase()+0x19cd0))(this, p0);
        else return EditorUI::onDeselectAll(p0);
    }

    void disableButton(CreateMenuItem* p0) {
        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem*)){&D::disableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
        else return EditorUI::disableButton(p0);
    }

    void editButtonUsable() {
        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28f30))(this);
        else return EditorUI::editButtonUsable();
    }

    void editObject(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject*)){&D::editObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x195a0))(this, p0);
        else return EditorUI::editObject(p0);
    }

    void enableButton(CreateMenuItem* p0) {
        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem*)){&D::enableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
        else return EditorUI::enableButton(p0);
    }

    CCMenuItemSpriteExtra* getCreateBtn(int p0, int p1) {
        if ((CCMenuItemSpriteExtra*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
        else return EditorUI::getCreateBtn(p0, p1);
    }

    void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
        else return EditorUI::getGroupCenter(p0, p1);
    }

    cocos2d::CCArray* getSelectedObjects() {
        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            return reinterpret_cast<cocos2d::CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
        else return EditorUI::getSelectedObjects();
    }

    void init(LevelEditorLayer* p0) {
        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer*)){&D::init})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8ae0))(this, p0);
        else return EditorUI::init(p0);
    }

    void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x30790))(this, p0);
        else return EditorUI::keyDown(p0);
    }

    void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        if ((void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
        else return EditorUI::moveObject(p0, p1);
    }

    void onDuplicate(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject*)){&D::onDuplicate})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
        else return EditorUI::onDuplicate(p0);
    }

    void pasteObjects(std::string p0) {
        if ((void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects} != (void(D::*)(std::string)){&D::pasteObjects})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x232d0))(this, p0);
        else return EditorUI::pasteObjects(p0);
    }

    void playtestStopped() {
        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24790))(this);
        else return EditorUI::playtestStopped();
    }

    void redoLastAction(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
        else return EditorUI::redoLastAction(p0);
    }

    void replaceGroupID(GameObject* p0, int p1, int p2) {
        if ((void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject*, int, int)){&D::replaceGroupID})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, int)>(m->getOriginal(getBase()+0x27470))(this, p0, p1, p2);
        else return EditorUI::replaceGroupID(p0, p1, p2);
    }

    void scaleChanged(float p0) {
        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x25490))(this, p0);
        else return EditorUI::scaleChanged(p0);
    }

    void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
        else return EditorUI::scaleObjects(p0, p1, p2);
    }

    void selectObjects(cocos2d::CCArray* p0, bool p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
        else return EditorUI::selectObjects(p0, p1);
    }

    void setupCreateMenu() {
        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xcb50))(this);
        else return EditorUI::setupCreateMenu();
    }

    void undoLastAction(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb830))(this, p0);
        else return EditorUI::undoLastAction(p0);
    }

    void updateButtons() {
        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
        else return EditorUI::updateButtons();
    }

    void updateObjectInfoLabel() {
        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cb10))(this);
        else return EditorUI::updateObjectInfoLabel();
    }

    void updateSlider() {
        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18a90))(this);
        else return EditorUI::updateSlider();
    }

    void updateZoom(float p0) {
        if ((void($EditorUI::*)(float)){&$EditorUI::updateZoom} != (void(D::*)(float)){&D::updateZoom})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x248c0))(this, p0);
        else return EditorUI::updateZoom(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            m->registerHook(getBase()+0x1c6d0, extract((void(D::*)()){&D::constrainGameLayerPosition}));

        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x8a80, extract((void(D::*)(LevelEditorLayer*)){&D::create}));

        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            m->registerHook(getBase()+0x1f300, extract((void(D::*)()){&D::deselectAll}));

        if ((void($EditorUI::*)(CCObject*)){&$EditorUI::onDeselectAll} != (void(D::*)(CCObject*)){&D::onDeselectAll})
            m->registerHook(getBase()+0x19cd0, extract((void(D::*)(CCObject*)){&D::onDeselectAll}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem*)){&D::disableButton})
            m->registerHook(getBase()+0x1c0f0, extract((void(D::*)(CreateMenuItem*)){&D::disableButton}));

        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            m->registerHook(getBase()+0x28f30, extract((void(D::*)()){&D::editButtonUsable}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject*)){&D::editObject})
            m->registerHook(getBase()+0x195a0, extract((void(D::*)(cocos2d::CCObject*)){&D::editObject}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem*)){&D::enableButton})
            m->registerHook(getBase()+0x1bff0, extract((void(D::*)(CreateMenuItem*)){&D::enableButton}));

        if ((CCMenuItemSpriteExtra*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn})
            m->registerHook(getBase()+0x1f6c0, extract((CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter})
            m->registerHook(getBase()+0x23470, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter}));

        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            m->registerHook(getBase()+0x23f30, extract((cocos2d::CCArray*(D::*)()){&D::getSelectedObjects}));

        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer*)){&D::init})
            m->registerHook(getBase()+0x8ae0, extract((void(D::*)(LevelEditorLayer*)){&D::init}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(getBase()+0x30790, extract_virtual(this, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject})
            m->registerHook(getBase()+0x24b10, extract((void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject*)){&D::onDuplicate})
            m->registerHook(getBase()+0x18ba0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDuplicate}));

        if ((void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects} != (void(D::*)(std::string)){&D::pasteObjects})
            m->registerHook(getBase()+0x232d0, extract((void(D::*)(std::string)){&D::pasteObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            m->registerHook(getBase()+0x24790, extract((void(D::*)()){&D::playtestStopped}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::redoLastAction})
            m->registerHook(getBase()+0xb8e0, extract((void(D::*)(cocos2d::CCObject*)){&D::redoLastAction}));

        if ((void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject*, int, int)){&D::replaceGroupID})
            m->registerHook(getBase()+0x27470, extract((void(D::*)(GameObject*, int, int)){&D::replaceGroupID}));

        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            m->registerHook(getBase()+0x25490, extract((void(D::*)(float)){&D::scaleChanged}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects})
            m->registerHook(getBase()+0x252e0, extract((void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects})
            m->registerHook(getBase()+0x23940, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            m->registerHook(getBase()+0xcb50, extract((void(D::*)()){&D::setupCreateMenu}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::undoLastAction})
            m->registerHook(getBase()+0xb830, extract((void(D::*)(cocos2d::CCObject*)){&D::undoLastAction}));

        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            m->registerHook(getBase()+0x1a300, extract((void(D::*)()){&D::updateButtons}));

        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            m->registerHook(getBase()+0x1cb10, extract((void(D::*)()){&D::updateObjectInfoLabel}));

        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            m->registerHook(getBase()+0x18a90, extract((void(D::*)()){&D::updateSlider}));

        if ((void($EditorUI::*)(float)){&$EditorUI::updateZoom} != (void(D::*)(float)){&D::updateZoom})
            m->registerHook(getBase()+0x248c0, extract((void(D::*)(float)){&D::updateZoom}));
    }
};


template<class D>
class $EndLevelLayer : public EndLevelLayer, public $CacBase {
 public:
    $EndLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EndLevelLayer() {}
    typedef EndLevelLayer* __thistype;

    static EndLevelLayer* create() {
        if ((EndLevelLayer*(*)()){&$EndLevelLayer::create} != (EndLevelLayer*(*)()){&D::create})
            return reinterpret_cast<EndLevelLayer*(*)()>(m->getOriginal(getBase()+0x2787d0))();
        else return EndLevelLayer::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((EndLevelLayer*(*)()){&$EndLevelLayer::create} != (EndLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x2787d0, (EndLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FLAlertLayer() {}
    typedef FLAlertLayer* __thistype;

    void onEnter() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f350))(this);
        else return FLAlertLayer::onEnter();
    }

    bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
        else return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
        else return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
        else return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
        else return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    void registerWithTouchDispatcher() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f2e0))(this);
        else return FLAlertLayer::registerWithTouchDispatcher();
    }

    void keyBackClicked() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25ed90))(this);
        else return FLAlertLayer::keyBackClicked();
    }

    void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
        else return FLAlertLayer::keyDown(p0);
    }

    void show() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f120))(this);
        else return FLAlertLayer::show();
    }

    bool init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) override {
        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::init(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(getBase()+0x25e0e0))(p0, p1, p2, p3, p4, p5);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25dec0))(p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(getBase()+0x25f350, extract_virtual(this, (void(D::*)()){&D::onEnter}));

        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(getBase()+0x25ee40, extract_virtual(this, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(getBase()+0x25f0a0, extract_virtual(this, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(getBase()+0x25ef60, extract_virtual(this, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(getBase()+0x25f020, extract_virtual(this, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x25f2e0, extract_virtual(this, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x25ed90, extract_virtual(this, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(getBase()+0x25ece0, extract_virtual(this, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x25f120, extract_virtual(this, (void(D::*)()){&D::show}));

        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init})
            m->registerHook(getBase()+0x25e1b0, extract_virtual(this, (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init}));

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create})
            m->registerHook(getBase()+0x25e0e0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create});

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create})
            m->registerHook(getBase()+0x25dec0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create});
    }
};


template<class D>
class $FLAlertLayerProtocol : public FLAlertLayerProtocol, public $CacBase {
 public:
    $FLAlertLayerProtocol() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FLAlertLayerProtocol() {}
    typedef FLAlertLayerProtocol* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $FMODAudioEngine : public FMODAudioEngine, public $CacBase {
 public:
    $FMODAudioEngine() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FMODAudioEngine() {}
    typedef FMODAudioEngine* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $FollowRewardPage : public FollowRewardPage, public $CacBase {
 public:
    $FollowRewardPage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$FollowRewardPage() {}
    typedef FollowRewardPage* __thistype;

    static FollowRewardPage* create() {
        if ((FollowRewardPage*(*)()){&$FollowRewardPage::create} != (FollowRewardPage*(*)()){&D::create})
            return reinterpret_cast<FollowRewardPage*(*)()>(m->getOriginal(getBase()+0x22f140))();
        else return FollowRewardPage::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((FollowRewardPage*(*)()){&$FollowRewardPage::create} != (FollowRewardPage*(*)()){&D::create})
            m->registerHook(getBase()+0x22f140, (FollowRewardPage*(*)()){&D::create});
    }
};


template<class D>
class $GJAccountManager : public GJAccountManager, public $CacBase {
 public:
    $GJAccountManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJAccountManager() {}
    typedef GJAccountManager* __thistype;

    static GJAccountManager* sharedState() {
        if ((GJAccountManager*(*)()){&$GJAccountManager::sharedState} != (GJAccountManager*(*)()){&D::sharedState})
            return reinterpret_cast<GJAccountManager*(*)()>(m->getOriginal(getBase()+0x85070))();
        else return GJAccountManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJAccountManager*(*)()){&$GJAccountManager::sharedState} != (GJAccountManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x85070, (GJAccountManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $GJBaseGameLayer : public GJBaseGameLayer, public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJBaseGameLayer() {}
    typedef GJBaseGameLayer* __thistype;

    void objectsCollided(int p0, int p1) override {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
        else return GJBaseGameLayer::objectsCollided(p0, p1);
    }

    void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) override {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJBaseGameLayer::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) override {
        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return GJBaseGameLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) override {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
        else return GJBaseGameLayer::flipGravity(p0, p1, p2);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
        else return GJBaseGameLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void toggleGroupTriggered(int p0, bool p1) override {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroupTriggered(p0, p1);
    }

    void spawnGroup(int p0) override {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7050))(this, p0);
        else return GJBaseGameLayer::spawnGroup(p0);
    }

    void addToSection(GameObject* p0) override {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
        else return GJBaseGameLayer::addToSection(p0);
    }

    void addToGroup(GameObject* p0, int p1, bool p2) override {
        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
        else return GJBaseGameLayer::addToGroup(p0, p1, p2);
    }

    void removeFromGroup(GameObject* p0, int p1) override {
        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
        else return GJBaseGameLayer::removeFromGroup(p0, p1);
    }

    bool init() override {
        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xafc90))(this);
        else return GJBaseGameLayer::init();
    }

    void addObjectCounter(LabelGameObject* p0, int p1) {
        if ((void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject*, int)){&D::addObjectCounter})
            return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
        else return GJBaseGameLayer::addObjectCounter(p0, p1);
    }

    void addToGroups(GameObject* p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject*, bool)){&D::addToGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
        else return GJBaseGameLayer::addToGroups(p0, p1);
    }

    void atlasValue(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(int)){&D::atlasValue})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
        else return GJBaseGameLayer::atlasValue(p0);
    }

    void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
        else return GJBaseGameLayer::bumpPlayer(p0, p1);
    }

    void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::calculateOpacityValues(p0, p1, p2, p3);
    }

    void checkSpawnObjects() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6f90))(this);
        else return GJBaseGameLayer::checkSpawnObjects();
    }

    void collectItem(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem} != (void(D::*)(int, int)){&D::collectItem})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
        else return GJBaseGameLayer::collectItem(p0, p1);
    }

    void collectedObject(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject*)){&D::collectedObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
        else return GJBaseGameLayer::collectedObject(p0);
    }

    void createTextLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb5260))(this);
        else return GJBaseGameLayer::createTextLayers();
    }

    void damagingObjectsInRect(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb6140))(this, p0);
        else return GJBaseGameLayer::damagingObjectsInRect(p0);
    }

    void enableHighCapacityMode() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb11e0))(this);
        else return GJBaseGameLayer::enableHighCapacityMode();
    }

    void getCapacityString() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb2210))(this);
        else return GJBaseGameLayer::getCapacityString();
    }

    void getGroundHeightForMode(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(int)){&D::getGroundHeightForMode})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6630))(this, p0);
        else return GJBaseGameLayer::getGroundHeightForMode(p0);
    }

    void getGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup} != (void(D::*)(int)){&D::getGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
        else return GJBaseGameLayer::getGroup(p0);
    }

    void getMoveDeltaForObjects(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(int, int)){&D::getMoveDeltaForObjects})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
        else return GJBaseGameLayer::getMoveDeltaForObjects(p0, p1);
    }

    void getOptimizedGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(int)){&D::getOptimizedGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7940))(this, p0);
        else return GJBaseGameLayer::getOptimizedGroup(p0);
    }

    void getStaticGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(int)){&D::getStaticGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
        else return GJBaseGameLayer::getStaticGroup(p0);
    }

    void isGroupDisabledForObject(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject*)){&D::isGroupDisabledForObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
        else return GJBaseGameLayer::isGroupDisabledForObject(p0);
    }

    void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
        else return GJBaseGameLayer::isGroupDisabledForObjectFull(p0, p1);
    }

    void loadUpToPosition(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(float)){&D::loadUpToPosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xba680))(this, p0);
        else return GJBaseGameLayer::loadUpToPosition(p0);
    }

    void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
        else return GJBaseGameLayer::objectIntersectsCircle(p0, p1);
    }

    void objectTriggered(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject*)){&D::objectTriggered})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
        else return GJBaseGameLayer::objectTriggered(p0);
    }

    void optimizeMoveGroups() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb96c0))(this);
        else return GJBaseGameLayer::optimizeMoveGroups();
    }

    void parentForZLayer(int p0, bool p1, int p2) {
        if ((void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(int, bool, int)){&D::parentForZLayer})
            return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
        else return GJBaseGameLayer::parentForZLayer(p0, p1, p2);
    }

    void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
        else return GJBaseGameLayer::playerTouchedRing(p0, p1);
    }

    void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::processColorObject(p0, p1, p2, p3, p4);
    }

    void processFollowActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8fd0))(this);
        else return GJBaseGameLayer::processFollowActions();
    }

    void processMoveActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb86c0))(this);
        else return GJBaseGameLayer::processMoveActions();
    }

    void processMoveActionsStep(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(float)){&D::processMoveActionsStep})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
        else return GJBaseGameLayer::processMoveActionsStep(p0);
    }

    void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::processOpacityObject(p0, p1, p2, p3);
    }

    void processPlayerFollowActions(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(float)){&D::processPlayerFollowActions})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
        else return GJBaseGameLayer::processPlayerFollowActions(p0);
    }

    void processRotationActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb7fd0))(this);
        else return GJBaseGameLayer::processRotationActions();
    }

    void pushButton(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton} != (void(D::*)(int, bool)){&D::pushButton})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
        else return GJBaseGameLayer::pushButton(p0, p1);
    }

    void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
        else return GJBaseGameLayer::rectIntersectsCircle(p0, p1, p2);
    }

    void refreshCounterLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9fc0))(this);
        else return GJBaseGameLayer::refreshCounterLabels();
    }

    void releaseButton(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(int, bool)){&D::releaseButton})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
        else return GJBaseGameLayer::releaseButton(p0, p1);
    }

    void removeFromGroups(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject*)){&D::removeFromGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
        else return GJBaseGameLayer::removeFromGroups(p0);
    }

    void removeObjectFromSection(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject*)){&D::removeObjectFromSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
        else return GJBaseGameLayer::removeObjectFromSection(p0);
    }

    void reorderObjectSection(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject*)){&D::reorderObjectSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
        else return GJBaseGameLayer::reorderObjectSection(p0);
    }

    void resetGroupCounters(bool p0) {
        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(bool)){&D::resetGroupCounters})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba300))(this, p0);
        else return GJBaseGameLayer::resetGroupCounters(p0);
    }

    void resetMoveOptimizedValue() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9670))(this);
        else return GJBaseGameLayer::resetMoveOptimizedValue();
    }

    void sectionForPos(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(float)){&D::sectionForPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb6120))(this, p0);
        else return GJBaseGameLayer::sectionForPos(p0);
    }

    void setupLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xaffe0))(this);
        else return GJBaseGameLayer::setupLayers();
    }

    void shouldExitHackedLevel() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb1100))(this);
        else return GJBaseGameLayer::shouldExitHackedLevel();
    }

    void spawnGroupTriggered(int p0, float p1, int p2) {
        if ((void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(int, float, int)){&D::spawnGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
        else return GJBaseGameLayer::spawnGroupTriggered(p0, p1, p2);
    }

    void staticObjectsInRect(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
        else return GJBaseGameLayer::staticObjectsInRect(p0);
    }

    void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        if ((void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger})
            return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::testInstantCountTrigger(p0, p1, p2, p3, p4);
    }

    void toggleGroup(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroup(p0, p1);
    }

    void togglePlayerVisibility(bool p0) {
        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(bool)){&D::togglePlayerVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba910))(this, p0);
        else return GJBaseGameLayer::togglePlayerVisibility(p0);
    }

    void triggerMoveCommand(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject*)){&D::triggerMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
        else return GJBaseGameLayer::triggerMoveCommand(p0);
    }

    void updateCollisionBlocks() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6a30))(this);
        else return GJBaseGameLayer::updateCollisionBlocks();
    }

    void updateCounters(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(int, int)){&D::updateCounters})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
        else return GJBaseGameLayer::updateCounters(p0, p1);
    }

    void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
        else return GJBaseGameLayer::updateDisabledObjectsLastPos(p0);
    }

    void updateLayerCapacity(std::string p0) {
        if ((void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::string)){&D::updateLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0xb1680))(this, p0);
        else return GJBaseGameLayer::updateLayerCapacity(p0);
    }

    void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        if ((void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::updateLegacyLayerCapacity(p0, p1, p2, p3);
    }

    void updateOBB2(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRect)){&D::updateOBB2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
        else return GJBaseGameLayer::updateOBB2(p0);
    }

    void updateQueuedLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9f30))(this);
        else return GJBaseGameLayer::updateQueuedLabels();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(getBase()+0xb6d90, extract_virtual(this, (void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(getBase()+0xb73a0, extract_virtual(this, (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0xb7420, extract_virtual(this, (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0xba990, extract_virtual(this, (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0xba9a0, extract_virtual(this, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            m->registerHook(getBase()+0xb75a0, extract_virtual(this, (void(D::*)(int, bool)){&D::toggleGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            m->registerHook(getBase()+0xb7050, extract_virtual(this, (void(D::*)(int)){&D::spawnGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            m->registerHook(getBase()+0xb7b70, extract_virtual(this, (void(D::*)(GameObject*)){&D::addToSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(getBase()+0xb77f0, extract_virtual(this, (void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(getBase()+0xb7a60, extract_virtual(this, (void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xafc90, extract_virtual(this, (bool(D::*)()){&D::init}));

        if ((void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject*, int)){&D::addObjectCounter})
            m->registerHook(getBase()+0xb9eb0, extract((void(D::*)(LabelGameObject*, int)){&D::addObjectCounter}));

        if ((void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject*, bool)){&D::addToGroups})
            m->registerHook(getBase()+0xb7780, extract((void(D::*)(GameObject*, bool)){&D::addToGroups}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(int)){&D::atlasValue})
            m->registerHook(getBase()+0xb21e0, extract((void(D::*)(int)){&D::atlasValue}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer})
            m->registerHook(getBase()+0xb6860, extract((void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues})
            m->registerHook(getBase()+0xb5be0, extract((void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            m->registerHook(getBase()+0xb6f90, extract((void(D::*)()){&D::checkSpawnObjects}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem} != (void(D::*)(int, int)){&D::collectItem})
            m->registerHook(getBase()+0xb9e20, extract((void(D::*)(int, int)){&D::collectItem}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject*)){&D::collectedObject})
            m->registerHook(getBase()+0xb9b60, extract((void(D::*)(EffectGameObject*)){&D::collectedObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            m->registerHook(getBase()+0xb5260, extract((void(D::*)()){&D::createTextLayers}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect})
            m->registerHook(getBase()+0xb6140, extract((void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            m->registerHook(getBase()+0xb11e0, extract((void(D::*)()){&D::enableHighCapacityMode}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            m->registerHook(getBase()+0xb2210, extract((void(D::*)()){&D::getCapacityString}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(int)){&D::getGroundHeightForMode})
            m->registerHook(getBase()+0xb6630, extract((void(D::*)(int)){&D::getGroundHeightForMode}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup} != (void(D::*)(int)){&D::getGroup})
            m->registerHook(getBase()+0xb6f20, extract((void(D::*)(int)){&D::getGroup}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(int, int)){&D::getMoveDeltaForObjects})
            m->registerHook(getBase()+0xb6db0, extract((void(D::*)(int, int)){&D::getMoveDeltaForObjects}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(int)){&D::getOptimizedGroup})
            m->registerHook(getBase()+0xb7940, extract((void(D::*)(int)){&D::getOptimizedGroup}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(int)){&D::getStaticGroup})
            m->registerHook(getBase()+0xb79a0, extract((void(D::*)(int)){&D::getStaticGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject*)){&D::isGroupDisabledForObject})
            m->registerHook(getBase()+0xb5cc0, extract((void(D::*)(GameObject*)){&D::isGroupDisabledForObject}));

        if ((void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull})
            m->registerHook(getBase()+0xb5de0, extract((void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(float)){&D::loadUpToPosition})
            m->registerHook(getBase()+0xba680, extract((void(D::*)(float)){&D::loadUpToPosition}));

        if ((void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle})
            m->registerHook(getBase()+0xb66e0, extract((void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject*)){&D::objectTriggered})
            m->registerHook(getBase()+0xb71b0, extract((void(D::*)(EffectGameObject*)){&D::objectTriggered}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            m->registerHook(getBase()+0xb96c0, extract((void(D::*)()){&D::optimizeMoveGroups}));

        if ((void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(int, bool, int)){&D::parentForZLayer})
            m->registerHook(getBase()+0xb55d0, extract((void(D::*)(int, bool, int)){&D::parentForZLayer}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing})
            m->registerHook(getBase()+0xb69e0, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject})
            m->registerHook(getBase()+0xb5a90, extract((void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            m->registerHook(getBase()+0xb8fd0, extract((void(D::*)()){&D::processFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            m->registerHook(getBase()+0xb86c0, extract((void(D::*)()){&D::processMoveActions}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(float)){&D::processMoveActionsStep})
            m->registerHook(getBase()+0xb7ea0, extract((void(D::*)(float)){&D::processMoveActionsStep}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject})
            m->registerHook(getBase()+0xb5ae0, extract((void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(float)){&D::processPlayerFollowActions})
            m->registerHook(getBase()+0xb8b50, extract((void(D::*)(float)){&D::processPlayerFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            m->registerHook(getBase()+0xb7fd0, extract((void(D::*)()){&D::processRotationActions}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton} != (void(D::*)(int, bool)){&D::pushButton})
            m->registerHook(getBase()+0xb9920, extract((void(D::*)(int, bool)){&D::pushButton}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle})
            m->registerHook(getBase()+0xb6470, extract((void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            m->registerHook(getBase()+0xb9fc0, extract((void(D::*)()){&D::refreshCounterLabels}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(int, bool)){&D::releaseButton})
            m->registerHook(getBase()+0xb9a00, extract((void(D::*)(int, bool)){&D::releaseButton}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject*)){&D::removeFromGroups})
            m->registerHook(getBase()+0xb7a00, extract((void(D::*)(GameObject*)){&D::removeFromGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject*)){&D::removeObjectFromSection})
            m->registerHook(getBase()+0xb7e00, extract((void(D::*)(GameObject*)){&D::removeObjectFromSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject*)){&D::reorderObjectSection})
            m->registerHook(getBase()+0xb7cb0, extract((void(D::*)(GameObject*)){&D::reorderObjectSection}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(bool)){&D::resetGroupCounters})
            m->registerHook(getBase()+0xba300, extract((void(D::*)(bool)){&D::resetGroupCounters}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            m->registerHook(getBase()+0xb9670, extract((void(D::*)()){&D::resetMoveOptimizedValue}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(float)){&D::sectionForPos})
            m->registerHook(getBase()+0xb6120, extract((void(D::*)(float)){&D::sectionForPos}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            m->registerHook(getBase()+0xaffe0, extract((void(D::*)()){&D::setupLayers}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            m->registerHook(getBase()+0xb1100, extract((void(D::*)()){&D::shouldExitHackedLevel}));

        if ((void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(int, float, int)){&D::spawnGroupTriggered})
            m->registerHook(getBase()+0xb7020, extract((void(D::*)(int, float, int)){&D::spawnGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect})
            m->registerHook(getBase()+0xb5f90, extract((void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect}));

        if ((void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger})
            m->registerHook(getBase()+0xb9ae0, extract((void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            m->registerHook(getBase()+0xb75f0, extract((void(D::*)(int, bool)){&D::toggleGroup}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(bool)){&D::togglePlayerVisibility})
            m->registerHook(getBase()+0xba910, extract((void(D::*)(bool)){&D::togglePlayerVisibility}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject*)){&D::triggerMoveCommand})
            m->registerHook(getBase()+0xb7290, extract((void(D::*)(EffectGameObject*)){&D::triggerMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            m->registerHook(getBase()+0xb6a30, extract((void(D::*)()){&D::updateCollisionBlocks}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(int, int)){&D::updateCounters})
            m->registerHook(getBase()+0xb9bc0, extract((void(D::*)(int, int)){&D::updateCounters}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos})
            m->registerHook(getBase()+0xb95b0, extract((void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos}));

        if ((void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::string)){&D::updateLayerCapacity})
            m->registerHook(getBase()+0xb1680, extract((void(D::*)(std::string)){&D::updateLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity})
            m->registerHook(getBase()+0xb1590, extract((void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRect)){&D::updateOBB2})
            m->registerHook(getBase()+0xb63f0, extract((void(D::*)(cocos2d::CCRect)){&D::updateOBB2}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            m->registerHook(getBase()+0xb9f30, extract((void(D::*)()){&D::updateQueuedLabels}));
    }
};


template<class D>
class $GJColorSetupLayer : public GJColorSetupLayer, public $CacBase {
 public:
    $GJColorSetupLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJColorSetupLayer() {}
    typedef GJColorSetupLayer* __thistype;

    void updateSpriteColors() {
        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors} != (void(D::*)()){&D::updateSpriteColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xefe50))(this);
        else return GJColorSetupLayer::updateSpriteColors();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors} != (void(D::*)()){&D::updateSpriteColors})
            m->registerHook(getBase()+0xefe50, extract((void(D::*)()){&D::updateSpriteColors}));
    }
};


template<class D>
class $GJDropDownLayer : public GJDropDownLayer, public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJDropDownLayer() {}
    typedef GJDropDownLayer* __thistype;

    void customSetup() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352570))(this);
        else return GJDropDownLayer::customSetup();
    }

    void enterLayer() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525c0))(this);
        else return GJDropDownLayer::enterLayer();
    }

    void exitLayer(cocos2d::CCObject* p0) override {
        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x352670))(this, p0);
        else return GJDropDownLayer::exitLayer(p0);
    }

    void showLayer(bool p0) override {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
        else return GJDropDownLayer::showLayer(p0);
    }

    void hideLayer(bool p0) override {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
        else return GJDropDownLayer::hideLayer(p0);
    }

    void layerVisible() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528b0))(this);
        else return GJDropDownLayer::layerVisible();
    }

    void layerHidden() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528d0))(this);
        else return GJDropDownLayer::layerHidden();
    }

    void enterAnimFinished() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528a0))(this);
        else return GJDropDownLayer::enterAnimFinished();
    }

    void disableUI() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352580))(this);
        else return GJDropDownLayer::disableUI();
    }

    void enableUI() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525a0))(this);
        else return GJDropDownLayer::enableUI();
    }

    void draw() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352910))(this);
        else return GJDropDownLayer::draw();
    }

    bool init(char const* p0, float p1) override {
        if ((bool($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init} != (bool(D::*)(char const*, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), char const*, float)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
        else return GJDropDownLayer::init(p0, p1);
    }

    void registerWithTouchDispatcher() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525f0))(this);
        else return GJDropDownLayer::registerWithTouchDispatcher();
    }

    static GJDropDownLayer* create(char const* p0) {
        if ((GJDropDownLayer*(*)(char const*)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const*)){&D::create})
            return reinterpret_cast<GJDropDownLayer*(*)(char const*)>(m->getOriginal(getBase()+0x352530))(p0);
        else return GJDropDownLayer::create(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x352570, extract_virtual(this, (void(D::*)()){&D::customSetup}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(getBase()+0x3525c0, extract_virtual(this, (void(D::*)()){&D::enterLayer}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(getBase()+0x352670, extract_virtual(this, (void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(getBase()+0x3526c0, extract_virtual(this, (void(D::*)(bool)){&D::showLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(getBase()+0x3527b0, extract_virtual(this, (void(D::*)(bool)){&D::hideLayer}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(getBase()+0x3528b0, extract_virtual(this, (void(D::*)()){&D::layerVisible}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(getBase()+0x3528d0, extract_virtual(this, (void(D::*)()){&D::layerHidden}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(getBase()+0x3528a0, extract_virtual(this, (void(D::*)()){&D::enterAnimFinished}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(getBase()+0x352580, extract_virtual(this, (void(D::*)()){&D::disableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(getBase()+0x3525a0, extract_virtual(this, (void(D::*)()){&D::enableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x352910, extract_virtual(this, (void(D::*)()){&D::draw}));

        if ((bool($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init} != (bool(D::*)(char const*, float)){&D::init})
            m->registerHook(getBase()+0x352100, extract_virtual(this, (bool(D::*)(char const*, float)){&D::init}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x3525f0, extract_virtual(this, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((GJDropDownLayer*(*)(char const*)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x352530, (GJDropDownLayer*(*)(char const*)){&D::create});
    }
};


template<class D>
class $GJEffectManager : public GJEffectManager, public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJEffectManager() {}
    typedef GJEffectManager* __thistype;

    bool init() override {
        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x180230))(this);
        else return GJEffectManager::init();
    }

    void activeColorForIndex(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex} != (void(D::*)(int)){&D::activeColorForIndex})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
        else return GJEffectManager::activeColorForIndex(p0);
    }

    void activeOpacityForIndex(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex} != (void(D::*)(int)){&D::activeOpacityForIndex})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e10))(this, p0);
        else return GJEffectManager::activeOpacityForIndex(p0);
    }

    void addAllInheritedColorActions(cocos2d::CCArray* p0) {
        if ((void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions} != (void(D::*)(cocos2d::CCArray*)){&D::addAllInheritedColorActions})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
        else return GJEffectManager::addAllInheritedColorActions(p0);
    }

    void addGroupPulseEffect(PulseEffectAction* p0) {
        if ((void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect} != (void(D::*)(PulseEffectAction*)){&D::addGroupPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), PulseEffectAction*)>(m->getOriginal(getBase()+0x184c10))(this, p0);
        else return GJEffectManager::addGroupPulseEffect(p0);
    }

    void calculateBaseActiveColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors} != (void(D::*)()){&D::calculateBaseActiveColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180f70))(this);
        else return GJEffectManager::calculateBaseActiveColors();
    }

    void calculateInheritedColor(int p0, ColorAction* p1) {
        if ((void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor} != (void(D::*)(int, ColorAction*)){&D::calculateInheritedColor})
            return reinterpret_cast<void(*)(decltype(this), int, ColorAction*)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
        else return GJEffectManager::calculateInheritedColor(p0, p1);
    }

    void calculateLightBGColor(cocos2d::_ccColor3B p0) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::calculateLightBGColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x185b90))(this, p0);
        else return GJEffectManager::calculateLightBGColor(p0);
    }

    void colorActionChanged(ColorAction* p0) {
        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged} != (void(D::*)(ColorAction*)){&D::colorActionChanged})
            return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
        else return GJEffectManager::colorActionChanged(p0);
    }

    void colorExists(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists} != (void(D::*)(int)){&D::colorExists})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181da0))(this, p0);
        else return GJEffectManager::colorExists(p0);
    }

    void colorForEffect(cocos2d::_ccColor3B p0, cocos2d::_ccHSVValue p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&D::colorForEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
        else return GJEffectManager::colorForEffect(p0, p1);
    }

    void colorForGroupID(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::colorForGroupID})
            return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
        else return GJEffectManager::colorForGroupID(p0, p1, p2);
    }

    void colorForIndex(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex} != (void(D::*)(int)){&D::colorForIndex})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
        else return GJEffectManager::colorForIndex(p0);
    }

    void colorForPulseEffect(cocos2d::_ccColor3B const& p0, PulseEffectAction* p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect} != (void(D::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&D::colorForPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, PulseEffectAction*)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
        else return GJEffectManager::colorForPulseEffect(p0, p1);
    }

    void countChangedForItem(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem} != (void(D::*)(int)){&D::countChangedForItem})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
        else return GJEffectManager::countChangedForItem(p0);
    }

    void countForItem(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem} != (void(D::*)(int)){&D::countForItem})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a10))(this, p0);
        else return GJEffectManager::countForItem(p0);
    }

    static GJEffectManager* create() {
        if ((GJEffectManager*(*)()){&$GJEffectManager::create} != (GJEffectManager*(*)()){&D::create})
            return reinterpret_cast<GJEffectManager*(*)()>(m->getOriginal(getBase()+0x1800f0))();
        else return GJEffectManager::create();
    }

    void createFollowCommand(float p0, float p1, float p2, int p3, int p4, bool p5, int p6) {
        if ((void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand} != (void(D::*)(float, float, float, int, int, bool, int)){&D::createFollowCommand})
            return reinterpret_cast<void(*)(decltype(this), float, float, float, int, int, bool, int)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
        else return GJEffectManager::createFollowCommand(p0, p1, p2, p3, p4, p5, p6);
    }

    void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        if ((void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJEffectManager::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void createPlayerFollowCommand(float p0, float p1, int p2, float p3, float p4, int p5, int p6) {
        if ((void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand} != (void(D::*)(float, float, int, float, float, int, int)){&D::createPlayerFollowCommand})
            return reinterpret_cast<void(*)(decltype(this), float, float, int, float, float, int, int)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
        else return GJEffectManager::createPlayerFollowCommand(p0, p1, p2, p3, p4, p5, p6);
    }

    void createRotateCommand(int p0, float p1, int p2, int p3, int p4, float p5, bool p6, int p7) {
        if ((void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand} != (void(D::*)(int, float, int, int, int, float, bool, int)){&D::createRotateCommand})
            return reinterpret_cast<void(*)(decltype(this), int, float, int, int, int, float, bool, int)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJEffectManager::createRotateCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void getAllColorActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions} != (void(D::*)()){&D::getAllColorActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180980))(this);
        else return GJEffectManager::getAllColorActions();
    }

    void getAllColorSprites() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites} != (void(D::*)()){&D::getAllColorSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1809e0))(this);
        else return GJEffectManager::getAllColorSprites();
    }

    const cocos2d::_ccColor3B& getColorAction(int p0) {
        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorAction})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180b00))(this, p0);
        else return GJEffectManager::getColorAction(p0);
    }

    const cocos2d::_ccColor3B& getColorSprite(int p0) {
        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorSprite})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180d00))(this, p0);
        else return GJEffectManager::getColorSprite(p0);
    }

    void getCurrentStateString() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString} != (void(D::*)()){&D::getCurrentStateString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1867e0))(this);
        else return GJEffectManager::getCurrentStateString();
    }

    void getLoadedMoveOffset() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset} != (void(D::*)()){&D::getLoadedMoveOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x184390))(this);
        else return GJEffectManager::getLoadedMoveOffset();
    }

    void getMixedColor(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::getMixedColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
        else return GJEffectManager::getMixedColor(p0, p1, p2);
    }

    uint8_t getOpacityActionForGroup(int p0) {
        if ((uint8_t($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup} != (uint8_t(D::*)(int)){&D::getOpacityActionForGroup})
            return reinterpret_cast<uint8_t(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
        else return GJEffectManager::getOpacityActionForGroup(p0);
    }

    void getSaveString() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185e90))(this);
        else return GJEffectManager::getSaveString();
    }

    void handleObjectCollision(bool p0, int p1, int p2) {
        if ((void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision} != (void(D::*)(bool, int, int)){&D::handleObjectCollision})
            return reinterpret_cast<void(*)(decltype(this), bool, int, int)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
        else return GJEffectManager::handleObjectCollision(p0, p1, p2);
    }

    void hasActiveDualTouch() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch} != (void(D::*)()){&D::hasActiveDualTouch})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185540))(this);
        else return GJEffectManager::hasActiveDualTouch();
    }

    void hasBeenTriggered(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered} != (void(D::*)(int)){&D::hasBeenTriggered})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
        else return GJEffectManager::hasBeenTriggered(p0);
    }

    void hasPulseEffectForGroupID(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID} != (void(D::*)(int)){&D::hasPulseEffectForGroupID})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184f60))(this, p0);
        else return GJEffectManager::hasPulseEffectForGroupID(p0);
    }

    bool isGroupEnabled(int p0) {
        if ((bool($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled} != (bool(D::*)(int)){&D::isGroupEnabled})
            return reinterpret_cast<bool(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
        else return GJEffectManager::isGroupEnabled(p0);
    }

    void keyForGroupIDColor(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::keyForGroupIDColor})
            return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
        else return GJEffectManager::keyForGroupIDColor(p0, p1, p2);
    }

    void loadState(std::string p0) {
        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState} != (void(D::*)(std::string)){&D::loadState})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x188db0))(this, p0);
        else return GJEffectManager::loadState(p0);
    }

    void objectsCollided(int p0, int p1) {
        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
        else return GJEffectManager::objectsCollided(p0, p1);
    }

    void opacityForIndex(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex} != (void(D::*)(int)){&D::opacityForIndex})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180c80))(this, p0);
        else return GJEffectManager::opacityForIndex(p0);
    }

    float opacityModForGroup(int p0) {
        if ((float($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup} != (float(D::*)(int)){&D::opacityModForGroup})
            return reinterpret_cast<float(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184740))(this, p0);
        else return GJEffectManager::opacityModForGroup(p0);
    }

    void playerButton(bool p0, bool p1) {
        if ((void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton} != (void(D::*)(bool, bool)){&D::playerButton})
            return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
        else return GJEffectManager::playerButton(p0, p1);
    }

    void playerDied() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::playerDied} != (void(D::*)()){&D::playerDied})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185860))(this);
        else return GJEffectManager::playerDied();
    }

    void postCollisionCheck() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck} != (void(D::*)()){&D::postCollisionCheck})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182720))(this);
        else return GJEffectManager::postCollisionCheck();
    }

    void preCollisionCheck() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck} != (void(D::*)()){&D::preCollisionCheck})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182680))(this);
        else return GJEffectManager::preCollisionCheck();
    }

    void prepareMoveActions(float p0, bool p1) {
        if ((void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions} != (void(D::*)(float, bool)){&D::prepareMoveActions})
            return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
        else return GJEffectManager::prepareMoveActions(p0, p1);
    }

    void processColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processColors} != (void(D::*)()){&D::processColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180e70))(this);
        else return GJEffectManager::processColors();
    }

    void processCopyColorPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions} != (void(D::*)()){&D::processCopyColorPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181530))(this);
        else return GJEffectManager::processCopyColorPulseActions();
    }

    void processInheritedColors() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors} != (void(D::*)()){&D::processInheritedColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181190))(this);
        else return GJEffectManager::processInheritedColors();
    }

    void processPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions} != (void(D::*)()){&D::processPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181040))(this);
        else return GJEffectManager::processPulseActions();
    }

    void registerCollisionTrigger(int p0, int p1, int p2, bool p3, bool p4, int p5) {
        if ((void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger} != (void(D::*)(int, int, int, bool, bool, int)){&D::registerCollisionTrigger})
            return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, bool, int)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
        else return GJEffectManager::registerCollisionTrigger(p0, p1, p2, p3, p4, p5);
    }

    void removeAllPulseActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions} != (void(D::*)()){&D::removeAllPulseActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1825e0))(this);
        else return GJEffectManager::removeAllPulseActions();
    }

    void removeColorAction(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction} != (void(D::*)(int)){&D::removeColorAction})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181d60))(this, p0);
        else return GJEffectManager::removeColorAction(p0);
    }

    void reset() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::reset} != (void(D::*)()){&D::reset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180690))(this);
        else return GJEffectManager::reset();
    }

    void resetColorCache() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache} != (void(D::*)()){&D::resetColorCache})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185280))(this);
        else return GJEffectManager::resetColorCache();
    }

    void resetEffects() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetEffects} != (void(D::*)()){&D::resetEffects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1807d0))(this);
        else return GJEffectManager::resetEffects();
    }

    void resetMoveActions() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions} != (void(D::*)()){&D::resetMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180940))(this);
        else return GJEffectManager::resetMoveActions();
    }

    void resetToggledGroups() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1853f0))(this);
        else return GJEffectManager::resetToggledGroups();
    }

    void resetTriggeredIDs() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs} != (void(D::*)()){&D::resetTriggeredIDs})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182630))(this);
        else return GJEffectManager::resetTriggeredIDs();
    }

    void runCountTrigger(int p0, int p1, bool p2, int p3, bool p4, int p5) {
        if ((void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger} != (void(D::*)(int, int, bool, int, bool, int)){&D::runCountTrigger})
            return reinterpret_cast<void(*)(decltype(this), int, int, bool, int, bool, int)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
        else return GJEffectManager::runCountTrigger(p0, p1, p2, p3, p4, p5);
    }

    void runDeathTrigger(int p0, bool p1, int p2) {
        if ((void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger} != (void(D::*)(int, bool, int)){&D::runDeathTrigger})
            return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
        else return GJEffectManager::runDeathTrigger(p0, p1, p2);
    }

    void runOpacityActionOnGroup(int p0, float p1, float p2, int p3) {
        if ((void($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup} != (void(D::*)(int, float, float, int)){&D::runOpacityActionOnGroup})
            return reinterpret_cast<void(*)(decltype(this), int, float, float, int)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
        else return GJEffectManager::runOpacityActionOnGroup(p0, p1, p2, p3);
    }

    void runPulseEffect(int p0, bool p1, float p2, float p3, float p4, PulseEffectType p5, cocos2d::_ccColor3B p6, cocos2d::_ccHSVValue p7, int p8, bool p9, bool p10, bool p11, int p12) {
        if ((void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect} != (void(D::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&D::runPulseEffect})
            return reinterpret_cast<void(*)(decltype(this), int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
        else return GJEffectManager::runPulseEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    void runTouchTriggerCommand(int p0, bool p1, TouchTriggerType p2, bool p3, int p4) {
        if ((void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand} != (void(D::*)(int, bool, TouchTriggerType, bool, int)){&D::runTouchTriggerCommand})
            return reinterpret_cast<void(*)(decltype(this), int, bool, TouchTriggerType, bool, int)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
        else return GJEffectManager::runTouchTriggerCommand(p0, p1, p2, p3, p4);
    }

    void setColorAction(ColorAction* p0, int p1) {
        if ((void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction} != (void(D::*)(ColorAction*, int)){&D::setColorAction})
            return reinterpret_cast<void(*)(decltype(this), ColorAction*, int)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
        else return GJEffectManager::setColorAction(p0, p1);
    }

    void setFollowing(int p0, int p1, bool p2) {
        if ((void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing} != (void(D::*)(int, int, bool)){&D::setFollowing})
            return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
        else return GJEffectManager::setFollowing(p0, p1, p2);
    }

    void setupFromString(std::string p0) {
        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x186290))(this, p0);
        else return GJEffectManager::setupFromString(p0);
    }

    void shouldBlend(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e40))(this, p0);
        else return GJEffectManager::shouldBlend(p0);
    }

    void spawnGroup(int p0, float p1, int p2) {
        if ((void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup} != (void(D::*)(int, float, int)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
        else return GJEffectManager::spawnGroup(p0, p1, p2);
    }

    void stopActionsForTrigger(EffectGameObject* p0) {
        if ((void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger} != (void(D::*)(EffectGameObject*)){&D::stopActionsForTrigger})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0x183150))(this, p0);
        else return GJEffectManager::stopActionsForTrigger(p0);
    }

    void stopMoveActionsForGroup(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup} != (void(D::*)(int)){&D::stopMoveActionsForGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
        else return GJEffectManager::stopMoveActionsForGroup(p0);
    }

    void storeTriggeredID(int p0) {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID} != (void(D::*)(int)){&D::storeTriggeredID})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185380))(this, p0);
        else return GJEffectManager::storeTriggeredID(p0);
    }

    void toggleGroup(int p0, bool p1) {
        if ((void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
        else return GJEffectManager::toggleGroup(p0, p1);
    }

    void traverseInheritanceChain(InheritanceNode* p0) {
        if ((void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain} != (void(D::*)(InheritanceNode*)){&D::traverseInheritanceChain})
            return reinterpret_cast<void(*)(decltype(this), InheritanceNode*)>(m->getOriginal(getBase()+0x181850))(this, p0);
        else return GJEffectManager::traverseInheritanceChain(p0);
    }

    void updateActiveOpacityEffects() {
        if ((void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects} != (void(D::*)()){&D::updateActiveOpacityEffects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1847e0))(this);
        else return GJEffectManager::updateActiveOpacityEffects();
    }

    void updateColorAction(ColorAction* p0) {
        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction} != (void(D::*)(ColorAction*)){&D::updateColorAction})
            return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x184560))(this, p0);
        else return GJEffectManager::updateColorAction(p0);
    }

    void updateColorEffects(float p0) {
        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects} != (void(D::*)(float)){&D::updateColorEffects})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181f40))(this, p0);
        else return GJEffectManager::updateColorEffects(p0);
    }

    void updateColors(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1) {
        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
        else return GJEffectManager::updateColors(p0, p1);
    }

    void updateEffects(float p0) {
        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects} != (void(D::*)(float)){&D::updateEffects})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181df0))(this, p0);
        else return GJEffectManager::updateEffects(p0);
    }

    void updateOpacityAction(OpacityEffectAction* p0) {
        if ((void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction} != (void(D::*)(OpacityEffectAction*)){&D::updateOpacityAction})
            return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction*)>(m->getOriginal(getBase()+0x184780))(this, p0);
        else return GJEffectManager::updateOpacityAction(p0);
    }

    void updateOpacityEffects(float p0) {
        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects} != (void(D::*)(float)){&D::updateOpacityEffects})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
        else return GJEffectManager::updateOpacityEffects(p0);
    }

    void updatePulseEffects(float p0) {
        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects} != (void(D::*)(float)){&D::updatePulseEffects})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182130))(this, p0);
        else return GJEffectManager::updatePulseEffects(p0);
    }

    void updateSpawnTriggers(float p0) {
        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers} != (void(D::*)(float)){&D::updateSpawnTriggers})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182510))(this, p0);
        else return GJEffectManager::updateSpawnTriggers(p0);
    }

    void wasFollowing(int p0, int p1) {
        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing} != (void(D::*)(int, int)){&D::wasFollowing})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
        else return GJEffectManager::wasFollowing(p0, p1);
    }

    void wouldCreateLoop(InheritanceNode* p0, int p1) {
        if ((void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop} != (void(D::*)(InheritanceNode*, int)){&D::wouldCreateLoop})
            return reinterpret_cast<void(*)(decltype(this), InheritanceNode*, int)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
        else return GJEffectManager::wouldCreateLoop(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x180230, extract_virtual(this, (bool(D::*)()){&D::init}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex} != (void(D::*)(int)){&D::activeColorForIndex})
            m->registerHook(getBase()+0x180cb0, extract((void(D::*)(int)){&D::activeColorForIndex}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex} != (void(D::*)(int)){&D::activeOpacityForIndex})
            m->registerHook(getBase()+0x180e10, extract((void(D::*)(int)){&D::activeOpacityForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions} != (void(D::*)(cocos2d::CCArray*)){&D::addAllInheritedColorActions})
            m->registerHook(getBase()+0x1817a0, extract((void(D::*)(cocos2d::CCArray*)){&D::addAllInheritedColorActions}));

        if ((void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect} != (void(D::*)(PulseEffectAction*)){&D::addGroupPulseEffect})
            m->registerHook(getBase()+0x184c10, extract((void(D::*)(PulseEffectAction*)){&D::addGroupPulseEffect}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors} != (void(D::*)()){&D::calculateBaseActiveColors})
            m->registerHook(getBase()+0x180f70, extract((void(D::*)()){&D::calculateBaseActiveColors}));

        if ((void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor} != (void(D::*)(int, ColorAction*)){&D::calculateInheritedColor})
            m->registerHook(getBase()+0x1818f0, extract((void(D::*)(int, ColorAction*)){&D::calculateInheritedColor}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::calculateLightBGColor})
            m->registerHook(getBase()+0x185b90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::calculateLightBGColor}));

        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged} != (void(D::*)(ColorAction*)){&D::colorActionChanged})
            m->registerHook(getBase()+0x181dc0, extract((void(D::*)(ColorAction*)){&D::colorActionChanged}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists} != (void(D::*)(int)){&D::colorExists})
            m->registerHook(getBase()+0x181da0, extract((void(D::*)(int)){&D::colorExists}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&D::colorForEffect})
            m->registerHook(getBase()+0x182650, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&D::colorForEffect}));

        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::colorForGroupID})
            m->registerHook(getBase()+0x184f90, extract((void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::colorForGroupID}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex} != (void(D::*)(int)){&D::colorForIndex})
            m->registerHook(getBase()+0x180ad0, extract((void(D::*)(int)){&D::colorForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect} != (void(D::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&D::colorForPulseEffect})
            m->registerHook(getBase()+0x181bf0, extract((void(D::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&D::colorForPulseEffect}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem} != (void(D::*)(int)){&D::countChangedForItem})
            m->registerHook(getBase()+0x185a40, extract((void(D::*)(int)){&D::countChangedForItem}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem} != (void(D::*)(int)){&D::countForItem})
            m->registerHook(getBase()+0x185a10, extract((void(D::*)(int)){&D::countForItem}));

        if ((GJEffectManager*(*)()){&$GJEffectManager::create} != (GJEffectManager*(*)()){&D::create})
            m->registerHook(getBase()+0x1800f0, (GJEffectManager*(*)()){&D::create});

        if ((void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand} != (void(D::*)(float, float, float, int, int, bool, int)){&D::createFollowCommand})
            m->registerHook(getBase()+0x182ed0, extract((void(D::*)(float, float, float, int, int, bool, int)){&D::createFollowCommand}));

        if ((void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(getBase()+0x182cc0, extract((void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand} != (void(D::*)(float, float, int, float, float, int, int)){&D::createPlayerFollowCommand})
            m->registerHook(getBase()+0x182fe0, extract((void(D::*)(float, float, int, float, float, int, int)){&D::createPlayerFollowCommand}));

        if ((void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand} != (void(D::*)(int, float, int, int, int, float, bool, int)){&D::createRotateCommand})
            m->registerHook(getBase()+0x182df0, extract((void(D::*)(int, float, int, int, int, float, bool, int)){&D::createRotateCommand}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions} != (void(D::*)()){&D::getAllColorActions})
            m->registerHook(getBase()+0x180980, extract((void(D::*)()){&D::getAllColorActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites} != (void(D::*)()){&D::getAllColorSprites})
            m->registerHook(getBase()+0x1809e0, extract((void(D::*)()){&D::getAllColorSprites}));

        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorAction})
            m->registerHook(getBase()+0x180b00, extract((const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorAction}));

        if ((const cocos2d::_ccColor3B&($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorSprite})
            m->registerHook(getBase()+0x180d00, extract((const cocos2d::_ccColor3B&(D::*)(int)){&D::getColorSprite}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString} != (void(D::*)()){&D::getCurrentStateString})
            m->registerHook(getBase()+0x1867e0, extract((void(D::*)()){&D::getCurrentStateString}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset} != (void(D::*)()){&D::getLoadedMoveOffset})
            m->registerHook(getBase()+0x184390, extract((void(D::*)()){&D::getLoadedMoveOffset}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::getMixedColor})
            m->registerHook(getBase()+0x185d30, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::getMixedColor}));

        if ((uint8_t($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup} != (uint8_t(D::*)(int)){&D::getOpacityActionForGroup})
            m->registerHook(getBase()+0x1845b0, extract((uint8_t(D::*)(int)){&D::getOpacityActionForGroup}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x185e90, extract((void(D::*)()){&D::getSaveString}));

        if ((void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision} != (void(D::*)(bool, int, int)){&D::handleObjectCollision})
            m->registerHook(getBase()+0x1828f0, extract((void(D::*)(bool, int, int)){&D::handleObjectCollision}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch} != (void(D::*)()){&D::hasActiveDualTouch})
            m->registerHook(getBase()+0x185540, extract((void(D::*)()){&D::hasActiveDualTouch}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered} != (void(D::*)(int)){&D::hasBeenTriggered})
            m->registerHook(getBase()+0x1853b0, extract((void(D::*)(int)){&D::hasBeenTriggered}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID} != (void(D::*)(int)){&D::hasPulseEffectForGroupID})
            m->registerHook(getBase()+0x184f60, extract((void(D::*)(int)){&D::hasPulseEffectForGroupID}));

        if ((bool($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled} != (bool(D::*)(int)){&D::isGroupEnabled})
            m->registerHook(getBase()+0x1853d0, extract((bool(D::*)(int)){&D::isGroupEnabled}));

        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::keyForGroupIDColor})
            m->registerHook(getBase()+0x184c90, extract((void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::keyForGroupIDColor}));

        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState} != (void(D::*)(std::string)){&D::loadState})
            m->registerHook(getBase()+0x188db0, extract((void(D::*)(std::string)){&D::loadState}));

        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(getBase()+0x182a00, extract((void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex} != (void(D::*)(int)){&D::opacityForIndex})
            m->registerHook(getBase()+0x180c80, extract((void(D::*)(int)){&D::opacityForIndex}));

        if ((float($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup} != (float(D::*)(int)){&D::opacityModForGroup})
            m->registerHook(getBase()+0x184740, extract((float(D::*)(int)){&D::opacityModForGroup}));

        if ((void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton} != (void(D::*)(bool, bool)){&D::playerButton})
            m->registerHook(getBase()+0x1855a0, extract((void(D::*)(bool, bool)){&D::playerButton}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::playerDied} != (void(D::*)()){&D::playerDied})
            m->registerHook(getBase()+0x185860, extract((void(D::*)()){&D::playerDied}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck} != (void(D::*)()){&D::postCollisionCheck})
            m->registerHook(getBase()+0x182720, extract((void(D::*)()){&D::postCollisionCheck}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck} != (void(D::*)()){&D::preCollisionCheck})
            m->registerHook(getBase()+0x182680, extract((void(D::*)()){&D::preCollisionCheck}));

        if ((void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions} != (void(D::*)(float, bool)){&D::prepareMoveActions})
            m->registerHook(getBase()+0x183660, extract((void(D::*)(float, bool)){&D::prepareMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processColors} != (void(D::*)()){&D::processColors})
            m->registerHook(getBase()+0x180e70, extract((void(D::*)()){&D::processColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions} != (void(D::*)()){&D::processCopyColorPulseActions})
            m->registerHook(getBase()+0x181530, extract((void(D::*)()){&D::processCopyColorPulseActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors} != (void(D::*)()){&D::processInheritedColors})
            m->registerHook(getBase()+0x181190, extract((void(D::*)()){&D::processInheritedColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions} != (void(D::*)()){&D::processPulseActions})
            m->registerHook(getBase()+0x181040, extract((void(D::*)()){&D::processPulseActions}));

        if ((void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger} != (void(D::*)(int, int, int, bool, bool, int)){&D::registerCollisionTrigger})
            m->registerHook(getBase()+0x182b70, extract((void(D::*)(int, int, int, bool, bool, int)){&D::registerCollisionTrigger}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions} != (void(D::*)()){&D::removeAllPulseActions})
            m->registerHook(getBase()+0x1825e0, extract((void(D::*)()){&D::removeAllPulseActions}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction} != (void(D::*)(int)){&D::removeColorAction})
            m->registerHook(getBase()+0x181d60, extract((void(D::*)(int)){&D::removeColorAction}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x180690, extract((void(D::*)()){&D::reset}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache} != (void(D::*)()){&D::resetColorCache})
            m->registerHook(getBase()+0x185280, extract((void(D::*)()){&D::resetColorCache}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetEffects} != (void(D::*)()){&D::resetEffects})
            m->registerHook(getBase()+0x1807d0, extract((void(D::*)()){&D::resetEffects}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions} != (void(D::*)()){&D::resetMoveActions})
            m->registerHook(getBase()+0x180940, extract((void(D::*)()){&D::resetMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x1853f0, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs} != (void(D::*)()){&D::resetTriggeredIDs})
            m->registerHook(getBase()+0x182630, extract((void(D::*)()){&D::resetTriggeredIDs}));

        if ((void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger} != (void(D::*)(int, int, bool, int, bool, int)){&D::runCountTrigger})
            m->registerHook(getBase()+0x1858d0, extract((void(D::*)(int, int, bool, int, bool, int)){&D::runCountTrigger}));

        if ((void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger} != (void(D::*)(int, bool, int)){&D::runDeathTrigger})
            m->registerHook(getBase()+0x1857a0, extract((void(D::*)(int, bool, int)){&D::runDeathTrigger}));

        if ((void($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup} != (void(D::*)(int, float, float, int)){&D::runOpacityActionOnGroup})
            m->registerHook(getBase()+0x1845d0, extract((void(D::*)(int, float, float, int)){&D::runOpacityActionOnGroup}));

        if ((void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect} != (void(D::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&D::runPulseEffect})
            m->registerHook(getBase()+0x184890, extract((void(D::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&D::runPulseEffect}));

        if ((void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand} != (void(D::*)(int, bool, TouchTriggerType, bool, int)){&D::runTouchTriggerCommand})
            m->registerHook(getBase()+0x185460, extract((void(D::*)(int, bool, TouchTriggerType, bool, int)){&D::runTouchTriggerCommand}));

        if ((void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction} != (void(D::*)(ColorAction*, int)){&D::setColorAction})
            m->registerHook(getBase()+0x181d00, extract((void(D::*)(ColorAction*, int)){&D::setColorAction}));

        if ((void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing} != (void(D::*)(int, int, bool)){&D::setFollowing})
            m->registerHook(getBase()+0x185e00, extract((void(D::*)(int, int, bool)){&D::setFollowing}));

        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            m->registerHook(getBase()+0x186290, extract((void(D::*)(std::string)){&D::setupFromString}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            m->registerHook(getBase()+0x180e40, extract((void(D::*)(int)){&D::shouldBlend}));

        if ((void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup} != (void(D::*)(int, float, int)){&D::spawnGroup})
            m->registerHook(getBase()+0x1852a0, extract((void(D::*)(int, float, int)){&D::spawnGroup}));

        if ((void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger} != (void(D::*)(EffectGameObject*)){&D::stopActionsForTrigger})
            m->registerHook(getBase()+0x183150, extract((void(D::*)(EffectGameObject*)){&D::stopActionsForTrigger}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup} != (void(D::*)(int)){&D::stopMoveActionsForGroup})
            m->registerHook(getBase()+0x1830e0, extract((void(D::*)(int)){&D::stopMoveActionsForGroup}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID} != (void(D::*)(int)){&D::storeTriggeredID})
            m->registerHook(getBase()+0x185380, extract((void(D::*)(int)){&D::storeTriggeredID}));

        if ((void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            m->registerHook(getBase()+0x182c80, extract((void(D::*)(int, bool)){&D::toggleGroup}));

        if ((void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain} != (void(D::*)(InheritanceNode*)){&D::traverseInheritanceChain})
            m->registerHook(getBase()+0x181850, extract((void(D::*)(InheritanceNode*)){&D::traverseInheritanceChain}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects} != (void(D::*)()){&D::updateActiveOpacityEffects})
            m->registerHook(getBase()+0x1847e0, extract((void(D::*)()){&D::updateActiveOpacityEffects}));

        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction} != (void(D::*)(ColorAction*)){&D::updateColorAction})
            m->registerHook(getBase()+0x184560, extract((void(D::*)(ColorAction*)){&D::updateColorAction}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects} != (void(D::*)(float)){&D::updateColorEffects})
            m->registerHook(getBase()+0x181f40, extract((void(D::*)(float)){&D::updateColorEffects}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::updateColors})
            m->registerHook(getBase()+0x180a40, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::updateColors}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects} != (void(D::*)(float)){&D::updateEffects})
            m->registerHook(getBase()+0x181df0, extract((void(D::*)(float)){&D::updateEffects}));

        if ((void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction} != (void(D::*)(OpacityEffectAction*)){&D::updateOpacityAction})
            m->registerHook(getBase()+0x184780, extract((void(D::*)(OpacityEffectAction*)){&D::updateOpacityAction}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects} != (void(D::*)(float)){&D::updateOpacityEffects})
            m->registerHook(getBase()+0x1823e0, extract((void(D::*)(float)){&D::updateOpacityEffects}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects} != (void(D::*)(float)){&D::updatePulseEffects})
            m->registerHook(getBase()+0x182130, extract((void(D::*)(float)){&D::updatePulseEffects}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers} != (void(D::*)(float)){&D::updateSpawnTriggers})
            m->registerHook(getBase()+0x182510, extract((void(D::*)(float)){&D::updateSpawnTriggers}));

        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing} != (void(D::*)(int, int)){&D::wasFollowing})
            m->registerHook(getBase()+0x185e60, extract((void(D::*)(int, int)){&D::wasFollowing}));

        if ((void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop} != (void(D::*)(InheritanceNode*, int)){&D::wouldCreateLoop})
            m->registerHook(getBase()+0x181820, extract((void(D::*)(InheritanceNode*, int)){&D::wouldCreateLoop}));
    }
};


template<class D>
class $GJFollowCommandLayer : public GJFollowCommandLayer, public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJFollowCommandLayer() {}
    typedef GJFollowCommandLayer* __thistype;

    static GJFollowCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create} != (GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x16a550))(p0, p1);
        else return GJFollowCommandLayer::create(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c8f0))(this, p0);
        else return GJFollowCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c9e0))(this, p0);
        else return GJFollowCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x16d480))(this, p0);
        else return GJFollowCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16cfe0))(this);
        else return GJFollowCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16d1c0))(this);
        else return GJFollowCommandLayer::updateTargetGroupID2();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create} != (GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x16a550, (GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x16c8f0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x16c9e0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x16d480, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x16cfe0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x16d1c0, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJGameLevel : public GJGameLevel, public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJGameLevel() {}
    typedef GJGameLevel* __thistype;

    static GJGameLevel* create() {
        if ((GJGameLevel*(*)()){&$GJGameLevel::create} != (GJGameLevel*(*)()){&D::create})
            return reinterpret_cast<GJGameLevel*(*)()>(m->getOriginal(getBase()+0x2b83e0))();
        else return GJGameLevel::create();
    }

    void getAudioFileName() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName} != (void(D::*)()){&D::getAudioFileName})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2dbe70))(this);
        else return GJGameLevel::getAudioFileName();
    }

    void getCoinKey(int p0) {
        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey} != (void(D::*)(int)){&D::getCoinKey})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
        else return GJGameLevel::getCoinKey(p0);
    }

    void getLengthKey(int p0) {
        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey} != (void(D::*)(int)){&D::getLengthKey})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2dbba0))(this, p0);
        else return GJGameLevel::getLengthKey(p0);
    }

    void getNormalPercent() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent} != (void(D::*)()){&D::getNormalPercent})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8b20))(this);
        else return GJGameLevel::getNormalPercent();
    }

    void levelWasAltered() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered} != (void(D::*)()){&D::levelWasAltered})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2db530))(this);
        else return GJGameLevel::levelWasAltered();
    }

    void savePercentage(int p0, bool p1, int p2, int p3, bool p4) {
        if ((void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage} != (void(D::*)(int, bool, int, int, bool)){&D::savePercentage})
            return reinterpret_cast<void(*)(decltype(this), int, bool, int, int, bool)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
        else return GJGameLevel::savePercentage(p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJGameLevel*(*)()){&$GJGameLevel::create} != (GJGameLevel*(*)()){&D::create})
            m->registerHook(getBase()+0x2b83e0, (GJGameLevel*(*)()){&D::create});

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName} != (void(D::*)()){&D::getAudioFileName})
            m->registerHook(getBase()+0x2dbe70, extract((void(D::*)()){&D::getAudioFileName}));

        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey} != (void(D::*)(int)){&D::getCoinKey})
            m->registerHook(getBase()+0x2ce360, extract((void(D::*)(int)){&D::getCoinKey}));

        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey} != (void(D::*)(int)){&D::getLengthKey})
            m->registerHook(getBase()+0x2dbba0, extract((void(D::*)(int)){&D::getLengthKey}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent} != (void(D::*)()){&D::getNormalPercent})
            m->registerHook(getBase()+0x2b8b20, extract((void(D::*)()){&D::getNormalPercent}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered} != (void(D::*)()){&D::levelWasAltered})
            m->registerHook(getBase()+0x2db530, extract((void(D::*)()){&D::levelWasAltered}));

        if ((void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage} != (void(D::*)(int, bool, int, int, bool)){&D::savePercentage})
            m->registerHook(getBase()+0x2db700, extract((void(D::*)(int, bool, int, int, bool)){&D::savePercentage}));
    }
};


template<class D>
class $GJGroundLayer : public GJGroundLayer, public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJGroundLayer() {}
    typedef GJGroundLayer* __thistype;

    static GJGroundLayer* create(int p0, int p1) {
        if ((GJGroundLayer*(*)(int, int)){&$GJGroundLayer::create} != (GJGroundLayer*(*)(int, int)){&D::create})
            return reinterpret_cast<GJGroundLayer*(*)(int, int)>(m->getOriginal(getBase()+0x355c00))(p0, p1);
        else return GJGroundLayer::create(p0, p1);
    }

    void deactivateGround() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround} != (void(D::*)()){&D::deactivateGround})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356a40))(this);
        else return GJGroundLayer::deactivateGround();
    }

    void getGroundY() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY} != (void(D::*)()){&D::getGroundY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356ac0))(this);
        else return GJGroundLayer::getGroundY();
    }

    void updateGround01Color(cocos2d::_ccColor3B p0) {
        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround01Color})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356640))(this, p0);
        else return GJGroundLayer::updateGround01Color(p0);
    }

    void updateGround02Color(cocos2d::_ccColor3B p0) {
        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround02Color})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356710))(this, p0);
        else return GJGroundLayer::updateGround02Color(p0);
    }

    void updateGroundPos(cocos2d::CCPoint p0) {
        if ((void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos} != (void(D::*)(cocos2d::CCPoint)){&D::updateGroundPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
        else return GJGroundLayer::updateGroundPos(p0);
    }

    void updateGroundWidth() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356790))(this);
        else return GJGroundLayer::updateGroundWidth();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJGroundLayer*(*)(int, int)){&$GJGroundLayer::create} != (GJGroundLayer*(*)(int, int)){&D::create})
            m->registerHook(getBase()+0x355c00, (GJGroundLayer*(*)(int, int)){&D::create});

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround} != (void(D::*)()){&D::deactivateGround})
            m->registerHook(getBase()+0x356a40, extract((void(D::*)()){&D::deactivateGround}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY} != (void(D::*)()){&D::getGroundY})
            m->registerHook(getBase()+0x356ac0, extract((void(D::*)()){&D::getGroundY}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround01Color})
            m->registerHook(getBase()+0x356640, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateGround01Color}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround02Color})
            m->registerHook(getBase()+0x356710, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateGround02Color}));

        if ((void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos} != (void(D::*)(cocos2d::CCPoint)){&D::updateGroundPos})
            m->registerHook(getBase()+0x3566c0, extract((void(D::*)(cocos2d::CCPoint)){&D::updateGroundPos}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x356790, extract((void(D::*)()){&D::updateGroundWidth}));
    }
};


template<class D>
class $GJListLayer : public GJListLayer, public $CacBase {
 public:
    $GJListLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJListLayer() {}
    typedef GJListLayer* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $GJMoveCommandLayer : public GJMoveCommandLayer, public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJMoveCommandLayer() {}
    typedef GJMoveCommandLayer* __thistype;

    static GJMoveCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create} != (GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36f8a0))(p0, p1);
        else return GJMoveCommandLayer::create(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((bool($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
        else return GJMoveCommandLayer::init(p0, p1);
    }

    void keyBackClicked() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374970))(this);
        else return GJMoveCommandLayer::keyBackClicked();
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x373350))(this, p0);
        else return GJMoveCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
        else return GJMoveCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374470))(this, p0);
        else return GJMoveCommandLayer::textChanged(p0);
    }

    void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374430))(this, p0);
        else return GJMoveCommandLayer::textInputClosed(p0);
    }

    void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374c10))(this, p0);
        else return GJMoveCommandLayer::textInputReturn(p0);
    }

    void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
        else return GJMoveCommandLayer::textInputShouldOffset(p0, p1);
    }

    void updateEditorLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374110))(this);
        else return GJMoveCommandLayer::updateEditorLabel();
    }

    void updateMoveTargetElements() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements} != (void(D::*)()){&D::updateMoveTargetElements})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373ac0))(this);
        else return GJMoveCommandLayer::updateMoveTargetElements();
    }

    void updateTargetGroupID() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374050))(this);
        else return GJMoveCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374230))(this);
        else return GJMoveCommandLayer::updateTargetGroupID2();
    }

    void updateTextInputLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373680))(this);
        else return GJMoveCommandLayer::updateTextInputLabel();
    }

    void updateTextInputLabel2() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2} != (void(D::*)()){&D::updateTextInputLabel2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373760))(this);
        else return GJMoveCommandLayer::updateTextInputLabel2();
    }

    void updateValueXLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel} != (void(D::*)()){&D::updateValueXLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373840))(this);
        else return GJMoveCommandLayer::updateValueXLabel();
    }

    void updateValueYLabel() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel} != (void(D::*)()){&D::updateValueYLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373950))(this);
        else return GJMoveCommandLayer::updateValueYLabel();
    }

    void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
        else return GJMoveCommandLayer::valuePopupClosed(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create} != (GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x36f8a0, (GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x36fac0, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x374970, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x373350, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x3734c0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x374470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(getBase()+0x374430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(getBase()+0x374c10, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(getBase()+0x374b50, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x374110, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements} != (void(D::*)()){&D::updateMoveTargetElements})
            m->registerHook(getBase()+0x373ac0, extract((void(D::*)()){&D::updateMoveTargetElements}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x374050, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x374230, extract((void(D::*)()){&D::updateTargetGroupID2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x373680, extract((void(D::*)()){&D::updateTextInputLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2} != (void(D::*)()){&D::updateTextInputLabel2})
            m->registerHook(getBase()+0x373760, extract((void(D::*)()){&D::updateTextInputLabel2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel} != (void(D::*)()){&D::updateValueXLabel})
            m->registerHook(getBase()+0x373840, extract((void(D::*)()){&D::updateValueXLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel} != (void(D::*)()){&D::updateValueYLabel})
            m->registerHook(getBase()+0x373950, extract((void(D::*)()){&D::updateValueYLabel}));

        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(getBase()+0x373c20, extract((void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));
    }
};


template<class D>
class $GJPFollowCommandLayer : public GJPFollowCommandLayer, public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJPFollowCommandLayer() {}
    typedef GJPFollowCommandLayer* __thistype;

    static GJPFollowCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create} != (GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1aea20))(p0, p1);
        else return GJPFollowCommandLayer::create(p0, p1);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1b1dc0))(this, p0);
        else return GJPFollowCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1b1a60))(this);
        else return GJPFollowCommandLayer::updateTargetGroupID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create} != (GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1aea20, (GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1b1dc0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x1b1a60, extract((void(D::*)()){&D::updateTargetGroupID}));
    }
};


template<class D>
class $GJRobotSprite : public GJRobotSprite, public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJRobotSprite() {}
    typedef GJRobotSprite* __thistype;

    static GJRobotSprite* create() {
        if ((GJRobotSprite*(*)()){&$GJRobotSprite::create} != (GJRobotSprite*(*)()){&D::create})
            return reinterpret_cast<GJRobotSprite*(*)()>(m->getOriginal(getBase()+0x34ac00))();
        else return GJRobotSprite::create();
    }

    void updateColor02(cocos2d::_ccColor3B p0) {
        if ((void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColor02})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
        else return GJRobotSprite::updateColor02(p0);
    }

    void updateFrame(int p0) {
        if ((void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame} != (void(D::*)(int)){&D::updateFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
        else return GJRobotSprite::updateFrame(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJRobotSprite*(*)()){&$GJRobotSprite::create} != (GJRobotSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34ac00, (GJRobotSprite*(*)()){&D::create});

        if ((void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColor02})
            m->registerHook(getBase()+0x34bbd0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateColor02}));

        if ((void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame} != (void(D::*)(int)){&D::updateFrame})
            m->registerHook(getBase()+0x34bdd0, extract((void(D::*)(int)){&D::updateFrame}));
    }
};


template<class D>
class $GJRotateCommandLayer : public GJRotateCommandLayer, public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJRotateCommandLayer() {}
    typedef GJRotateCommandLayer* __thistype;

    static GJRotateCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create} != (GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1ba0))(p0, p1);
        else return GJRotateCommandLayer::create(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4bb0))(this, p0);
        else return GJRotateCommandLayer::onUpdateGroupID(p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4ca0))(this, p0);
        else return GJRotateCommandLayer::onUpdateGroupID2(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x58d0))(this, p0);
        else return GJRotateCommandLayer::textChanged(p0);
    }

    void updateTargetGroupID() {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x54b0))(this);
        else return GJRotateCommandLayer::updateTargetGroupID();
    }

    void updateTargetGroupID2() {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5690))(this);
        else return GJRotateCommandLayer::updateTargetGroupID2();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create} != (GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1ba0, (GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x4bb0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x4ca0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x58d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x54b0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x5690, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJSearchObject : public GJSearchObject, public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSearchObject() {}
    typedef GJSearchObject* __thistype;

    static GJSearchObject* create(SearchType p0) {
        if ((GJSearchObject*(*)(SearchType)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType)){&D::create})
            return reinterpret_cast<GJSearchObject*(*)(SearchType)>(m->getOriginal(getBase()+0x2df120))(p0);
        else return GJSearchObject::create(p0);
    }

    static GJSearchObject* create(SearchType p0, std::string p1, std::string p2, std::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, int p17, int p18) {
        if ((GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&D::create})
            return reinterpret_cast<GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)>(m->getOriginal(getBase()+0x2dee30))(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
        else return GJSearchObject::create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    void getPageObject(int p0) {
        if ((void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject} != (void(D::*)(int)){&D::getPageObject})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2df9a0))(this, p0);
        else return GJSearchObject::getPageObject(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJSearchObject*(*)(SearchType)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType)){&D::create})
            m->registerHook(getBase()+0x2df120, (GJSearchObject*(*)(SearchType)){&D::create});

        if ((GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&D::create})
            m->registerHook(getBase()+0x2dee30, (GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&D::create});

        if ((void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject} != (void(D::*)(int)){&D::getPageObject})
            m->registerHook(getBase()+0x2df9a0, extract((void(D::*)(int)){&D::getPageObject}));
    }
};


template<class D>
class $GJSpecialColorSelect : public GJSpecialColorSelect, public $CacBase {
 public:
    $GJSpecialColorSelect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSpecialColorSelect() {}
    typedef GJSpecialColorSelect* __thistype;

    void textForColorIdx(int p0) {
        if ((void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx} != (void(D::*)(int)){&D::textForColorIdx})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x383a50))(this, p0);
        else return GJSpecialColorSelect::textForColorIdx(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx} != (void(D::*)(int)){&D::textForColorIdx})
            m->registerHook(getBase()+0x383a50, extract((void(D::*)(int)){&D::textForColorIdx}));
    }
};


template<class D>
class $GJSpecialColorSelectDelegate : public GJSpecialColorSelectDelegate, public $CacBase {
 public:
    $GJSpecialColorSelectDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSpecialColorSelectDelegate() {}
    typedef GJSpecialColorSelectDelegate* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $GJSpiderSprite : public GJSpiderSprite, public $CacBase {
 public:
    $GJSpiderSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GJSpiderSprite() {}
    typedef GJSpiderSprite* __thistype;

    static GJSpiderSprite* create() {
        if ((GJSpiderSprite*(*)()){&$GJSpiderSprite::create} != (GJSpiderSprite*(*)()){&D::create})
            return reinterpret_cast<GJSpiderSprite*(*)()>(m->getOriginal(getBase()+0x34c5b0))();
        else return GJSpiderSprite::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJSpiderSprite*(*)()){&$GJSpiderSprite::create} != (GJSpiderSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34c5b0, (GJSpiderSprite*(*)()){&D::create});
    }
};


template<class D>
class $GManager : public GManager, public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GManager() {}
    typedef GManager* __thistype;

    void save() {
        if ((void($GManager::*)()){&$GManager::save} != (void(D::*)()){&D::save})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26f300))(this);
        else return GManager::save();
    }

    void saveData(DS_Dictionary* p0, std::string p1) {
        if ((void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData} != (void(D::*)(DS_Dictionary*, std::string)){&D::saveData})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*, std::string)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
        else return GManager::saveData(p0, p1);
    }

    void saveGMTo(std::string p0) {
        if ((void($GManager::*)(std::string)){&$GManager::saveGMTo} != (void(D::*)(std::string)){&D::saveGMTo})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
        else return GManager::saveGMTo(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GManager::*)()){&$GManager::save} != (void(D::*)()){&D::save})
            m->registerHook(getBase()+0x26f300, extract((void(D::*)()){&D::save}));

        if ((void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData} != (void(D::*)(DS_Dictionary*, std::string)){&D::saveData})
            m->registerHook(getBase()+0x26f4b0, extract((void(D::*)(DS_Dictionary*, std::string)){&D::saveData}));

        if ((void($GManager::*)(std::string)){&$GManager::saveGMTo} != (void(D::*)(std::string)){&D::saveGMTo})
            m->registerHook(getBase()+0x26f3b0, extract((void(D::*)(std::string)){&D::saveGMTo}));
    }
};


template<class D>
class $GameLevelManager : public GameLevelManager, public $CacBase {
 public:
    $GameLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameLevelManager() {}
    typedef GameLevelManager* __thistype;

    GJGameLevel* createNewLevel() {
        if ((GJGameLevel*($GameLevelManager::*)()){&$GameLevelManager::createNewLevel} != (GJGameLevel*(D::*)()){&D::createNewLevel})
            return reinterpret_cast<GJGameLevel*(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8180))(this);
        else return GameLevelManager::createNewLevel();
    }

    static GameLevelManager* sharedState() {
        if ((GameLevelManager*(*)()){&$GameLevelManager::sharedState} != (GameLevelManager*(*)()){&D::sharedState})
            return reinterpret_cast<GameLevelManager*(*)()>(m->getOriginal(getBase()+0x2a8340))();
        else return GameLevelManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GJGameLevel*($GameLevelManager::*)()){&$GameLevelManager::createNewLevel} != (GJGameLevel*(D::*)()){&D::createNewLevel})
            m->registerHook(getBase()+0x2b8180, extract((GJGameLevel*(D::*)()){&D::createNewLevel}));

        if ((GameLevelManager*(*)()){&$GameLevelManager::sharedState} != (GameLevelManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x2a8340, (GameLevelManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $GameManager : public GameManager, public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameManager() {}
    typedef GameManager* __thistype;

    void accountStatusChanged() {
        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
        else return GameManager::accountStatusChanged();
    }

    const cocos2d::_ccColor3B& colorForIdx(int p0) {
        if ((const cocos2d::_ccColor3B&($GameManager::*)(int)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
        else return GameManager::colorForIdx(p0);
    }

    void didExitPlayscene() {
        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0230))(this);
        else return GameManager::didExitPlayscene();
    }

    void doQuickSave() {
        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
        else return GameManager::doQuickSave();
    }

    void fadeInMusic(char const* p0) {
        if ((void($GameManager::*)(char const*)){&$GameManager::fadeInMusic} != (void(D::*)(char const*)){&D::fadeInMusic})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
        else return GameManager::fadeInMusic(p0);
    }

    void getBGTexture(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::getBGTexture} != (void(D::*)(int)){&D::getBGTexture})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
        else return GameManager::getBGTexture(p0);
    }

    void getFontFile(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::getFontFile} != (void(D::*)(int)){&D::getFontFile})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
        else return GameManager::getFontFile(p0);
    }

    bool getGameVariable(char const* p0) {
        if ((bool($GameManager::*)(char const*)){&$GameManager::getGameVariable} != (bool(D::*)(char const*)){&D::getGameVariable})
            return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
        else return GameManager::getGameVariable(p0);
    }

    int getIntGameVariable(char const* p0) {
        if ((int($GameManager::*)(char const*)){&$GameManager::getIntGameVariable} != (int(D::*)(char const*)){&D::getIntGameVariable})
            return reinterpret_cast<int(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
        else return GameManager::getIntGameVariable(p0);
    }

    void getUGV(char const* p0) {
        if ((void($GameManager::*)(char const*)){&$GameManager::getUGV} != (void(D::*)(char const*)){&D::getUGV})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
        else return GameManager::getUGV(p0);
    }

    void loadDeathEffect(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::loadDeathEffect} != (void(D::*)(int)){&D::loadDeathEffect})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
        else return GameManager::loadDeathEffect(p0);
    }

    void loadFont(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::loadFont} != (void(D::*)(int)){&D::loadFont})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
        else return GameManager::loadFont(p0);
    }

    void reloadAll(bool p0, bool p1, bool p2) {
        if ((void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll} != (void(D::*)(bool, bool, bool)){&D::reloadAll})
            return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
        else return GameManager::reloadAll(p0, p1, p2);
    }

    void reloadAllStep5() {
        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
        else return GameManager::reloadAllStep5();
    }

    void reportPercentageForLevel(int p0, int p1, bool p2) {
        if ((void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel} != (void(D::*)(int, int, bool)){&D::reportPercentageForLevel})
            return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
        else return GameManager::reportPercentageForLevel(p0, p1, p2);
    }

    void setGameVariable(char const* p0, bool p1) {
        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable} != (void(D::*)(char const*, bool)){&D::setGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
        else return GameManager::setGameVariable(p0, p1);
    }

    void setIntGameVariable(char const* p0, int p1) {
        if ((void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable} != (void(D::*)(char const*, int)){&D::setIntGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x1cd0e0))(this, p0, p1);
        else return GameManager::setIntGameVariable(p0, p1);
    }

    void setUGV(char const* p0, bool p1) {
        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setUGV} != (void(D::*)(char const*, bool)){&D::setUGV})
            return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
        else return GameManager::setUGV(p0, p1);
    }

    static GameManager* sharedState() {
        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            return reinterpret_cast<GameManager*(*)()>(m->getOriginal(getBase()+0x1c2b30))();
        else return GameManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(getBase()+0x1cdad0, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((const cocos2d::_ccColor3B&($GameManager::*)(int)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx})
            m->registerHook(getBase()+0x1cbc80, extract((const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx}));

        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            m->registerHook(getBase()+0x1d0230, extract((void(D::*)()){&D::didExitPlayscene}));

        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            m->registerHook(getBase()+0x1d0200, extract((void(D::*)()){&D::doQuickSave}));

        if ((void($GameManager::*)(char const*)){&$GameManager::fadeInMusic} != (void(D::*)(char const*)){&D::fadeInMusic})
            m->registerHook(getBase()+0x1c2ff0, extract((void(D::*)(char const*)){&D::fadeInMusic}));

        if ((void($GameManager::*)(int)){&$GameManager::getBGTexture} != (void(D::*)(int)){&D::getBGTexture})
            m->registerHook(getBase()+0x1cca00, extract((void(D::*)(int)){&D::getBGTexture}));

        if ((void($GameManager::*)(int)){&$GameManager::getFontFile} != (void(D::*)(int)){&D::getFontFile})
            m->registerHook(getBase()+0x1cc5f0, extract((void(D::*)(int)){&D::getFontFile}));

        if ((bool($GameManager::*)(char const*)){&$GameManager::getGameVariable} != (bool(D::*)(char const*)){&D::getGameVariable})
            m->registerHook(getBase()+0x1cccd0, extract((bool(D::*)(char const*)){&D::getGameVariable}));

        if ((int($GameManager::*)(char const*)){&$GameManager::getIntGameVariable} != (int(D::*)(char const*)){&D::getIntGameVariable})
            m->registerHook(getBase()+0x1cd1d0, extract((int(D::*)(char const*)){&D::getIntGameVariable}));

        if ((void($GameManager::*)(char const*)){&$GameManager::getUGV} != (void(D::*)(char const*)){&D::getUGV})
            m->registerHook(getBase()+0x1ccfa0, extract((void(D::*)(char const*)){&D::getUGV}));

        if ((void($GameManager::*)(int)){&$GameManager::loadDeathEffect} != (void(D::*)(int)){&D::loadDeathEffect})
            m->registerHook(getBase()+0x1cc690, extract((void(D::*)(int)){&D::loadDeathEffect}));

        if ((void($GameManager::*)(int)){&$GameManager::loadFont} != (void(D::*)(int)){&D::loadFont})
            m->registerHook(getBase()+0x1cc550, extract((void(D::*)(int)){&D::loadFont}));

        if ((void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll} != (void(D::*)(bool, bool, bool)){&D::reloadAll})
            m->registerHook(getBase()+0x1d08a0, extract((void(D::*)(bool, bool, bool)){&D::reloadAll}));

        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            m->registerHook(getBase()+0x1d0b00, extract((void(D::*)()){&D::reloadAllStep5}));

        if ((void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel} != (void(D::*)(int, int, bool)){&D::reportPercentageForLevel})
            m->registerHook(getBase()+0x1c5b00, extract((void(D::*)(int, int, bool)){&D::reportPercentageForLevel}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable} != (void(D::*)(char const*, bool)){&D::setGameVariable})
            m->registerHook(getBase()+0x1cca80, extract((void(D::*)(char const*, bool)){&D::setGameVariable}));

        if ((void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable} != (void(D::*)(char const*, int)){&D::setIntGameVariable})
            m->registerHook(getBase()+0x1cd0e0, extract((void(D::*)(char const*, int)){&D::setIntGameVariable}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setUGV} != (void(D::*)(char const*, bool)){&D::setUGV})
            m->registerHook(getBase()+0x1cce50, extract((void(D::*)(char const*, bool)){&D::setUGV}));

        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x1c2b30, (GameManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $GameObject : public GameObject, public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameObject() {}
    typedef GameObject* __thistype;

    void activateObject() {
        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2faf60))(this);
        else return GameObject::activateObject();
    }

    void activatedByPlayer(GameObject* p0) {
        if ((void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer} != (void(D::*)(GameObject*)){&D::activatedByPlayer})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a20))(this, p0);
        else return GameObject::activatedByPlayer(p0);
    }

    void addColorSprite() {
        if ((void($GameObject::*)()){&$GameObject::addColorSprite} != (void(D::*)()){&D::addColorSprite})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7fe0))(this);
        else return GameObject::addColorSprite();
    }

    void addColorSpriteToParent(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent} != (void(D::*)(bool)){&D::addColorSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
        else return GameObject::addColorSpriteToParent(p0);
    }

    void addMainSpriteToParent(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
        else return GameObject::addMainSpriteToParent(p0);
    }

    void addToGroup(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
        else return GameObject::addToGroup(p0);
    }

    void addToTempOffset(float p0, float p1) {
        if ((void($GameObject::*)(float, float)){&$GameObject::addToTempOffset} != (void(D::*)(float, float)){&D::addToTempOffset})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
        else return GameObject::addToTempOffset(p0, p1);
    }

    void calculateOrientedBox() {
        if ((void($GameObject::*)()){&$GameObject::calculateOrientedBox} != (void(D::*)()){&D::calculateOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b20))(this);
        else return GameObject::calculateOrientedBox();
    }

    void calculateSpawnXPos() {
        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
        else return GameObject::calculateSpawnXPos();
    }

    void canChangeCustomColor() {
        if ((void($GameObject::*)()){&$GameObject::canChangeCustomColor} != (void(D::*)()){&D::canChangeCustomColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342db0))(this);
        else return GameObject::canChangeCustomColor();
    }

    void colorForMode(int p0, bool p1) {
        if ((void($GameObject::*)(int, bool)){&$GameObject::colorForMode} != (void(D::*)(int, bool)){&D::colorForMode})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
        else return GameObject::colorForMode(p0, p1);
    }

    void commonSetup() {
        if ((void($GameObject::*)()){&$GameObject::commonSetup} != (void(D::*)()){&D::commonSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5570))(this);
        else return GameObject::commonSetup();
    }

    void copyGroups(GameObject* p0) {
        if ((void($GameObject::*)(GameObject*)){&$GameObject::copyGroups} != (void(D::*)(GameObject*)){&D::copyGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
        else return GameObject::copyGroups(p0);
    }

    static GameObject* createWithFrame(char const* p0) {
        if ((GameObject*(*)(char const*)){&$GameObject::createWithFrame} != (GameObject*(*)(char const*)){&D::createWithFrame})
            return reinterpret_cast<GameObject*(*)(char const*)>(m->getOriginal(getBase()+0x2f5490))(p0);
        else return GameObject::createWithFrame(p0);
    }

    static GameObject* createWithKey(int p0) {
        if ((GameObject*(*)(int)){&$GameObject::createWithKey} != (GameObject*(*)(int)){&D::createWithKey})
            return reinterpret_cast<GameObject*(*)(int)>(m->getOriginal(getBase()+0x2f4ce0))(p0);
        else return GameObject::createWithKey(p0);
    }

    void customSetup() {
        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fbba0))(this);
        else return GameObject::customSetup();
    }

    void deactivateObject(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
        else return GameObject::deactivateObject(p0);
    }

    void destroyObject() {
        if ((void($GameObject::*)()){&$GameObject::destroyObject} != (void(D::*)()){&D::destroyObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
        else return GameObject::destroyObject();
    }

    void determineSlopeDirection() {
        if ((void($GameObject::*)()){&$GameObject::determineSlopeDirection} != (void(D::*)()){&D::determineSlopeDirection})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33a9e0))(this);
        else return GameObject::determineSlopeDirection();
    }

    void getActiveColorForMode(int p0, bool p1) {
        if ((void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode} != (void(D::*)(int, bool)){&D::getActiveColorForMode})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
        else return GameObject::getActiveColorForMode(p0, p1);
    }

    void getBallFrame(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::getBallFrame} != (void(D::*)(int)){&D::getBallFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
        else return GameObject::getBallFrame(p0);
    }

    void getBoxOffset() {
        if ((void($GameObject::*)()){&$GameObject::getBoxOffset} != (void(D::*)()){&D::getBoxOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3353d0))(this);
        else return GameObject::getBoxOffset();
    }

    const cocos2d::_ccColor3B& getColorIndex() {
        if ((const cocos2d::_ccColor3B&($GameObject::*)()){&$GameObject::getColorIndex} != (const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this))>(m->getOriginal(getBase()+0x343b90))(this);
        else return GameObject::getColorIndex();
    }

    void getDidUpdateLastPosition() {
        if ((void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition} != (void(D::*)()){&D::getDidUpdateLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a20))(this);
        else return GameObject::getDidUpdateLastPosition();
    }

    int getGroupID(int p0) {
        if ((int($GameObject::*)(int)){&$GameObject::getGroupID} != (int(D::*)(int)){&D::getGroupID})
            return reinterpret_cast<int(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
        else return GameObject::getGroupID(p0);
    }

    void getLastPosition() {
        if ((void($GameObject::*)()){&$GameObject::getLastPosition} != (void(D::*)()){&D::getLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3439d0))(this);
        else return GameObject::getLastPosition();
    }

    void getMainColorMode() {
        if ((void($GameObject::*)()){&$GameObject::getMainColorMode} != (void(D::*)()){&D::getMainColorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x334c30))(this);
        else return GameObject::getMainColorMode();
    }

    cocos2d::CCRect* getObjectRect() {
        if ((cocos2d::CCRect*($GameObject::*)()){&$GameObject::getObjectRect} != (cocos2d::CCRect*(D::*)()){&D::getObjectRect})
            return reinterpret_cast<cocos2d::CCRect*(*)(decltype(this))>(m->getOriginal(getBase()+0x3352b0))(this);
        else return GameObject::getObjectRect();
    }

    void getObjectRect(float p0, float p1) {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
        else return GameObject::getObjectRect(p0, p1);
    }

    void getObjectRect2(float p0, float p1) {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
        else return GameObject::getObjectRect2(p0, p1);
    }

    void getObjectRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1d0))(this);
        else return GameObject::getObjectRectDirty();
    }

    void getObjectTextureRect() {
        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3355b0))(this);
        else return GameObject::getObjectTextureRect();
    }

    void getObjectZOrder() {
        if ((void($GameObject::*)()){&$GameObject::getObjectZOrder} != (void(D::*)()){&D::getObjectZOrder})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337d70))(this);
        else return GameObject::getObjectZOrder();
    }

    void getOrientedRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1f0))(this);
        else return GameObject::getOrientedRectDirty();
    }

    void getRScaleX() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e50))(this);
        else return GameObject::getRScaleX();
    }

    void getRScaleY() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e80))(this);
        else return GameObject::getRScaleY();
    }

    std::string getSaveString() {
        if ((std::string($GameObject::*)()){&$GameObject::getSaveString} != (std::string(D::*)()){&D::getSaveString})
            return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x33d3d0))(this);
        else return GameObject::getSaveString();
    }

    void getSecondaryColorMode() {
        if ((void($GameObject::*)()){&$GameObject::getSecondaryColorMode} != (void(D::*)()){&D::getSecondaryColorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x341c20))(this);
        else return GameObject::getSecondaryColorMode();
    }

    void getSectionIdx() {
        if ((void($GameObject::*)()){&$GameObject::getSectionIdx} != (void(D::*)()){&D::getSectionIdx})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a00))(this);
        else return GameObject::getSectionIdx();
    }

    void getStartPos() {
        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc230))(this);
        else return GameObject::getStartPos();
    }

    void getType() {
        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc210))(this);
        else return GameObject::getType();
    }

    void groupWasDisabled() {
        if ((void($GameObject::*)()){&$GameObject::groupWasDisabled} != (void(D::*)()){&D::groupWasDisabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b110))(this);
        else return GameObject::groupWasDisabled();
    }

    void groupWasEnabled() {
        if ((void($GameObject::*)()){&$GameObject::groupWasEnabled} != (void(D::*)()){&D::groupWasEnabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b0f0))(this);
        else return GameObject::groupWasEnabled();
    }

    void hasBeenActivated() {
        if ((void($GameObject::*)()){&$GameObject::hasBeenActivated} != (void(D::*)()){&D::hasBeenActivated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342a80))(this);
        else return GameObject::hasBeenActivated();
    }

    void hasBeenActivatedByPlayer(GameObject* p0) {
        if ((void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer} != (void(D::*)(GameObject*)){&D::hasBeenActivatedByPlayer})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a50))(this, p0);
        else return GameObject::hasBeenActivatedByPlayer(p0);
    }

    void hasSecondaryColor() {
        if ((void($GameObject::*)()){&$GameObject::hasSecondaryColor} != (void(D::*)()){&D::hasSecondaryColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342f80))(this);
        else return GameObject::hasSecondaryColor();
    }

    void ignoreEnter() {
        if ((void($GameObject::*)()){&$GameObject::ignoreEnter} != (void(D::*)()){&D::ignoreEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352a0))(this);
        else return GameObject::ignoreEnter();
    }

    void ignoreFade() {
        if ((void($GameObject::*)()){&$GameObject::ignoreFade} != (void(D::*)()){&D::ignoreFade})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335290))(this);
        else return GameObject::ignoreFade();
    }

    bool initWithTexture(cocos2d::CCTexture2D* p0) {
        if ((bool($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
        else return GameObject::initWithTexture(p0);
    }

    void isBasicTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isBasicTrigger} != (void(D::*)()){&D::isBasicTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343d10))(this);
        else return GameObject::isBasicTrigger();
    }

    void isColorTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isColorTrigger} != (void(D::*)()){&D::isColorTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b40))(this);
        else return GameObject::isColorTrigger();
    }

    void isFlipX() {
        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a40))(this);
        else return GameObject::isFlipX();
    }

    void isFlipY() {
        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a50))(this);
        else return GameObject::isFlipY();
    }

    void isSpawnableTrigger() {
        if ((void($GameObject::*)()){&$GameObject::isSpawnableTrigger} != (void(D::*)()){&D::isSpawnableTrigger})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a60))(this);
        else return GameObject::isSpawnableTrigger();
    }

    void isSpecialObject() {
        if ((void($GameObject::*)()){&$GameObject::isSpecialObject} != (void(D::*)()){&D::isSpecialObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343c40))(this);
        else return GameObject::isSpecialObject();
    }

    static GameObject* objectFromString(std::string p0, bool p1) {
        if ((GameObject*(*)(std::string, bool)){&$GameObject::objectFromString} != (GameObject*(*)(std::string, bool)){&D::objectFromString})
            return reinterpret_cast<GameObject*(*)(std::string, bool)>(m->getOriginal(getBase()+0x33b720))(p0, p1);
        else return GameObject::objectFromString(p0, p1);
    }

    void playShineEffect() {
        if ((void($GameObject::*)()){&$GameObject::playShineEffect} != (void(D::*)()){&D::playShineEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
        else return GameObject::playShineEffect();
    }

    void powerOffObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369c0))(this);
        else return GameObject::powerOffObject();
    }

    void powerOnObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369a0))(this);
        else return GameObject::powerOnObject();
    }

    void quickUpdatePosition() {
        if ((void($GameObject::*)()){&$GameObject::quickUpdatePosition} != (void(D::*)()){&D::quickUpdatePosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335790))(this);
        else return GameObject::quickUpdatePosition();
    }

    void removeFromGroup(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
        else return GameObject::removeFromGroup(p0);
    }

    void removeGlow() {
        if ((void($GameObject::*)()){&$GameObject::removeGlow} != (void(D::*)()){&D::removeGlow})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7f70))(this);
        else return GameObject::removeGlow();
    }

    void resetGroupDisabled() {
        if ((void($GameObject::*)()){&$GameObject::resetGroupDisabled} != (void(D::*)()){&D::resetGroupDisabled})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa7e0))(this);
        else return GameObject::resetGroupDisabled();
    }

    void saveActiveColors() {
        if ((void($GameObject::*)()){&$GameObject::saveActiveColors} != (void(D::*)()){&D::saveActiveColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d250))(this);
        else return GameObject::saveActiveColors();
    }

    void selectObject(cocos2d::_ccColor3B p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject} != (void(D::*)(cocos2d::_ccColor3B)){&D::selectObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x341f90))(this, p0);
        else return GameObject::selectObject(p0);
    }

    void setChildColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341f20))(this, p0);
        else return GameObject::setChildColor(p0);
    }

    void setDefaultMainColorMode(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode} != (void(D::*)(int)){&D::setDefaultMainColorMode})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
        else return GameObject::setDefaultMainColorMode(p0);
    }

    void setDidUpdateLastPosition(bool const& p0) {
        if ((void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition} != (void(D::*)(bool const&)){&D::setDidUpdateLastPosition})
            return reinterpret_cast<void(*)(decltype(this), bool const&)>(m->getOriginal(getBase()+0x343a30))(this, p0);
        else return GameObject::setDidUpdateLastPosition(p0);
    }

    void setGlowColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
        else return GameObject::setGlowColor(p0);
    }

    void setGlowOpacity(unsigned char p0) {
        if ((void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity} != (void(D::*)(unsigned char)){&D::setGlowOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x336200))(this, p0);
        else return GameObject::setGlowOpacity(p0);
    }

    void setLastPosition(cocos2d::CCPoint const& p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setLastPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
        else return GameObject::setLastPosition(p0);
    }

    void setMainColorMode(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::setMainColorMode} != (void(D::*)(int)){&D::setMainColorMode})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x342e70))(this, p0);
        else return GameObject::setMainColorMode(p0);
    }

    void setObjectColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341c90))(this, p0);
        else return GameObject::setObjectColor(p0);
    }

    void setObjectRectDirty(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
        else return GameObject::setObjectRectDirty(p0);
    }

    void setOrientedRectDirty(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc200))(this, p0);
        else return GameObject::setOrientedRectDirty(p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x335850))(this, p0);
        else return GameObject::setPosition(p0);
    }

    void setRScale(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335e10))(this, p0);
        else return GameObject::setRScale(p0);
    }

    void setRScaleX(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
        else return GameObject::setRScaleX(p0);
    }

    void setRScaleY(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335d60))(this, p0);
        else return GameObject::setRScaleY(p0);
    }

    void setSectionIdx(int const& p0) {
        if ((void($GameObject::*)(int const&)){&$GameObject::setSectionIdx} != (void(D::*)(int const&)){&D::setSectionIdx})
            return reinterpret_cast<void(*)(decltype(this), int const&)>(m->getOriginal(getBase()+0x343a10))(this, p0);
        else return GameObject::setSectionIdx(p0);
    }

    void setStartPos(cocos2d::CCPoint p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
        else return GameObject::setStartPos(p0);
    }

    void setType(GameObjectType p0) {
        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0xdc220))(this, p0);
        else return GameObject::setType(p0);
    }

    void setupCoinArt() {
        if ((void($GameObject::*)()){&$GameObject::setupCoinArt} != (void(D::*)()){&D::setupCoinArt})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
        else return GameObject::setupCoinArt();
    }

    void setupCustomSprites() {
        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x307f60))(this);
        else return GameObject::setupCustomSprites();
    }

    void slopeFloorTop() {
        if ((void($GameObject::*)()){&$GameObject::slopeFloorTop} != (void(D::*)()){&D::slopeFloorTop})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342800))(this);
        else return GameObject::slopeFloorTop();
    }

    void slopeWallLeft() {
        if ((void($GameObject::*)()){&$GameObject::slopeWallLeft} != (void(D::*)()){&D::slopeWallLeft})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3427e0))(this);
        else return GameObject::slopeWallLeft();
    }

    void spawnXPosition() {
        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1b0))(this);
        else return GameObject::spawnXPosition();
    }

    void triggerActivated(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x336990))(this, p0);
        else return GameObject::triggerActivated(p0);
    }

    void triggerObject(GJBaseGameLayer* p0) {
        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
        else return GameObject::triggerObject(p0);
    }

    void updateCustomScale(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::updateCustomScale} != (void(D::*)(float)){&D::updateCustomScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
        else return GameObject::updateCustomScale(p0);
    }

    void updateMainColor() {
        if ((void($GameObject::*)()){&$GameObject::updateMainColor} != (void(D::*)()){&D::updateMainColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343340))(this);
        else return GameObject::updateMainColor();
    }

    void updateOrientedBox() {
        if ((void($GameObject::*)()){&$GameObject::updateOrientedBox} != (void(D::*)()){&D::updateOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b50))(this);
        else return GameObject::updateOrientedBox();
    }

    void updateSecondaryColor() {
        if ((void($GameObject::*)()){&$GameObject::updateSecondaryColor} != (void(D::*)()){&D::updateSecondaryColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343740))(this);
        else return GameObject::updateSecondaryColor();
    }

    void updateStartPos() {
        if ((void($GameObject::*)()){&$GameObject::updateStartPos} != (void(D::*)()){&D::updateStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa590))(this);
        else return GameObject::updateStartPos();
    }

    void updateStartValues() {
        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa800))(this);
        else return GameObject::updateStartValues();
    }

    void updateState() {
        if ((void($GameObject::*)()){&$GameObject::updateState} != (void(D::*)()){&D::updateState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369e0))(this);
        else return GameObject::updateState();
    }

    void updateSyncedAnimation(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation} != (void(D::*)(float)){&D::updateSyncedAnimation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x337f00))(this, p0);
        else return GameObject::updateSyncedAnimation(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(getBase()+0x2faf60, extract((void(D::*)()){&D::activateObject}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer} != (void(D::*)(GameObject*)){&D::activatedByPlayer})
            m->registerHook(getBase()+0x342a20, extract((void(D::*)(GameObject*)){&D::activatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::addColorSprite} != (void(D::*)()){&D::addColorSprite})
            m->registerHook(getBase()+0x2f7fe0, extract((void(D::*)()){&D::addColorSprite}));

        if ((void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent} != (void(D::*)(bool)){&D::addColorSpriteToParent})
            m->registerHook(getBase()+0x2fb470, extract((void(D::*)(bool)){&D::addColorSpriteToParent}));

        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(getBase()+0x33a5b0, extract((void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(getBase()+0x33ad00, extract((void(D::*)(int)){&D::addToGroup}));

        if ((void($GameObject::*)(float, float)){&$GameObject::addToTempOffset} != (void(D::*)(float, float)){&D::addToTempOffset})
            m->registerHook(getBase()+0x335700, extract((void(D::*)(float, float)){&D::addToTempOffset}));

        if ((void($GameObject::*)()){&$GameObject::calculateOrientedBox} != (void(D::*)()){&D::calculateOrientedBox})
            m->registerHook(getBase()+0x342b20, extract((void(D::*)()){&D::calculateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(getBase()+0x336970, extract((void(D::*)()){&D::calculateSpawnXPos}));

        if ((void($GameObject::*)()){&$GameObject::canChangeCustomColor} != (void(D::*)()){&D::canChangeCustomColor})
            m->registerHook(getBase()+0x342db0, extract((void(D::*)()){&D::canChangeCustomColor}));

        if ((void($GameObject::*)(int, bool)){&$GameObject::colorForMode} != (void(D::*)(int, bool)){&D::colorForMode})
            m->registerHook(getBase()+0x343460, extract((void(D::*)(int, bool)){&D::colorForMode}));

        if ((void($GameObject::*)()){&$GameObject::commonSetup} != (void(D::*)()){&D::commonSetup})
            m->registerHook(getBase()+0x2f5570, extract((void(D::*)()){&D::commonSetup}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::copyGroups} != (void(D::*)(GameObject*)){&D::copyGroups})
            m->registerHook(getBase()+0x33ae30, extract((void(D::*)(GameObject*)){&D::copyGroups}));

        if ((GameObject*(*)(char const*)){&$GameObject::createWithFrame} != (GameObject*(*)(char const*)){&D::createWithFrame})
            m->registerHook(getBase()+0x2f5490, (GameObject*(*)(char const*)){&D::createWithFrame});

        if ((GameObject*(*)(int)){&$GameObject::createWithKey} != (GameObject*(*)(int)){&D::createWithKey})
            m->registerHook(getBase()+0x2f4ce0, (GameObject*(*)(int)){&D::createWithKey});

        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x2fbba0, extract((void(D::*)()){&D::customSetup}));

        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(getBase()+0x2fb8f0, extract((void(D::*)(bool)){&D::deactivateObject}));

        if ((void($GameObject::*)()){&$GameObject::destroyObject} != (void(D::*)()){&D::destroyObject})
            m->registerHook(getBase()+0x336a00, extract((void(D::*)()){&D::destroyObject}));

        if ((void($GameObject::*)()){&$GameObject::determineSlopeDirection} != (void(D::*)()){&D::determineSlopeDirection})
            m->registerHook(getBase()+0x33a9e0, extract((void(D::*)()){&D::determineSlopeDirection}));

        if ((void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode} != (void(D::*)(int, bool)){&D::getActiveColorForMode})
            m->registerHook(getBase()+0x343860, extract((void(D::*)(int, bool)){&D::getActiveColorForMode}));

        if ((void($GameObject::*)(int)){&$GameObject::getBallFrame} != (void(D::*)(int)){&D::getBallFrame})
            m->registerHook(getBase()+0x341bf0, extract((void(D::*)(int)){&D::getBallFrame}));

        if ((void($GameObject::*)()){&$GameObject::getBoxOffset} != (void(D::*)()){&D::getBoxOffset})
            m->registerHook(getBase()+0x3353d0, extract((void(D::*)()){&D::getBoxOffset}));

        if ((const cocos2d::_ccColor3B&($GameObject::*)()){&$GameObject::getColorIndex} != (const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex})
            m->registerHook(getBase()+0x343b90, extract((const cocos2d::_ccColor3B&(D::*)()){&D::getColorIndex}));

        if ((void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition} != (void(D::*)()){&D::getDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a20, extract((void(D::*)()){&D::getDidUpdateLastPosition}));

        if ((int($GameObject::*)(int)){&$GameObject::getGroupID} != (int(D::*)(int)){&D::getGroupID})
            m->registerHook(getBase()+0x33ae10, extract((int(D::*)(int)){&D::getGroupID}));

        if ((void($GameObject::*)()){&$GameObject::getLastPosition} != (void(D::*)()){&D::getLastPosition})
            m->registerHook(getBase()+0x3439d0, extract((void(D::*)()){&D::getLastPosition}));

        if ((void($GameObject::*)()){&$GameObject::getMainColorMode} != (void(D::*)()){&D::getMainColorMode})
            m->registerHook(getBase()+0x334c30, extract((void(D::*)()){&D::getMainColorMode}));

        if ((cocos2d::CCRect*($GameObject::*)()){&$GameObject::getObjectRect} != (cocos2d::CCRect*(D::*)()){&D::getObjectRect})
            m->registerHook(getBase()+0x3352b0, extract((cocos2d::CCRect*(D::*)()){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            m->registerHook(getBase()+0x3352d0, extract((void(D::*)(float, float)){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            m->registerHook(getBase()+0x3354e0, extract((void(D::*)(float, float)){&D::getObjectRect2}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            m->registerHook(getBase()+0xdc1d0, extract((void(D::*)()){&D::getObjectRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            m->registerHook(getBase()+0x3355b0, extract((void(D::*)()){&D::getObjectTextureRect}));

        if ((void($GameObject::*)()){&$GameObject::getObjectZOrder} != (void(D::*)()){&D::getObjectZOrder})
            m->registerHook(getBase()+0x337d70, extract((void(D::*)()){&D::getObjectZOrder}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            m->registerHook(getBase()+0xdc1f0, extract((void(D::*)()){&D::getOrientedRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            m->registerHook(getBase()+0x335e50, extract((void(D::*)()){&D::getRScaleX}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            m->registerHook(getBase()+0x335e80, extract((void(D::*)()){&D::getRScaleY}));

        if ((std::string($GameObject::*)()){&$GameObject::getSaveString} != (std::string(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x33d3d0, extract((std::string(D::*)()){&D::getSaveString}));

        if ((void($GameObject::*)()){&$GameObject::getSecondaryColorMode} != (void(D::*)()){&D::getSecondaryColorMode})
            m->registerHook(getBase()+0x341c20, extract((void(D::*)()){&D::getSecondaryColorMode}));

        if ((void($GameObject::*)()){&$GameObject::getSectionIdx} != (void(D::*)()){&D::getSectionIdx})
            m->registerHook(getBase()+0x343a00, extract((void(D::*)()){&D::getSectionIdx}));

        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            m->registerHook(getBase()+0xdc230, extract((void(D::*)()){&D::getStartPos}));

        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            m->registerHook(getBase()+0xdc210, extract((void(D::*)()){&D::getType}));

        if ((void($GameObject::*)()){&$GameObject::groupWasDisabled} != (void(D::*)()){&D::groupWasDisabled})
            m->registerHook(getBase()+0x33b110, extract((void(D::*)()){&D::groupWasDisabled}));

        if ((void($GameObject::*)()){&$GameObject::groupWasEnabled} != (void(D::*)()){&D::groupWasEnabled})
            m->registerHook(getBase()+0x33b0f0, extract((void(D::*)()){&D::groupWasEnabled}));

        if ((void($GameObject::*)()){&$GameObject::hasBeenActivated} != (void(D::*)()){&D::hasBeenActivated})
            m->registerHook(getBase()+0x342a80, extract((void(D::*)()){&D::hasBeenActivated}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer} != (void(D::*)(GameObject*)){&D::hasBeenActivatedByPlayer})
            m->registerHook(getBase()+0x342a50, extract((void(D::*)(GameObject*)){&D::hasBeenActivatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::hasSecondaryColor} != (void(D::*)()){&D::hasSecondaryColor})
            m->registerHook(getBase()+0x342f80, extract((void(D::*)()){&D::hasSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::ignoreEnter} != (void(D::*)()){&D::ignoreEnter})
            m->registerHook(getBase()+0x3352a0, extract((void(D::*)()){&D::ignoreEnter}));

        if ((void($GameObject::*)()){&$GameObject::ignoreFade} != (void(D::*)()){&D::ignoreFade})
            m->registerHook(getBase()+0x335290, extract((void(D::*)()){&D::ignoreFade}));

        if ((bool($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(getBase()+0x2f56a0, extract((bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($GameObject::*)()){&$GameObject::isBasicTrigger} != (void(D::*)()){&D::isBasicTrigger})
            m->registerHook(getBase()+0x343d10, extract((void(D::*)()){&D::isBasicTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isColorTrigger} != (void(D::*)()){&D::isColorTrigger})
            m->registerHook(getBase()+0x343b40, extract((void(D::*)()){&D::isColorTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            m->registerHook(getBase()+0x335a40, extract((void(D::*)()){&D::isFlipX}));

        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            m->registerHook(getBase()+0x335a50, extract((void(D::*)()){&D::isFlipY}));

        if ((void($GameObject::*)()){&$GameObject::isSpawnableTrigger} != (void(D::*)()){&D::isSpawnableTrigger})
            m->registerHook(getBase()+0x343a60, extract((void(D::*)()){&D::isSpawnableTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isSpecialObject} != (void(D::*)()){&D::isSpecialObject})
            m->registerHook(getBase()+0x343c40, extract((void(D::*)()){&D::isSpecialObject}));

        if ((GameObject*(*)(std::string, bool)){&$GameObject::objectFromString} != (GameObject*(*)(std::string, bool)){&D::objectFromString})
            m->registerHook(getBase()+0x33b720, (GameObject*(*)(std::string, bool)){&D::objectFromString});

        if ((void($GameObject::*)()){&$GameObject::playShineEffect} != (void(D::*)()){&D::playShineEffect})
            m->registerHook(getBase()+0x2fa9d0, extract((void(D::*)()){&D::playShineEffect}));

        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(getBase()+0x3369c0, extract((void(D::*)()){&D::powerOffObject}));

        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(getBase()+0x3369a0, extract((void(D::*)()){&D::powerOnObject}));

        if ((void($GameObject::*)()){&$GameObject::quickUpdatePosition} != (void(D::*)()){&D::quickUpdatePosition})
            m->registerHook(getBase()+0x335790, extract((void(D::*)()){&D::quickUpdatePosition}));

        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(getBase()+0x33ada0, extract((void(D::*)(int)){&D::removeFromGroup}));

        if ((void($GameObject::*)()){&$GameObject::removeGlow} != (void(D::*)()){&D::removeGlow})
            m->registerHook(getBase()+0x2f7f70, extract((void(D::*)()){&D::removeGlow}));

        if ((void($GameObject::*)()){&$GameObject::resetGroupDisabled} != (void(D::*)()){&D::resetGroupDisabled})
            m->registerHook(getBase()+0x2fa7e0, extract((void(D::*)()){&D::resetGroupDisabled}));

        if ((void($GameObject::*)()){&$GameObject::saveActiveColors} != (void(D::*)()){&D::saveActiveColors})
            m->registerHook(getBase()+0x33d250, extract((void(D::*)()){&D::saveActiveColors}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject} != (void(D::*)(cocos2d::_ccColor3B)){&D::selectObject})
            m->registerHook(getBase()+0x341f90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::selectObject}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            m->registerHook(getBase()+0x341f20, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor}));

        if ((void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode} != (void(D::*)(int)){&D::setDefaultMainColorMode})
            m->registerHook(getBase()+0x304fc0, extract((void(D::*)(int)){&D::setDefaultMainColorMode}));

        if ((void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition} != (void(D::*)(bool const&)){&D::setDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a30, extract((void(D::*)(bool const&)){&D::setDidUpdateLastPosition}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            m->registerHook(getBase()+0x341ed0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor}));

        if ((void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity} != (void(D::*)(unsigned char)){&D::setGlowOpacity})
            m->registerHook(getBase()+0x336200, extract((void(D::*)(unsigned char)){&D::setGlowOpacity}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setLastPosition})
            m->registerHook(getBase()+0x3439e0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setLastPosition}));

        if ((void($GameObject::*)(int)){&$GameObject::setMainColorMode} != (void(D::*)(int)){&D::setMainColorMode})
            m->registerHook(getBase()+0x342e70, extract((void(D::*)(int)){&D::setMainColorMode}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(getBase()+0x341c90, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            m->registerHook(getBase()+0xdc1e0, extract((void(D::*)(bool)){&D::setObjectRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            m->registerHook(getBase()+0xdc200, extract((void(D::*)(bool)){&D::setOrientedRectDirty}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x335850, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(getBase()+0x335e10, extract((void(D::*)(float)){&D::setRScale}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            m->registerHook(getBase()+0x335cb0, extract((void(D::*)(float)){&D::setRScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            m->registerHook(getBase()+0x335d60, extract((void(D::*)(float)){&D::setRScaleY}));

        if ((void($GameObject::*)(int const&)){&$GameObject::setSectionIdx} != (void(D::*)(int const&)){&D::setSectionIdx})
            m->registerHook(getBase()+0x343a10, extract((void(D::*)(int const&)){&D::setSectionIdx}));

        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(getBase()+0x2fa520, extract((void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            m->registerHook(getBase()+0xdc220, extract((void(D::*)(GameObjectType)){&D::setType}));

        if ((void($GameObject::*)()){&$GameObject::setupCoinArt} != (void(D::*)()){&D::setupCoinArt})
            m->registerHook(getBase()+0x337dd0, extract((void(D::*)()){&D::setupCoinArt}));

        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(getBase()+0x307f60, extract((void(D::*)()){&D::setupCustomSprites}));

        if ((void($GameObject::*)()){&$GameObject::slopeFloorTop} != (void(D::*)()){&D::slopeFloorTop})
            m->registerHook(getBase()+0x342800, extract((void(D::*)()){&D::slopeFloorTop}));

        if ((void($GameObject::*)()){&$GameObject::slopeWallLeft} != (void(D::*)()){&D::slopeWallLeft})
            m->registerHook(getBase()+0x3427e0, extract((void(D::*)()){&D::slopeWallLeft}));

        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(getBase()+0xdc1b0, extract((void(D::*)()){&D::spawnXPosition}));

        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(getBase()+0x336990, extract((void(D::*)(float)){&D::triggerActivated}));

        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(getBase()+0x2fa8f0, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($GameObject::*)(float)){&$GameObject::updateCustomScale} != (void(D::*)(float)){&D::updateCustomScale})
            m->registerHook(getBase()+0x335eb0, extract((void(D::*)(float)){&D::updateCustomScale}));

        if ((void($GameObject::*)()){&$GameObject::updateMainColor} != (void(D::*)()){&D::updateMainColor})
            m->registerHook(getBase()+0x343340, extract((void(D::*)()){&D::updateMainColor}));

        if ((void($GameObject::*)()){&$GameObject::updateOrientedBox} != (void(D::*)()){&D::updateOrientedBox})
            m->registerHook(getBase()+0x342b50, extract((void(D::*)()){&D::updateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::updateSecondaryColor} != (void(D::*)()){&D::updateSecondaryColor})
            m->registerHook(getBase()+0x343740, extract((void(D::*)()){&D::updateSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::updateStartPos} != (void(D::*)()){&D::updateStartPos})
            m->registerHook(getBase()+0x2fa590, extract((void(D::*)()){&D::updateStartPos}));

        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            m->registerHook(getBase()+0x2fa800, extract((void(D::*)()){&D::updateStartValues}));

        if ((void($GameObject::*)()){&$GameObject::updateState} != (void(D::*)()){&D::updateState})
            m->registerHook(getBase()+0x3369e0, extract((void(D::*)()){&D::updateState}));

        if ((void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation} != (void(D::*)(float)){&D::updateSyncedAnimation})
            m->registerHook(getBase()+0x337f00, extract((void(D::*)(float)){&D::updateSyncedAnimation}));
    }
};


template<class D>
class $GameObjectCopy : public GameObjectCopy, public $CacBase {
 public:
    $GameObjectCopy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameObjectCopy() {}
    typedef GameObjectCopy* __thistype;

    static GameObjectCopy* create(GameObject* p0) {
        if ((GameObjectCopy*(*)(GameObject*)){&$GameObjectCopy::create} != (GameObjectCopy*(*)(GameObject*)){&D::create})
            return reinterpret_cast<GameObjectCopy*(*)(GameObject*)>(m->getOriginal(getBase()+0x975a0))(p0);
        else return GameObjectCopy::create(p0);
    }

    void resetObject() {
        if ((void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x976a0))(this);
        else return GameObjectCopy::resetObject();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GameObjectCopy*(*)(GameObject*)){&$GameObjectCopy::create} != (GameObjectCopy*(*)(GameObject*)){&D::create})
            m->registerHook(getBase()+0x975a0, (GameObjectCopy*(*)(GameObject*)){&D::create});

        if ((void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x976a0, extract((void(D::*)()){&D::resetObject}));
    }
};


template<class D>
class $GameSoundManager : public GameSoundManager, public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameSoundManager() {}
    typedef GameSoundManager* __thistype;

    void disableMetering() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::disableMetering} != (void(D::*)()){&D::disableMetering})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d80))(this);
        else return GameSoundManager::disableMetering();
    }

    void enableMetering() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::enableMetering} != (void(D::*)()){&D::enableMetering})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d00))(this);
        else return GameSoundManager::enableMetering();
    }

    void getMeteringValue() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue} != (void(D::*)()){&D::getMeteringValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362db0))(this);
        else return GameSoundManager::getMeteringValue();
    }

    void playBackgroundMusic(std::string p0, bool p1, bool p2) {
        if ((void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic} != (void(D::*)(std::string, bool, bool)){&D::playBackgroundMusic})
            return reinterpret_cast<void(*)(decltype(this), std::string, bool, bool)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
        else return GameSoundManager::playBackgroundMusic(p0, p1, p2);
    }

    void playEffect(std::string p0, float p1, float p2, float p3) {
        if ((void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect} != (void(D::*)(std::string, float, float, float)){&D::playEffect})
            return reinterpret_cast<void(*)(decltype(this), std::string, float, float, float)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
        else return GameSoundManager::playEffect(p0, p1, p2, p3);
    }

    void sharedManager() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::sharedManager} != (void(D::*)()){&D::sharedManager})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3610f0))(this);
        else return GameSoundManager::sharedManager();
    }

    void stopBackgroundMusic() {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic} != (void(D::*)()){&D::stopBackgroundMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
        else return GameSoundManager::stopBackgroundMusic();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GameSoundManager::*)()){&$GameSoundManager::disableMetering} != (void(D::*)()){&D::disableMetering})
            m->registerHook(getBase()+0x362d80, extract((void(D::*)()){&D::disableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::enableMetering} != (void(D::*)()){&D::enableMetering})
            m->registerHook(getBase()+0x362d00, extract((void(D::*)()){&D::enableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue} != (void(D::*)()){&D::getMeteringValue})
            m->registerHook(getBase()+0x362db0, extract((void(D::*)()){&D::getMeteringValue}));

        if ((void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic} != (void(D::*)(std::string, bool, bool)){&D::playBackgroundMusic})
            m->registerHook(getBase()+0x362070, extract((void(D::*)(std::string, bool, bool)){&D::playBackgroundMusic}));

        if ((void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect} != (void(D::*)(std::string, float, float, float)){&D::playEffect})
            m->registerHook(getBase()+0x3623d0, extract((void(D::*)(std::string, float, float, float)){&D::playEffect}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::sharedManager} != (void(D::*)()){&D::sharedManager})
            m->registerHook(getBase()+0x3610f0, extract((void(D::*)()){&D::sharedManager}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic} != (void(D::*)()){&D::stopBackgroundMusic})
            m->registerHook(getBase()+0x362130, extract((void(D::*)()){&D::stopBackgroundMusic}));
    }
};


template<class D>
class $GameStatsManager : public GameStatsManager, public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameStatsManager() {}
    typedef GameStatsManager* __thistype;

    void awardCurrencyForLevel(GJGameLevel* p0) {
        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel} != (void(D::*)(GJGameLevel*)){&D::awardCurrencyForLevel})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43600))(this, p0);
        else return GameStatsManager::awardCurrencyForLevel(p0);
    }

    void awardDiamondsForLevel(GJGameLevel* p0) {
        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel} != (void(D::*)(GJGameLevel*)){&D::awardDiamondsForLevel})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43c60))(this, p0);
        else return GameStatsManager::awardDiamondsForLevel(p0);
    }

    void awardSecretKey() {
        if ((void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey} != (void(D::*)()){&D::awardSecretKey})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x4b1e0))(this);
        else return GameStatsManager::awardSecretKey();
    }

    void getSecretCoinKey(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey} != (void(D::*)(char const*)){&D::getSecretCoinKey})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x429f0))(this, p0);
        else return GameStatsManager::getSecretCoinKey(p0);
    }

    void getStat(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat} != (void(D::*)(char const*)){&D::getStat})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d310))(this, p0);
        else return GameStatsManager::getStat(p0);
    }

    void hasPendingUserCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin} != (void(D::*)(char const*)){&D::hasPendingUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42730))(this, p0);
        else return GameStatsManager::hasPendingUserCoin(p0);
    }

    void hasSecretCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin} != (void(D::*)(char const*)){&D::hasSecretCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x40730))(this, p0);
        else return GameStatsManager::hasSecretCoin(p0);
    }

    void hasUserCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin} != (void(D::*)(char const*)){&D::hasUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x427e0))(this, p0);
        else return GameStatsManager::hasUserCoin(p0);
    }

    void incrementStat(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*)){&D::incrementStat})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
        else return GameStatsManager::incrementStat(p0);
    }

    void incrementStat(char const* p0, int p1) {
        if ((void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*, int)){&D::incrementStat})
            return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
        else return GameStatsManager::incrementStat(p0, p1);
    }

    void sharedState() {
        if ((void($GameStatsManager::*)()){&$GameStatsManager::sharedState} != (void(D::*)()){&D::sharedState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x38f20))(this);
        else return GameStatsManager::sharedState();
    }

    void storePendingUserCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin} != (void(D::*)(char const*)){&D::storePendingUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42940))(this, p0);
        else return GameStatsManager::storePendingUserCoin(p0);
    }

    void storeSecretCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin} != (void(D::*)(char const*)){&D::storeSecretCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42a10))(this, p0);
        else return GameStatsManager::storeSecretCoin(p0);
    }

    void storeUserCoin(char const* p0) {
        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin} != (void(D::*)(char const*)){&D::storeUserCoin})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42890))(this, p0);
        else return GameStatsManager::storeUserCoin(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel} != (void(D::*)(GJGameLevel*)){&D::awardCurrencyForLevel})
            m->registerHook(getBase()+0x43600, extract((void(D::*)(GJGameLevel*)){&D::awardCurrencyForLevel}));

        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel} != (void(D::*)(GJGameLevel*)){&D::awardDiamondsForLevel})
            m->registerHook(getBase()+0x43c60, extract((void(D::*)(GJGameLevel*)){&D::awardDiamondsForLevel}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey} != (void(D::*)()){&D::awardSecretKey})
            m->registerHook(getBase()+0x4b1e0, extract((void(D::*)()){&D::awardSecretKey}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey} != (void(D::*)(char const*)){&D::getSecretCoinKey})
            m->registerHook(getBase()+0x429f0, extract((void(D::*)(char const*)){&D::getSecretCoinKey}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat} != (void(D::*)(char const*)){&D::getStat})
            m->registerHook(getBase()+0x3d310, extract((void(D::*)(char const*)){&D::getStat}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin} != (void(D::*)(char const*)){&D::hasPendingUserCoin})
            m->registerHook(getBase()+0x42730, extract((void(D::*)(char const*)){&D::hasPendingUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin} != (void(D::*)(char const*)){&D::hasSecretCoin})
            m->registerHook(getBase()+0x40730, extract((void(D::*)(char const*)){&D::hasSecretCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin} != (void(D::*)(char const*)){&D::hasUserCoin})
            m->registerHook(getBase()+0x427e0, extract((void(D::*)(char const*)){&D::hasUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6d0, extract((void(D::*)(char const*)){&D::incrementStat}));

        if ((void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*, int)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6e0, extract((void(D::*)(char const*, int)){&D::incrementStat}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x38f20, extract((void(D::*)()){&D::sharedState}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin} != (void(D::*)(char const*)){&D::storePendingUserCoin})
            m->registerHook(getBase()+0x42940, extract((void(D::*)(char const*)){&D::storePendingUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin} != (void(D::*)(char const*)){&D::storeSecretCoin})
            m->registerHook(getBase()+0x42a10, extract((void(D::*)(char const*)){&D::storeSecretCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin} != (void(D::*)(char const*)){&D::storeUserCoin})
            m->registerHook(getBase()+0x42890, extract((void(D::*)(char const*)){&D::storeUserCoin}));
    }
};


template<class D>
class $GameToolbox : public GameToolbox, public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GameToolbox() {}
    typedef GameToolbox* __thistype;

    static void createToggleButton(std::string p0, cocos2d::SEL_CallFuncO p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) {
        if ((void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton} != (void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&D::createToggleButton})
            return reinterpret_cast<void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x28bdd0))(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
        else return GameToolbox::createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

    static void getRelativeOffset(GameObject* p0, cocos2d::CCPoint p1) {
        if ((void(*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset} != (void(*)(GameObject*, cocos2d::CCPoint)){&D::getRelativeOffset})
            return reinterpret_cast<void(*)(GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x28c060))(p0, p1);
        else return GameToolbox::getRelativeOffset(p0, p1);
    }

    static void multipliedColorValue(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        if ((void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue} != (void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::multipliedColorValue})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x28cb90))(p0, p1, p2);
        else return GameToolbox::multipliedColorValue(p0, p1, p2);
    }

    static void stringSetupToDict(std::string p0, char const* p1) {
        if ((void(*)(std::string, char const*)){&$GameToolbox::stringSetupToDict} != (void(*)(std::string, char const*)){&D::stringSetupToDict})
            return reinterpret_cast<void(*)(std::string, char const*)>(m->getOriginal(getBase()+0x28d700))(p0, p1);
        else return GameToolbox::stringSetupToDict(p0, p1);
    }

    static void stringSetupToMap(std::string p0, char const* p1) {
        if ((void(*)(std::string, char const*)){&$GameToolbox::stringSetupToMap} != (void(*)(std::string, char const*)){&D::stringSetupToMap})
            return reinterpret_cast<void(*)(std::string, char const*)>(m->getOriginal(getBase()+0x28d4c0))(p0, p1);
        else return GameToolbox::stringSetupToMap(p0, p1);
    }

    static void transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) {
        if ((void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&D::transformColor})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x28c950))(p0, p1);
        else return GameToolbox::transformColor(p0, p1);
    }

    static void transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) {
        if ((void(*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const&, float, float, float)){&D::transformColor})
            return reinterpret_cast<void(*)(cocos2d::_ccColor3B const&, float, float, float)>(m->getOriginal(getBase()+0x28c930))(p0, p1, p2, p3);
        else return GameToolbox::transformColor(p0, p1, p2, p3);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton} != (void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&D::createToggleButton})
            m->registerHook(getBase()+0x28bdd0, (void(*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&D::createToggleButton});

        if ((void(*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset} != (void(*)(GameObject*, cocos2d::CCPoint)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x28c060, (void(*)(GameObject*, cocos2d::CCPoint)){&D::getRelativeOffset});

        if ((void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue} != (void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::multipliedColorValue})
            m->registerHook(getBase()+0x28cb90, (void(*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::multipliedColorValue});

        if ((void(*)(std::string, char const*)){&$GameToolbox::stringSetupToDict} != (void(*)(std::string, char const*)){&D::stringSetupToDict})
            m->registerHook(getBase()+0x28d700, (void(*)(std::string, char const*)){&D::stringSetupToDict});

        if ((void(*)(std::string, char const*)){&$GameToolbox::stringSetupToMap} != (void(*)(std::string, char const*)){&D::stringSetupToMap})
            m->registerHook(getBase()+0x28d4c0, (void(*)(std::string, char const*)){&D::stringSetupToMap});

        if ((void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&D::transformColor})
            m->registerHook(getBase()+0x28c950, (void(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&D::transformColor});

        if ((void(*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor} != (void(*)(cocos2d::_ccColor3B const&, float, float, float)){&D::transformColor})
            m->registerHook(getBase()+0x28c930, (void(*)(cocos2d::_ccColor3B const&, float, float, float)){&D::transformColor});
    }
};


template<class D>
class $GravityEffectSprite : public GravityEffectSprite, public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GravityEffectSprite() {}
    typedef GravityEffectSprite* __thistype;

    static GravityEffectSprite* create() {
        if ((GravityEffectSprite*(*)()){&$GravityEffectSprite::create} != (GravityEffectSprite*(*)()){&D::create})
            return reinterpret_cast<GravityEffectSprite*(*)()>(m->getOriginal(getBase()+0x6d0a0))();
        else return GravityEffectSprite::create();
    }

    bool init() {
        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x80b20))(this);
        else return GravityEffectSprite::init();
    }

    void updateSpritesColor(cocos2d::_ccColor3B p0) {
        if ((void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateSpritesColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
        else return GravityEffectSprite::updateSpritesColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GravityEffectSprite*(*)()){&$GravityEffectSprite::create} != (GravityEffectSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x6d0a0, (GravityEffectSprite*(*)()){&D::create});

        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x80b20, extract((bool(D::*)()){&D::init}));

        if ((void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateSpritesColor})
            m->registerHook(getBase()+0x7ce30, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateSpritesColor}));
    }
};


template<class D>
class $GroupCommandObject : public GroupCommandObject, public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$GroupCommandObject() {}
    typedef GroupCommandObject* __thistype;

    static GroupCommandObject* create() {
        if ((GroupCommandObject*(*)()){&$GroupCommandObject::create} != (GroupCommandObject*(*)()){&D::create})
            return reinterpret_cast<GroupCommandObject*(*)()>(m->getOriginal(getBase()+0x18b460))();
        else return GroupCommandObject::create();
    }

    static GroupCommandObject* createFromString(std::string p0) {
        if ((GroupCommandObject*(*)(std::string)){&$GroupCommandObject::createFromString} != (GroupCommandObject*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<GroupCommandObject*(*)(std::string)>(m->getOriginal(getBase()+0x16ece0))(p0);
        else return GroupCommandObject::createFromString(p0);
    }

    void easeToText(int p0) {
        if ((void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText} != (void(D::*)(int)){&D::easeToText})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
        else return GroupCommandObject::easeToText(p0);
    }

    void getEasedAction(cocos2d::CCActionInterval* p0, int p1, float p2) {
        if ((void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction} != (void(D::*)(cocos2d::CCActionInterval*, int, float)){&D::getEasedAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, int, float)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
        else return GroupCommandObject::getEasedAction(p0, p1, p2);
    }

    void runMoveCommand(cocos2d::CCPoint p0, float p1, int p2, float p3, bool p4, bool p5) {
        if ((void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand} != (void(D::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&D::runMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, int, float, bool, bool)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
        else return GroupCommandObject::runMoveCommand(p0, p1, p2, p3, p4, p5);
    }

    void runRotateCommand(float p0, float p1, int p2, float p3, bool p4) {
        if ((void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand} != (void(D::*)(float, float, int, float, bool)){&D::runRotateCommand})
            return reinterpret_cast<void(*)(decltype(this), float, float, int, float, bool)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
        else return GroupCommandObject::runRotateCommand(p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((GroupCommandObject*(*)()){&$GroupCommandObject::create} != (GroupCommandObject*(*)()){&D::create})
            m->registerHook(getBase()+0x18b460, (GroupCommandObject*(*)()){&D::create});

        if ((GroupCommandObject*(*)(std::string)){&$GroupCommandObject::createFromString} != (GroupCommandObject*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x16ece0, (GroupCommandObject*(*)(std::string)){&D::createFromString});

        if ((void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText} != (void(D::*)(int)){&D::easeToText})
            m->registerHook(getBase()+0x16ecb0, extract((void(D::*)(int)){&D::easeToText}));

        if ((void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction} != (void(D::*)(cocos2d::CCActionInterval*, int, float)){&D::getEasedAction})
            m->registerHook(getBase()+0x16e7b0, extract((void(D::*)(cocos2d::CCActionInterval*, int, float)){&D::getEasedAction}));

        if ((void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand} != (void(D::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&D::runMoveCommand})
            m->registerHook(getBase()+0x16e640, extract((void(D::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&D::runMoveCommand}));

        if ((void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand} != (void(D::*)(float, float, int, float, bool)){&D::runRotateCommand})
            m->registerHook(getBase()+0x16e8f0, extract((void(D::*)(float, float, int, float, bool)){&D::runRotateCommand}));
    }
};


template<class D>
class $HardStreak : public HardStreak, public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$HardStreak() {}
    typedef HardStreak* __thistype;

    void addPoint(cocos2d::CCPoint p0) {
        if ((void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPoint})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x5c950))(this, p0);
        else return HardStreak::addPoint(p0);
    }

    void reset() {
        if ((void($HardStreak::*)()){&$HardStreak::reset} != (void(D::*)()){&D::reset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c930))(this);
        else return HardStreak::reset();
    }

    void resumeStroke() {
        if ((void($HardStreak::*)()){&$HardStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c210))(this);
        else return HardStreak::resumeStroke();
    }

    void stopStroke() {
        if ((void($HardStreak::*)()){&$HardStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c8f0))(this);
        else return HardStreak::stopStroke();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPoint})
            m->registerHook(getBase()+0x5c950, extract((void(D::*)(cocos2d::CCPoint)){&D::addPoint}));

        if ((void($HardStreak::*)()){&$HardStreak::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x5c930, extract((void(D::*)()){&D::reset}));

        if ((void($HardStreak::*)()){&$HardStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            m->registerHook(getBase()+0x5c210, extract((void(D::*)()){&D::resumeStroke}));

        if ((void($HardStreak::*)()){&$HardStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            m->registerHook(getBase()+0x5c8f0, extract((void(D::*)()){&D::stopStroke}));
    }
};


template<class D>
class $InfoLayer : public InfoLayer, public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$InfoLayer() {}
    typedef InfoLayer* __thistype;

    void loadPage(int p0, bool p1) {
        if ((void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage} != (void(D::*)(int, bool)){&D::loadPage})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
        else return InfoLayer::loadPage(p0, p1);
    }

    void onRefreshComments(cocos2d::CCObject* p0) {
        if ((void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments} != (void(D::*)(cocos2d::CCObject*)){&D::onRefreshComments})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x459b60))(this, p0);
        else return InfoLayer::onRefreshComments(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage} != (void(D::*)(int, bool)){&D::loadPage})
            m->registerHook(getBase()+0x458fb0, extract((void(D::*)(int, bool)){&D::loadPage}));

        if ((void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments} != (void(D::*)(cocos2d::CCObject*)){&D::onRefreshComments})
            m->registerHook(getBase()+0x459b60, extract((void(D::*)(cocos2d::CCObject*)){&D::onRefreshComments}));
    }
};


template<class D>
class $InheritanceNode : public InheritanceNode, public $CacBase {
 public:
    $InheritanceNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$InheritanceNode() {}
    typedef InheritanceNode* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $EffectGameObject : public EffectGameObject, public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EffectGameObject() {}
    typedef EffectGameObject* __thistype;

    static EffectGameObject* create(char const* p0) {
        if ((EffectGameObject*(*)(char const*)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const*)){&D::create})
            return reinterpret_cast<EffectGameObject*(*)(char const*)>(m->getOriginal(getBase()+0xc9790))(p0);
        else return EffectGameObject::create(p0);
    }

    void getTargetColorIndex() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xca1f0))(this);
        else return EffectGameObject::getTargetColorIndex();
    }

    void triggerObject(GJBaseGameLayer* p0) {
        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
        else return EffectGameObject::triggerObject(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((EffectGameObject*(*)(char const*)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0xc9790, (EffectGameObject*(*)(char const*)){&D::create});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            m->registerHook(getBase()+0xca1f0, extract((void(D::*)()){&D::getTargetColorIndex}));

        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(getBase()+0xc9870, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));
    }
};


template<class D>
class $EndPortalObject : public EndPortalObject, public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EndPortalObject() {}
    typedef EndPortalObject* __thistype;

    static EndPortalObject* create() {
        if ((EndPortalObject*(*)()){&$EndPortalObject::create} != (EndPortalObject*(*)()){&D::create})
            return reinterpret_cast<EndPortalObject*(*)()>(m->getOriginal(getBase()+0x1da8f0))();
        else return EndPortalObject::create();
    }

    void updateColors(cocos2d::_ccColor3B p0) {
        if ((void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
        else return EndPortalObject::updateColors(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((EndPortalObject*(*)()){&$EndPortalObject::create} != (EndPortalObject*(*)()){&D::create})
            m->registerHook(getBase()+0x1da8f0, (EndPortalObject*(*)()){&D::create});

        if ((void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColors})
            m->registerHook(getBase()+0x1dacb0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateColors}));
    }
};


template<class D>
class $LabelGameObject : public LabelGameObject, public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LabelGameObject() {}
    typedef LabelGameObject* __thistype;

    bool init() {
        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5520))(this);
        else return LabelGameObject::init();
    }

    void setObjectColor(cocos2d::_ccColor3B const& p0) {
        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
        else return LabelGameObject::setObjectColor(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x2f5520, extract((bool(D::*)()){&D::init}));

        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(getBase()+0xdbca0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));
    }
};


template<class D>
class $LevelBrowserLayer : public LevelBrowserLayer, public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelBrowserLayer() {}
    typedef LevelBrowserLayer* __thistype;

    void loadPage(GJSearchObject* p0) {
        if ((void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage} != (void(D::*)(GJSearchObject*)){&D::loadPage})
            return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x253650))(this, p0);
        else return LevelBrowserLayer::loadPage(p0);
    }

    static cocos2d::CCScene* scene(GJSearchObject* p0) {
        if ((cocos2d::CCScene*(*)(GJSearchObject*)){&$LevelBrowserLayer::scene} != (cocos2d::CCScene*(*)(GJSearchObject*)){&D::scene})
            return reinterpret_cast<cocos2d::CCScene*(*)(GJSearchObject*)>(m->getOriginal(getBase()+0x2511d0))(p0);
        else return LevelBrowserLayer::scene(p0);
    }

    void setIDPopupClosed(SetIDPopup* p0, int p1) {
        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(getBase()+0x2554f0))(this, p0, p1);
        else return LevelBrowserLayer::setIDPopupClosed(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage} != (void(D::*)(GJSearchObject*)){&D::loadPage})
            m->registerHook(getBase()+0x253650, extract((void(D::*)(GJSearchObject*)){&D::loadPage}));

        if ((cocos2d::CCScene*(*)(GJSearchObject*)){&$LevelBrowserLayer::scene} != (cocos2d::CCScene*(*)(GJSearchObject*)){&D::scene})
            m->registerHook(getBase()+0x2511d0, (cocos2d::CCScene*(*)(GJSearchObject*)){&D::scene});

        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(getBase()+0x2554f0, extract((void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $LevelEditorLayer : public LevelEditorLayer, public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelEditorLayer() {}
    typedef LevelEditorLayer* __thistype;

    void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::activateTriggerEffect(p0, p1, p2, p3);
    }

    GameObject* addObjectFromString(std::string p0) {
        if ((GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::string)){&D::addObjectFromString})
            return reinterpret_cast<GameObject*(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x94640))(this, p0);
        else return LevelEditorLayer::addObjectFromString(p0);
    }

    void addSpecial(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject*)){&D::addSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x94f30))(this, p0);
        else return LevelEditorLayer::addSpecial(p0);
    }

    void addToGroup(GameObject* p0, int p1, bool p2) {
        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0x9dab0))(this, p0, p1, p2);
        else return LevelEditorLayer::addToGroup(p0, p1, p2);
    }

    void addToRedoList(UndoObject* p0) {
        if ((void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject*)){&D::addToRedoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject*)>(m->getOriginal(getBase()+0x96f80))(this, p0);
        else return LevelEditorLayer::addToRedoList(p0);
    }

    void addToUndoList(UndoObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject*, bool)){&D::addToUndoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject*, bool)>(m->getOriginal(getBase()+0x94e20))(this, p0, p1);
        else return LevelEditorLayer::addToUndoList(p0, p1);
    }

    void animateInDualGround(GameObject* p0, float p1, bool p2) {
        if ((void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
        else return LevelEditorLayer::animateInDualGround(p0, p1, p2);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x9c590))(this, p0, p1, p2, p3, p4, p5);
        else return LevelEditorLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void checkCollisions(PlayerObject* p0, float p1) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
        else return LevelEditorLayer::checkCollisions(p0, p1);
    }

    static LevelEditorLayer* create(GJGameLevel* p0) {
        if ((LevelEditorLayer*(*)(GJGameLevel*)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel*)){&D::create})
            return reinterpret_cast<LevelEditorLayer*(*)(GJGameLevel*)>(m->getOriginal(getBase()+0x90fb0))(p0);
        else return LevelEditorLayer::create(p0);
    }

    void createBackground() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x929f0))(this);
        else return LevelEditorLayer::createBackground();
    }

    void createGroundLayer() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92840))(this);
        else return LevelEditorLayer::createGroundLayer();
    }

    GameObject* createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        if ((GameObject*($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject})
            return reinterpret_cast<GameObject*(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
        else return LevelEditorLayer::createObject(p0, p1, p2);
    }

    void createObjectsFromSetup(std::string p0) {
        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x92230))(this, p0);
        else return LevelEditorLayer::createObjectsFromSetup(p0);
    }

    void createObjectsFromString(std::string p0, bool p1) {
        if ((void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::string, bool)){&D::createObjectsFromString})
            return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
        else return LevelEditorLayer::createObjectsFromString(p0, p1);
    }

    void draw() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa2a70))(this);
        else return LevelEditorLayer::draw();
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xa04e0))(this, p0, p1, p2);
        else return LevelEditorLayer::flipGravity(p0, p1, p2);
    }

    void getLastObjectX() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c860))(this);
        else return LevelEditorLayer::getLastObjectX();
    }

    void getLevelString() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97790))(this);
        else return LevelEditorLayer::getLevelString();
    }

    void getNextColorChannel() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a610))(this);
        else return LevelEditorLayer::getNextColorChannel();
    }

    void getNextFreeBlockID(cocos2d::CCArray* p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a4e0))(this, p0);
        else return LevelEditorLayer::getNextFreeBlockID(p0);
    }

    int getNextFreeGroupID(cocos2d::CCArray* p0) {
        if ((int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID})
            return reinterpret_cast<int(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
        else return LevelEditorLayer::getNextFreeGroupID(p0);
    }

    void getNextFreeItemID(cocos2d::CCArray* p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a390))(this, p0);
        else return LevelEditorLayer::getNextFreeItemID(p0);
    }

    void getObjectRect(GameObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject*, bool)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96240))(this, p0, p1);
        else return LevelEditorLayer::getObjectRect(p0, p1);
    }

    void getRelativeOffset(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject*)){&D::getRelativeOffset})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x96840))(this, p0);
        else return LevelEditorLayer::getRelativeOffset(p0);
    }

    void handleAction(bool p0, cocos2d::CCArray* p1) {
        if ((void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction} != (void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction})
            return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
        else return LevelEditorLayer::handleAction(p0, p1);
    }

    bool init(GJGameLevel* p0) {
        if ((bool($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x91010))(this, p0);
        else return LevelEditorLayer::init(p0);
    }

    void levelSettingsUpdated() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93f30))(this);
        else return LevelEditorLayer::levelSettingsUpdated();
    }

    void objectAtPosition(cocos2d::CCPoint p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x960c0))(this, p0);
        else return LevelEditorLayer::objectAtPosition(p0);
    }

    void objectMoved(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject*)){&D::objectMoved})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x999f0))(this, p0);
        else return LevelEditorLayer::objectMoved(p0);
    }

    void objectsInRect(cocos2d::CCRect p0, bool p1) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, bool)>(m->getOriginal(getBase()+0x95e60))(this, p0, p1);
        else return LevelEditorLayer::objectsInRect(p0, p1);
    }

    void onPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa06b0))(this);
        else return LevelEditorLayer::onPlaytest();
    }

    void onStopPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa1780))(this);
        else return LevelEditorLayer::onStopPlaytest();
    }

    void playMusic() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa13c0))(this);
        else return LevelEditorLayer::playMusic();
    }

    void recreateGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9dbf0))(this);
        else return LevelEditorLayer::recreateGroups();
    }

    void redoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
        else return LevelEditorLayer::redoLastAction();
    }

    void removeAllObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
        else return LevelEditorLayer::removeAllObjects();
    }

    void removeAllObjectsOfType(int p0) {
        if ((void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(int)){&D::removeAllObjectsOfType})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x96d40))(this, p0);
        else return LevelEditorLayer::removeAllObjectsOfType(p0);
    }

    void removeFromGroup(GameObject* p0, int p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0x9db60))(this, p0, p1);
        else return LevelEditorLayer::removeFromGroup(p0, p1);
    }

    void removeObject(GameObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject*, bool)){&D::removeObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
        else return LevelEditorLayer::removeObject(p0, p1);
    }

    void removeSpecial(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject*)){&D::removeSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x969c0))(this, p0);
        else return LevelEditorLayer::removeSpecial(p0);
    }

    void resetMovingObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9ddc0))(this);
        else return LevelEditorLayer::resetMovingObjects();
    }

    void resetObjectVector() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c4b0))(this);
        else return LevelEditorLayer::resetObjectVector();
    }

    void resetToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9aa70))(this);
        else return LevelEditorLayer::resetToggledGroups();
    }

    void resetToggledGroupsAndObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c3c0))(this);
        else return LevelEditorLayer::resetToggledGroupsAndObjects();
    }

    void resetUnusedColorChannels() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a870))(this);
        else return LevelEditorLayer::resetUnusedColorChannels();
    }

    void rotationForSlopeNearObject(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject*)){&D::rotationForSlopeNearObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x95cd0))(this, p0);
        else return LevelEditorLayer::rotationForSlopeNearObject(p0);
    }

    void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
        else return LevelEditorLayer::runColorEffect(p0, p1, p2, p3, p4);
    }

    void scene(GJGameLevel* p0) {
        if ((void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x90f20))(this, p0);
        else return LevelEditorLayer::scene(p0);
    }

    void setupLevelStart(LevelSettingsObject* p0) {
        if ((void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
        else return LevelEditorLayer::setupLevelStart(p0);
    }

    void sortStickyGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92b10))(this);
        else return LevelEditorLayer::sortStickyGroups();
    }

    void stopTriggersInGroup(int p0, float p1) {
        if ((void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(int, float)){&D::stopTriggersInGroup})
            return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
        else return LevelEditorLayer::stopTriggersInGroup(p0, p1);
    }

    void timeForXPos(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c7d0))(this, p0);
        else return LevelEditorLayer::timeForXPos(p0);
    }

    void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::toggleDualMode(p0, p1, p2, p3);
    }

    void toggleGroupPreview(int p0, bool p1) {
        if ((void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(int, bool)){&D::toggleGroupPreview})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
        else return LevelEditorLayer::toggleGroupPreview(p0, p1);
    }

    void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        if ((void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors})
            return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
        else return LevelEditorLayer::transferDefaultColors(p0, p1);
    }

    void undoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
        else return LevelEditorLayer::undoLastAction();
    }

    void update(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
        else return LevelEditorLayer::update(p0);
    }

    void updateBGAndGColors() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9b9b0))(this);
        else return LevelEditorLayer::updateBGAndGColors();
    }

    void updateBlendValues() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bc60))(this);
        else return LevelEditorLayer::updateBlendValues();
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return LevelEditorLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
        else return LevelEditorLayer::updateDualGround(p0, p1, p2);
    }

    void updateEditorMode() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93b50))(this);
        else return LevelEditorLayer::updateEditorMode();
    }

    void updateGameObjectsNew() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9adc0))(this);
        else return LevelEditorLayer::updateGameObjectsNew();
    }

    void updateGround(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround} != (void(D::*)(float)){&D::updateGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x93a60))(this, p0);
        else return LevelEditorLayer::updateGround(p0);
    }

    void updateGroundWidth() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92af0))(this);
        else return LevelEditorLayer::updateGroundWidth();
    }

    void updateOptions() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x91ed0))(this);
        else return LevelEditorLayer::updateOptions();
    }

    void updateToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bb10))(this);
        else return LevelEditorLayer::updateToggledGroups();
    }

    void updateVisibility(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(float)){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x92c70))(this, p0);
        else return LevelEditorLayer::updateVisibility(p0);
    }

    void xPosForTime(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c800))(this, p0);
        else return LevelEditorLayer::xPosForTime(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect})
            m->registerHook(getBase()+0x9b520, extract((void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect}));

        if ((GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::string)){&D::addObjectFromString})
            m->registerHook(getBase()+0x94640, extract((GameObject*(D::*)(std::string)){&D::addObjectFromString}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject*)){&D::addSpecial})
            m->registerHook(getBase()+0x94f30, extract((void(D::*)(GameObject*)){&D::addSpecial}));

        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(getBase()+0x9dab0, extract((void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject*)){&D::addToRedoList})
            m->registerHook(getBase()+0x96f80, extract((void(D::*)(UndoObject*)){&D::addToRedoList}));

        if ((void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject*, bool)){&D::addToUndoList})
            m->registerHook(getBase()+0x94e20, extract((void(D::*)(UndoObject*, bool)){&D::addToUndoList}));

        if ((void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(getBase()+0xa2780, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0x9c590, extract_virtual(this, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(getBase()+0x9e620, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((LevelEditorLayer*(*)(GJGameLevel*)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(getBase()+0x90fb0, (LevelEditorLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            m->registerHook(getBase()+0x929f0, extract((void(D::*)()){&D::createBackground}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            m->registerHook(getBase()+0x92840, extract((void(D::*)()){&D::createGroundLayer}));

        if ((GameObject*($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject})
            m->registerHook(getBase()+0x957c0, extract((GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject}));

        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x92230, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::string, bool)){&D::createObjectsFromString})
            m->registerHook(getBase()+0x94730, extract((void(D::*)(std::string, bool)){&D::createObjectsFromString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0xa2a70, extract((void(D::*)()){&D::draw}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0xa04e0, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            m->registerHook(getBase()+0x9c860, extract((void(D::*)()){&D::getLastObjectX}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            m->registerHook(getBase()+0x97790, extract((void(D::*)()){&D::getLevelString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            m->registerHook(getBase()+0x9a610, extract((void(D::*)()){&D::getNextColorChannel}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID})
            m->registerHook(getBase()+0x9a4e0, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID}));

        if ((int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID})
            m->registerHook(getBase()+0x9a1b0, extract((int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID})
            m->registerHook(getBase()+0x9a390, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject*, bool)){&D::getObjectRect})
            m->registerHook(getBase()+0x96240, extract((void(D::*)(GameObject*, bool)){&D::getObjectRect}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject*)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x96840, extract((void(D::*)(GameObject*)){&D::getRelativeOffset}));

        if ((void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction} != (void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction})
            m->registerHook(getBase()+0x97020, extract((void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction}));

        if ((bool($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(getBase()+0x91010, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            m->registerHook(getBase()+0x93f30, extract((void(D::*)()){&D::levelSettingsUpdated}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition})
            m->registerHook(getBase()+0x960c0, extract((void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject*)){&D::objectMoved})
            m->registerHook(getBase()+0x999f0, extract((void(D::*)(GameObject*)){&D::objectMoved}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect})
            m->registerHook(getBase()+0x95e60, extract((void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            m->registerHook(getBase()+0xa06b0, extract((void(D::*)()){&D::onPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            m->registerHook(getBase()+0xa1780, extract((void(D::*)()){&D::onStopPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            m->registerHook(getBase()+0xa13c0, extract((void(D::*)()){&D::playMusic}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            m->registerHook(getBase()+0x9dbf0, extract((void(D::*)()){&D::recreateGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            m->registerHook(getBase()+0x97750, extract((void(D::*)()){&D::redoLastAction}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x93d80, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(int)){&D::removeAllObjectsOfType})
            m->registerHook(getBase()+0x96d40, extract((void(D::*)(int)){&D::removeAllObjectsOfType}));

        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(getBase()+0x9db60, extract((void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject*, bool)){&D::removeObject})
            m->registerHook(getBase()+0x96890, extract((void(D::*)(GameObject*, bool)){&D::removeObject}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject*)){&D::removeSpecial})
            m->registerHook(getBase()+0x969c0, extract((void(D::*)(GameObject*)){&D::removeSpecial}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            m->registerHook(getBase()+0x9ddc0, extract((void(D::*)()){&D::resetMovingObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            m->registerHook(getBase()+0x9c4b0, extract((void(D::*)()){&D::resetObjectVector}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x9aa70, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            m->registerHook(getBase()+0x9c3c0, extract((void(D::*)()){&D::resetToggledGroupsAndObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            m->registerHook(getBase()+0x9a870, extract((void(D::*)()){&D::resetUnusedColorChannels}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject*)){&D::rotationForSlopeNearObject})
            m->registerHook(getBase()+0x95cd0, extract((void(D::*)(GameObject*)){&D::rotationForSlopeNearObject}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect})
            m->registerHook(getBase()+0x9bd30, extract((void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect}));

        if ((void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(getBase()+0x90f20, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(getBase()+0xa0ca0, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            m->registerHook(getBase()+0x92b10, extract((void(D::*)()){&D::sortStickyGroups}));

        if ((void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(int, float)){&D::stopTriggersInGroup})
            m->registerHook(getBase()+0x9c030, extract((void(D::*)(int, float)){&D::stopTriggersInGroup}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x9c7d0, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(getBase()+0xa0200, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(int, bool)){&D::toggleGroupPreview})
            m->registerHook(getBase()+0x9bea0, extract((void(D::*)(int, bool)){&D::toggleGroupPreview}));

        if ((void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors})
            m->registerHook(getBase()+0x9ab50, extract((void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            m->registerHook(getBase()+0x97770, extract((void(D::*)()){&D::undoLastAction}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0xa1b70, extract((void(D::*)(float)){&D::update}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            m->registerHook(getBase()+0x9b9b0, extract((void(D::*)()){&D::updateBGAndGColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            m->registerHook(getBase()+0x9bc60, extract((void(D::*)()){&D::updateBlendValues}));

        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0x9c200, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(getBase()+0xa1a60, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            m->registerHook(getBase()+0x93b50, extract((void(D::*)()){&D::updateEditorMode}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            m->registerHook(getBase()+0x9adc0, extract((void(D::*)()){&D::updateGameObjectsNew}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround} != (void(D::*)(float)){&D::updateGround})
            m->registerHook(getBase()+0x93a60, extract((void(D::*)(float)){&D::updateGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x92af0, extract((void(D::*)()){&D::updateGroundWidth}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            m->registerHook(getBase()+0x91ed0, extract((void(D::*)()){&D::updateOptions}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            m->registerHook(getBase()+0x9bb10, extract((void(D::*)()){&D::updateToggledGroups}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(float)){&D::updateVisibility})
            m->registerHook(getBase()+0x92c70, extract((void(D::*)(float)){&D::updateVisibility}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c800, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $LevelInfoLayer : public LevelInfoLayer, public $CacBase {
 public:
    $LevelInfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelInfoLayer() {}
    typedef LevelInfoLayer* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $LevelSettingsLayer : public LevelSettingsLayer, public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelSettingsLayer() {}
    typedef LevelSettingsLayer* __thistype;

    static LevelSettingsLayer* create(LevelSettingsObject* p0, LevelEditorLayer* p1) {
        if ((LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create} != (LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&D::create})
            return reinterpret_cast<LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa7c30))(p0, p1);
        else return LevelSettingsLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create} != (LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0xa7c30, (LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&D::create});
    }
};


template<class D>
class $LevelSettingsObject : public LevelSettingsObject, public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelSettingsObject() {}
    typedef LevelSettingsObject* __thistype;

    static LevelSettingsObject* create() {
        if ((LevelSettingsObject*(*)()){&$LevelSettingsObject::create} != (LevelSettingsObject*(*)()){&D::create})
            return reinterpret_cast<LevelSettingsObject*(*)()>(m->getOriginal(getBase()+0x92760))();
        else return LevelSettingsObject::create();
    }

    bool init() {
        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xa5690))(this);
        else return LevelSettingsObject::init();
    }

    void objectFromDict(cocos2d::CCDictionary* p0) {
        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::objectFromDict})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa5810))(this, p0);
        else return LevelSettingsObject::objectFromDict(p0);
    }

    static LevelSettingsObject* objectFromString(std::string p0) {
        if ((LevelSettingsObject*(*)(std::string)){&$LevelSettingsObject::objectFromString} != (LevelSettingsObject*(*)(std::string)){&D::objectFromString})
            return reinterpret_cast<LevelSettingsObject*(*)(std::string)>(m->getOriginal(getBase()+0x945a0))(p0);
        else return LevelSettingsObject::objectFromString(p0);
    }

    void setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) {
        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupColorsFromLegacyMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
        else return LevelSettingsObject::setupColorsFromLegacyMode(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((LevelSettingsObject*(*)()){&$LevelSettingsObject::create} != (LevelSettingsObject*(*)()){&D::create})
            m->registerHook(getBase()+0x92760, (LevelSettingsObject*(*)()){&D::create});

        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xa5690, extract((bool(D::*)()){&D::init}));

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::objectFromDict})
            m->registerHook(getBase()+0xa5810, extract((void(D::*)(cocos2d::CCDictionary*)){&D::objectFromDict}));

        if ((LevelSettingsObject*(*)(std::string)){&$LevelSettingsObject::objectFromString} != (LevelSettingsObject*(*)(std::string)){&D::objectFromString})
            m->registerHook(getBase()+0x945a0, (LevelSettingsObject*(*)(std::string)){&D::objectFromString});

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupColorsFromLegacyMode})
            m->registerHook(getBase()+0xa6a30, extract((void(D::*)(cocos2d::CCDictionary*)){&D::setupColorsFromLegacyMode}));
    }
};


template<class D>
class $LevelTools : public LevelTools, public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LevelTools() {}
    typedef LevelTools* __thistype;

    void getAudioString(int p0) {
        if ((void($LevelTools::*)(int)){&$LevelTools::getAudioString} != (void(D::*)(int)){&D::getAudioString})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x293880))(this, p0);
        else return LevelTools::getAudioString(p0);
    }

    void verifyLevelIntegrity(std::string p0, int p1) {
        if ((void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity} != (void(D::*)(std::string, int)){&D::verifyLevelIntegrity})
            return reinterpret_cast<void(*)(decltype(this), std::string, int)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
        else return LevelTools::verifyLevelIntegrity(p0, p1);
    }

    void xPosForTime(float p0, cocos2d::CCArray* p1, int p2) {
        if ((void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime} != (void(D::*)(float, cocos2d::CCArray*, int)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCArray*, int)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
        else return LevelTools::xPosForTime(p0, p1, p2);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($LevelTools::*)(int)){&$LevelTools::getAudioString} != (void(D::*)(int)){&D::getAudioString})
            m->registerHook(getBase()+0x293880, extract((void(D::*)(int)){&D::getAudioString}));

        if ((void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity} != (void(D::*)(std::string, int)){&D::verifyLevelIntegrity})
            m->registerHook(getBase()+0x294360, extract((void(D::*)(std::string, int)){&D::verifyLevelIntegrity}));

        if ((void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime} != (void(D::*)(float, cocos2d::CCArray*, int)){&D::xPosForTime})
            m->registerHook(getBase()+0x293d90, extract((void(D::*)(float, cocos2d::CCArray*, int)){&D::xPosForTime}));
    }
};


template<class D>
class $LoadingLayer : public LoadingLayer, public $CacBase {
 public:
    $LoadingLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LoadingLayer() {}
    typedef LoadingLayer* __thistype;

    void loadAssets() {
        if ((void($LoadingLayer::*)()){&$LoadingLayer::loadAssets} != (void(D::*)()){&D::loadAssets})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1dfb20))(this);
        else return LoadingLayer::loadAssets();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($LoadingLayer::*)()){&$LoadingLayer::loadAssets} != (void(D::*)()){&D::loadAssets})
            m->registerHook(getBase()+0x1dfb20, extract((void(D::*)()){&D::loadAssets}));
    }
};


template<class D>
class $LocalLevelManager : public LocalLevelManager, public $CacBase {
 public:
    $LocalLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$LocalLevelManager() {}
    typedef LocalLevelManager* __thistype;

    static LocalLevelManager* sharedState() {
        if ((LocalLevelManager*(*)()){&$LocalLevelManager::sharedState} != (LocalLevelManager*(*)()){&D::sharedState})
            return reinterpret_cast<LocalLevelManager*(*)()>(m->getOriginal(getBase()+0x35dd60))();
        else return LocalLevelManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((LocalLevelManager*(*)()){&$LocalLevelManager::sharedState} != (LocalLevelManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x35dd60, (LocalLevelManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $MenuGameLayer : public MenuGameLayer, public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MenuGameLayer() {}
    typedef MenuGameLayer* __thistype;

    void resetPlayer() {
        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer} != (void(D::*)()){&D::resetPlayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28fdc0))(this);
        else return MenuGameLayer::resetPlayer();
    }

    void update(float p0) {
        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
        else return MenuGameLayer::update(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer} != (void(D::*)()){&D::resetPlayer})
            m->registerHook(getBase()+0x28fdc0, extract((void(D::*)()){&D::resetPlayer}));

        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x28fa70, extract((void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MenuLayer() {}
    typedef MenuLayer* __thistype;

    void keyBackClicked() override {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3160))(this);
        else return MenuLayer::keyBackClicked();
    }

    void onMoreGames(cocos2d::CCObject* p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
        else return MenuLayer::onMoreGames(p0);
    }

    void onQuit(cocos2d::CCObject* p0) {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
        else return MenuLayer::onQuit(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x1d3160, extract_virtual(this, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            m->registerHook(getBase()+0x1d2ad0, extract((void(D::*)(cocos2d::CCObject*)){&D::onMoreGames}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            m->registerHook(getBase()+0x1d2b40, extract((void(D::*)(cocos2d::CCObject*)){&D::onQuit}));
    }
};


template<class D>
class $MoreVideoOptionsLayer : public MoreVideoOptionsLayer, public $CacBase {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MoreVideoOptionsLayer() {}
    typedef MoreVideoOptionsLayer* __thistype;

    static MoreVideoOptionsLayer* create() {
        if ((MoreVideoOptionsLayer*(*)()){&$MoreVideoOptionsLayer::create} != (MoreVideoOptionsLayer*(*)()){&D::create})
            return reinterpret_cast<MoreVideoOptionsLayer*(*)()>(m->getOriginal(getBase()+0x443c10))();
        else return MoreVideoOptionsLayer::create();
    }

    bool init() {
        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
        else return MoreVideoOptionsLayer::init();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((MoreVideoOptionsLayer*(*)()){&$MoreVideoOptionsLayer::create} != (MoreVideoOptionsLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x443c10, (MoreVideoOptionsLayer*(*)()){&D::create});

        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x444150, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $MusicDownloadManager : public MusicDownloadManager, public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$MusicDownloadManager() {}
    typedef MusicDownloadManager* __thistype;

    void incrementPriorityForSong(int p0) {
        if ((void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong} != (void(D::*)(int)){&D::incrementPriorityForSong})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
        else return MusicDownloadManager::incrementPriorityForSong(p0);
    }

    static MusicDownloadManager* sharedState() {
        if ((MusicDownloadManager*(*)()){&$MusicDownloadManager::sharedState} != (MusicDownloadManager*(*)()){&D::sharedState})
            return reinterpret_cast<MusicDownloadManager*(*)()>(m->getOriginal(getBase()+0x2ee4c0))();
        else return MusicDownloadManager::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong} != (void(D::*)(int)){&D::incrementPriorityForSong})
            m->registerHook(getBase()+0x2ef750, extract((void(D::*)(int)){&D::incrementPriorityForSong}));

        if ((MusicDownloadManager*(*)()){&$MusicDownloadManager::sharedState} != (MusicDownloadManager*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x2ee4c0, (MusicDownloadManager*(*)()){&D::sharedState});
    }
};


template<class D>
class $OBB2D : public OBB2D, public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$OBB2D() {}
    typedef OBB2D* __thistype;

    void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
        else return OBB2D::calculateWithCenter(p0, p1, p2, p3);
    }

    static OBB2D* create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create})
            return reinterpret_cast<OBB2D*(*)(cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a890))(p0, p1, p2, p3);
        else return OBB2D::create(p0, p1, p2, p3);
    }

    void getBoundingRect() {
        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35b2b0))(this);
        else return OBB2D::getBoundingRect();
    }

    void overlaps(OBB2D* p0) {
        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps} != (void(D::*)(OBB2D*)){&D::overlaps})
            return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0a0))(this, p0);
        else return OBB2D::overlaps(p0);
    }

    void overlaps1Way(OBB2D* p0) {
        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D*)){&D::overlaps1Way})
            return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
        else return OBB2D::overlaps1Way(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter})
            m->registerHook(getBase()+0x35a9c0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter}));

        if ((OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create})
            m->registerHook(getBase()+0x35a890, (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create});

        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            m->registerHook(getBase()+0x35b2b0, extract((void(D::*)()){&D::getBoundingRect}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps} != (void(D::*)(OBB2D*)){&D::overlaps})
            m->registerHook(getBase()+0x35b0a0, extract((void(D::*)(OBB2D*)){&D::overlaps}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D*)){&D::overlaps1Way})
            m->registerHook(getBase()+0x35b0d0, extract((void(D::*)(OBB2D*)){&D::overlaps1Way}));
    }
};


template<class D>
class $ObjectToolbox : public ObjectToolbox, public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ObjectToolbox() {}
    typedef ObjectToolbox* __thistype;

    bool init() {
        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2d80))(this);
        else return ObjectToolbox::init();
    }

    char const* intKeyToFrame(int p0) {
        if ((char const*($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame} != (char const*(D::*)(int)){&D::intKeyToFrame})
            return reinterpret_cast<char const*(*)(decltype(this), int)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
        else return ObjectToolbox::intKeyToFrame(p0);
    }

    static ObjectToolbox* sharedState() {
        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            return reinterpret_cast<ObjectToolbox*(*)()>(m->getOriginal(getBase()+0x3b2bc0))();
        else return ObjectToolbox::sharedState();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x3b2d80, extract((bool(D::*)()){&D::init}));

        if ((char const*($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame} != (char const*(D::*)(int)){&D::intKeyToFrame})
            m->registerHook(getBase()+0x4173b0, extract((char const*(D::*)(int)){&D::intKeyToFrame}));

        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            m->registerHook(getBase()+0x3b2bc0, (ObjectToolbox*(*)()){&D::sharedState});
    }
};


template<class D>
class $OpacityEffectAction : public OpacityEffectAction, public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$OpacityEffectAction() {}
    typedef OpacityEffectAction* __thistype;

    static OpacityEffectAction* create(float p0, float p1, float p2, int p3) {
        if ((OpacityEffectAction*(*)(float, float, float, int)){&$OpacityEffectAction::create} != (OpacityEffectAction*(*)(float, float, float, int)){&D::create})
            return reinterpret_cast<OpacityEffectAction*(*)(float, float, float, int)>(m->getOriginal(getBase()+0x1789f0))(p0, p1, p2, p3);
        else return OpacityEffectAction::create(p0, p1, p2, p3);
    }

    static OpacityEffectAction* createFromString(std::string p0) {
        if ((OpacityEffectAction*(*)(std::string)){&$OpacityEffectAction::createFromString} != (OpacityEffectAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<OpacityEffectAction*(*)(std::string)>(m->getOriginal(getBase()+0x178c10))(p0);
        else return OpacityEffectAction::createFromString(p0);
    }

    bool init(float p0, float p1, float p2, int p3) {
        if ((bool($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init} != (bool(D::*)(float, float, float, int)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), float, float, float, int)>(m->getOriginal(getBase()+0x178b00))(this, p0, p1, p2, p3);
        else return OpacityEffectAction::init(p0, p1, p2, p3);
    }

    void step(float p0) {
        if ((void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step} != (void(D::*)(float)){&D::step})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x178b90))(this, p0);
        else return OpacityEffectAction::step(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((OpacityEffectAction*(*)(float, float, float, int)){&$OpacityEffectAction::create} != (OpacityEffectAction*(*)(float, float, float, int)){&D::create})
            m->registerHook(getBase()+0x1789f0, (OpacityEffectAction*(*)(float, float, float, int)){&D::create});

        if ((OpacityEffectAction*(*)(std::string)){&$OpacityEffectAction::createFromString} != (OpacityEffectAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x178c10, (OpacityEffectAction*(*)(std::string)){&D::createFromString});

        if ((bool($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init} != (bool(D::*)(float, float, float, int)){&D::init})
            m->registerHook(getBase()+0x178b00, extract((bool(D::*)(float, float, float, int)){&D::init}));

        if ((void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step} != (void(D::*)(float)){&D::step})
            m->registerHook(getBase()+0x178b90, extract((void(D::*)(float)){&D::step}));
    }
};


template<class D>
class $EditorPauseLayer : public EditorPauseLayer, public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$EditorPauseLayer() {}
    typedef EditorPauseLayer* __thistype;

    static EditorPauseLayer* create(LevelEditorLayer* p0) {
        if ((EditorPauseLayer*(*)(LevelEditorLayer*)){&$EditorPauseLayer::create} != (EditorPauseLayer*(*)(LevelEditorLayer*)){&D::create})
            return reinterpret_cast<EditorPauseLayer*(*)(LevelEditorLayer*)>(m->getOriginal(getBase()+0x13c680))(p0);
        else return EditorPauseLayer::create(p0);
    }

    void saveLevel() {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel} != (void(D::*)()){&D::saveLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
        else return EditorPauseLayer::saveLevel();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((EditorPauseLayer*(*)(LevelEditorLayer*)){&$EditorPauseLayer::create} != (EditorPauseLayer*(*)(LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x13c680, (EditorPauseLayer*(*)(LevelEditorLayer*)){&D::create});

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel} != (void(D::*)()){&D::saveLevel})
            m->registerHook(getBase()+0x13ebd0, extract((void(D::*)()){&D::saveLevel}));
    }
};


template<class D>
class $PauseLayer : public PauseLayer, public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PauseLayer() {}
    typedef PauseLayer* __thistype;

    static PauseLayer* create(bool p0) {
        if ((PauseLayer*(*)(bool)){&$PauseLayer::create} != (PauseLayer*(*)(bool)){&D::create})
            return reinterpret_cast<PauseLayer*(*)(bool)>(m->getOriginal(getBase()+0x20b1e0))(p0);
        else return PauseLayer::create(p0);
    }

    void onEdit(cocos2d::CCObject* p0) {
        if ((void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit} != (void(D::*)(cocos2d::CCObject*)){&D::onEdit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x20c630))(this, p0);
        else return PauseLayer::onEdit(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((PauseLayer*(*)(bool)){&$PauseLayer::create} != (PauseLayer*(*)(bool)){&D::create})
            m->registerHook(getBase()+0x20b1e0, (PauseLayer*(*)(bool)){&D::create});

        if ((void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit} != (void(D::*)(cocos2d::CCObject*)){&D::onEdit})
            m->registerHook(getBase()+0x20c630, extract((void(D::*)(cocos2d::CCObject*)){&D::onEdit}));
    }
};


template<class D>
class $PlatformToolbox : public PlatformToolbox, public $CacBase {
 public:
    $PlatformToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlatformToolbox() {}
    typedef PlatformToolbox* __thistype;

    void hideCursor() {
        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor} != (void(D::*)()){&D::hideCursor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c340))(this);
        else return PlatformToolbox::hideCursor();
    }

    void showCursor() {
        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor} != (void(D::*)()){&D::showCursor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c360))(this);
        else return PlatformToolbox::showCursor();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor} != (void(D::*)()){&D::hideCursor})
            m->registerHook(getBase()+0x27c340, extract((void(D::*)()){&D::hideCursor}));

        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor} != (void(D::*)()){&D::showCursor})
            m->registerHook(getBase()+0x27c360, extract((void(D::*)()){&D::showCursor}));
    }
};


template<class D>
class $PlayLayer : public PlayLayer, public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayLayer() {}
    typedef PlayLayer* __thistype;

    void addCircle(CCCircleWave* p0) {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave*)){&D::addCircle})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
        else return PlayLayer::addCircle(p0);
    }

    void addObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject} != (void(D::*)(GameObject*)){&D::addObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x70e50))(this, p0);
        else return PlayLayer::addObject(p0);
    }

    void addToGroupOld(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject*)){&D::addToGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77680))(this, p0);
        else return PlayLayer::addToGroupOld(p0);
    }

    void addToSpeedObjects(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
        else return PlayLayer::addToSpeedObjects(p0);
    }

    void animateInDualGround(GameObject* p0, float p1, bool p2) {
        if ((void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
        else return PlayLayer::animateInDualGround(p0, p1, p2);
    }

    void animateInGround(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround} != (void(D::*)(bool)){&D::animateInGround})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
        else return PlayLayer::animateInGround(p0);
    }

    void animateOutGround(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround} != (void(D::*)(bool)){&D::animateOutGround})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6f350))(this, p0);
        else return PlayLayer::animateOutGround(p0);
    }

    void animateOutGroundFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7de80))(this);
        else return PlayLayer::animateOutGroundFinished();
    }

    void applyEnterEffect(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject*)){&D::applyEnterEffect})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c310))(this, p0);
        else return PlayLayer::applyEnterEffect(p0);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    void cameraMoveX(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX} != (void(D::*)(float, float, float)){&D::cameraMoveX})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveX(p0, p1, p2);
    }

    void cameraMoveY(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY} != (void(D::*)(float, float, float)){&D::cameraMoveY})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveY(p0, p1, p2);
    }

    void checkCollisions(PlayerObject* p0, float p1) {
        if ((void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
        else return PlayLayer::checkCollisions(p0, p1);
    }

    void circleWaveWillBeRemoved(CCCircleWave* p0) {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e110))(this, p0);
        else return PlayLayer::circleWaveWillBeRemoved(p0);
    }

    void claimParticle(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle} != (void(D::*)(std::string)){&D::claimParticle})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
        else return PlayLayer::claimParticle(p0);
    }

    void clearPickedUpItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cfa0))(this);
        else return PlayLayer::clearPickedUpItems();
    }

    void colorObject(int p0, cocos2d::_ccColor3B p1) {
        if ((void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject} != (void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject})
            return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
        else return PlayLayer::colorObject(p0, p1);
    }

    void commitJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x737e0))(this);
        else return PlayLayer::commitJumps();
    }

    static PlayLayer* create(GJGameLevel* p0) {
        if ((PlayLayer*(*)(GJGameLevel*)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel*)){&D::create})
            return reinterpret_cast<PlayLayer*(*)(GJGameLevel*)>(m->getOriginal(getBase()+0x6b590))(p0);
        else return PlayLayer::create(p0);
    }

    void createCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e470))(this);
        else return PlayLayer::createCheckpoint();
    }

    void createObjectsFromSetup(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x6d130))(this, p0);
        else return PlayLayer::createObjectsFromSetup(p0);
    }

    void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle})
            return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
        else return PlayLayer::createParticle(p0, p1, p2, p3);
    }

    void currencyWillExit(CurrencyRewardLayer* p0) {
        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(getBase()+0x7e070))(this, p0);
        else return PlayLayer::currencyWillExit(p0);
    }

    void delayedResetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e050))(this);
        else return PlayLayer::delayedResetLevel();
    }

    void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
        else return PlayLayer::destroyPlayer(p0, p1);
    }

    void dialogClosed(DialogLayer* p0) {
        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
        else return PlayLayer::dialogClosed(p0);
    }

    void draw() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d160))(this);
        else return PlayLayer::draw();
    }

    void enterDualMode(GameObject* p0, bool p1) {
        if ((void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject*, bool)){&D::enterDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
        else return PlayLayer::enterDualMode(p0, p1);
    }

    void exitAirMode() {
        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7dd40))(this);
        else return PlayLayer::exitAirMode();
    }

    void exitBirdMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject*)){&D::exitBirdMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
        else return PlayLayer::exitBirdMode(p0);
    }

    void exitDartMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject*)){&D::exitDartMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
        else return PlayLayer::exitDartMode(p0);
    }

    void exitFlyMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject*)){&D::exitFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
        else return PlayLayer::exitFlyMode(p0);
    }

    void exitRobotMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject*)){&D::exitRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de20))(this, p0);
        else return PlayLayer::exitRobotMode(p0);
    }

    void exitRollMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject*)){&D::exitRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de60))(this, p0);
        else return PlayLayer::exitRollMode(p0);
    }

    void exitSpiderMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject*)){&D::exitSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de40))(this, p0);
        else return PlayLayer::exitSpiderMode(p0);
    }

    void flipFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e150))(this);
        else return PlayLayer::flipFinished();
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) override {
        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
        else return PlayLayer::flipGravity(p0, p1, p2);
    }

    void flipObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76130))(this);
        else return PlayLayer::flipObjects();
    }

    void fullReset() {
        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f8e0))(this);
        else return PlayLayer::fullReset();
    }

    void getLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f840))(this);
        else return PlayLayer::getLastCheckpoint();
    }

    void getMaxPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b4e0))(this);
        else return PlayLayer::getMaxPortalY();
    }

    void getMinPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b550))(this);
        else return PlayLayer::getMinPortalY();
    }

    void getObjectsState() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e9d0))(this);
        else return PlayLayer::getObjectsState();
    }

    void getOtherPlayer(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject*)){&D::getOtherPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
        else return PlayLayer::getOtherPlayer(p0);
    }

    void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey})
            return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
        else return PlayLayer::getParticleKey(p0, p1, p2, p3);
    }

    void getParticleKey2(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::string)){&D::getParticleKey2})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x767b0))(this, p0);
        else return PlayLayer::getParticleKey2(p0);
    }

    void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
        else return PlayLayer::getRelativeMod(p0, p1, p2, p3);
    }

    void getTempMilliTime() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x778e0))(this);
        else return PlayLayer::getTempMilliTime();
    }

    void gravityEffectFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cec0))(this);
        else return PlayLayer::gravityEffectFinished();
    }

    void hasItem(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::hasItem} != (void(D::*)(int)){&D::hasItem})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
        else return PlayLayer::hasItem(p0);
    }

    void hasUniqueCoin(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject*)){&D::hasUniqueCoin})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77510))(this, p0);
        else return PlayLayer::hasUniqueCoin(p0);
    }

    void incrementJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ff40))(this);
        else return PlayLayer::incrementJumps();
    }

    bool init(GJGameLevel* p0) {
        if ((bool($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
        else return PlayLayer::init(p0);
    }

    void isFlipping() {
        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76100))(this);
        else return PlayLayer::isFlipping();
    }

    void levelComplete() {
        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72b80))(this);
        else return PlayLayer::levelComplete();
    }

    void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return PlayLayer::lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
        else return PlayLayer::lightningFlash(p0, p1);
    }

    void loadDefaultColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ef30))(this);
        else return PlayLayer::loadDefaultColors();
    }

    void loadFromCheckpoint(CheckpointObject* p0) {
        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7f000))(this, p0);
        else return PlayLayer::loadFromCheckpoint(p0);
    }

    void loadLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7efc0))(this);
        else return PlayLayer::loadLastCheckpoint();
    }

    void loadSavedObjectsState(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::string)){&D::loadSavedObjectsState})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
        else return PlayLayer::loadSavedObjectsState(p0);
    }

    void markCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef60))(this);
        else return PlayLayer::markCheckpoint();
    }

    void moveCameraToPos(cocos2d::CCPoint p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x7c980))(this, p0);
        else return PlayLayer::moveCameraToPos(p0);
    }

    void onEnterTransitionDidFinish() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x806e0))(this);
        else return PlayLayer::onEnterTransitionDidFinish();
    }

    void onExit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80710))(this);
        else return PlayLayer::onExit();
    }

    void onQuit() {
        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72710))(this);
        else return PlayLayer::onQuit();
    }

    void optimizeColorGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dad0))(this);
        else return PlayLayer::optimizeColorGroups();
    }

    void optimizeOpacityGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dc20))(this);
        else return PlayLayer::optimizeOpacityGroups();
    }

    void optimizeSaveRequiredGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dd70))(this);
        else return PlayLayer::optimizeSaveRequiredGroups();
    }

    void pauseGame(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame} != (void(D::*)(bool)){&D::pauseGame})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x802d0))(this, p0);
        else return PlayLayer::pauseGame(p0);
    }

    void pickupItem(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject*)){&D::pickupItem})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
        else return PlayLayer::pickupItem(p0);
    }

    void playAnimationCommand(int p0, int p1) {
        if ((void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand} != (void(D::*)(int, int)){&D::playAnimationCommand})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
        else return PlayLayer::playAnimationCommand(p0, p1);
    }

    void playEndAnimationToPos(cocos2d::CCPoint p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x759a0))(this, p0);
        else return PlayLayer::playEndAnimationToPos(p0);
    }

    void playExitDualEffect(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject*)){&D::playExitDualEffect})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
        else return PlayLayer::playExitDualEffect(p0);
    }

    void playFlashEffect(float p0, int p1, float p2) {
        if ((void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect} != (void(D::*)(float, int, float)){&D::playFlashEffect})
            return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
        else return PlayLayer::playFlashEffect(p0, p1, p2);
    }

    void playGravityEffect(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect} != (void(D::*)(bool)){&D::playGravityEffect})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
        else return PlayLayer::playGravityEffect(p0);
    }

    void playSpeedParticle(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle} != (void(D::*)(float)){&D::playSpeedParticle})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77030))(this, p0);
        else return PlayLayer::playSpeedParticle(p0);
    }

    void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
        else return PlayLayer::playerWillSwitchMode(p0, p1);
    }

    void prepareSpawnObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fc00))(this);
        else return PlayLayer::prepareSpawnObjects();
    }

    void processItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x735c0))(this);
        else return PlayLayer::processItems();
    }

    void processLoadedMoveActions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a7c0))(this);
        else return PlayLayer::processLoadedMoveActions();
    }

    void recordAction(bool p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction} != (void(D::*)(bool, PlayerObject*)){&D::recordAction})
            return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
        else return PlayLayer::recordAction(p0, p1);
    }

    void registerActiveObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject*)){&D::registerActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77620))(this, p0);
        else return PlayLayer::registerActiveObject(p0);
    }

    void registerStateObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject*)){&D::registerStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777b0))(this, p0);
        else return PlayLayer::registerStateObject(p0);
    }

    void removeAllObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x727b0))(this);
        else return PlayLayer::removeAllObjects();
    }

    void removeFromGroupOld(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject*)){&D::removeFromGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77750))(this, p0);
        else return PlayLayer::removeFromGroupOld(p0);
    }

    void removeLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f870))(this);
        else return PlayLayer::removeLastCheckpoint();
    }

    void removePlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d630))(this);
        else return PlayLayer::removePlayer2();
    }

    void resetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
        else return PlayLayer::resetLevel();
    }

    void resume() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80480))(this);
        else return PlayLayer::resume();
    }

    void resumeAndRestart() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80400))(this);
        else return PlayLayer::resumeAndRestart();
    }

    void saveRecordAction(bool p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction} != (void(D::*)(bool, PlayerObject*)){&D::saveRecordAction})
            return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
        else return PlayLayer::saveRecordAction(p0, p1);
    }

    void scene(GJGameLevel* p0) {
        if ((void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b500))(this, p0);
        else return PlayLayer::scene(p0);
    }

    void setupLevelStart(LevelSettingsObject* p0) {
        if ((void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0x6f560))(this, p0);
        else return PlayLayer::setupLevelStart(p0);
    }

    void setupReplay(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay} != (void(D::*)(std::string)){&D::setupReplay})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
        else return PlayLayer::setupReplay(p0);
    }

    void shakeCamera(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera} != (void(D::*)(float, float, float)){&D::shakeCamera})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
        else return PlayLayer::shakeCamera(p0, p1, p2);
    }

    void shouldBlend(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x771b0))(this, p0);
        else return PlayLayer::shouldBlend(p0);
    }

    void showCompleteEffect() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x738e0))(this);
        else return PlayLayer::showCompleteEffect();
    }

    void showCompleteText() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73be0))(this);
        else return PlayLayer::showCompleteText();
    }

    void showEndLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74450))(this);
        else return PlayLayer::showEndLayer();
    }

    void showHint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7deb0))(this);
        else return PlayLayer::showHint();
    }

    void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        if ((void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest} != (void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest})
            return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::showNewBest(p0, p1, p2, p3, p4, p5);
    }

    void showRetryLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ba0))(this);
        else return PlayLayer::showRetryLayer();
    }

    void showTwoPlayerGuide() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6df00))(this);
        else return PlayLayer::showTwoPlayerGuide();
    }

    void sortGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d9e0))(this);
        else return PlayLayer::sortGroups();
    }

    void spawnCircle() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73820))(this);
        else return PlayLayer::spawnCircle();
    }

    void spawnFirework() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74200))(this);
        else return PlayLayer::spawnFirework();
    }

    void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        if ((void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle} != (void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle})
            return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
        else return PlayLayer::spawnParticle(p0, p1, p2, p3);
    }

    void spawnPlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d170))(this);
        else return PlayLayer::spawnPlayer2();
    }

    void startGame() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x726b0))(this);
        else return PlayLayer::startGame();
    }

    void startMusic() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72910))(this);
        else return PlayLayer::startMusic();
    }

    void startRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fec0))(this);
        else return PlayLayer::startRecording();
    }

    void startRecordingDelayed() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fed0))(this);
        else return PlayLayer::startRecordingDelayed();
    }

    void stopCameraShake() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75900))(this);
        else return PlayLayer::stopCameraShake();
    }

    void stopRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d090))(this);
        else return PlayLayer::stopRecording();
    }

    void storeCheckpoint(CheckpointObject* p0) {
        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject*)){&D::storeCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
        else return PlayLayer::storeCheckpoint(p0);
    }

    void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
        else return PlayLayer::switchToFlyMode(p0, p1, p2, p3);
    }

    void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
        else return PlayLayer::switchToRobotMode(p0, p1, p2);
    }

    void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
        else return PlayLayer::switchToRollMode(p0, p1, p2);
    }

    void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
        else return PlayLayer::switchToSpiderMode(p0, p1, p2);
    }

    void timeForXPos(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d120))(this, p0);
        else return PlayLayer::timeForXPos(p0);
    }

    void timeForXPos2(float p0, bool p1) {
        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2} != (void(D::*)(float, bool)){&D::timeForXPos2})
            return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
        else return PlayLayer::timeForXPos2(p0, p1);
    }

    void toggleBGEffectVisibility(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(bool)){&D::toggleBGEffectVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
        else return PlayLayer::toggleBGEffectVisibility(p0);
    }

    void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        if ((void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
        else return PlayLayer::toggleDualMode(p0, p1, p2, p3);
    }

    void toggleFlipped(bool p0, bool p1) {
        if ((void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped} != (void(D::*)(bool, bool)){&D::toggleFlipped})
            return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
        else return PlayLayer::toggleFlipped(p0, p1);
    }

    void toggleGhostEffect(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(int)){&D::toggleGhostEffect})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
        else return PlayLayer::toggleGhostEffect(p0);
    }

    void toggleGlitter(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter} != (void(D::*)(bool)){&D::toggleGlitter})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x70e00))(this, p0);
        else return PlayLayer::toggleGlitter(p0);
    }

    void togglePracticeMode(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode} != (void(D::*)(bool)){&D::togglePracticeMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
        else return PlayLayer::togglePracticeMode(p0);
    }

    void toggleProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6eeb0))(this);
        else return PlayLayer::toggleProgressbar();
    }

    void tryStartRecord() {
        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fe00))(this);
        else return PlayLayer::tryStartRecord();
    }

    void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        if ((void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle})
            return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
        else return PlayLayer::unclaimParticle(p0, p1);
    }

    void unregisterActiveObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject*)){&D::unregisterActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77660))(this, p0);
        else return PlayLayer::unregisterActiveObject(p0);
    }

    void unregisterStateObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject*)){&D::unregisterStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777f0))(this, p0);
        else return PlayLayer::unregisterStateObject(p0);
    }

    void update(float p0) override {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77900))(this, p0);
        else return PlayLayer::update(p0);
    }

    void updateAttempts() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcd0))(this);
        else return PlayLayer::updateAttempts();
    }

    void updateCamera(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateCamera} != (void(D::*)(float)){&D::updateCamera})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
        else return PlayLayer::updateCamera(p0);
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) override {
        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return PlayLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
        else return PlayLayer::updateDualGround(p0, p1, p2);
    }

    void updateEffectPositions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a6d0))(this);
        else return PlayLayer::updateEffectPositions();
    }

    void updateLevelColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6f1e0))(this);
        else return PlayLayer::updateLevelColors();
    }

    void updateMoveObjectsLastPosition() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a720))(this);
        else return PlayLayer::updateMoveObjectsLastPosition();
    }

    void updateProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ed70))(this);
        else return PlayLayer::updateProgressbar();
    }

    void updateReplay(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateReplay} != (void(D::*)(float)){&D::updateReplay})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x78b60))(this, p0);
        else return PlayLayer::updateReplay(p0);
    }

    void updateTimeMod(float p0, bool p1) {
        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod} != (void(D::*)(float, bool)){&D::updateTimeMod})
            return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
        else return PlayLayer::updateTimeMod(p0, p1);
    }

    void updateTweenAction(float p0, char const* p1) override {
        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
        else return PlayLayer::updateTweenAction(p0, p1);
    }

    void updateVisibility() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6fb90))(this);
        else return PlayLayer::updateVisibility();
    }

    void vfDChk() {
        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcb0))(this);
        else return PlayLayer::vfDChk();
    }

    void visit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ef0))(this);
        else return PlayLayer::visit();
    }

    void visitWithColorFlash() {
        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x761f0))(this);
        else return PlayLayer::visitWithColorFlash();
    }

    void willSwitchToMode(int p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode} != (void(D::*)(int, PlayerObject*)){&D::willSwitchToMode})
            return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
        else return PlayLayer::willSwitchToMode(p0, p1);
    }

    void xPosForTime(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d140))(this, p0);
        else return PlayLayer::xPosForTime(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave*)){&D::addCircle})
            m->registerHook(getBase()+0x7e0f0, extract((void(D::*)(CCCircleWave*)){&D::addCircle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject} != (void(D::*)(GameObject*)){&D::addObject})
            m->registerHook(getBase()+0x70e50, extract((void(D::*)(GameObject*)){&D::addObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject*)){&D::addToGroupOld})
            m->registerHook(getBase()+0x77680, extract((void(D::*)(GameObject*)){&D::addToGroupOld}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x7cfc0, extract((void(D::*)(GameObject*)){&D::addToSpeedObjects}));

        if ((void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(getBase()+0x7d710, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround} != (void(D::*)(bool)){&D::animateInGround})
            m->registerHook(getBase()+0x7d9d0, extract((void(D::*)(bool)){&D::animateInGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround} != (void(D::*)(bool)){&D::animateOutGround})
            m->registerHook(getBase()+0x6f350, extract((void(D::*)(bool)){&D::animateOutGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            m->registerHook(getBase()+0x7de80, extract((void(D::*)()){&D::animateOutGroundFinished}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject*)){&D::applyEnterEffect})
            m->registerHook(getBase()+0x7c310, extract((void(D::*)(GameObject*)){&D::applyEnterEffect}));

        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0x7aa10, extract_virtual(this, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX} != (void(D::*)(float, float, float)){&D::cameraMoveX})
            m->registerHook(getBase()+0x7cbe0, extract((void(D::*)(float, float, float)){&D::cameraMoveX}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY} != (void(D::*)(float, float, float)){&D::cameraMoveY})
            m->registerHook(getBase()+0x7cc60, extract((void(D::*)(float, float, float)){&D::cameraMoveY}));

        if ((void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(getBase()+0x78c90, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            m->registerHook(getBase()+0x7e110, extract((void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle} != (void(D::*)(std::string)){&D::claimParticle})
            m->registerHook(getBase()+0x76ba0, extract((void(D::*)(std::string)){&D::claimParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            m->registerHook(getBase()+0x7cfa0, extract((void(D::*)()){&D::clearPickedUpItems}));

        if ((void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject} != (void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject})
            m->registerHook(getBase()+0x77810, extract((void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            m->registerHook(getBase()+0x737e0, extract((void(D::*)()){&D::commitJumps}));

        if ((PlayLayer*(*)(GJGameLevel*)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(getBase()+0x6b590, (PlayLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            m->registerHook(getBase()+0x7e470, extract((void(D::*)()){&D::createCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x6d130, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle})
            m->registerHook(getBase()+0x76800, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle}));

        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(getBase()+0x7e070, extract((void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            m->registerHook(getBase()+0x7e050, extract((void(D::*)()){&D::delayedResetLevel}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer})
            m->registerHook(getBase()+0x7ab80, extract((void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer}));

        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(getBase()+0x7e0b0, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x7d160, extract_virtual(this, (void(D::*)()){&D::draw}));

        if ((void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject*, bool)){&D::enterDualMode})
            m->registerHook(getBase()+0x7d6a0, extract((void(D::*)(GameObject*, bool)){&D::enterDualMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            m->registerHook(getBase()+0x7dd40, extract((void(D::*)()){&D::exitAirMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject*)){&D::exitBirdMode})
            m->registerHook(getBase()+0x7dd80, extract((void(D::*)(PlayerObject*)){&D::exitBirdMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject*)){&D::exitDartMode})
            m->registerHook(getBase()+0x7ddd0, extract((void(D::*)(PlayerObject*)){&D::exitDartMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject*)){&D::exitFlyMode})
            m->registerHook(getBase()+0x7dcf0, extract((void(D::*)(PlayerObject*)){&D::exitFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject*)){&D::exitRobotMode})
            m->registerHook(getBase()+0x7de20, extract((void(D::*)(PlayerObject*)){&D::exitRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject*)){&D::exitRollMode})
            m->registerHook(getBase()+0x7de60, extract((void(D::*)(PlayerObject*)){&D::exitRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject*)){&D::exitSpiderMode})
            m->registerHook(getBase()+0x7de40, extract((void(D::*)(PlayerObject*)){&D::exitSpiderMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            m->registerHook(getBase()+0x7e150, extract((void(D::*)()){&D::flipFinished}));

        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0x7cd10, extract_virtual(this, (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            m->registerHook(getBase()+0x76130, extract((void(D::*)()){&D::flipObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            m->registerHook(getBase()+0x7f8e0, extract((void(D::*)()){&D::fullReset}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            m->registerHook(getBase()+0x7f840, extract((void(D::*)()){&D::getLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            m->registerHook(getBase()+0x7b4e0, extract((void(D::*)()){&D::getMaxPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            m->registerHook(getBase()+0x7b550, extract((void(D::*)()){&D::getMinPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            m->registerHook(getBase()+0x7e9d0, extract((void(D::*)()){&D::getObjectsState}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject*)){&D::getOtherPlayer})
            m->registerHook(getBase()+0x7dcc0, extract((void(D::*)(PlayerObject*)){&D::getOtherPlayer}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey})
            m->registerHook(getBase()+0x764d0, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::string)){&D::getParticleKey2})
            m->registerHook(getBase()+0x767b0, extract((void(D::*)(std::string)){&D::getParticleKey2}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod})
            m->registerHook(getBase()+0x7c2a0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            m->registerHook(getBase()+0x778e0, extract((void(D::*)()){&D::getTempMilliTime}));

        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            m->registerHook(getBase()+0x7cec0, extract((void(D::*)()){&D::gravityEffectFinished}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::hasItem} != (void(D::*)(int)){&D::hasItem})
            m->registerHook(getBase()+0x7cee0, extract((void(D::*)(int)){&D::hasItem}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject*)){&D::hasUniqueCoin})
            m->registerHook(getBase()+0x77510, extract((void(D::*)(GameObject*)){&D::hasUniqueCoin}));

        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x7ff40, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(getBase()+0x6b5f0, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            m->registerHook(getBase()+0x76100, extract((void(D::*)()){&D::isFlipping}));

        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            m->registerHook(getBase()+0x72b80, extract((void(D::*)()){&D::levelComplete}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash})
            m->registerHook(getBase()+0x75cc0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash})
            m->registerHook(getBase()+0x75bf0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            m->registerHook(getBase()+0x6ef30, extract((void(D::*)()){&D::loadDefaultColors}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x7f000, extract((void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            m->registerHook(getBase()+0x7efc0, extract((void(D::*)()){&D::loadLastCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::string)){&D::loadSavedObjectsState})
            m->registerHook(getBase()+0x7f3d0, extract((void(D::*)(std::string)){&D::loadSavedObjectsState}));

        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            m->registerHook(getBase()+0x7ef60, extract((void(D::*)()){&D::markCheckpoint}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos})
            m->registerHook(getBase()+0x7c980, extract((void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(getBase()+0x806e0, extract_virtual(this, (void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(getBase()+0x80710, extract_virtual(this, (void(D::*)()){&D::onExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            m->registerHook(getBase()+0x72710, extract((void(D::*)()){&D::onQuit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            m->registerHook(getBase()+0x6dad0, extract((void(D::*)()){&D::optimizeColorGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            m->registerHook(getBase()+0x6dc20, extract((void(D::*)()){&D::optimizeOpacityGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            m->registerHook(getBase()+0x6dd70, extract((void(D::*)()){&D::optimizeSaveRequiredGroups}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame} != (void(D::*)(bool)){&D::pauseGame})
            m->registerHook(getBase()+0x802d0, extract((void(D::*)(bool)){&D::pauseGame}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject*)){&D::pickupItem})
            m->registerHook(getBase()+0x7c1d0, extract((void(D::*)(GameObject*)){&D::pickupItem}));

        if ((void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand} != (void(D::*)(int, int)){&D::playAnimationCommand})
            m->registerHook(getBase()+0x75930, extract((void(D::*)(int, int)){&D::playAnimationCommand}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos})
            m->registerHook(getBase()+0x759a0, extract((void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject*)){&D::playExitDualEffect})
            m->registerHook(getBase()+0x7d1d0, extract((void(D::*)(PlayerObject*)){&D::playExitDualEffect}));

        if ((void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect} != (void(D::*)(float, int, float)){&D::playFlashEffect})
            m->registerHook(getBase()+0x75e50, extract((void(D::*)(float, int, float)){&D::playFlashEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect} != (void(D::*)(bool)){&D::playGravityEffect})
            m->registerHook(getBase()+0x7b5a0, extract((void(D::*)(bool)){&D::playGravityEffect}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle} != (void(D::*)(float)){&D::playSpeedParticle})
            m->registerHook(getBase()+0x77030, extract((void(D::*)(float)){&D::playSpeedParticle}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode})
            m->registerHook(getBase()+0x7b820, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            m->registerHook(getBase()+0x7fc00, extract((void(D::*)()){&D::prepareSpawnObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            m->registerHook(getBase()+0x735c0, extract((void(D::*)()){&D::processItems}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            m->registerHook(getBase()+0x7a7c0, extract((void(D::*)()){&D::processLoadedMoveActions}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction} != (void(D::*)(bool, PlayerObject*)){&D::recordAction})
            m->registerHook(getBase()+0x7e190, extract((void(D::*)(bool, PlayerObject*)){&D::recordAction}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject*)){&D::registerActiveObject})
            m->registerHook(getBase()+0x77620, extract((void(D::*)(GameObject*)){&D::registerActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject*)){&D::registerStateObject})
            m->registerHook(getBase()+0x777b0, extract((void(D::*)(GameObject*)){&D::registerStateObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x727b0, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject*)){&D::removeFromGroupOld})
            m->registerHook(getBase()+0x77750, extract((void(D::*)(GameObject*)){&D::removeFromGroupOld}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            m->registerHook(getBase()+0x7f870, extract((void(D::*)()){&D::removeLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            m->registerHook(getBase()+0x7d630, extract((void(D::*)()){&D::removePlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            m->registerHook(getBase()+0x71c50, extract((void(D::*)()){&D::resetLevel}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            m->registerHook(getBase()+0x80480, extract((void(D::*)()){&D::resume}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            m->registerHook(getBase()+0x80400, extract((void(D::*)()){&D::resumeAndRestart}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction} != (void(D::*)(bool, PlayerObject*)){&D::saveRecordAction})
            m->registerHook(getBase()+0x78750, extract((void(D::*)(bool, PlayerObject*)){&D::saveRecordAction}));

        if ((void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(getBase()+0x6b500, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(getBase()+0x6f560, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay} != (void(D::*)(std::string)){&D::setupReplay})
            m->registerHook(getBase()+0x7e1e0, extract((void(D::*)(std::string)){&D::setupReplay}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera} != (void(D::*)(float, float, float)){&D::shakeCamera})
            m->registerHook(getBase()+0x744a0, extract((void(D::*)(float, float, float)){&D::shakeCamera}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            m->registerHook(getBase()+0x771b0, extract((void(D::*)(int)){&D::shouldBlend}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            m->registerHook(getBase()+0x738e0, extract((void(D::*)()){&D::showCompleteEffect}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            m->registerHook(getBase()+0x73be0, extract((void(D::*)()){&D::showCompleteText}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            m->registerHook(getBase()+0x74450, extract((void(D::*)()){&D::showEndLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            m->registerHook(getBase()+0x7deb0, extract((void(D::*)()){&D::showHint}));

        if ((void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest} != (void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest})
            m->registerHook(getBase()+0x74580, extract((void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            m->registerHook(getBase()+0x75ba0, extract((void(D::*)()){&D::showRetryLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            m->registerHook(getBase()+0x6df00, extract((void(D::*)()){&D::showTwoPlayerGuide}));

        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            m->registerHook(getBase()+0x6d9e0, extract((void(D::*)()){&D::sortGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x73820, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            m->registerHook(getBase()+0x74200, extract((void(D::*)()){&D::spawnFirework}));

        if ((void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle} != (void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle})
            m->registerHook(getBase()+0x76330, extract((void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            m->registerHook(getBase()+0x7d170, extract((void(D::*)()){&D::spawnPlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            m->registerHook(getBase()+0x726b0, extract((void(D::*)()){&D::startGame}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            m->registerHook(getBase()+0x72910, extract((void(D::*)()){&D::startMusic}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            m->registerHook(getBase()+0x7fec0, extract((void(D::*)()){&D::startRecording}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            m->registerHook(getBase()+0x7fed0, extract((void(D::*)()){&D::startRecordingDelayed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            m->registerHook(getBase()+0x75900, extract((void(D::*)()){&D::stopCameraShake}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            m->registerHook(getBase()+0x6d090, extract((void(D::*)()){&D::stopRecording}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject*)){&D::storeCheckpoint})
            m->registerHook(getBase()+0x7ef10, extract((void(D::*)(CheckpointObject*)){&D::storeCheckpoint}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode})
            m->registerHook(getBase()+0x7baf0, extract((void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode})
            m->registerHook(getBase()+0x7bc80, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode})
            m->registerHook(getBase()+0x7bbe0, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode})
            m->registerHook(getBase()+0x7bd20, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x7d120, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2} != (void(D::*)(float, bool)){&D::timeForXPos2})
            m->registerHook(getBase()+0x293eb0, extract((void(D::*)(float, bool)){&D::timeForXPos2}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(bool)){&D::toggleBGEffectVisibility})
            m->registerHook(getBase()+0x7fe80, extract((void(D::*)(bool)){&D::toggleBGEffectVisibility}));

        if ((void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(getBase()+0x7bf90, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped} != (void(D::*)(bool, bool)){&D::toggleFlipped})
            m->registerHook(getBase()+0x7bdc0, extract((void(D::*)(bool, bool)){&D::toggleFlipped}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(int)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x7fe40, extract((void(D::*)(int)){&D::toggleGhostEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter} != (void(D::*)(bool)){&D::toggleGlitter})
            m->registerHook(getBase()+0x70e00, extract((void(D::*)(bool)){&D::toggleGlitter}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode} != (void(D::*)(bool)){&D::togglePracticeMode})
            m->registerHook(getBase()+0x7f9e0, extract((void(D::*)(bool)){&D::togglePracticeMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            m->registerHook(getBase()+0x6eeb0, extract((void(D::*)()){&D::toggleProgressbar}));

        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            m->registerHook(getBase()+0x7fe00, extract((void(D::*)()){&D::tryStartRecord}));

        if ((void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle})
            m->registerHook(getBase()+0x76e00, extract((void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject*)){&D::unregisterActiveObject})
            m->registerHook(getBase()+0x77660, extract((void(D::*)(GameObject*)){&D::unregisterActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject*)){&D::unregisterStateObject})
            m->registerHook(getBase()+0x777f0, extract((void(D::*)(GameObject*)){&D::unregisterStateObject}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x77900, extract_virtual(this, (void(D::*)(float)){&D::update}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            m->registerHook(getBase()+0x7fcd0, extract((void(D::*)()){&D::updateAttempts}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateCamera} != (void(D::*)(float)){&D::updateCamera})
            m->registerHook(getBase()+0x6e2b0, extract((void(D::*)(float)){&D::updateCamera}));

        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0x7c7f0, extract_virtual(this, (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(getBase()+0x7caa0, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            m->registerHook(getBase()+0x7a6d0, extract((void(D::*)()){&D::updateEffectPositions}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            m->registerHook(getBase()+0x6f1e0, extract((void(D::*)()){&D::updateLevelColors}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            m->registerHook(getBase()+0x7a720, extract((void(D::*)()){&D::updateMoveObjectsLastPosition}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            m->registerHook(getBase()+0x6ed70, extract((void(D::*)()){&D::updateProgressbar}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateReplay} != (void(D::*)(float)){&D::updateReplay})
            m->registerHook(getBase()+0x78b60, extract((void(D::*)(float)){&D::updateReplay}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod} != (void(D::*)(float, bool)){&D::updateTimeMod})
            m->registerHook(getBase()+0x786f0, extract((void(D::*)(float, bool)){&D::updateTimeMod}));

        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(getBase()+0x7ffb0, extract_virtual(this, (void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            m->registerHook(getBase()+0x6fb90, extract((void(D::*)()){&D::updateVisibility}));

        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            m->registerHook(getBase()+0x7fcb0, extract((void(D::*)()){&D::vfDChk}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0x75ef0, extract_virtual(this, (void(D::*)()){&D::visit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            m->registerHook(getBase()+0x761f0, extract((void(D::*)()){&D::visitWithColorFlash}));

        if ((void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode} != (void(D::*)(int, PlayerObject*)){&D::willSwitchToMode})
            m->registerHook(getBase()+0x7b9e0, extract((void(D::*)(int, PlayerObject*)){&D::willSwitchToMode}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x7d140, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $PlayerCheckpoint : public PlayerCheckpoint, public $CacBase {
 public:
    $PlayerCheckpoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayerCheckpoint() {}
    typedef PlayerCheckpoint* __thistype;

    static PlayerCheckpoint* create() {
        if ((PlayerCheckpoint*(*)()){&$PlayerCheckpoint::create} != (PlayerCheckpoint*(*)()){&D::create})
            return reinterpret_cast<PlayerCheckpoint*(*)()>(m->getOriginal(getBase()+0x7e8c0))();
        else return PlayerCheckpoint::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((PlayerCheckpoint*(*)()){&$PlayerCheckpoint::create} != (PlayerCheckpoint*(*)()){&D::create})
            m->registerHook(getBase()+0x7e8c0, (PlayerCheckpoint*(*)()){&D::create});
    }
};


template<class D>
class $PlayerObject : public PlayerObject, public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PlayerObject() {}
    typedef PlayerObject* __thistype;

    void activateStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::activateStreak} != (void(D::*)()){&D::activateStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21aef0))(this);
        else return PlayerObject::activateStreak();
    }

    void addAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::addAllParticles} != (void(D::*)()){&D::addAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
        else return PlayerObject::addAllParticles();
    }

    void addToTouchedRings(GameObject* p0) {
        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings} != (void(D::*)(GameObject*)){&D::addToTouchedRings})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22b800))(this, p0);
        else return PlayerObject::addToTouchedRings(p0);
    }

    void animationFinished(char const* p0) override {
        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
        else return PlayerObject::animationFinished(p0);
    }

    void boostPlayer(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer} != (void(D::*)(float)){&D::boostPlayer})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
        else return PlayerObject::boostPlayer(p0);
    }

    void bumpPlayer(float p0, int p1) {
        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer} != (void(D::*)(float, int)){&D::bumpPlayer})
            return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
        else return PlayerObject::bumpPlayer(p0, p1);
    }

    void buttonDown(PlayerButton p0) {
        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown} != (void(D::*)(PlayerButton)){&D::buttonDown})
            return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
        else return PlayerObject::buttonDown(p0);
    }

    void checkSnapJumpToObject(GameObject* p0) {
        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject} != (void(D::*)(GameObject*)){&D::checkSnapJumpToObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
        else return PlayerObject::checkSnapJumpToObject(p0);
    }

    void collidedWithObject(float p0, GameObject* p1) {
        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*)){&D::collidedWithObject})
            return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
        else return PlayerObject::collidedWithObject(p0, p1);
    }

    void collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2) {
        if ((void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*, cocos2d::CCRect)){&D::collidedWithObject})
            return reinterpret_cast<void(*)(decltype(this), float, GameObject*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
        else return PlayerObject::collidedWithObject(p0, p1, p2);
    }

    void collidedWithSlope(float p0, GameObject* p1, bool p2) {
        if ((void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope} != (void(D::*)(float, GameObject*, bool)){&D::collidedWithSlope})
            return reinterpret_cast<void(*)(decltype(this), float, GameObject*, bool)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
        else return PlayerObject::collidedWithSlope(p0, p1, p2);
    }

    void convertToClosestRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation} != (void(D::*)(float)){&D::convertToClosestRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21c860))(this, p0);
        else return PlayerObject::convertToClosestRotation(p0);
    }

    void copyAttributes(PlayerObject* p0) {
        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes} != (void(D::*)(PlayerObject*)){&D::copyAttributes})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
        else return PlayerObject::copyAttributes(p0);
    }

    static PlayerObject* create(int p0, int p1, cocos2d::CCLayer* p2) {
        if ((PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create} != (PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&D::create})
            return reinterpret_cast<PlayerObject*(*)(int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x217260))(p0, p1, p2);
        else return PlayerObject::create(p0, p1, p2);
    }

    void deactivateParticle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::deactivateParticle} != (void(D::*)()){&D::deactivateParticle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a540))(this);
        else return PlayerObject::deactivateParticle();
    }

    void deactivateStreak(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak} != (void(D::*)(bool)){&D::deactivateStreak})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218b30))(this, p0);
        else return PlayerObject::deactivateStreak(p0);
    }

    void fadeOutStreak2(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2} != (void(D::*)(float)){&D::fadeOutStreak2})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x225890))(this, p0);
        else return PlayerObject::fadeOutStreak2(p0);
    }

    void flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) {
        if ((void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer} != (void(D::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::flashPlayer})
            return reinterpret_cast<void(*)(decltype(this), float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
        else return PlayerObject::flashPlayer(p0, p1, p2, p3);
    }

    void flipGravity(bool p0, bool p1) {
        if ((void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity} != (void(D::*)(bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
        else return PlayerObject::flipGravity(p0, p1);
    }

    void flipMod() {
        if ((void($PlayerObject::*)()){&$PlayerObject::flipMod} != (void(D::*)()){&D::flipMod})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4c0))(this);
        else return PlayerObject::flipMod();
    }

    void getActiveMode() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getActiveMode} != (void(D::*)()){&D::getActiveMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b950))(this);
        else return PlayerObject::getActiveMode();
    }

    void getModifiedSlopeYVel() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel} != (void(D::*)()){&D::getModifiedSlopeYVel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21bff0))(this);
        else return PlayerObject::getModifiedSlopeYVel();
    }

    void getOldPosition(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition} != (void(D::*)(float)){&D::getOldPosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a830))(this, p0);
        else return PlayerObject::getOldPosition(p0);
    }

    void getOrientedBox() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dee0))(this);
        else return PlayerObject::getOrientedBox();
    }

    void getRealPosition() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d5f0))(this);
        else return PlayerObject::getRealPosition();
    }

    void getSecondColor() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getSecondColor} != (void(D::*)()){&D::getSecondColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cee0))(this);
        else return PlayerObject::getSecondColor();
    }

    void gravityDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::gravityDown} != (void(D::*)()){&D::gravityDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e930))(this);
        else return PlayerObject::gravityDown();
    }

    void gravityUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::gravityUp} != (void(D::*)()){&D::gravityUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e900))(this);
        else return PlayerObject::gravityUp();
    }

    void hardFlipGravity() {
        if ((void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity} != (void(D::*)()){&D::hardFlipGravity})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b860))(this);
        else return PlayerObject::hardFlipGravity();
    }

    void hitGround(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::hitGround} != (void(D::*)(bool)){&D::hitGround})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x220a30))(this, p0);
        else return PlayerObject::hitGround(p0);
    }

    void incrementJumps() {
        if ((void($PlayerObject::*)()){&$PlayerObject::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c050))(this);
        else return PlayerObject::incrementJumps();
    }

    bool init(int p0, int p1, cocos2d::CCLayer* p2) {
        if ((bool($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init} != (bool(D::*)(int, int, cocos2d::CCLayer*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
        else return PlayerObject::init(p0, p1, p2);
    }

    void isBoostValid(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid} != (void(D::*)(float)){&D::isBoostValid})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d650))(this, p0);
        else return PlayerObject::isBoostValid(p0);
    }

    void isFlying() {
        if ((void($PlayerObject::*)()){&$PlayerObject::isFlying} != (void(D::*)()){&D::isFlying})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4e0))(this);
        else return PlayerObject::isFlying();
    }

    void isSafeFlip(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip} != (void(D::*)(float)){&D::isSafeFlip})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
        else return PlayerObject::isSafeFlip(p0);
    }

    void isSafeMode(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode} != (void(D::*)(float)){&D::isSafeMode})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
        else return PlayerObject::isSafeMode(p0);
    }

    void isSafeSpiderFlip(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip} != (void(D::*)(float)){&D::isSafeSpiderFlip})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221be0))(this, p0);
        else return PlayerObject::isSafeSpiderFlip(p0);
    }

    void levelFlipFinished() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished} != (void(D::*)()){&D::levelFlipFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b060))(this);
        else return PlayerObject::levelFlipFinished();
    }

    void levelFlipping() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipping} != (void(D::*)()){&D::levelFlipping})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a510))(this);
        else return PlayerObject::levelFlipping();
    }

    void levelWillFlip() {
        if ((void($PlayerObject::*)()){&$PlayerObject::levelWillFlip} != (void(D::*)()){&D::levelWillFlip})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b020))(this);
        else return PlayerObject::levelWillFlip();
    }

    void loadFromCheckpoint(PlayerCheckpoint* p0) {
        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::loadFromCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e420))(this, p0);
        else return PlayerObject::loadFromCheckpoint(p0);
    }

    void lockPlayer() {
        if ((void($PlayerObject::*)()){&$PlayerObject::lockPlayer} != (void(D::*)()){&D::lockPlayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d680))(this);
        else return PlayerObject::lockPlayer();
    }

    void logValues() {
        if ((void($PlayerObject::*)()){&$PlayerObject::logValues} != (void(D::*)()){&D::logValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x221220))(this);
        else return PlayerObject::logValues();
    }

    void modeDidChange() {
        if ((void($PlayerObject::*)()){&$PlayerObject::modeDidChange} != (void(D::*)()){&D::modeDidChange})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bfd0))(this);
        else return PlayerObject::modeDidChange();
    }

    void placeStreakPoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint} != (void(D::*)()){&D::placeStreakPoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21af90))(this);
        else return PlayerObject::placeStreakPoint();
    }

    void playBurstEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playBurstEffect} != (void(D::*)()){&D::playBurstEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c780))(this);
        else return PlayerObject::playBurstEffect();
    }

    void playDeathEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playDeathEffect} != (void(D::*)()){&D::playDeathEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225930))(this);
        else return PlayerObject::playDeathEffect();
    }

    void playDynamicSpiderRun() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun} != (void(D::*)()){&D::playDynamicSpiderRun})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222ec0))(this);
        else return PlayerObject::playDynamicSpiderRun();
    }

    void playerDestroyed(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed} != (void(D::*)(bool)){&D::playerDestroyed})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
        else return PlayerObject::playerDestroyed(p0);
    }

    void playerIsFalling() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playerIsFalling} != (void(D::*)()){&D::playerIsFalling})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c730))(this);
        else return PlayerObject::playerIsFalling();
    }

    void playerTeleported() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playerTeleported} != (void(D::*)()){&D::playerTeleported})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b840))(this);
        else return PlayerObject::playerTeleported();
    }

    void playingEndEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::playingEndEffect} != (void(D::*)()){&D::playingEndEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d7e0))(this);
        else return PlayerObject::playingEndEffect();
    }

    void postCollision(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::postCollision} != (void(D::*)(float)){&D::postCollision})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
        else return PlayerObject::postCollision(p0);
    }

    void preCollision() {
        if ((void($PlayerObject::*)()){&$PlayerObject::preCollision} != (void(D::*)()){&D::preCollision})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ccc0))(this);
        else return PlayerObject::preCollision();
    }

    void preSlopeCollision(float p0, GameObject* p1) {
        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision} != (void(D::*)(float, GameObject*)){&D::preSlopeCollision})
            return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
        else return PlayerObject::preSlopeCollision(p0, p1);
    }

    void propellPlayer(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer} != (void(D::*)(float)){&D::propellPlayer})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
        else return PlayerObject::propellPlayer(p0);
    }

    void pushButton(PlayerButton p0) {
        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton} != (void(D::*)(PlayerButton)){&D::pushButton})
            return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
        else return PlayerObject::pushButton(p0);
    }

    void pushDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::pushDown} != (void(D::*)()){&D::pushDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbd0))(this);
        else return PlayerObject::pushDown();
    }

    void pushPlayer(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer} != (void(D::*)(float)){&D::pushPlayer})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
        else return PlayerObject::pushPlayer(p0);
    }

    void releaseButton(PlayerButton p0) {
        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton} != (void(D::*)(PlayerButton)){&D::releaseButton})
            return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
        else return PlayerObject::releaseButton(p0);
    }

    void removeAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::removeAllParticles} != (void(D::*)()){&D::removeAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218ac0))(this);
        else return PlayerObject::removeAllParticles();
    }

    void removePendingCheckpoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint} != (void(D::*)()){&D::removePendingCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2237b0))(this);
        else return PlayerObject::removePendingCheckpoint();
    }

    void resetAllParticles() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetAllParticles} != (void(D::*)()){&D::resetAllParticles})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21adb0))(this);
        else return PlayerObject::resetAllParticles();
    }

    void resetCollisionLog() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog} != (void(D::*)()){&D::resetCollisionLog})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cc20))(this);
        else return PlayerObject::resetCollisionLog();
    }

    void resetObject() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223170))(this);
        else return PlayerObject::resetObject();
    }

    void resetPlayerIcon() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon} != (void(D::*)()){&D::resetPlayerIcon})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22be00))(this);
        else return PlayerObject::resetPlayerIcon();
    }

    void resetStateVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetStateVariables} != (void(D::*)()){&D::resetStateVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223760))(this);
        else return PlayerObject::resetStateVariables();
    }

    void resetStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetStreak} != (void(D::*)()){&D::resetStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ae10))(this);
        else return PlayerObject::resetStreak();
    }

    void ringJump(GameObject* p0) {
        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump} != (void(D::*)(GameObject*)){&D::ringJump})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
        else return PlayerObject::ringJump(p0);
    }

    void runBallRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation} != (void(D::*)(float)){&D::runBallRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
        else return PlayerObject::runBallRotation(p0);
    }

    void runBallRotation2() {
        if ((void($PlayerObject::*)()){&$PlayerObject::runBallRotation2} != (void(D::*)()){&D::runBallRotation2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cb10))(this);
        else return PlayerObject::runBallRotation2();
    }

    void runNormalRotation() {
        if ((void($PlayerObject::*)()){&$PlayerObject::runNormalRotation} != (void(D::*)()){&D::runNormalRotation})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c960))(this);
        else return PlayerObject::runNormalRotation();
    }

    void runRotateAction(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction} != (void(D::*)(bool)){&D::runRotateAction})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c570))(this, p0);
        else return PlayerObject::runRotateAction(p0);
    }

    void saveToCheckpoint(PlayerCheckpoint* p0) {
        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::saveToCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
        else return PlayerObject::saveToCheckpoint(p0);
    }

    void setColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
        else return PlayerObject::setColor(p0);
    }

    void setFlipX(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e720))(this, p0);
        else return PlayerObject::setFlipX(p0);
    }

    void setFlipY(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
        else return PlayerObject::setFlipY(p0);
    }

    void setOpacity(unsigned char p0) override {
        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x22d400))(this, p0);
        else return PlayerObject::setOpacity(p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
        else return PlayerObject::setPosition(p0);
    }

    void setRotation(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
        else return PlayerObject::setRotation(p0);
    }

    void setScale(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e870))(this, p0);
        else return PlayerObject::setScale(p0);
    }

    void setScaleX(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
        else return PlayerObject::setScaleX(p0);
    }

    void setScaleY(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e830))(this, p0);
        else return PlayerObject::setScaleY(p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const& p0) {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x219610))(this, p0);
        else return PlayerObject::setSecondColor(p0);
    }

    void setVisible(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
        else return PlayerObject::setVisible(p0);
    }

    void setupStreak() {
        if ((void($PlayerObject::*)()){&$PlayerObject::setupStreak} != (void(D::*)()){&D::setupStreak})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218720))(this);
        else return PlayerObject::setupStreak();
    }

    void spawnCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225480))(this);
        else return PlayerObject::spawnCircle();
    }

    void spawnCircle2() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle2} != (void(D::*)()){&D::spawnCircle2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2252a0))(this);
        else return PlayerObject::spawnCircle2();
    }

    void spawnDualCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle} != (void(D::*)()){&D::spawnDualCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2255c0))(this);
        else return PlayerObject::spawnDualCircle();
    }

    void spawnFromPlayer(PlayerObject* p0) {
        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer} != (void(D::*)(PlayerObject*)){&D::spawnFromPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
        else return PlayerObject::spawnFromPlayer(p0);
    }

    void spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle} != (void(D::*)(cocos2d::_ccColor3B, float)){&D::spawnPortalCircle})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
        else return PlayerObject::spawnPortalCircle(p0, p1);
    }

    void spawnScaleCircle() {
        if ((void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle} != (void(D::*)()){&D::spawnScaleCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2251b0))(this);
        else return PlayerObject::spawnScaleCircle();
    }

    void specialGroundHit() {
        if ((void($PlayerObject::*)()){&$PlayerObject::specialGroundHit} != (void(D::*)()){&D::specialGroundHit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbf0))(this);
        else return PlayerObject::specialGroundHit();
    }

    void speedDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::speedDown} != (void(D::*)()){&D::speedDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e970))(this);
        else return PlayerObject::speedDown();
    }

    void speedUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::speedUp} != (void(D::*)()){&D::speedUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e950))(this);
        else return PlayerObject::speedUp();
    }

    void spiderTestJump(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump} != (void(D::*)(bool)){&D::spiderTestJump})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21b160))(this, p0);
        else return PlayerObject::spiderTestJump(p0);
    }

    void startDashing(GameObject* p0) {
        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing} != (void(D::*)(GameObject*)){&D::startDashing})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x221d70))(this, p0);
        else return PlayerObject::startDashing(p0);
    }

    void stopBurstEffect() {
        if ((void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect} != (void(D::*)()){&D::stopBurstEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22c680))(this);
        else return PlayerObject::stopBurstEffect();
    }

    void stopDashing() {
        if ((void($PlayerObject::*)()){&$PlayerObject::stopDashing} != (void(D::*)()){&D::stopDashing})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222990))(this);
        else return PlayerObject::stopDashing();
    }

    void stopRotation(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation} != (void(D::*)(bool)){&D::stopRotation})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c830))(this, p0);
        else return PlayerObject::stopRotation(p0);
    }

    void storeCollision(bool p0, int p1) {
        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision} != (void(D::*)(bool, int)){&D::storeCollision})
            return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
        else return PlayerObject::storeCollision(p0, p1);
    }

    void switchedToMode(GameObjectType p0) {
        if ((void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode} != (void(D::*)(GameObjectType)){&D::switchedToMode})
            return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
        else return PlayerObject::switchedToMode(p0);
    }

    void testForMoving(float p0, GameObject* p1) {
        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving} != (void(D::*)(float, GameObject*)){&D::testForMoving})
            return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
        else return PlayerObject::testForMoving(p0, p1);
    }

    void toggleBirdMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode} != (void(D::*)(bool)){&D::toggleBirdMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224070))(this, p0);
        else return PlayerObject::toggleBirdMode(p0);
    }

    void toggleDartMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode} != (void(D::*)(bool)){&D::toggleDartMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
        else return PlayerObject::toggleDartMode(p0);
    }

    void toggleFlyMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode} != (void(D::*)(bool)){&D::toggleFlyMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223820))(this, p0);
        else return PlayerObject::toggleFlyMode(p0);
    }

    void toggleGhostEffect(GhostType p0) {
        if ((void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect} != (void(D::*)(GhostType)){&D::toggleGhostEffect})
            return reinterpret_cast<void(*)(decltype(this), GhostType)>(m->getOriginal(getBase()+0x225000))(this, p0);
        else return PlayerObject::toggleGhostEffect(p0);
    }

    void togglePlayerScale(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale} != (void(D::*)(bool)){&D::togglePlayerScale})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
        else return PlayerObject::togglePlayerScale(p0);
    }

    void toggleRobotMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode} != (void(D::*)(bool)){&D::toggleRobotMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223c70))(this, p0);
        else return PlayerObject::toggleRobotMode(p0);
    }

    void toggleRollMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode} != (void(D::*)(bool)){&D::toggleRollMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223b20))(this, p0);
        else return PlayerObject::toggleRollMode(p0);
    }

    void toggleSpiderMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode} != (void(D::*)(bool)){&D::toggleSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224830))(this, p0);
        else return PlayerObject::toggleSpiderMode(p0);
    }

    void toggleVisibility(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility} != (void(D::*)(bool)){&D::toggleVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
        else return PlayerObject::toggleVisibility(p0);
    }

    void touchedObject(GameObject* p0) {
        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject} != (void(D::*)(GameObject*)){&D::touchedObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22e660))(this, p0);
        else return PlayerObject::touchedObject(p0);
    }

    void tryPlaceCheckpoint() {
        if ((void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint} != (void(D::*)()){&D::tryPlaceCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a950))(this);
        else return PlayerObject::tryPlaceCheckpoint();
    }

    void update(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
        else return PlayerObject::update(p0);
    }

    void updateCheckpointMode(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode} != (void(D::*)(bool)){&D::updateCheckpointMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218980))(this, p0);
        else return PlayerObject::updateCheckpointMode(p0);
    }

    void updateCheckpointTest() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest} != (void(D::*)()){&D::updateCheckpointTest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a890))(this);
        else return PlayerObject::updateCheckpointTest();
    }

    void updateCollide(bool p0, int p1) {
        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide} != (void(D::*)(bool, int)){&D::updateCollide})
            return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
        else return PlayerObject::updateCollide(p0, p1);
    }

    void updateCollideBottom(float p0, int p1) {
        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom} != (void(D::*)(float, int)){&D::updateCollideBottom})
            return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
        else return PlayerObject::updateCollideBottom(p0, p1);
    }

    void updateCollideTop(float p0, int p1) {
        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop} != (void(D::*)(float, int)){&D::updateCollideTop})
            return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
        else return PlayerObject::updateCollideTop(p0, p1);
    }

    void updateDashAnimation() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation} != (void(D::*)()){&D::updateDashAnimation})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a570))(this);
        else return PlayerObject::updateDashAnimation();
    }

    void updateDashArt() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashArt} != (void(D::*)()){&D::updateDashArt})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222520))(this);
        else return PlayerObject::updateDashArt();
    }

    void updateGlowColor() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateGlowColor} != (void(D::*)()){&D::updateGlowColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cf10))(this);
        else return PlayerObject::updateGlowColor();
    }

    void updateJump(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateJump} != (void(D::*)(float)){&D::updateJump})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x219680))(this, p0);
        else return PlayerObject::updateJump(p0);
    }

    void updateJumpVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables} != (void(D::*)()){&D::updateJumpVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a740))(this);
        else return PlayerObject::updateJumpVariables();
    }

    void updatePlayerBirdFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame} != (void(D::*)(int)){&D::updatePlayerBirdFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
        else return PlayerObject::updatePlayerBirdFrame(p0);
    }

    void updatePlayerDartFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame} != (void(D::*)(int)){&D::updatePlayerDartFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c260))(this, p0);
        else return PlayerObject::updatePlayerDartFrame(p0);
    }

    void updatePlayerFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame} != (void(D::*)(int)){&D::updatePlayerFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c470))(this, p0);
        else return PlayerObject::updatePlayerFrame(p0);
    }

    void updatePlayerGlow() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow} != (void(D::*)()){&D::updatePlayerGlow})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bc50))(this);
        else return PlayerObject::updatePlayerGlow();
    }

    void updatePlayerRobotFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame} != (void(D::*)(int)){&D::updatePlayerRobotFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d620))(this, p0);
        else return PlayerObject::updatePlayerRobotFrame(p0);
    }

    void updatePlayerRollFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame} != (void(D::*)(int)){&D::updatePlayerRollFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
        else return PlayerObject::updatePlayerRollFrame(p0);
    }

    void updatePlayerScale() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale} != (void(D::*)()){&D::updatePlayerScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b8b0))(this);
        else return PlayerObject::updatePlayerScale();
    }

    void updatePlayerShipFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame} != (void(D::*)(int)){&D::updatePlayerShipFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
        else return PlayerObject::updatePlayerShipFrame(p0);
    }

    void updatePlayerSpiderFrame(int p0) {
        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame} != (void(D::*)(int)){&D::updatePlayerSpiderFrame})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d650))(this, p0);
        else return PlayerObject::updatePlayerSpiderFrame(p0);
    }

    void updatePlayerSpriteExtra(std::string p0) {
        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra} != (void(D::*)(std::string)){&D::updatePlayerSpriteExtra})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218440))(this, p0);
        else return PlayerObject::updatePlayerSpriteExtra(p0);
    }

    void updateRobotAnimationSpeed() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed} != (void(D::*)()){&D::updateRobotAnimationSpeed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df40))(this);
        else return PlayerObject::updateRobotAnimationSpeed();
    }

    void updateRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateRotation} != (void(D::*)(float)){&D::updateRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
        else return PlayerObject::updateRotation(p0);
    }

    void updateRotation(float p0, float p1) {
        if ((void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation} != (void(D::*)(float, float)){&D::updateRotation})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
        else return PlayerObject::updateRotation(p0, p1);
    }

    void updateShipRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation} != (void(D::*)(float)){&D::updateShipRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221310))(this, p0);
        else return PlayerObject::updateShipRotation(p0);
    }

    void updateShipSpriteExtra(std::string p0) {
        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra} != (void(D::*)(std::string)){&D::updateShipSpriteExtra})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218510))(this, p0);
        else return PlayerObject::updateShipSpriteExtra(p0);
    }

    void updateSlopeRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation} != (void(D::*)(float)){&D::updateSlopeRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221030))(this, p0);
        else return PlayerObject::updateSlopeRotation(p0);
    }

    void updateSlopeYVelocity(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity} != (void(D::*)(float)){&D::updateSlopeYVelocity})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e920))(this, p0);
        else return PlayerObject::updateSlopeYVelocity(p0);
    }

    void updateSpecial(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial} != (void(D::*)(float)){&D::updateSpecial})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a790))(this, p0);
        else return PlayerObject::updateSpecial(p0);
    }

    void updateStateVariables() {
        if ((void($PlayerObject::*)()){&$PlayerObject::updateStateVariables} != (void(D::*)()){&D::updateStateVariables})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a770))(this);
        else return PlayerObject::updateStateVariables();
    }

    void updateTimeMod(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod} != (void(D::*)(float)){&D::updateTimeMod})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
        else return PlayerObject::updateTimeMod(p0);
    }

    void usingWallLimitedMode() {
        if ((void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode} != (void(D::*)()){&D::usingWallLimitedMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df00))(this);
        else return PlayerObject::usingWallLimitedMode();
    }

    void yStartDown() {
        if ((void($PlayerObject::*)()){&$PlayerObject::yStartDown} != (void(D::*)()){&D::yStartDown})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e9b0))(this);
        else return PlayerObject::yStartDown();
    }

    void yStartUp() {
        if ((void($PlayerObject::*)()){&$PlayerObject::yStartUp} != (void(D::*)()){&D::yStartUp})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e990))(this);
        else return PlayerObject::yStartUp();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($PlayerObject::*)()){&$PlayerObject::activateStreak} != (void(D::*)()){&D::activateStreak})
            m->registerHook(getBase()+0x21aef0, extract((void(D::*)()){&D::activateStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::addAllParticles} != (void(D::*)()){&D::addAllParticles})
            m->registerHook(getBase()+0x2189b0, extract((void(D::*)()){&D::addAllParticles}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings} != (void(D::*)(GameObject*)){&D::addToTouchedRings})
            m->registerHook(getBase()+0x22b800, extract((void(D::*)(GameObject*)){&D::addToTouchedRings}));

        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(getBase()+0x22e9d0, extract_virtual(this, (void(D::*)(char const*)){&D::animationFinished}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer} != (void(D::*)(float)){&D::boostPlayer})
            m->registerHook(getBase()+0x21d6b0, extract((void(D::*)(float)){&D::boostPlayer}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer} != (void(D::*)(float, int)){&D::bumpPlayer})
            m->registerHook(getBase()+0x22d890, extract((void(D::*)(float, int)){&D::bumpPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown} != (void(D::*)(PlayerButton)){&D::buttonDown})
            m->registerHook(getBase()+0x22b7e0, extract((void(D::*)(PlayerButton)){&D::buttonDown}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject} != (void(D::*)(GameObject*)){&D::checkSnapJumpToObject})
            m->registerHook(getBase()+0x2217f0, extract((void(D::*)(GameObject*)){&D::checkSnapJumpToObject}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21d880, extract((void(D::*)(float, GameObject*)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*, cocos2d::CCRect)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21f0b0, extract((void(D::*)(float, GameObject*, cocos2d::CCRect)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope} != (void(D::*)(float, GameObject*, bool)){&D::collidedWithSlope})
            m->registerHook(getBase()+0x21d8d0, extract((void(D::*)(float, GameObject*, bool)){&D::collidedWithSlope}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation} != (void(D::*)(float)){&D::convertToClosestRotation})
            m->registerHook(getBase()+0x21c860, extract((void(D::*)(float)){&D::convertToClosestRotation}));

        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes} != (void(D::*)(PlayerObject*)){&D::copyAttributes})
            m->registerHook(getBase()+0x22dc70, extract((void(D::*)(PlayerObject*)){&D::copyAttributes}));

        if ((PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create} != (PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&D::create})
            m->registerHook(getBase()+0x217260, (PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&D::create});

        if ((void($PlayerObject::*)()){&$PlayerObject::deactivateParticle} != (void(D::*)()){&D::deactivateParticle})
            m->registerHook(getBase()+0x21a540, extract((void(D::*)()){&D::deactivateParticle}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak} != (void(D::*)(bool)){&D::deactivateStreak})
            m->registerHook(getBase()+0x218b30, extract((void(D::*)(bool)){&D::deactivateStreak}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2} != (void(D::*)(float)){&D::fadeOutStreak2})
            m->registerHook(getBase()+0x225890, extract((void(D::*)(float)){&D::fadeOutStreak2}));

        if ((void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer} != (void(D::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::flashPlayer})
            m->registerHook(getBase()+0x221c80, extract((void(D::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::flashPlayer}));

        if ((void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity} != (void(D::*)(bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0x21c090, extract((void(D::*)(bool, bool)){&D::flipGravity}));

        if ((void($PlayerObject::*)()){&$PlayerObject::flipMod} != (void(D::*)()){&D::flipMod})
            m->registerHook(getBase()+0x21a4c0, extract((void(D::*)()){&D::flipMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getActiveMode} != (void(D::*)()){&D::getActiveMode})
            m->registerHook(getBase()+0x22b950, extract((void(D::*)()){&D::getActiveMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel} != (void(D::*)()){&D::getModifiedSlopeYVel})
            m->registerHook(getBase()+0x21bff0, extract((void(D::*)()){&D::getModifiedSlopeYVel}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition} != (void(D::*)(float)){&D::getOldPosition})
            m->registerHook(getBase()+0x21a830, extract((void(D::*)(float)){&D::getOldPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(getBase()+0x22dee0, extract_virtual(this, (void(D::*)()){&D::getOrientedBox}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(getBase()+0x22d5f0, extract_virtual(this, (void(D::*)()){&D::getRealPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getSecondColor} != (void(D::*)()){&D::getSecondColor})
            m->registerHook(getBase()+0x22cee0, extract((void(D::*)()){&D::getSecondColor}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityDown} != (void(D::*)()){&D::gravityDown})
            m->registerHook(getBase()+0x22e930, extract((void(D::*)()){&D::gravityDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityUp} != (void(D::*)()){&D::gravityUp})
            m->registerHook(getBase()+0x22e900, extract((void(D::*)()){&D::gravityUp}));

        if ((void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity} != (void(D::*)()){&D::hardFlipGravity})
            m->registerHook(getBase()+0x22b860, extract((void(D::*)()){&D::hardFlipGravity}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::hitGround} != (void(D::*)(bool)){&D::hitGround})
            m->registerHook(getBase()+0x220a30, extract((void(D::*)(bool)){&D::hitGround}));

        if ((void($PlayerObject::*)()){&$PlayerObject::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x21c050, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init} != (bool(D::*)(int, int, cocos2d::CCLayer*)){&D::init})
            m->registerHook(getBase()+0x2172e0, extract((bool(D::*)(int, int, cocos2d::CCLayer*)){&D::init}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid} != (void(D::*)(float)){&D::isBoostValid})
            m->registerHook(getBase()+0x21d650, extract((void(D::*)(float)){&D::isBoostValid}));

        if ((void($PlayerObject::*)()){&$PlayerObject::isFlying} != (void(D::*)()){&D::isFlying})
            m->registerHook(getBase()+0x21a4e0, extract((void(D::*)()){&D::isFlying}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip} != (void(D::*)(float)){&D::isSafeFlip})
            m->registerHook(getBase()+0x2209f0, extract((void(D::*)(float)){&D::isSafeFlip}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode} != (void(D::*)(float)){&D::isSafeMode})
            m->registerHook(getBase()+0x2209b0, extract((void(D::*)(float)){&D::isSafeMode}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip} != (void(D::*)(float)){&D::isSafeSpiderFlip})
            m->registerHook(getBase()+0x221be0, extract((void(D::*)(float)){&D::isSafeSpiderFlip}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished} != (void(D::*)()){&D::levelFlipFinished})
            m->registerHook(getBase()+0x21b060, extract((void(D::*)()){&D::levelFlipFinished}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipping} != (void(D::*)()){&D::levelFlipping})
            m->registerHook(getBase()+0x21a510, extract((void(D::*)()){&D::levelFlipping}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelWillFlip} != (void(D::*)()){&D::levelWillFlip})
            m->registerHook(getBase()+0x21b020, extract((void(D::*)()){&D::levelWillFlip}));

        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x22e420, extract((void(D::*)(PlayerCheckpoint*)){&D::loadFromCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::lockPlayer} != (void(D::*)()){&D::lockPlayer})
            m->registerHook(getBase()+0x22d680, extract((void(D::*)()){&D::lockPlayer}));

        if ((void($PlayerObject::*)()){&$PlayerObject::logValues} != (void(D::*)()){&D::logValues})
            m->registerHook(getBase()+0x221220, extract((void(D::*)()){&D::logValues}));

        if ((void($PlayerObject::*)()){&$PlayerObject::modeDidChange} != (void(D::*)()){&D::modeDidChange})
            m->registerHook(getBase()+0x22bfd0, extract((void(D::*)()){&D::modeDidChange}));

        if ((void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint} != (void(D::*)()){&D::placeStreakPoint})
            m->registerHook(getBase()+0x21af90, extract((void(D::*)()){&D::placeStreakPoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playBurstEffect} != (void(D::*)()){&D::playBurstEffect})
            m->registerHook(getBase()+0x21c780, extract((void(D::*)()){&D::playBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDeathEffect} != (void(D::*)()){&D::playDeathEffect})
            m->registerHook(getBase()+0x225930, extract((void(D::*)()){&D::playDeathEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun} != (void(D::*)()){&D::playDynamicSpiderRun})
            m->registerHook(getBase()+0x222ec0, extract((void(D::*)()){&D::playDynamicSpiderRun}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed} != (void(D::*)(bool)){&D::playerDestroyed})
            m->registerHook(getBase()+0x2256d0, extract((void(D::*)(bool)){&D::playerDestroyed}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerIsFalling} != (void(D::*)()){&D::playerIsFalling})
            m->registerHook(getBase()+0x21c730, extract((void(D::*)()){&D::playerIsFalling}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerTeleported} != (void(D::*)()){&D::playerTeleported})
            m->registerHook(getBase()+0x22b840, extract((void(D::*)()){&D::playerTeleported}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playingEndEffect} != (void(D::*)()){&D::playingEndEffect})
            m->registerHook(getBase()+0x22d7e0, extract((void(D::*)()){&D::playingEndEffect}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::postCollision} != (void(D::*)(float)){&D::postCollision})
            m->registerHook(getBase()+0x21cd10, extract((void(D::*)(float)){&D::postCollision}));

        if ((void($PlayerObject::*)()){&$PlayerObject::preCollision} != (void(D::*)()){&D::preCollision})
            m->registerHook(getBase()+0x21ccc0, extract((void(D::*)()){&D::preCollision}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision} != (void(D::*)(float, GameObject*)){&D::preSlopeCollision})
            m->registerHook(getBase()+0x21ec80, extract((void(D::*)(float, GameObject*)){&D::preSlopeCollision}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer} != (void(D::*)(float)){&D::propellPlayer})
            m->registerHook(getBase()+0x22d8e0, extract((void(D::*)(float)){&D::propellPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton} != (void(D::*)(PlayerButton)){&D::pushButton})
            m->registerHook(getBase()+0x22aa00, extract((void(D::*)(PlayerButton)){&D::pushButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::pushDown} != (void(D::*)()){&D::pushDown})
            m->registerHook(getBase()+0x22dbd0, extract((void(D::*)()){&D::pushDown}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer} != (void(D::*)(float)){&D::pushPlayer})
            m->registerHook(getBase()+0x22dbb0, extract((void(D::*)(float)){&D::pushPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton} != (void(D::*)(PlayerButton)){&D::releaseButton})
            m->registerHook(getBase()+0x22b6f0, extract((void(D::*)(PlayerButton)){&D::releaseButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removeAllParticles} != (void(D::*)()){&D::removeAllParticles})
            m->registerHook(getBase()+0x218ac0, extract((void(D::*)()){&D::removeAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint} != (void(D::*)()){&D::removePendingCheckpoint})
            m->registerHook(getBase()+0x2237b0, extract((void(D::*)()){&D::removePendingCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetAllParticles} != (void(D::*)()){&D::resetAllParticles})
            m->registerHook(getBase()+0x21adb0, extract((void(D::*)()){&D::resetAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog} != (void(D::*)()){&D::resetCollisionLog})
            m->registerHook(getBase()+0x21cc20, extract((void(D::*)()){&D::resetCollisionLog}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x223170, extract_virtual(this, (void(D::*)()){&D::resetObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon} != (void(D::*)()){&D::resetPlayerIcon})
            m->registerHook(getBase()+0x22be00, extract((void(D::*)()){&D::resetPlayerIcon}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStateVariables} != (void(D::*)()){&D::resetStateVariables})
            m->registerHook(getBase()+0x223760, extract((void(D::*)()){&D::resetStateVariables}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStreak} != (void(D::*)()){&D::resetStreak})
            m->registerHook(getBase()+0x21ae10, extract((void(D::*)()){&D::resetStreak}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump} != (void(D::*)(GameObject*)){&D::ringJump})
            m->registerHook(getBase()+0x22abf0, extract((void(D::*)(GameObject*)){&D::ringJump}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation} != (void(D::*)(float)){&D::runBallRotation})
            m->registerHook(getBase()+0x21ca10, extract((void(D::*)(float)){&D::runBallRotation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runBallRotation2} != (void(D::*)()){&D::runBallRotation2})
            m->registerHook(getBase()+0x21cb10, extract((void(D::*)()){&D::runBallRotation2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runNormalRotation} != (void(D::*)()){&D::runNormalRotation})
            m->registerHook(getBase()+0x21c960, extract((void(D::*)()){&D::runNormalRotation}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction} != (void(D::*)(bool)){&D::runRotateAction})
            m->registerHook(getBase()+0x21c570, extract((void(D::*)(bool)){&D::runRotateAction}));

        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::saveToCheckpoint})
            m->registerHook(getBase()+0x22e2f0, extract((void(D::*)(PlayerCheckpoint*)){&D::saveToCheckpoint}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(getBase()+0x22cdf0, extract_virtual(this, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(getBase()+0x22e720, extract_virtual(this, (void(D::*)(bool)){&D::setFlipX}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(getBase()+0x22e7b0, extract_virtual(this, (void(D::*)(bool)){&D::setFlipY}));

        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(getBase()+0x22d400, extract_virtual(this, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x22c8b0, extract_virtual(this, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(getBase()+0x22e6e0, extract_virtual(this, (void(D::*)(float)){&D::setRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(getBase()+0x22e870, extract_virtual(this, (void(D::*)(float)){&D::setScale}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(getBase()+0x22e7f0, extract_virtual(this, (void(D::*)(float)){&D::setScaleX}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(getBase()+0x22e830, extract_virtual(this, (void(D::*)(float)){&D::setScaleY}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            m->registerHook(getBase()+0x219610, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(getBase()+0x22e8b0, extract_virtual(this, (void(D::*)(bool)){&D::setVisible}));

        if ((void($PlayerObject::*)()){&$PlayerObject::setupStreak} != (void(D::*)()){&D::setupStreak})
            m->registerHook(getBase()+0x218720, extract((void(D::*)()){&D::setupStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x225480, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle2} != (void(D::*)()){&D::spawnCircle2})
            m->registerHook(getBase()+0x2252a0, extract((void(D::*)()){&D::spawnCircle2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle} != (void(D::*)()){&D::spawnDualCircle})
            m->registerHook(getBase()+0x2255c0, extract((void(D::*)()){&D::spawnDualCircle}));

        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer} != (void(D::*)(PlayerObject*)){&D::spawnFromPlayer})
            m->registerHook(getBase()+0x22dde0, extract((void(D::*)(PlayerObject*)){&D::spawnFromPlayer}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle} != (void(D::*)(cocos2d::_ccColor3B, float)){&D::spawnPortalCircle})
            m->registerHook(getBase()+0x225350, extract((void(D::*)(cocos2d::_ccColor3B, float)){&D::spawnPortalCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle} != (void(D::*)()){&D::spawnScaleCircle})
            m->registerHook(getBase()+0x2251b0, extract((void(D::*)()){&D::spawnScaleCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::specialGroundHit} != (void(D::*)()){&D::specialGroundHit})
            m->registerHook(getBase()+0x22dbf0, extract((void(D::*)()){&D::specialGroundHit}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedDown} != (void(D::*)()){&D::speedDown})
            m->registerHook(getBase()+0x22e970, extract((void(D::*)()){&D::speedDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedUp} != (void(D::*)()){&D::speedUp})
            m->registerHook(getBase()+0x22e950, extract((void(D::*)()){&D::speedUp}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump} != (void(D::*)(bool)){&D::spiderTestJump})
            m->registerHook(getBase()+0x21b160, extract((void(D::*)(bool)){&D::spiderTestJump}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing} != (void(D::*)(GameObject*)){&D::startDashing})
            m->registerHook(getBase()+0x221d70, extract((void(D::*)(GameObject*)){&D::startDashing}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect} != (void(D::*)()){&D::stopBurstEffect})
            m->registerHook(getBase()+0x22c680, extract((void(D::*)()){&D::stopBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopDashing} != (void(D::*)()){&D::stopDashing})
            m->registerHook(getBase()+0x222990, extract((void(D::*)()){&D::stopDashing}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation} != (void(D::*)(bool)){&D::stopRotation})
            m->registerHook(getBase()+0x21c830, extract((void(D::*)(bool)){&D::stopRotation}));

        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision} != (void(D::*)(bool, int)){&D::storeCollision})
            m->registerHook(getBase()+0x21cc60, extract((void(D::*)(bool, int)){&D::storeCollision}));

        if ((void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode} != (void(D::*)(GameObjectType)){&D::switchedToMode})
            m->registerHook(getBase()+0x22b9a0, extract((void(D::*)(GameObjectType)){&D::switchedToMode}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving} != (void(D::*)(float, GameObject*)){&D::testForMoving})
            m->registerHook(getBase()+0x21eb70, extract((void(D::*)(float, GameObject*)){&D::testForMoving}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode} != (void(D::*)(bool)){&D::toggleBirdMode})
            m->registerHook(getBase()+0x224070, extract((void(D::*)(bool)){&D::toggleBirdMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode} != (void(D::*)(bool)){&D::toggleDartMode})
            m->registerHook(getBase()+0x2243f0, extract((void(D::*)(bool)){&D::toggleDartMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode} != (void(D::*)(bool)){&D::toggleFlyMode})
            m->registerHook(getBase()+0x223820, extract((void(D::*)(bool)){&D::toggleFlyMode}));

        if ((void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect} != (void(D::*)(GhostType)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x225000, extract((void(D::*)(GhostType)){&D::toggleGhostEffect}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale} != (void(D::*)(bool)){&D::togglePlayerScale})
            m->registerHook(getBase()+0x224bd0, extract((void(D::*)(bool)){&D::togglePlayerScale}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode} != (void(D::*)(bool)){&D::toggleRobotMode})
            m->registerHook(getBase()+0x223c70, extract((void(D::*)(bool)){&D::toggleRobotMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode} != (void(D::*)(bool)){&D::toggleRollMode})
            m->registerHook(getBase()+0x223b20, extract((void(D::*)(bool)){&D::toggleRollMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode} != (void(D::*)(bool)){&D::toggleSpiderMode})
            m->registerHook(getBase()+0x224830, extract((void(D::*)(bool)){&D::toggleSpiderMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility} != (void(D::*)(bool)){&D::toggleVisibility})
            m->registerHook(getBase()+0x21abf0, extract((void(D::*)(bool)){&D::toggleVisibility}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject} != (void(D::*)(GameObject*)){&D::touchedObject})
            m->registerHook(getBase()+0x22e660, extract((void(D::*)(GameObject*)){&D::touchedObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint} != (void(D::*)()){&D::tryPlaceCheckpoint})
            m->registerHook(getBase()+0x21a950, extract((void(D::*)()){&D::tryPlaceCheckpoint}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x218bf0, extract_virtual(this, (void(D::*)(float)){&D::update}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode} != (void(D::*)(bool)){&D::updateCheckpointMode})
            m->registerHook(getBase()+0x218980, extract((void(D::*)(bool)){&D::updateCheckpointMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest} != (void(D::*)()){&D::updateCheckpointTest})
            m->registerHook(getBase()+0x21a890, extract((void(D::*)()){&D::updateCheckpointTest}));

        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide} != (void(D::*)(bool, int)){&D::updateCollide})
            m->registerHook(getBase()+0x220f10, extract((void(D::*)(bool, int)){&D::updateCollide}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom} != (void(D::*)(float, int)){&D::updateCollideBottom})
            m->registerHook(getBase()+0x221790, extract((void(D::*)(float, int)){&D::updateCollideBottom}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop} != (void(D::*)(float, int)){&D::updateCollideTop})
            m->registerHook(getBase()+0x221c20, extract((void(D::*)(float, int)){&D::updateCollideTop}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation} != (void(D::*)()){&D::updateDashAnimation})
            m->registerHook(getBase()+0x21a570, extract((void(D::*)()){&D::updateDashAnimation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashArt} != (void(D::*)()){&D::updateDashArt})
            m->registerHook(getBase()+0x222520, extract((void(D::*)()){&D::updateDashArt}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateGlowColor} != (void(D::*)()){&D::updateGlowColor})
            m->registerHook(getBase()+0x22cf10, extract((void(D::*)()){&D::updateGlowColor}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateJump} != (void(D::*)(float)){&D::updateJump})
            m->registerHook(getBase()+0x219680, extract((void(D::*)(float)){&D::updateJump}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables} != (void(D::*)()){&D::updateJumpVariables})
            m->registerHook(getBase()+0x21a740, extract((void(D::*)()){&D::updateJumpVariables}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame} != (void(D::*)(int)){&D::updatePlayerBirdFrame})
            m->registerHook(getBase()+0x22bfe0, extract((void(D::*)(int)){&D::updatePlayerBirdFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame} != (void(D::*)(int)){&D::updatePlayerDartFrame})
            m->registerHook(getBase()+0x22c260, extract((void(D::*)(int)){&D::updatePlayerDartFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame} != (void(D::*)(int)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x22c470, extract((void(D::*)(int)){&D::updatePlayerFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow} != (void(D::*)()){&D::updatePlayerGlow})
            m->registerHook(getBase()+0x22bc50, extract((void(D::*)()){&D::updatePlayerGlow}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame} != (void(D::*)(int)){&D::updatePlayerRobotFrame})
            m->registerHook(getBase()+0x22d620, extract((void(D::*)(int)){&D::updatePlayerRobotFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame} != (void(D::*)(int)){&D::updatePlayerRollFrame})
            m->registerHook(getBase()+0x22c6a0, extract((void(D::*)(int)){&D::updatePlayerRollFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale} != (void(D::*)()){&D::updatePlayerScale})
            m->registerHook(getBase()+0x22b8b0, extract((void(D::*)()){&D::updatePlayerScale}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame} != (void(D::*)(int)){&D::updatePlayerShipFrame})
            m->registerHook(getBase()+0x22ba40, extract((void(D::*)(int)){&D::updatePlayerShipFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame} != (void(D::*)(int)){&D::updatePlayerSpiderFrame})
            m->registerHook(getBase()+0x22d650, extract((void(D::*)(int)){&D::updatePlayerSpiderFrame}));

        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra} != (void(D::*)(std::string)){&D::updatePlayerSpriteExtra})
            m->registerHook(getBase()+0x218440, extract((void(D::*)(std::string)){&D::updatePlayerSpriteExtra}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed} != (void(D::*)()){&D::updateRobotAnimationSpeed})
            m->registerHook(getBase()+0x22df40, extract((void(D::*)()){&D::updateRobotAnimationSpeed}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateRotation} != (void(D::*)(float)){&D::updateRotation})
            m->registerHook(getBase()+0x2214b0, extract((void(D::*)(float)){&D::updateRotation}));

        if ((void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation} != (void(D::*)(float, float)){&D::updateRotation})
            m->registerHook(getBase()+0x221230, extract((void(D::*)(float, float)){&D::updateRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation} != (void(D::*)(float)){&D::updateShipRotation})
            m->registerHook(getBase()+0x221310, extract((void(D::*)(float)){&D::updateShipRotation}));

        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra} != (void(D::*)(std::string)){&D::updateShipSpriteExtra})
            m->registerHook(getBase()+0x218510, extract((void(D::*)(std::string)){&D::updateShipSpriteExtra}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation} != (void(D::*)(float)){&D::updateSlopeRotation})
            m->registerHook(getBase()+0x221030, extract((void(D::*)(float)){&D::updateSlopeRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity} != (void(D::*)(float)){&D::updateSlopeYVelocity})
            m->registerHook(getBase()+0x22e920, extract((void(D::*)(float)){&D::updateSlopeYVelocity}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial} != (void(D::*)(float)){&D::updateSpecial})
            m->registerHook(getBase()+0x21a790, extract((void(D::*)(float)){&D::updateSpecial}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateStateVariables} != (void(D::*)()){&D::updateStateVariables})
            m->registerHook(getBase()+0x21a770, extract((void(D::*)()){&D::updateStateVariables}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod} != (void(D::*)(float)){&D::updateTimeMod})
            m->registerHook(getBase()+0x2185e0, extract((void(D::*)(float)){&D::updateTimeMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode} != (void(D::*)()){&D::usingWallLimitedMode})
            m->registerHook(getBase()+0x22df00, extract((void(D::*)()){&D::usingWallLimitedMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartDown} != (void(D::*)()){&D::yStartDown})
            m->registerHook(getBase()+0x22e9b0, extract((void(D::*)()){&D::yStartDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartUp} != (void(D::*)()){&D::yStartUp})
            m->registerHook(getBase()+0x22e990, extract((void(D::*)()){&D::yStartUp}));
    }
};


template<class D>
class $PulseEffectAction : public PulseEffectAction, public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$PulseEffectAction() {}
    typedef PulseEffectAction* __thistype;

    static PulseEffectAction* createFromString(std::string p0) {
        if ((PulseEffectAction*(*)(std::string)){&$PulseEffectAction::createFromString} != (PulseEffectAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<PulseEffectAction*(*)(std::string)>(m->getOriginal(getBase()+0x179e90))(p0);
        else return PulseEffectAction::createFromString(p0);
    }

    void getSaveString() {
        if ((void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17a850))(this);
        else return PulseEffectAction::getSaveString();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((PulseEffectAction*(*)(std::string)){&$PulseEffectAction::createFromString} != (PulseEffectAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x179e90, (PulseEffectAction*(*)(std::string)){&D::createFromString});

        if ((void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17a850, extract((void(D::*)()){&D::getSaveString}));
    }
};


template<class D>
class $RetryLevelLayer : public RetryLevelLayer, public $CacBase {
 public:
    $RetryLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$RetryLevelLayer() {}
    typedef RetryLevelLayer* __thistype;

    static RetryLevelLayer* create() {
        if ((RetryLevelLayer*(*)()){&$RetryLevelLayer::create} != (RetryLevelLayer*(*)()){&D::create})
            return reinterpret_cast<RetryLevelLayer*(*)()>(m->getOriginal(getBase()+0x28dd60))();
        else return RetryLevelLayer::create();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((RetryLevelLayer*(*)()){&$RetryLevelLayer::create} != (RetryLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x28dd60, (RetryLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $SetGroupIDLayer : public SetGroupIDLayer, public $CacBase {
 public:
    $SetGroupIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetGroupIDLayer() {}
    typedef SetGroupIDLayer* __thistype;

    void onNextGroupID1(cocos2d::CCObject* p0) {
        if ((void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1} != (void(D::*)(cocos2d::CCObject*)){&D::onNextGroupID1})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1967a0))(this, p0);
        else return SetGroupIDLayer::onNextGroupID1(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x197af0))(this, p0);
        else return SetGroupIDLayer::textChanged(p0);
    }

    void updateGroupIDLabel() {
        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel} != (void(D::*)()){&D::updateGroupIDLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x197260))(this);
        else return SetGroupIDLayer::updateGroupIDLabel();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1} != (void(D::*)(cocos2d::CCObject*)){&D::onNextGroupID1})
            m->registerHook(getBase()+0x1967a0, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextGroupID1}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x197af0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel} != (void(D::*)()){&D::updateGroupIDLabel})
            m->registerHook(getBase()+0x197260, extract((void(D::*)()){&D::updateGroupIDLabel}));
    }
};


template<class D>
class $SetIDLayer : public SetIDLayer, public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetIDLayer() {}
    typedef SetIDLayer* __thistype;

    static SetIDLayer* create(GameObject* p0) {
        if ((SetIDLayer*(*)(GameObject*)){&$SetIDLayer::create} != (SetIDLayer*(*)(GameObject*)){&D::create})
            return reinterpret_cast<SetIDLayer*(*)(GameObject*)>(m->getOriginal(getBase()+0x168f20))(p0);
        else return SetIDLayer::create(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetIDLayer*(*)(GameObject*)){&$SetIDLayer::create} != (SetIDLayer*(*)(GameObject*)){&D::create})
            m->registerHook(getBase()+0x168f20, (SetIDLayer*(*)(GameObject*)){&D::create});
    }
};


template<class D>
class $SetIDPopup : public SetIDPopup, public $CacBase {
 public:
    $SetIDPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetIDPopup() {}
    typedef SetIDPopup* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $SetItemIDLayer : public SetItemIDLayer, public $CacBase {
 public:
    $SetItemIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetItemIDLayer() {}
    typedef SetItemIDLayer* __thistype;

    static SetItemIDLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create} != (SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x5a830))(p0, p1);
        else return SetItemIDLayer::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create} != (SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x5a830, (SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});
    }
};


template<class D>
class $SetTargetIDLayer : public SetTargetIDLayer, public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetTargetIDLayer() {}
    typedef SetTargetIDLayer* __thistype;

    static SetTargetIDLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1, std::string p2) {
        if ((SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create} != (SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&D::create})
            return reinterpret_cast<SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)>(m->getOriginal(getBase()+0x159d20))(p0, p1, p2);
        else return SetTargetIDLayer::create(p0, p1, p2);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15aed0))(this, p0);
        else return SetTargetIDLayer::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15b6c0))(this, p0);
        else return SetTargetIDLayer::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15b4a0))(this);
        else return SetTargetIDLayer::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create} != (SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&D::create})
            m->registerHook(getBase()+0x159d20, (SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&D::create});

        if ((void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15aed0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x15b6c0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15b4a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupAnimationPopup : public SetupAnimationPopup, public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupAnimationPopup() {}
    typedef SetupAnimationPopup* __thistype;

    static SetupAnimationPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create} != (SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x208b70))(p0, p1);
        else return SetupAnimationPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x209fc0))(this, p0);
        else return SetupAnimationPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x20ab30))(this, p0);
        else return SetupAnimationPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20a910))(this);
        else return SetupAnimationPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create} != (SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x208b70, (SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x209fc0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x20ab30, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x20a910, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCollisionTriggerPopup : public SetupCollisionTriggerPopup, public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupCollisionTriggerPopup() {}
    typedef SetupCollisionTriggerPopup* __thistype;

    static SetupCollisionTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create} != (SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1d6120))(p0, p1);
        else return SetupCollisionTriggerPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d77b0))(this, p0);
        else return SetupCollisionTriggerPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1d84d0))(this, p0);
        else return SetupCollisionTriggerPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d82b0))(this);
        else return SetupCollisionTriggerPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create} != (SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1d6120, (SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1d77b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1d84d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1d82b0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCountTriggerPopup : public SetupCountTriggerPopup, public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupCountTriggerPopup() {}
    typedef SetupCountTriggerPopup* __thistype;

    static SetupCountTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create} != (SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x15c6c0))(p0, p1);
        else return SetupCountTriggerPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15dd40))(this, p0);
        else return SetupCountTriggerPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15e9a0))(this, p0);
        else return SetupCountTriggerPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15e8a0))(this);
        else return SetupCountTriggerPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create} != (SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x15c6c0, (SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15dd40, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x15e9a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15e8a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInstantCountPopup : public SetupInstantCountPopup, public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupInstantCountPopup() {}
    typedef SetupInstantCountPopup* __thistype;

    static SetupInstantCountPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create} != (SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x352c10))(p0, p1);
        else return SetupInstantCountPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x354520))(this, p0);
        else return SetupInstantCountPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x355270))(this, p0);
        else return SetupInstantCountPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x355170))(this);
        else return SetupInstantCountPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create} != (SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x352c10, (SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x354520, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x355270, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x355170, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInteractObjectPopup : public SetupInteractObjectPopup, public $CacBase {
 public:
    $SetupInteractObjectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupInteractObjectPopup() {}
    typedef SetupInteractObjectPopup* __thistype;

    static SetupInteractObjectPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create} != (SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x29a400))(p0, p1);
        else return SetupInteractObjectPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x29bbc0))(this, p0);
        else return SetupInteractObjectPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x29c2b0))(this, p0);
        else return SetupInteractObjectPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x29c120))(this);
        else return SetupInteractObjectPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create} != (SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x29a400, (SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x29bbc0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x29c2b0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x29c120, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupObjectTogglePopup : public SetupObjectTogglePopup, public $CacBase {
 public:
    $SetupObjectTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupObjectTogglePopup() {}
    typedef SetupObjectTogglePopup* __thistype;

    static SetupObjectTogglePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create} != (SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0860))(p0, p1);
        else return SetupObjectTogglePopup::create(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((bool($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0a40))(this, p0, p1);
        else return SetupObjectTogglePopup::init(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1c1c40))(this, p0);
        else return SetupObjectTogglePopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1c2660))(this, p0);
        else return SetupObjectTogglePopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2440))(this);
        else return SetupObjectTogglePopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create} != (SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1c0860, (SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x1c0a40, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1c1c40, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1c2660, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1c2440, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupOpacityPopup : public SetupOpacityPopup, public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupOpacityPopup() {}
    typedef SetupOpacityPopup* __thistype;

    static SetupOpacityPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create} != (SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x32b70))(p0, p1);
        else return SetupOpacityPopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x340a0))(this, p0);
        else return SetupOpacityPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x34a60))(this, p0);
        else return SetupOpacityPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34760))(this);
        else return SetupOpacityPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create} != (SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x32b70, (SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x340a0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x34a60, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x34760, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupPickupTriggerPopup : public SetupPickupTriggerPopup, public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupPickupTriggerPopup() {}
    typedef SetupPickupTriggerPopup* __thistype;

    static SetupPickupTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create} != (SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x35e70))(p0, p1);
        else return SetupPickupTriggerPopup::create(p0, p1);
    }

    void onItemIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onItemIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37100))(this, p0);
        else return SetupPickupTriggerPopup::onItemIDArrow(p0);
    }

    void onNextItemID(cocos2d::CCObject* p0) {
        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37260))(this, p0);
        else return SetupPickupTriggerPopup::onNextItemID(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x37ca0))(this, p0);
        else return SetupPickupTriggerPopup::textChanged(p0);
    }

    void updateItemID() {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID} != (void(D::*)()){&D::updateItemID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x37ab0))(this);
        else return SetupPickupTriggerPopup::updateItemID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create} != (SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x35e70, (SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onItemIDArrow})
            m->registerHook(getBase()+0x37100, extract((void(D::*)(cocos2d::CCObject*)){&D::onItemIDArrow}));

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            m->registerHook(getBase()+0x37260, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextItemID}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x37ca0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID} != (void(D::*)()){&D::updateItemID})
            m->registerHook(getBase()+0x37ab0, extract((void(D::*)()){&D::updateItemID}));
    }
};


template<class D>
class $SetupShakePopup : public SetupShakePopup, public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupShakePopup() {}
    typedef SetupShakePopup* __thistype;

    static SetupShakePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create} != (SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x3adc00))(p0, p1);
        else return SetupShakePopup::create(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create} != (SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x3adc00, (SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});
    }
};


template<class D>
class $SetupSpawnPopup : public SetupSpawnPopup, public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupSpawnPopup() {}
    typedef SetupSpawnPopup* __thistype;

    static SetupSpawnPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create} != (SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x139790))(p0, p1);
        else return SetupSpawnPopup::create(p0, p1);
    }

    void createToggleButton(std::string p0, cocos2d::SEL_CallFuncO p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) {
        if ((void($SetupSpawnPopup::*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton} != (void(D::*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&D::createToggleButton})
            return reinterpret_cast<void(*)(decltype(this), std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
        else return SetupSpawnPopup::createToggleButton(p0, p1, p2, p3, p4, p5);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x13ad80))(this, p0);
        else return SetupSpawnPopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x13b990))(this, p0);
        else return SetupSpawnPopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13b770))(this);
        else return SetupSpawnPopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create} != (SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x139790, (SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupSpawnPopup::*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton} != (void(D::*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&D::createToggleButton})
            m->registerHook(getBase()+0x13b0e0, extract((void(D::*)(std::string, cocos2d::SEL_CallFuncO, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&D::createToggleButton}));

        if ((void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x13ad80, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x13b990, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x13b770, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupTouchTogglePopup : public SetupTouchTogglePopup, public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupTouchTogglePopup() {}
    typedef SetupTouchTogglePopup* __thistype;

    static SetupTouchTogglePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create} != (SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1576a0))(p0, p1);
        else return SetupTouchTogglePopup::create(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        if ((void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x158b60))(this, p0);
        else return SetupTouchTogglePopup::onTargetIDArrow(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1596a0))(this, p0);
        else return SetupTouchTogglePopup::textChanged(p0);
    }

    void updateTargetID() {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x159480))(this);
        else return SetupTouchTogglePopup::updateTargetID();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create} != (SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1576a0, (SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x158b60, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1596a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x159480, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SimplePlayer : public SimplePlayer, public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SimplePlayer() {}
    typedef SimplePlayer* __thistype;

    static SimplePlayer* create(int p0) {
        if ((SimplePlayer*(*)(int)){&$SimplePlayer::create} != (SimplePlayer*(*)(int)){&D::create})
            return reinterpret_cast<SimplePlayer*(*)(int)>(m->getOriginal(getBase()+0x1b6140))(p0);
        else return SimplePlayer::create(p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const& p0) {
        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
        else return SimplePlayer::setSecondColor(p0);
    }

    void updateColors() {
        if ((void($SimplePlayer::*)()){&$SimplePlayer::updateColors} != (void(D::*)()){&D::updateColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ba1f0))(this);
        else return SimplePlayer::updateColors();
    }

    void updatePlayerFrame(int p0, IconType p1) {
        if ((void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame} != (void(D::*)(int, IconType)){&D::updatePlayerFrame})
            return reinterpret_cast<void(*)(decltype(this), int, IconType)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
        else return SimplePlayer::updatePlayerFrame(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SimplePlayer*(*)(int)){&$SimplePlayer::create} != (SimplePlayer*(*)(int)){&D::create})
            m->registerHook(getBase()+0x1b6140, (SimplePlayer*(*)(int)){&D::create});

        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            m->registerHook(getBase()+0x1bace0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor}));

        if ((void($SimplePlayer::*)()){&$SimplePlayer::updateColors} != (void(D::*)()){&D::updateColors})
            m->registerHook(getBase()+0x1ba1f0, extract((void(D::*)()){&D::updateColors}));

        if ((void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame} != (void(D::*)(int, IconType)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x1b62f0, extract((void(D::*)(int, IconType)){&D::updatePlayerFrame}));
    }
};


template<class D>
class $Slider : public Slider, public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$Slider() {}
    typedef Slider* __thistype;

    static Slider* create(cocos2d::CCNode* p0, cocos2d::SEL_CallFuncO p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) {
        if ((Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)){&D::create})
            return reinterpret_cast<Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)>(m->getOriginal(getBase()+0x18dd80))(p0, p1, p2, p3, p4, p5, p6);
        else return Slider::create(p0, p1, p2, p3, p4, p5, p6);
    }

    static Slider* create(cocos2d::CCNode* p0, cocos2d::SEL_CallFuncO p1, float p2) {
        if ((Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)){&D::create})
            return reinterpret_cast<Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)>(m->getOriginal(getBase()+0x18dc40))(p0, p1, p2);
        else return Slider::create(p0, p1, p2);
    }

    void getValue() {
        if ((void($Slider::*)()){&$Slider::getValue} != (void(D::*)()){&D::getValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
        else return Slider::getValue();
    }

    void setBarVisibility(bool p0) {
        if ((void($Slider::*)(bool)){&$Slider::setBarVisibility} != (void(D::*)(bool)){&D::setBarVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x18e280))(this, p0);
        else return Slider::setBarVisibility(p0);
    }

    void setValue(float p0) {
        if ((void($Slider::*)(float)){&$Slider::setValue} != (void(D::*)(float)){&D::setValue})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x18e170))(this, p0);
        else return Slider::setValue(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)){&D::create})
            m->registerHook(getBase()+0x18dd80, (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, char const*, char const*, char const*, char const*, float)){&D::create});

        if ((Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)){&D::create})
            m->registerHook(getBase()+0x18dc40, (Slider*(*)(cocos2d::CCNode*, cocos2d::SEL_CallFuncO, float)){&D::create});

        if ((void($Slider::*)()){&$Slider::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18e0c0, extract((void(D::*)()){&D::getValue}));

        if ((void($Slider::*)(bool)){&$Slider::setBarVisibility} != (void(D::*)(bool)){&D::setBarVisibility})
            m->registerHook(getBase()+0x18e280, extract((void(D::*)(bool)){&D::setBarVisibility}));

        if ((void($Slider::*)(float)){&$Slider::setValue} != (void(D::*)(float)){&D::setValue})
            m->registerHook(getBase()+0x18e170, extract((void(D::*)(float)){&D::setValue}));
    }
};


template<class D>
class $SliderThumb : public SliderThumb, public $CacBase {
 public:
    $SliderThumb() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SliderThumb() {}
    typedef SliderThumb* __thistype;

    void getValue() {
        if ((void($SliderThumb::*)()){&$SliderThumb::getValue} != (void(D::*)()){&D::getValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18ce80))(this);
        else return SliderThumb::getValue();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($SliderThumb::*)()){&$SliderThumb::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18ce80, extract((void(D::*)()){&D::getValue}));
    }
};


template<class D>
class $SpawnTriggerAction : public SpawnTriggerAction, public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SpawnTriggerAction() {}
    typedef SpawnTriggerAction* __thistype;

    static SpawnTriggerAction* createFromString(std::string p0) {
        if ((SpawnTriggerAction*(*)(std::string)){&$SpawnTriggerAction::createFromString} != (SpawnTriggerAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<SpawnTriggerAction*(*)(std::string)>(m->getOriginal(getBase()+0x17bf50))(p0);
        else return SpawnTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SpawnTriggerAction*(*)(std::string)){&$SpawnTriggerAction::createFromString} != (SpawnTriggerAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x17bf50, (SpawnTriggerAction*(*)(std::string)){&D::createFromString});
    }
};


template<class D>
class $SpeedObject : public SpeedObject, public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SpeedObject() {}
    typedef SpeedObject* __thistype;

    static SpeedObject* create(GameObject* p0, int p1, float p2) {
        if ((SpeedObject*(*)(GameObject*, int, float)){&$SpeedObject::create} != (SpeedObject*(*)(GameObject*, int, float)){&D::create})
            return reinterpret_cast<SpeedObject*(*)(GameObject*, int, float)>(m->getOriginal(getBase()+0x77450))(p0, p1, p2);
        else return SpeedObject::create(p0, p1, p2);
    }

    bool init(GameObject* p0, int p1, float p2) {
        if ((bool($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init} != (bool(D::*)(GameObject*, int, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
        else return SpeedObject::init(p0, p1, p2);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((SpeedObject*(*)(GameObject*, int, float)){&$SpeedObject::create} != (SpeedObject*(*)(GameObject*, int, float)){&D::create})
            m->registerHook(getBase()+0x77450, (SpeedObject*(*)(GameObject*, int, float)){&D::create});

        if ((bool($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init} != (bool(D::*)(GameObject*, int, float)){&D::init})
            m->registerHook(getBase()+0x77400, extract((bool(D::*)(GameObject*, int, float)){&D::init}));
    }
};


template<class D>
class $TeleportPortalObject : public TeleportPortalObject, public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TeleportPortalObject() {}
    typedef TeleportPortalObject* __thistype;

    static TeleportPortalObject* create(char const* p0) {
        if ((TeleportPortalObject*(*)(char const*)){&$TeleportPortalObject::create} != (TeleportPortalObject*(*)(char const*)){&D::create})
            return reinterpret_cast<TeleportPortalObject*(*)(char const*)>(m->getOriginal(getBase()+0xdaa50))(p0);
        else return TeleportPortalObject::create(p0);
    }

    void getTeleportXOff(cocos2d::CCNode* p0) {
        if ((void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff} != (void(D::*)(cocos2d::CCNode*)){&D::getTeleportXOff})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xdac20))(this, p0);
        else return TeleportPortalObject::getTeleportXOff(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((TeleportPortalObject*(*)(char const*)){&$TeleportPortalObject::create} != (TeleportPortalObject*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0xdaa50, (TeleportPortalObject*(*)(char const*)){&D::create});

        if ((void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff} != (void(D::*)(cocos2d::CCNode*)){&D::getTeleportXOff})
            m->registerHook(getBase()+0xdac20, extract((void(D::*)(cocos2d::CCNode*)){&D::getTeleportXOff}));
    }
};


template<class D>
class $TextArea : public TextArea, public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TextArea() {}
    typedef TextArea* __thistype;

    static TextArea* create(std::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) {
        if ((TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create} != (TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&D::create})
            return reinterpret_cast<TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)>(m->getOriginal(getBase()+0x19eb40))(p0, p1, p2, p3, p4, p5, p6);
        else return TextArea::create(p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create} != (TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&D::create})
            m->registerHook(getBase()+0x19eb40, (TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&D::create});
    }
};


template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TextInputDelegate() {}
    typedef TextInputDelegate* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $ToggleTriggerAction : public ToggleTriggerAction, public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ToggleTriggerAction() {}
    typedef ToggleTriggerAction* __thistype;

    static ToggleTriggerAction* createFromString(std::string p0) {
        if ((ToggleTriggerAction*(*)(std::string)){&$ToggleTriggerAction::createFromString} != (ToggleTriggerAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<ToggleTriggerAction*(*)(std::string)>(m->getOriginal(getBase()+0x1765e0))(p0);
        else return ToggleTriggerAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((ToggleTriggerAction*(*)(std::string)){&$ToggleTriggerAction::createFromString} != (ToggleTriggerAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x1765e0, (ToggleTriggerAction*(*)(std::string)){&D::createFromString});
    }
};


template<class D>
class $TouchToggleAction : public TouchToggleAction, public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$TouchToggleAction() {}
    typedef TouchToggleAction* __thistype;

    static TouchToggleAction* createFromString(std::string p0) {
        if ((TouchToggleAction*(*)(std::string)){&$TouchToggleAction::createFromString} != (TouchToggleAction*(*)(std::string)){&D::createFromString})
            return reinterpret_cast<TouchToggleAction*(*)(std::string)>(m->getOriginal(getBase()+0x177e10))(p0);
        else return TouchToggleAction::createFromString(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((TouchToggleAction*(*)(std::string)){&$TouchToggleAction::createFromString} != (TouchToggleAction*(*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x177e10, (TouchToggleAction*(*)(std::string)){&D::createFromString});
    }
};


template<class D>
class $UILayer : public UILayer, public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$UILayer() {}
    typedef UILayer* __thistype;

    static UILayer* create() {
        if ((UILayer*(*)()){&$UILayer::create} != (UILayer*(*)()){&D::create})
            return reinterpret_cast<UILayer*(*)()>(m->getOriginal(getBase()+0x27fd10))();
        else return UILayer::create();
    }

    void disableMenu() {
        if ((void($UILayer::*)()){&$UILayer::disableMenu} != (void(D::*)()){&D::disableMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280960))(this);
        else return UILayer::disableMenu();
    }

    void enableMenu() {
        if ((void($UILayer::*)()){&$UILayer::enableMenu} != (void(D::*)()){&D::enableMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280940))(this);
        else return UILayer::enableMenu();
    }

    void pCommand(cocos2d::CCNode* p0) {
        if ((void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand} != (void(D::*)(cocos2d::CCNode*)){&D::pCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x280830))(this, p0);
        else return UILayer::pCommand(p0);
    }

    void toggleCheckpointsMenu(bool p0) {
        if ((void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu} != (void(D::*)(bool)){&D::toggleCheckpointsMenu})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x280430))(this, p0);
        else return UILayer::toggleCheckpointsMenu(p0);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((UILayer*(*)()){&$UILayer::create} != (UILayer*(*)()){&D::create})
            m->registerHook(getBase()+0x27fd10, (UILayer*(*)()){&D::create});

        if ((void($UILayer::*)()){&$UILayer::disableMenu} != (void(D::*)()){&D::disableMenu})
            m->registerHook(getBase()+0x280960, extract((void(D::*)()){&D::disableMenu}));

        if ((void($UILayer::*)()){&$UILayer::enableMenu} != (void(D::*)()){&D::enableMenu})
            m->registerHook(getBase()+0x280940, extract((void(D::*)()){&D::enableMenu}));

        if ((void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand} != (void(D::*)(cocos2d::CCNode*)){&D::pCommand})
            m->registerHook(getBase()+0x280830, extract((void(D::*)(cocos2d::CCNode*)){&D::pCommand}));

        if ((void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu} != (void(D::*)(bool)){&D::toggleCheckpointsMenu})
            m->registerHook(getBase()+0x280430, extract((void(D::*)(bool)){&D::toggleCheckpointsMenu}));
    }
};


template<class D>
class $UndoCommand : public UndoCommand, public $CacBase {
 public:
    $UndoCommand() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$UndoCommand() {}
    typedef UndoCommand* __thistype;

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});
    }
};


template<class D>
class $UndoObject : public UndoObject, public $CacBase {
 public:
    $UndoObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$UndoObject() {}
    typedef UndoObject* __thistype;

    static UndoObject* create(GameObject* p0, UndoCommand p1) {
        if ((UndoObject*(*)(GameObject*, UndoCommand)){&$UndoObject::create} != (UndoObject*(*)(GameObject*, UndoCommand)){&D::create})
            return reinterpret_cast<UndoObject*(*)(GameObject*, UndoCommand)>(m->getOriginal(getBase()+0x94ea0))(p0, p1);
        else return UndoObject::create(p0, p1);
    }

    static UndoObject* createWithArray(cocos2d::CCArray* p0, UndoCommand p1) {
        if ((UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray} != (UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&D::createWithArray})
            return reinterpret_cast<UndoObject*(*)(cocos2d::CCArray*, UndoCommand)>(m->getOriginal(getBase()+0x96ee0))(p0, p1);
        else return UndoObject::createWithArray(p0, p1);
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((UndoObject*(*)(GameObject*, UndoCommand)){&$UndoObject::create} != (UndoObject*(*)(GameObject*, UndoCommand)){&D::create})
            m->registerHook(getBase()+0x94ea0, (UndoObject*(*)(GameObject*, UndoCommand)){&D::create});

        if ((UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray} != (UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&D::createWithArray})
            m->registerHook(getBase()+0x96ee0, (UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&D::createWithArray});
    }
};


template<class D>
class $ColorSelectPopup : public ColorSelectPopup, public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$ColorSelectPopup() {}
    typedef ColorSelectPopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3B p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x423320))(this, p0);
        else return ColorSelectPopup::colorValueChanged(p0);
    }

    static ColorSelectPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create} != (ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41eb70))(p0, p1);
        else return ColorSelectPopup::create(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) {
        if ((bool($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
        else return ColorSelectPopup::init(p0, p1, p2);
    }

    void onDefault(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault} != (void(D::*)(cocos2d::CCObject*)){&D::onDefault})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
        else return ColorSelectPopup::onDefault(p0);
    }

    void onMultiTrigger(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onMultiTrigger})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422680))(this, p0);
        else return ColorSelectPopup::onMultiTrigger(p0);
    }

    void onPlayerColor1(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor1})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422500))(this, p0);
        else return ColorSelectPopup::onPlayerColor1(p0);
    }

    void onPlayerColor2(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
        else return ColorSelectPopup::onPlayerColor2(p0);
    }

    void onSpawnedByTrigger(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onSpawnedByTrigger})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
        else return ColorSelectPopup::onSpawnedByTrigger(p0);
    }

    void onToggleHSVMode(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode} != (void(D::*)(cocos2d::CCObject*)){&D::onToggleHSVMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
        else return ColorSelectPopup::onToggleHSVMode(p0);
    }

    void onTouchTriggered(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered} != (void(D::*)(cocos2d::CCObject*)){&D::onTouchTriggered})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
        else return ColorSelectPopup::onTouchTriggered(p0);
    }

    void show() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423570))(this);
        else return ColorSelectPopup::show();
    }

    void sliderChanged(cocos2d::CCObject* p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged} != (void(D::*)(cocos2d::CCObject*)){&D::sliderChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
        else return ColorSelectPopup::sliderChanged(p0);
    }

    void updateCopyColor() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor} != (void(D::*)()){&D::updateCopyColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423b70))(this);
        else return ColorSelectPopup::updateCopyColor();
    }

    void updateCopyColorTextInputLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422ed0))(this);
        else return ColorSelectPopup::updateCopyColorTextInputLabel();
    }

    void updateDurLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel} != (void(D::*)()){&D::updateDurLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x421eb0))(this);
        else return ColorSelectPopup::updateDurLabel();
    }

    void updateHSVMode() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode} != (void(D::*)()){&D::updateHSVMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422e00))(this);
        else return ColorSelectPopup::updateHSVMode();
    }

    void updateOpacityLabel() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel} != (void(D::*)()){&D::updateOpacityLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422000))(this);
        else return ColorSelectPopup::updateOpacityLabel();
    }

    void updateTouchTriggered() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered} != (void(D::*)()){&D::updateTouchTriggered})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423020))(this);
        else return ColorSelectPopup::updateTouchTriggered();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(getBase()+0x423320, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create} != (ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x41eb70, (ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&D::init})
            m->registerHook(getBase()+0x41ee70, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&D::init}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault} != (void(D::*)(cocos2d::CCObject*)){&D::onDefault})
            m->registerHook(getBase()+0x4220e0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDefault}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onMultiTrigger})
            m->registerHook(getBase()+0x422680, extract((void(D::*)(cocos2d::CCObject*)){&D::onMultiTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor1})
            m->registerHook(getBase()+0x422500, extract((void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor1}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor2})
            m->registerHook(getBase()+0x4225c0, extract((void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor2}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onSpawnedByTrigger})
            m->registerHook(getBase()+0x4227f0, extract((void(D::*)(cocos2d::CCObject*)){&D::onSpawnedByTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode} != (void(D::*)(cocos2d::CCObject*)){&D::onToggleHSVMode})
            m->registerHook(getBase()+0x4227b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onToggleHSVMode}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered} != (void(D::*)(cocos2d::CCObject*)){&D::onTouchTriggered})
            m->registerHook(getBase()+0x4228b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTouchTriggered}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x423570, extract((void(D::*)()){&D::show}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged} != (void(D::*)(cocos2d::CCObject*)){&D::sliderChanged})
            m->registerHook(getBase()+0x421ca0, extract((void(D::*)(cocos2d::CCObject*)){&D::sliderChanged}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor} != (void(D::*)()){&D::updateCopyColor})
            m->registerHook(getBase()+0x423b70, extract((void(D::*)()){&D::updateCopyColor}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x422ed0, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel} != (void(D::*)()){&D::updateDurLabel})
            m->registerHook(getBase()+0x421eb0, extract((void(D::*)()){&D::updateDurLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode} != (void(D::*)()){&D::updateHSVMode})
            m->registerHook(getBase()+0x422e00, extract((void(D::*)()){&D::updateHSVMode}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel} != (void(D::*)()){&D::updateOpacityLabel})
            m->registerHook(getBase()+0x422000, extract((void(D::*)()){&D::updateOpacityLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered} != (void(D::*)()){&D::updateTouchTriggered})
            m->registerHook(getBase()+0x423020, extract((void(D::*)()){&D::updateTouchTriggered}));
    }
};


template<class D>
class $SetupPulsePopup : public SetupPulsePopup, public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    ~$SetupPulsePopup() {}
    typedef SetupPulsePopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3B p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
        else return SetupPulsePopup::colorValueChanged(p0);
    }

    static SetupPulsePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create} != (SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            return reinterpret_cast<SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e6d40))(p0, p1);
        else return SetupPulsePopup::create(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        if ((bool($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
        else return SetupPulsePopup::init(p0, p1);
    }

    void onSelectPulseMode(cocos2d::CCObject* p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectPulseMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
        else return SetupPulsePopup::onSelectPulseMode(p0);
    }

    void onSelectTargetMode(cocos2d::CCObject* p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectTargetMode})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eac30))(this, p0);
        else return SetupPulsePopup::onSelectTargetMode(p0);
    }

    void onUpdateCustomColor(cocos2d::CCObject* p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateCustomColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eaef0))(this, p0);
        else return SetupPulsePopup::onUpdateCustomColor(p0);
    }

    void textChanged(CCTextInputNode* p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1ec960))(this, p0);
        else return SetupPulsePopup::textChanged(p0);
    }

    void updateCopyColorTextInputLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebf20))(this);
        else return SetupPulsePopup::updateCopyColorTextInputLabel();
    }

    void updateEditorLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ec310))(this);
        else return SetupPulsePopup::updateEditorLabel();
    }

    void updateFadeOutLabel(bool p0) {
        if ((void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel} != (void(D::*)(bool)){&D::updateFadeOutLabel})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
        else return SetupPulsePopup::updateFadeOutLabel(p0);
    }

    void updateTargetID() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebbe0))(this);
        else return SetupPulsePopup::updateTargetID();
    }

    void updateTextInputLabel() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1eb8d0))(this);
        else return SetupPulsePopup::updateTextInputLabel();
    }

    void apply_hooks() override {
    m->registerHook(extract_destructor(this), +[](){});

        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(getBase()+0x1ec680, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create} != (SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1e6d40, (SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x1e7010, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectPulseMode})
            m->registerHook(getBase()+0x1eb020, extract((void(D::*)(cocos2d::CCObject*)){&D::onSelectPulseMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectTargetMode})
            m->registerHook(getBase()+0x1eac30, extract((void(D::*)(cocos2d::CCObject*)){&D::onSelectTargetMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateCustomColor})
            m->registerHook(getBase()+0x1eaef0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateCustomColor}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1ec960, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x1ebf20, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x1ec310, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel} != (void(D::*)(bool)){&D::updateFadeOutLabel})
            m->registerHook(getBase()+0x1eba20, extract((void(D::*)(bool)){&D::updateFadeOutLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1ebbe0, extract((void(D::*)()){&D::updateTargetID}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x1eb8d0, extract((void(D::*)()){&D::updateTextInputLabel}));
    }
};
