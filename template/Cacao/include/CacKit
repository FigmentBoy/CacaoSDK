//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
using namespace cocos2d::extension;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

void __apply_hooks();
#define APPLY_HOOKS() static int const __cachook = (__apply_hooks(), 0)

#define CONCAT_(x, y) x##y
#define CONCAT(x, y) CONCAT_(x, y)
#define REDIRECT_(base, counter) CONCAT($hook, counter): public base<CONCAT($hook, counter)>
#define REDIRECT(base) REDIRECT_(base, __COUNTER__)

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

// you will be missed extract_virtual o7
template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};

template <typename F>
inline typename GetReturnType<F>::type (*extract(F func))() {
    return reinterpret_cast<typename GetReturnType<F>::type(*)()>(*reinterpret_cast<long*>(&func));
};

class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}

void __apply_hooks() {
    for(auto& i : __cackit::glob) i->apply_hooks();
    m->enable();
}


template<class D>
class $AnimatedGameObject : public AnimatedGameObject, public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef AnimatedGameObject* __thistype;

    void playAnimation(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
    }

    void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0xc8450))(this, p0);
    }

    void apply_hooks() override {
        if ((void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation} != (void(D::*)(int)){&D::playAnimation})
            m->registerHook(getBase()+0xc93d0, extract((void(D::*)(int)){&D::playAnimation}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor})
            m->registerHook(getBase()+0xc8450, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor}));
    }
};


template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
 public:
    $AppDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef AppDelegate* __thistype;

    void bgScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aaab0))(this);
    }

    void get() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aab10))(this);
    }

    void apply_hooks() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            m->registerHook(getBase()+0x3aaab0, extract((void(D::*)()){&D::bgScale}));

        if ((void($AppDelegate::*)()){&$AppDelegate::get} != (void(D::*)()){&D::get})
            m->registerHook(getBase()+0x3aab10, extract((void(D::*)()){&D::get}));
    }
};


template<class D>
class $AudioEffectsLayer : public AudioEffectsLayer, public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef AudioEffectsLayer* __thistype;

    void audioStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x271f40))(this, p0);
    }

    static AudioEffectsLayer* create(std::string p0) {
        return reinterpret_cast<AudioEffectsLayer*(*)(std::string)>(m->getOriginal(getBase()+0x271a00))(p0);
    }

    void resetAudioVars() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x271ee0))(this);
    }

    void apply_hooks() override {
        if ((void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep} != (void(D::*)(float)){&D::audioStep})
            m->registerHook(getBase()+0x271f40, extract((void(D::*)(float)){&D::audioStep}));

        if ((AudioEffectsLayer*(*)(std::string)){&$AudioEffectsLayer::create} != (AudioEffectsLayer*(*)(std::string)){&D::create})
            m->registerHook(getBase()+0x271a00, (AudioEffectsLayer*(*)(std::string)){&D::create});

        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars} != (void(D::*)()){&D::resetAudioVars})
            m->registerHook(getBase()+0x271ee0, extract((void(D::*)()){&D::resetAudioVars}));
    }
};


template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ButtonSprite* __thistype;

    static ButtonSprite* create(char const* p0) {
        return reinterpret_cast<ButtonSprite*(*)(char const*)>(m->getOriginal(getBase()+0x4fa10))(p0);
    }

    static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        return reinterpret_cast<ButtonSprite*(*)(char const*, int, int, float, bool)>(m->getOriginal(getBase()+0x4fa40))(p0, p1, p2, p3, p4);
    }

    void updateBGImage(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x502d0))(this, p0);
    }

    void apply_hooks() override {
        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x4fa10, (ButtonSprite*(*)(char const*)){&D::create});

        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            m->registerHook(getBase()+0x4fa40, (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create});

        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            m->registerHook(getBase()+0x502d0, extract((void(D::*)(char const*)){&D::updateBGImage}));
    }
};


template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimatedSprite* __thistype;

    void runAnimation(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
    }

    void tweenToAnimation(std::string p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation} != (void(D::*)(std::string)){&D::runAnimation})
            m->registerHook(getBase()+0x1a6430, extract((void(D::*)(std::string)){&D::runAnimation}));

        if ((void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation} != (void(D::*)(std::string, float)){&D::tweenToAnimation})
            m->registerHook(getBase()+0x1a65b0, extract((void(D::*)(std::string, float)){&D::tweenToAnimation}));
    }
};


template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCircleWave* __thistype;

    static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool)>(m->getOriginal(getBase()+0xbd270))(p0, p1, p2, p3);
    }

    static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool, bool)>(m->getOriginal(getBase()+0xbd290))(p0, p1, p2, p3, p4);
    }

    void followObject(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
    }

    void updatePosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xbd630))(this, p0);
    }

    void apply_hooks() override {
        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            m->registerHook(getBase()+0xbd270, (CCCircleWave*(*)(float, float, float, bool)){&D::create});

        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            m->registerHook(getBase()+0xbd290, (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create});

        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            m->registerHook(getBase()+0xbd670, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::followObject}));

        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            m->registerHook(getBase()+0xbd630, extract((void(D::*)(float)){&D::updatePosition}));
    }
};


template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLightFlash* __thistype;

    static CCLightFlash* create() {
        return reinterpret_cast<CCLightFlash*(*)()>(m->getOriginal(getBase()+0x295870))();
    }

    void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    void apply_hooks() override {
        if ((CCLightFlash*(*)()){&$CCLightFlash::create} != (CCLightFlash*(*)()){&D::create})
            m->registerHook(getBase()+0x295870, (CCLightFlash*(*)()){&D::create});

        if ((void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect})
            m->registerHook(getBase()+0x295900, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&D::playEffect}));
    }
};


template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemSpriteExtra* __thistype;

    static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1253c0))(p0, p1, p2, p3);
    }

    void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
    }

    void apply_hooks() override {
        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create})
            m->registerHook(getBase()+0x1253c0, (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create});

        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(getBase()+0x1255e0, extract((void(D::*)(float)){&D::setSizeMult}));
    }
};


template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemToggler* __thistype;

    static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x38400))(p0, p1, p2, p3);
    }

    void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x38a40))(this, p0);
    }

    void toggle(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x38950))(this, p0);
    }

    void apply_hooks() override {
        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create})
            m->registerHook(getBase()+0x38400, (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create});

        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(getBase()+0x38a40, extract((void(D::*)(float)){&D::setSizeMult}));

        if ((void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle} != (void(D::*)(bool)){&D::toggle})
            m->registerHook(getBase()+0x38950, extract((void(D::*)(bool)){&D::toggle}));
    }
};


template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
 public:
    $CCMoveCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMoveCNode* __thistype;

    static CCMoveCNode* create() {
        return reinterpret_cast<CCMoveCNode*(*)()>(m->getOriginal(getBase()+0x1842a0))();
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x18b3d0))(this);
    }

    void apply_hooks() override {
        if ((CCMoveCNode*(*)()){&$CCMoveCNode::create} != (CCMoveCNode*(*)()){&D::create})
            m->registerHook(getBase()+0x1842a0, (CCMoveCNode*(*)()){&D::create});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x18b3d0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
 public:
    $CCNodeContainer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNodeContainer* __thistype;

    static CCNodeContainer* create() {
        return reinterpret_cast<CCNodeContainer*(*)()>(m->getOriginal(getBase()+0xb1090))();
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xba950))(this);
    }

    void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xba960))(this);
    }

    void apply_hooks() override {
        if ((CCNodeContainer*(*)()){&$CCNodeContainer::create} != (CCNodeContainer*(*)()){&D::create})
            m->registerHook(getBase()+0xb1090, (CCNodeContainer*(*)()){&D::create});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xba950, extract((bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0xba960, extract((void(D::*)()){&D::visit}));
    }
};


template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpritePlus* __thistype;

    bool initWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x248670))(this, p0);
    }

    void apply_hooks() override {
        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            m->registerHook(getBase()+0x248670, extract((bool(D::*)(char const*)){&D::initWithSpriteFrameName}));
    }
};


template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTextInputNode* __thistype;

    static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)>(m->getOriginal(getBase()+0x5cfb0))(p0, p1, p2, p3, p4, p5);
    }

    void getString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
    }

    void refreshLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d730))(this);
    }

    void setAllowedChars(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d360))(this, p0);
    }

    void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x5da90))(this, p0);
    }

    void setLabelPlaceholderScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da70))(this, p0);
    }

    void setMaxLabelScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da30))(this, p0);
    }

    void setMaxLabelWidth(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da50))(this, p0);
    }

    void setString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
    }

    void updateLabel(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d4a0))(this, p0);
    }

    void apply_hooks() override {
        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            m->registerHook(getBase()+0x5cfb0, (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create});

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (void(D::*)()){&D::getString})
            m->registerHook(getBase()+0x5d6f0, extract((void(D::*)()){&D::getString}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            m->registerHook(getBase()+0x5d730, extract((void(D::*)()){&D::refreshLabel}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::string)){&D::setAllowedChars})
            m->registerHook(getBase()+0x5d360, extract((void(D::*)(std::string)){&D::setAllowedChars}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            m->registerHook(getBase()+0x5da90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            m->registerHook(getBase()+0x5da70, extract((void(D::*)(float)){&D::setLabelPlaceholderScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            m->registerHook(getBase()+0x5da30, extract((void(D::*)(float)){&D::setMaxLabelScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            m->registerHook(getBase()+0x5da50, extract((void(D::*)(float)){&D::setMaxLabelWidth}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString} != (void(D::*)(std::string)){&D::setString})
            m->registerHook(getBase()+0x5d3e0, extract((void(D::*)(std::string)){&D::setString}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::string)){&D::updateLabel})
            m->registerHook(getBase()+0x5d4a0, extract((void(D::*)(std::string)){&D::updateLabel}));
    }
};


template<class D>
class $CheckpointObject : public CheckpointObject, public $CacBase {
 public:
    $CheckpointObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CheckpointObject* __thistype;

    static CheckpointObject* create() {
        return reinterpret_cast<CheckpointObject*(*)()>(m->getOriginal(getBase()+0x7e7d0))();
    }

    void getObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef50))(this);
    }

    void apply_hooks() override {
        if ((CheckpointObject*(*)()){&$CheckpointObject::create} != (CheckpointObject*(*)()){&D::create})
            m->registerHook(getBase()+0x7e7d0, (CheckpointObject*(*)()){&D::create});

        if ((void($CheckpointObject::*)()){&$CheckpointObject::getObject} != (void(D::*)()){&D::getObject})
            m->registerHook(getBase()+0x7ef50, extract((void(D::*)()){&D::getObject}));
    }
};


template<class D>
class $CollisionBlockPopup : public CollisionBlockPopup, public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CollisionBlockPopup* __thistype;

    static CollisionBlockPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x130010))(p0, p1);
    }

    void onNextItemID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x130e60))(this, p0);
    }

    void apply_hooks() override {
        if ((CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create} != (CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x130010, (CollisionBlockPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            m->registerHook(getBase()+0x130e60, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextItemID}));
    }
};


template<class D>
class $CollisionTriggerAction : public CollisionTriggerAction, public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CollisionTriggerAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x176ee0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x176ee0, extract((void(D::*)(std::string)){&D::createFromString}));
    }
};


template<class D>
class $ColorAction : public ColorAction, public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorAction* __thistype;

    void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17d080))(this);
    }

    void setupFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0x17f310))(this, p0);
    }

    void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17f270))(this, p0);
    }

    void apply_hooks() override {
        if ((void($ColorAction::*)()){&$ColorAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17d080, extract((void(D::*)()){&D::getSaveString}));

        if ((void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupFromDict})
            m->registerHook(getBase()+0x17f310, extract((void(D::*)(cocos2d::CCDictionary*)){&D::setupFromDict}));

        if ((void($ColorAction::*)(std::string)){&$ColorAction::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            m->registerHook(getBase()+0x17f270, extract((void(D::*)(std::string)){&D::setupFromString}));
    }
};


template<class D>
class $ColorChannelSprite : public ColorChannelSprite, public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorChannelSprite* __thistype;

    void updateBlending(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x16e1d0))(this, p0);
    }

    void updateCopyLabel(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x16ded0))(this, p0, p1);
    }

    void updateOpacity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x16e080))(this, p0);
    }

    void updateValues(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending} != (void(D::*)(bool)){&D::updateBlending})
            m->registerHook(getBase()+0x16e1d0, extract((void(D::*)(bool)){&D::updateBlending}));

        if ((void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel} != (void(D::*)(int, bool)){&D::updateCopyLabel})
            m->registerHook(getBase()+0x16ded0, extract((void(D::*)(int, bool)){&D::updateCopyLabel}));

        if ((void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity} != (void(D::*)(float)){&D::updateOpacity})
            m->registerHook(getBase()+0x16e080, extract((void(D::*)(float)){&D::updateOpacity}));

        if ((void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues} != (void(D::*)(ColorAction*)){&D::updateValues})
            m->registerHook(getBase()+0x16e2e0, extract((void(D::*)(ColorAction*)){&D::updateValues}));
    }
};


template<class D>
class $ColorSelectPopup : public ColorSelectPopup, public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorSelectPopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x423320))(this, p0);
    }

    static ColorSelectPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41eb70))(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
    }

    void onDefault(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
    }

    void onMultiTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422680))(this, p0);
    }

    void onPlayerColor1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422500))(this, p0);
    }

    void onPlayerColor2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
    }

    void onSpawnedByTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
    }

    void onToggleHSVMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
    }

    void onTouchTriggered(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
    }

    void show() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423570))(this);
    }

    void sliderChanged(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
    }

    void updateCopyColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423b70))(this);
    }

    void updateCopyColorTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422ed0))(this);
    }

    void updateDurLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x421eb0))(this);
    }

    void updateHSVMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422e00))(this);
    }

    void updateOpacityLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422000))(this);
    }

    void updateTouchTriggered() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423020))(this);
    }

    void apply_hooks() override {
        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(getBase()+0x423320, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create} != (ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x41eb70, (ColorSelectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&D::init})
            m->registerHook(getBase()+0x41ee70, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&D::init}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault} != (void(D::*)(cocos2d::CCObject*)){&D::onDefault})
            m->registerHook(getBase()+0x4220e0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDefault}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onMultiTrigger})
            m->registerHook(getBase()+0x422680, extract((void(D::*)(cocos2d::CCObject*)){&D::onMultiTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor1})
            m->registerHook(getBase()+0x422500, extract((void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor1}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2} != (void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor2})
            m->registerHook(getBase()+0x4225c0, extract((void(D::*)(cocos2d::CCObject*)){&D::onPlayerColor2}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger} != (void(D::*)(cocos2d::CCObject*)){&D::onSpawnedByTrigger})
            m->registerHook(getBase()+0x4227f0, extract((void(D::*)(cocos2d::CCObject*)){&D::onSpawnedByTrigger}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode} != (void(D::*)(cocos2d::CCObject*)){&D::onToggleHSVMode})
            m->registerHook(getBase()+0x4227b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onToggleHSVMode}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered} != (void(D::*)(cocos2d::CCObject*)){&D::onTouchTriggered})
            m->registerHook(getBase()+0x4228b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTouchTriggered}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x423570, extract((void(D::*)()){&D::show}));

        if ((void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged} != (void(D::*)(cocos2d::CCObject*)){&D::sliderChanged})
            m->registerHook(getBase()+0x421ca0, extract((void(D::*)(cocos2d::CCObject*)){&D::sliderChanged}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor} != (void(D::*)()){&D::updateCopyColor})
            m->registerHook(getBase()+0x423b70, extract((void(D::*)()){&D::updateCopyColor}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x422ed0, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel} != (void(D::*)()){&D::updateDurLabel})
            m->registerHook(getBase()+0x421eb0, extract((void(D::*)()){&D::updateDurLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode} != (void(D::*)()){&D::updateHSVMode})
            m->registerHook(getBase()+0x422e00, extract((void(D::*)()){&D::updateHSVMode}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel} != (void(D::*)()){&D::updateOpacityLabel})
            m->registerHook(getBase()+0x422000, extract((void(D::*)()){&D::updateOpacityLabel}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered} != (void(D::*)()){&D::updateTouchTriggered})
            m->registerHook(getBase()+0x423020, extract((void(D::*)()){&D::updateTouchTriggered}));
    }
};


template<class D>
class $CountTriggerAction : public CountTriggerAction, public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CountTriggerAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1754f0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x1754f0, extract((void(D::*)(std::string)){&D::createFromString}));
    }
};


template<class D>
class $CreateMenuItem : public CreateMenuItem, public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CreateMenuItem* __thistype;

    static CreateMenuItem* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<CreateMenuItem*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1c580))(p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((CreateMenuItem*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create} != (CreateMenuItem*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create})
            m->registerHook(getBase()+0x1c580, (CreateMenuItem*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&D::create});
    }
};


template<class D>
class $CreatorLayer : public CreatorLayer, public $CacBase {
 public:
    $CreatorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CreatorLayer* __thistype;

    void onMyLevels(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142b70))(this, p0);
    }

    void onSavedLevels(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142860))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onMyLevels})
            m->registerHook(getBase()+0x142b70, extract((void(D::*)(cocos2d::CCObject*)){&D::onMyLevels}));

        if ((void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels} != (void(D::*)(cocos2d::CCObject*)){&D::onSavedLevels})
            m->registerHook(getBase()+0x142860, extract((void(D::*)(cocos2d::CCObject*)){&D::onSavedLevels}));
    }
};


template<class D>
class $CustomizeObjectLayer : public CustomizeObjectLayer, public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CustomizeObjectLayer* __thistype;

    void colorSelectClosed(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xe1050))(this, p0);
    }

    static CustomizeObjectLayer* create(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd340))(p0, p1);
    }

    bool init(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<bool(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1470))(this, p0);
    }

    void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1430))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(getBase()+0xe1050, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create} != (CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0xdd340, (CustomizeObjectLayer*(*)(GameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init} != (bool(D::*)(GameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0xdd560, extract((bool(D::*)(GameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0xe1470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(getBase()+0xe1430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));
    }
};


template<class D>
class $DelayedSpawnNode : public DelayedSpawnNode, public $CacBase {
 public:
    $DelayedSpawnNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DelayedSpawnNode* __thistype;

    static DelayedSpawnNode* create() {
        return reinterpret_cast<DelayedSpawnNode*(*)()>(m->getOriginal(getBase()+0x9b360))();
    }

    void apply_hooks() override {
        if ((DelayedSpawnNode*(*)()){&$DelayedSpawnNode::create} != (DelayedSpawnNode*(*)()){&D::create})
            m->registerHook(getBase()+0x9b360, (DelayedSpawnNode*(*)()){&D::create});
    }
};


template<class D>
class $DialogLayer : public DialogLayer, public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DialogLayer* __thistype;

    static DialogLayer* create(DialogObject* p0, int p1) {
        return reinterpret_cast<DialogLayer*(*)(DialogObject*, int)>(m->getOriginal(getBase()+0x2047c0))(p0, p1);
    }

    void apply_hooks() override {
        if ((DialogLayer*(*)(DialogObject*, int)){&$DialogLayer::create} != (DialogLayer*(*)(DialogObject*, int)){&D::create})
            m->registerHook(getBase()+0x2047c0, (DialogLayer*(*)(DialogObject*, int)){&D::create});
    }
};


template<class D>
class $DialogObject : public DialogObject, public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DialogObject* __thistype;

    static DialogObject* create(std::string p0, std::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) {
        return reinterpret_cast<DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x204410))(p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create} != (DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&D::create})
            m->registerHook(getBase()+0x204410, (DialogObject*(*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&D::create});
    }
};


template<class D>
class $DrawGridLayer : public DrawGridLayer, public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef DrawGridLayer* __thistype;

    void addPlayer2Point(cocos2d::CCPoint p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
    }

    void addPlayerPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
    }

    void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x99900))(this, p0);
    }

    static DrawGridLayer* create(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0x920c0))(p0, p1);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa3c40))(this);
    }

    bool init(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa36e0))(this, p0, p1);
    }

    void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9b330))(this, p0);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa3b30))(this, p0);
    }

    void updateTimeMarkers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92950))(this);
    }

    void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c830))(this, p0);
    }

    void apply_hooks() override {
        if ((void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point} != (void(D::*)(cocos2d::CCPoint, bool)){&D::addPlayer2Point})
            m->registerHook(getBase()+0xa25b0, extract((void(D::*)(cocos2d::CCPoint, bool)){&D::addPlayer2Point}));

        if ((void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPlayerPoint})
            m->registerHook(getBase()+0xa39c0, extract((void(D::*)(cocos2d::CCPoint)){&D::addPlayerPoint}));

        if ((void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x99900, extract((void(D::*)(GameObject*)){&D::addToSpeedObjects}));

        if ((DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create} != (DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x920c0, (DrawGridLayer*(*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::create});

        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0xa3c40, extract((void(D::*)()){&D::draw}));

        if ((bool($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init} != (bool(D::*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::init})
            m->registerHook(getBase()+0xa36e0, extract((bool(D::*)(cocos2d::CCNode*, LevelEditorLayer*)){&D::init}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x9b330, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0xa3b30, extract((void(D::*)(float)){&D::update}));

        if ((void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers} != (void(D::*)()){&D::updateTimeMarkers})
            m->registerHook(getBase()+0x92950, extract((void(D::*)()){&D::updateTimeMarkers}));

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c830, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $EditButtonBar : public EditButtonBar, public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditButtonBar* __thistype;

    void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems})
            m->registerHook(getBase()+0x351010, extract((void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems}));
    }
};


template<class D>
class $EditorOptionsLayer : public EditorOptionsLayer, public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorOptionsLayer* __thistype;

    void onButtonsPerRow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x147b30))(this, p0);
    }

    void apply_hooks() override {
        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow} != (void(D::*)(cocos2d::CCObject*)){&D::onButtonsPerRow})
            m->registerHook(getBase()+0x147b30, extract((void(D::*)(cocos2d::CCObject*)){&D::onButtonsPerRow}));
    }
};


template<class D>
class $EditorPauseLayer : public EditorPauseLayer, public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorPauseLayer* __thistype;

    static EditorPauseLayer* create(LevelEditorLayer* p0) {
        return reinterpret_cast<EditorPauseLayer*(*)(LevelEditorLayer*)>(m->getOriginal(getBase()+0x13c680))(p0);
    }

    void saveLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
    }

    void apply_hooks() override {
        if ((EditorPauseLayer*(*)(LevelEditorLayer*)){&$EditorPauseLayer::create} != (EditorPauseLayer*(*)(LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x13c680, (EditorPauseLayer*(*)(LevelEditorLayer*)){&D::create});

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel} != (void(D::*)()){&D::saveLevel})
            m->registerHook(getBase()+0x13ebd0, extract((void(D::*)()){&D::saveLevel}));
    }
};


template<class D>
class $EditorUI : public EditorUI, public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorUI* __thistype;

    void constrainGameLayerPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c6d0))(this);
    }

    static EditorUI* create(LevelEditorLayer* p0) {
        return reinterpret_cast<EditorUI*(*)(LevelEditorLayer*)>(m->getOriginal(getBase()+0x8a80))(p0);
    }

    void deselectAll() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
    }

    void disableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
    }

    void editButtonUsable() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28f30))(this);
    }

    void editObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x195a0))(this, p0);
    }

    void enableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
    }

    void getCreateBtn(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
    }

    void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
    }

    void getSelectedObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
    }

    bool init(LevelEditorLayer* p0) {
        return reinterpret_cast<bool(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8ae0))(this, p0);
    }

    void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x30790))(this, p0);
    }

    void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
    }

    void onDuplicate(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
    }

    void pasteObjects(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x232d0))(this, p0);
    }

    void playtestStopped() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24790))(this);
    }

    void redoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
    }

    void replaceGroupID(GameObject* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, int)>(m->getOriginal(getBase()+0x27470))(this, p0, p1, p2);
    }

    void scaleChanged(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x25490))(this, p0);
    }

    void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
    }

    void selectObjects(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
    }

    void setupCreateMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xcb50))(this);
    }

    void undoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb830))(this, p0);
    }

    void updateButtons() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
    }

    void updateObjectInfoLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cb10))(this);
    }

    void updateSlider() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18a90))(this);
    }

    void updateZoom(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x248c0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            m->registerHook(getBase()+0x1c6d0, extract((void(D::*)()){&D::constrainGameLayerPosition}));

        if ((EditorUI*(*)(LevelEditorLayer*)){&$EditorUI::create} != (EditorUI*(*)(LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0x8a80, (EditorUI*(*)(LevelEditorLayer*)){&D::create});

        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            m->registerHook(getBase()+0x1f300, extract((void(D::*)()){&D::deselectAll}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem*)){&D::disableButton})
            m->registerHook(getBase()+0x1c0f0, extract((void(D::*)(CreateMenuItem*)){&D::disableButton}));

        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            m->registerHook(getBase()+0x28f30, extract((void(D::*)()){&D::editButtonUsable}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject*)){&D::editObject})
            m->registerHook(getBase()+0x195a0, extract((void(D::*)(cocos2d::CCObject*)){&D::editObject}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem*)){&D::enableButton})
            m->registerHook(getBase()+0x1bff0, extract((void(D::*)(CreateMenuItem*)){&D::enableButton}));

        if ((void($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn} != (void(D::*)(int, int)){&D::getCreateBtn})
            m->registerHook(getBase()+0x1f6c0, extract((void(D::*)(int, int)){&D::getCreateBtn}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter})
            m->registerHook(getBase()+0x23470, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter}));

        if ((void($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (void(D::*)()){&D::getSelectedObjects})
            m->registerHook(getBase()+0x23f30, extract((void(D::*)()){&D::getSelectedObjects}));

        if ((bool($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init} != (bool(D::*)(LevelEditorLayer*)){&D::init})
            m->registerHook(getBase()+0x8ae0, extract((bool(D::*)(LevelEditorLayer*)){&D::init}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(getBase()+0x30790, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject})
            m->registerHook(getBase()+0x24b10, extract((void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject*)){&D::onDuplicate})
            m->registerHook(getBase()+0x18ba0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDuplicate}));

        if ((void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects} != (void(D::*)(std::string)){&D::pasteObjects})
            m->registerHook(getBase()+0x232d0, extract((void(D::*)(std::string)){&D::pasteObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            m->registerHook(getBase()+0x24790, extract((void(D::*)()){&D::playtestStopped}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::redoLastAction})
            m->registerHook(getBase()+0xb8e0, extract((void(D::*)(cocos2d::CCObject*)){&D::redoLastAction}));

        if ((void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject*, int, int)){&D::replaceGroupID})
            m->registerHook(getBase()+0x27470, extract((void(D::*)(GameObject*, int, int)){&D::replaceGroupID}));

        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            m->registerHook(getBase()+0x25490, extract((void(D::*)(float)){&D::scaleChanged}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects})
            m->registerHook(getBase()+0x252e0, extract((void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects})
            m->registerHook(getBase()+0x23940, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            m->registerHook(getBase()+0xcb50, extract((void(D::*)()){&D::setupCreateMenu}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::undoLastAction})
            m->registerHook(getBase()+0xb830, extract((void(D::*)(cocos2d::CCObject*)){&D::undoLastAction}));

        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            m->registerHook(getBase()+0x1a300, extract((void(D::*)()){&D::updateButtons}));

        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            m->registerHook(getBase()+0x1cb10, extract((void(D::*)()){&D::updateObjectInfoLabel}));

        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            m->registerHook(getBase()+0x18a90, extract((void(D::*)()){&D::updateSlider}));

        if ((void($EditorUI::*)(float)){&$EditorUI::updateZoom} != (void(D::*)(float)){&D::updateZoom})
            m->registerHook(getBase()+0x248c0, extract((void(D::*)(float)){&D::updateZoom}));
    }
};


template<class D>
class $EffectGameObject : public EffectGameObject, public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EffectGameObject* __thistype;

    static EffectGameObject* create(char const* p0) {
        return reinterpret_cast<EffectGameObject*(*)(char const*)>(m->getOriginal(getBase()+0xc9790))(p0);
    }

    void getTargetColorIndex() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xca1f0))(this);
    }

    void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
    }

    void apply_hooks() override {
        if ((EffectGameObject*(*)(char const*)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0xc9790, (EffectGameObject*(*)(char const*)){&D::create});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            m->registerHook(getBase()+0xca1f0, extract((void(D::*)()){&D::getTargetColorIndex}));

        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(getBase()+0xc9870, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));
    }
};


template<class D>
class $EndLevelLayer : public EndLevelLayer, public $CacBase {
 public:
    $EndLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EndLevelLayer* __thistype;

    static EndLevelLayer* create() {
        return reinterpret_cast<EndLevelLayer*(*)()>(m->getOriginal(getBase()+0x2787d0))();
    }

    void apply_hooks() override {
        if ((EndLevelLayer*(*)()){&$EndLevelLayer::create} != (EndLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x2787d0, (EndLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $EndPortalObject : public EndPortalObject, public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EndPortalObject* __thistype;

    static EndPortalObject* create() {
        return reinterpret_cast<EndPortalObject*(*)()>(m->getOriginal(getBase()+0x1da8f0))();
    }

    void updateColors(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
    }

    void apply_hooks() override {
        if ((EndPortalObject*(*)()){&$EndPortalObject::create} != (EndPortalObject*(*)()){&D::create})
            m->registerHook(getBase()+0x1da8f0, (EndPortalObject*(*)()){&D::create});

        if ((void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColors})
            m->registerHook(getBase()+0x1dacb0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateColors}));
    }
};


template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef FLAlertLayer* __thistype;

    void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
    }

    void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
    }

    void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
    }

    void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(getBase()+0x25e0e0))(p0, p1, p2, p3, p4, p5);
    }

    static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25dec0))(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    bool init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<bool(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25ed90))(this);
    }

    void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
    }

    void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f350))(this);
    }

    void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f2e0))(this);
    }

    void show() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f120))(this);
    }

    void apply_hooks() override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(getBase()+0x25ee40, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(getBase()+0x25f020, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(getBase()+0x25ef60, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(getBase()+0x25f0a0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create})
            m->registerHook(getBase()+0x25e0e0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create});

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create})
            m->registerHook(getBase()+0x25dec0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create});

        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init})
            m->registerHook(getBase()+0x25e1b0, extract((bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x25ed90, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(getBase()+0x25ece0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(getBase()+0x25f350, extract((void(D::*)()){&D::onEnter}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x25f2e0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(getBase()+0x25f120, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $FMODAudioEngine : public FMODAudioEngine, public $CacBase {
 public:
    $FMODAudioEngine() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef FMODAudioEngine* __thistype;

    void fadeBackgroundMusic(bool p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, float)>(m->getOriginal(getBase()+0x20fd50))(this, p0, p1);
    }

    void getBackgroundMusicVolume() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2104a0))(this);
    }

    void isBackgroundMusicPlaying() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20feb0))(this);
    }

    void pauseAllEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x210420))(this);
    }

    void pauseBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20fdd0))(this);
    }

    void resumeAllEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x210440))(this);
    }

    void resumeBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20fdf0))(this);
    }

    void setBackgroundMusicTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x20fe10))(this, p0);
    }

    void sharedEngine() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20ef80))(this);
    }

    void apply_hooks() override {
        if ((void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic} != (void(D::*)(bool, float)){&D::fadeBackgroundMusic})
            m->registerHook(getBase()+0x20fd50, extract((void(D::*)(bool, float)){&D::fadeBackgroundMusic}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::getBackgroundMusicVolume} != (void(D::*)()){&D::getBackgroundMusicVolume})
            m->registerHook(getBase()+0x2104a0, extract((void(D::*)()){&D::getBackgroundMusicVolume}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::isBackgroundMusicPlaying} != (void(D::*)()){&D::isBackgroundMusicPlaying})
            m->registerHook(getBase()+0x20feb0, extract((void(D::*)()){&D::isBackgroundMusicPlaying}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseAllEffects} != (void(D::*)()){&D::pauseAllEffects})
            m->registerHook(getBase()+0x210420, extract((void(D::*)()){&D::pauseAllEffects}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseBackgroundMusic} != (void(D::*)()){&D::pauseBackgroundMusic})
            m->registerHook(getBase()+0x20fdd0, extract((void(D::*)()){&D::pauseBackgroundMusic}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeAllEffects} != (void(D::*)()){&D::resumeAllEffects})
            m->registerHook(getBase()+0x210440, extract((void(D::*)()){&D::resumeAllEffects}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeBackgroundMusic} != (void(D::*)()){&D::resumeBackgroundMusic})
            m->registerHook(getBase()+0x20fdf0, extract((void(D::*)()){&D::resumeBackgroundMusic}));

        if ((void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime} != (void(D::*)(float)){&D::setBackgroundMusicTime})
            m->registerHook(getBase()+0x20fe10, extract((void(D::*)(float)){&D::setBackgroundMusicTime}));

        if ((void($FMODAudioEngine::*)()){&$FMODAudioEngine::sharedEngine} != (void(D::*)()){&D::sharedEngine})
            m->registerHook(getBase()+0x20ef80, extract((void(D::*)()){&D::sharedEngine}));
    }
};


template<class D>
class $FollowRewardPage : public FollowRewardPage, public $CacBase {
 public:
    $FollowRewardPage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef FollowRewardPage* __thistype;

    static FollowRewardPage* create() {
        return reinterpret_cast<FollowRewardPage*(*)()>(m->getOriginal(getBase()+0x22f140))();
    }

    void apply_hooks() override {
        if ((FollowRewardPage*(*)()){&$FollowRewardPage::create} != (FollowRewardPage*(*)()){&D::create})
            m->registerHook(getBase()+0x22f140, (FollowRewardPage*(*)()){&D::create});
    }
};


template<class D>
class $GJAccountManager : public GJAccountManager, public $CacBase {
 public:
    $GJAccountManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJAccountManager* __thistype;

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x85070))(this);
    }

    void apply_hooks() override {
        if ((void($GJAccountManager::*)()){&$GJAccountManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x85070, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $GJBaseGameLayer : public GJBaseGameLayer, public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJBaseGameLayer* __thistype;

    void addObjectCounter(LabelGameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
    }

    void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
    }

    void addToGroups(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
    }

    void addToSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
    }

    void atlasValue(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
    }

    void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
    }

    void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
    }

    void checkSpawnObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6f90))(this);
    }

    void collectItem(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
    }

    void collectedObject(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
    }

    void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void createTextLayers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb5260))(this);
    }

    void damagingObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb6140))(this, p0);
    }

    void enableHighCapacityMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb11e0))(this);
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
    }

    void getCapacityString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb2210))(this);
    }

    void getGroundHeightForMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6630))(this, p0);
    }

    void getGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
    }

    void getMoveDeltaForObjects(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
    }

    void getOptimizedGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7940))(this, p0);
    }

    void getStaticGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xafc90))(this);
    }

    void isGroupDisabledForObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
    }

    void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
    }

    void loadUpToPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xba680))(this, p0);
    }

    void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
    }

    void objectTriggered(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
    }

    void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
    }

    void optimizeMoveGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb96c0))(this);
    }

    void parentForZLayer(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
    }

    void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
    }

    void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
    }

    void processFollowActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8fd0))(this);
    }

    void processMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb86c0))(this);
    }

    void processMoveActionsStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
    }

    void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
    }

    void processPlayerFollowActions(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
    }

    void processRotationActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb7fd0))(this);
    }

    void pushButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
    }

    void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
    }

    void refreshCounterLabels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9fc0))(this);
    }

    void releaseButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
    }

    void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
    }

    void removeFromGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
    }

    void removeObjectFromSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
    }

    void reorderObjectSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
    }

    void resetGroupCounters(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba300))(this, p0);
    }

    void resetMoveOptimizedValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9670))(this);
    }

    void sectionForPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb6120))(this, p0);
    }

    void setupLayers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xaffe0))(this);
    }

    void shouldExitHackedLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb1100))(this);
    }

    void spawnGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7050))(this, p0);
    }

    void spawnGroupTriggered(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
    }

    void staticObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
    }

    void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
    }

    void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
    }

    void toggleGroupTriggered(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
    }

    void togglePlayerVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba910))(this, p0);
    }

    void triggerMoveCommand(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
    }

    void updateCollisionBlocks() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6a30))(this);
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateCounters(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
    }

    void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
    }

    void updateLayerCapacity(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0xb1680))(this, p0);
    }

    void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
    }

    void updateOBB2(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
    }

    void updateQueuedLabels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9f30))(this);
    }

    void apply_hooks() override {
        if ((void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject*, int)){&D::addObjectCounter})
            m->registerHook(getBase()+0xb9eb0, extract((void(D::*)(LabelGameObject*, int)){&D::addObjectCounter}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(getBase()+0xb77f0, extract((void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject*, bool)){&D::addToGroups})
            m->registerHook(getBase()+0xb7780, extract((void(D::*)(GameObject*, bool)){&D::addToGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            m->registerHook(getBase()+0xb7b70, extract((void(D::*)(GameObject*)){&D::addToSection}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(int)){&D::atlasValue})
            m->registerHook(getBase()+0xb21e0, extract((void(D::*)(int)){&D::atlasValue}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer})
            m->registerHook(getBase()+0xb6860, extract((void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0xba9a0, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues})
            m->registerHook(getBase()+0xb5be0, extract((void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            m->registerHook(getBase()+0xb6f90, extract((void(D::*)()){&D::checkSpawnObjects}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem} != (void(D::*)(int, int)){&D::collectItem})
            m->registerHook(getBase()+0xb9e20, extract((void(D::*)(int, int)){&D::collectItem}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject*)){&D::collectedObject})
            m->registerHook(getBase()+0xb9b60, extract((void(D::*)(EffectGameObject*)){&D::collectedObject}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(getBase()+0xb73a0, extract((void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            m->registerHook(getBase()+0xb5260, extract((void(D::*)()){&D::createTextLayers}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect})
            m->registerHook(getBase()+0xb6140, extract((void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            m->registerHook(getBase()+0xb11e0, extract((void(D::*)()){&D::enableHighCapacityMode}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0xba990, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            m->registerHook(getBase()+0xb2210, extract((void(D::*)()){&D::getCapacityString}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(int)){&D::getGroundHeightForMode})
            m->registerHook(getBase()+0xb6630, extract((void(D::*)(int)){&D::getGroundHeightForMode}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup} != (void(D::*)(int)){&D::getGroup})
            m->registerHook(getBase()+0xb6f20, extract((void(D::*)(int)){&D::getGroup}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(int, int)){&D::getMoveDeltaForObjects})
            m->registerHook(getBase()+0xb6db0, extract((void(D::*)(int, int)){&D::getMoveDeltaForObjects}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(int)){&D::getOptimizedGroup})
            m->registerHook(getBase()+0xb7940, extract((void(D::*)(int)){&D::getOptimizedGroup}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(int)){&D::getStaticGroup})
            m->registerHook(getBase()+0xb79a0, extract((void(D::*)(int)){&D::getStaticGroup}));

        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xafc90, extract((bool(D::*)()){&D::init}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject*)){&D::isGroupDisabledForObject})
            m->registerHook(getBase()+0xb5cc0, extract((void(D::*)(GameObject*)){&D::isGroupDisabledForObject}));

        if ((void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull})
            m->registerHook(getBase()+0xb5de0, extract((void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(float)){&D::loadUpToPosition})
            m->registerHook(getBase()+0xba680, extract((void(D::*)(float)){&D::loadUpToPosition}));

        if ((void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle})
            m->registerHook(getBase()+0xb66e0, extract((void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject*)){&D::objectTriggered})
            m->registerHook(getBase()+0xb71b0, extract((void(D::*)(EffectGameObject*)){&D::objectTriggered}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(getBase()+0xb6d90, extract((void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            m->registerHook(getBase()+0xb96c0, extract((void(D::*)()){&D::optimizeMoveGroups}));

        if ((void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(int, bool, int)){&D::parentForZLayer})
            m->registerHook(getBase()+0xb55d0, extract((void(D::*)(int, bool, int)){&D::parentForZLayer}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing})
            m->registerHook(getBase()+0xb69e0, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject})
            m->registerHook(getBase()+0xb5a90, extract((void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            m->registerHook(getBase()+0xb8fd0, extract((void(D::*)()){&D::processFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            m->registerHook(getBase()+0xb86c0, extract((void(D::*)()){&D::processMoveActions}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(float)){&D::processMoveActionsStep})
            m->registerHook(getBase()+0xb7ea0, extract((void(D::*)(float)){&D::processMoveActionsStep}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject})
            m->registerHook(getBase()+0xb5ae0, extract((void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(float)){&D::processPlayerFollowActions})
            m->registerHook(getBase()+0xb8b50, extract((void(D::*)(float)){&D::processPlayerFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            m->registerHook(getBase()+0xb7fd0, extract((void(D::*)()){&D::processRotationActions}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton} != (void(D::*)(int, bool)){&D::pushButton})
            m->registerHook(getBase()+0xb9920, extract((void(D::*)(int, bool)){&D::pushButton}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle})
            m->registerHook(getBase()+0xb6470, extract((void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            m->registerHook(getBase()+0xb9fc0, extract((void(D::*)()){&D::refreshCounterLabels}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(int, bool)){&D::releaseButton})
            m->registerHook(getBase()+0xb9a00, extract((void(D::*)(int, bool)){&D::releaseButton}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(getBase()+0xb7a60, extract((void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject*)){&D::removeFromGroups})
            m->registerHook(getBase()+0xb7a00, extract((void(D::*)(GameObject*)){&D::removeFromGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject*)){&D::removeObjectFromSection})
            m->registerHook(getBase()+0xb7e00, extract((void(D::*)(GameObject*)){&D::removeObjectFromSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject*)){&D::reorderObjectSection})
            m->registerHook(getBase()+0xb7cb0, extract((void(D::*)(GameObject*)){&D::reorderObjectSection}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(bool)){&D::resetGroupCounters})
            m->registerHook(getBase()+0xba300, extract((void(D::*)(bool)){&D::resetGroupCounters}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            m->registerHook(getBase()+0xb9670, extract((void(D::*)()){&D::resetMoveOptimizedValue}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(float)){&D::sectionForPos})
            m->registerHook(getBase()+0xb6120, extract((void(D::*)(float)){&D::sectionForPos}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            m->registerHook(getBase()+0xaffe0, extract((void(D::*)()){&D::setupLayers}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            m->registerHook(getBase()+0xb1100, extract((void(D::*)()){&D::shouldExitHackedLevel}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            m->registerHook(getBase()+0xb7050, extract((void(D::*)(int)){&D::spawnGroup}));

        if ((void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(int, float, int)){&D::spawnGroupTriggered})
            m->registerHook(getBase()+0xb7020, extract((void(D::*)(int, float, int)){&D::spawnGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect})
            m->registerHook(getBase()+0xb5f90, extract((void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect}));

        if ((void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger})
            m->registerHook(getBase()+0xb9ae0, extract((void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            m->registerHook(getBase()+0xb75f0, extract((void(D::*)(int, bool)){&D::toggleGroup}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            m->registerHook(getBase()+0xb75a0, extract((void(D::*)(int, bool)){&D::toggleGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(bool)){&D::togglePlayerVisibility})
            m->registerHook(getBase()+0xba910, extract((void(D::*)(bool)){&D::togglePlayerVisibility}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject*)){&D::triggerMoveCommand})
            m->registerHook(getBase()+0xb7290, extract((void(D::*)(EffectGameObject*)){&D::triggerMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            m->registerHook(getBase()+0xb6a30, extract((void(D::*)()){&D::updateCollisionBlocks}));

        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0xb7420, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(int, int)){&D::updateCounters})
            m->registerHook(getBase()+0xb9bc0, extract((void(D::*)(int, int)){&D::updateCounters}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos})
            m->registerHook(getBase()+0xb95b0, extract((void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos}));

        if ((void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::string)){&D::updateLayerCapacity})
            m->registerHook(getBase()+0xb1680, extract((void(D::*)(std::string)){&D::updateLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity})
            m->registerHook(getBase()+0xb1590, extract((void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRect)){&D::updateOBB2})
            m->registerHook(getBase()+0xb63f0, extract((void(D::*)(cocos2d::CCRect)){&D::updateOBB2}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            m->registerHook(getBase()+0xb9f30, extract((void(D::*)()){&D::updateQueuedLabels}));
    }
};


template<class D>
class $GJColorSetupLayer : public GJColorSetupLayer, public $CacBase {
 public:
    $GJColorSetupLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJColorSetupLayer* __thistype;

    void updateSpriteColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xefe50))(this);
    }

    void apply_hooks() override {
        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors} != (void(D::*)()){&D::updateSpriteColors})
            m->registerHook(getBase()+0xefe50, extract((void(D::*)()){&D::updateSpriteColors}));
    }
};


template<class D>
class $GJDropDownLayer : public GJDropDownLayer, public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJDropDownLayer* __thistype;

    static GJDropDownLayer* create(char const* p0) {
        return reinterpret_cast<GJDropDownLayer*(*)(char const*)>(m->getOriginal(getBase()+0x352530))(p0);
    }

    void customSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352570))(this);
    }

    void disableUI() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352580))(this);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352910))(this);
    }

    void enableUI() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525a0))(this);
    }

    void enterAnimFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528a0))(this);
    }

    void enterLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525c0))(this);
    }

    void exitLayer(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x352670))(this, p0);
    }

    void hideLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
    }

    bool init(char const* p0, float p1) {
        return reinterpret_cast<bool(*)(decltype(this), char const*, float)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
    }

    void layerHidden() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528d0))(this);
    }

    void layerVisible() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528b0))(this);
    }

    void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525f0))(this);
    }

    void showLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
    }

    void apply_hooks() override {
        if ((GJDropDownLayer*(*)(char const*)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x352530, (GJDropDownLayer*(*)(char const*)){&D::create});

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x352570, extract((void(D::*)()){&D::customSetup}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(getBase()+0x352580, extract((void(D::*)()){&D::disableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x352910, extract((void(D::*)()){&D::draw}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(getBase()+0x3525a0, extract((void(D::*)()){&D::enableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(getBase()+0x3528a0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(getBase()+0x3525c0, extract((void(D::*)()){&D::enterLayer}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(getBase()+0x352670, extract((void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(getBase()+0x3527b0, extract((void(D::*)(bool)){&D::hideLayer}));

        if ((bool($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init} != (bool(D::*)(char const*, float)){&D::init})
            m->registerHook(getBase()+0x352100, extract((bool(D::*)(char const*, float)){&D::init}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(getBase()+0x3528d0, extract((void(D::*)()){&D::layerHidden}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(getBase()+0x3528b0, extract((void(D::*)()){&D::layerVisible}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x3525f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(getBase()+0x3526c0, extract((void(D::*)(bool)){&D::showLayer}));
    }
};


template<class D>
class $GJEffectManager : public GJEffectManager, public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJEffectManager* __thistype;

    void activeColorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
    }

    void activeOpacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e10))(this, p0);
    }

    void addAllInheritedColorActions(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
    }

    void addGroupPulseEffect(PulseEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), PulseEffectAction*)>(m->getOriginal(getBase()+0x184c10))(this, p0);
    }

    void calculateBaseActiveColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180f70))(this);
    }

    void calculateInheritedColor(int p0, ColorAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, ColorAction*)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
    }

    void calculateLightBGColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x185b90))(this, p0);
    }

    void colorActionChanged(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
    }

    void colorExists(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181da0))(this, p0);
    }

    void colorForEffect(cocos2d::_ccColor3B p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
    }

    void colorForGroupID(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
    }

    void colorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
    }

    void colorForPulseEffect(cocos2d::_ccColor3B const& p0, PulseEffectAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, PulseEffectAction*)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
    }

    void countChangedForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
    }

    void countForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a10))(this, p0);
    }

    static GJEffectManager* create() {
        return reinterpret_cast<GJEffectManager*(*)()>(m->getOriginal(getBase()+0x1800f0))();
    }

    void createFollowCommand(float p0, float p1, float p2, int p3, int p4, bool p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, int, int, bool, int)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void createPlayerFollowCommand(float p0, float p1, int p2, float p3, float p4, int p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, float, int, int)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    void createRotateCommand(int p0, float p1, int p2, int p3, int p4, float p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int, int, int, float, bool, int)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void getAllColorActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180980))(this);
    }

    void getAllColorSprites() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1809e0))(this);
    }

    void getColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180b00))(this, p0);
    }

    void getColorSprite(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180d00))(this, p0);
    }

    void getCurrentStateString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1867e0))(this);
    }

    void getLoadedMoveOffset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x184390))(this);
    }

    void getMixedColor(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
    }

    void getOpacityActionForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
    }

    void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185e90))(this);
    }

    void handleObjectCollision(bool p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
    }

    void hasActiveDualTouch() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185540))(this);
    }

    void hasBeenTriggered(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
    }

    void hasPulseEffectForGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184f60))(this, p0);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x180230))(this);
    }

    void isGroupEnabled(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
    }

    void keyForGroupIDColor(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
    }

    void loadState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x188db0))(this, p0);
    }

    void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
    }

    void opacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180c80))(this, p0);
    }

    void opacityModForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184740))(this, p0);
    }

    void playerButton(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
    }

    void playerDied() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185860))(this);
    }

    void postCollisionCheck() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182720))(this);
    }

    void preCollisionCheck() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182680))(this);
    }

    void prepareMoveActions(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
    }

    void processColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180e70))(this);
    }

    void processCopyColorPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181530))(this);
    }

    void processInheritedColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181190))(this);
    }

    void processPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181040))(this);
    }

    void registerCollisionTrigger(int p0, int p1, int p2, bool p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, bool, int)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
    }

    void removeAllPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1825e0))(this);
    }

    void removeColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181d60))(this, p0);
    }

    void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180690))(this);
    }

    void resetColorCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185280))(this);
    }

    void resetEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1807d0))(this);
    }

    void resetMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180940))(this);
    }

    void resetToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1853f0))(this);
    }

    void resetTriggeredIDs() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182630))(this);
    }

    void runCountTrigger(int p0, int p1, bool p2, int p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool, int, bool, int)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
    }

    void runDeathTrigger(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
    }

    void runOpacityActionOnGroup(int p0, float p1, float p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, float, float, int)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
    }

    void runPulseEffect(int p0, bool p1, float p2, float p3, float p4, PulseEffectType p5, cocos2d::_ccColor3B p6, cocos2d::_ccHSVValue p7, int p8, bool p9, bool p10, bool p11, int p12) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    void runTouchTriggerCommand(int p0, bool p1, TouchTriggerType p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, TouchTriggerType, bool, int)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
    }

    void setColorAction(ColorAction* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*, int)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
    }

    void setFollowing(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
    }

    void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x186290))(this, p0);
    }

    void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e40))(this, p0);
    }

    void spawnGroup(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
    }

    void stopActionsForTrigger(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0x183150))(this, p0);
    }

    void stopMoveActionsForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
    }

    void storeTriggeredID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185380))(this, p0);
    }

    void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
    }

    void traverseInheritanceChain(InheritanceNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*)>(m->getOriginal(getBase()+0x181850))(this, p0);
    }

    void updateActiveOpacityEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1847e0))(this);
    }

    void updateColorAction(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x184560))(this, p0);
    }

    void updateColorEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181f40))(this, p0);
    }

    void updateColors(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
    }

    void updateEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181df0))(this, p0);
    }

    void updateOpacityAction(OpacityEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction*)>(m->getOriginal(getBase()+0x184780))(this, p0);
    }

    void updateOpacityEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
    }

    void updatePulseEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182130))(this, p0);
    }

    void updateSpawnTriggers(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182510))(this, p0);
    }

    void wasFollowing(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
    }

    void wouldCreateLoop(InheritanceNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*, int)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex} != (void(D::*)(int)){&D::activeColorForIndex})
            m->registerHook(getBase()+0x180cb0, extract((void(D::*)(int)){&D::activeColorForIndex}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex} != (void(D::*)(int)){&D::activeOpacityForIndex})
            m->registerHook(getBase()+0x180e10, extract((void(D::*)(int)){&D::activeOpacityForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions} != (void(D::*)(cocos2d::CCArray*)){&D::addAllInheritedColorActions})
            m->registerHook(getBase()+0x1817a0, extract((void(D::*)(cocos2d::CCArray*)){&D::addAllInheritedColorActions}));

        if ((void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect} != (void(D::*)(PulseEffectAction*)){&D::addGroupPulseEffect})
            m->registerHook(getBase()+0x184c10, extract((void(D::*)(PulseEffectAction*)){&D::addGroupPulseEffect}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors} != (void(D::*)()){&D::calculateBaseActiveColors})
            m->registerHook(getBase()+0x180f70, extract((void(D::*)()){&D::calculateBaseActiveColors}));

        if ((void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor} != (void(D::*)(int, ColorAction*)){&D::calculateInheritedColor})
            m->registerHook(getBase()+0x1818f0, extract((void(D::*)(int, ColorAction*)){&D::calculateInheritedColor}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::calculateLightBGColor})
            m->registerHook(getBase()+0x185b90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::calculateLightBGColor}));

        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged} != (void(D::*)(ColorAction*)){&D::colorActionChanged})
            m->registerHook(getBase()+0x181dc0, extract((void(D::*)(ColorAction*)){&D::colorActionChanged}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists} != (void(D::*)(int)){&D::colorExists})
            m->registerHook(getBase()+0x181da0, extract((void(D::*)(int)){&D::colorExists}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&D::colorForEffect})
            m->registerHook(getBase()+0x182650, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&D::colorForEffect}));

        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::colorForGroupID})
            m->registerHook(getBase()+0x184f90, extract((void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::colorForGroupID}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex} != (void(D::*)(int)){&D::colorForIndex})
            m->registerHook(getBase()+0x180ad0, extract((void(D::*)(int)){&D::colorForIndex}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect} != (void(D::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&D::colorForPulseEffect})
            m->registerHook(getBase()+0x181bf0, extract((void(D::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&D::colorForPulseEffect}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem} != (void(D::*)(int)){&D::countChangedForItem})
            m->registerHook(getBase()+0x185a40, extract((void(D::*)(int)){&D::countChangedForItem}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem} != (void(D::*)(int)){&D::countForItem})
            m->registerHook(getBase()+0x185a10, extract((void(D::*)(int)){&D::countForItem}));

        if ((GJEffectManager*(*)()){&$GJEffectManager::create} != (GJEffectManager*(*)()){&D::create})
            m->registerHook(getBase()+0x1800f0, (GJEffectManager*(*)()){&D::create});

        if ((void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand} != (void(D::*)(float, float, float, int, int, bool, int)){&D::createFollowCommand})
            m->registerHook(getBase()+0x182ed0, extract((void(D::*)(float, float, float, int, int, bool, int)){&D::createFollowCommand}));

        if ((void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(getBase()+0x182cc0, extract((void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand} != (void(D::*)(float, float, int, float, float, int, int)){&D::createPlayerFollowCommand})
            m->registerHook(getBase()+0x182fe0, extract((void(D::*)(float, float, int, float, float, int, int)){&D::createPlayerFollowCommand}));

        if ((void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand} != (void(D::*)(int, float, int, int, int, float, bool, int)){&D::createRotateCommand})
            m->registerHook(getBase()+0x182df0, extract((void(D::*)(int, float, int, int, int, float, bool, int)){&D::createRotateCommand}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions} != (void(D::*)()){&D::getAllColorActions})
            m->registerHook(getBase()+0x180980, extract((void(D::*)()){&D::getAllColorActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites} != (void(D::*)()){&D::getAllColorSprites})
            m->registerHook(getBase()+0x1809e0, extract((void(D::*)()){&D::getAllColorSprites}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction} != (void(D::*)(int)){&D::getColorAction})
            m->registerHook(getBase()+0x180b00, extract((void(D::*)(int)){&D::getColorAction}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite} != (void(D::*)(int)){&D::getColorSprite})
            m->registerHook(getBase()+0x180d00, extract((void(D::*)(int)){&D::getColorSprite}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString} != (void(D::*)()){&D::getCurrentStateString})
            m->registerHook(getBase()+0x1867e0, extract((void(D::*)()){&D::getCurrentStateString}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset} != (void(D::*)()){&D::getLoadedMoveOffset})
            m->registerHook(getBase()+0x184390, extract((void(D::*)()){&D::getLoadedMoveOffset}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::getMixedColor})
            m->registerHook(getBase()+0x185d30, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::getMixedColor}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup} != (void(D::*)(int)){&D::getOpacityActionForGroup})
            m->registerHook(getBase()+0x1845b0, extract((void(D::*)(int)){&D::getOpacityActionForGroup}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x185e90, extract((void(D::*)()){&D::getSaveString}));

        if ((void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision} != (void(D::*)(bool, int, int)){&D::handleObjectCollision})
            m->registerHook(getBase()+0x1828f0, extract((void(D::*)(bool, int, int)){&D::handleObjectCollision}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch} != (void(D::*)()){&D::hasActiveDualTouch})
            m->registerHook(getBase()+0x185540, extract((void(D::*)()){&D::hasActiveDualTouch}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered} != (void(D::*)(int)){&D::hasBeenTriggered})
            m->registerHook(getBase()+0x1853b0, extract((void(D::*)(int)){&D::hasBeenTriggered}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID} != (void(D::*)(int)){&D::hasPulseEffectForGroupID})
            m->registerHook(getBase()+0x184f60, extract((void(D::*)(int)){&D::hasPulseEffectForGroupID}));

        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x180230, extract((bool(D::*)()){&D::init}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled} != (void(D::*)(int)){&D::isGroupEnabled})
            m->registerHook(getBase()+0x1853d0, extract((void(D::*)(int)){&D::isGroupEnabled}));

        if ((void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor} != (void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::keyForGroupIDColor})
            m->registerHook(getBase()+0x184c90, extract((void(D::*)(int, cocos2d::_ccColor3B const&, bool)){&D::keyForGroupIDColor}));

        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState} != (void(D::*)(std::string)){&D::loadState})
            m->registerHook(getBase()+0x188db0, extract((void(D::*)(std::string)){&D::loadState}));

        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(getBase()+0x182a00, extract((void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex} != (void(D::*)(int)){&D::opacityForIndex})
            m->registerHook(getBase()+0x180c80, extract((void(D::*)(int)){&D::opacityForIndex}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup} != (void(D::*)(int)){&D::opacityModForGroup})
            m->registerHook(getBase()+0x184740, extract((void(D::*)(int)){&D::opacityModForGroup}));

        if ((void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton} != (void(D::*)(bool, bool)){&D::playerButton})
            m->registerHook(getBase()+0x1855a0, extract((void(D::*)(bool, bool)){&D::playerButton}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::playerDied} != (void(D::*)()){&D::playerDied})
            m->registerHook(getBase()+0x185860, extract((void(D::*)()){&D::playerDied}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck} != (void(D::*)()){&D::postCollisionCheck})
            m->registerHook(getBase()+0x182720, extract((void(D::*)()){&D::postCollisionCheck}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck} != (void(D::*)()){&D::preCollisionCheck})
            m->registerHook(getBase()+0x182680, extract((void(D::*)()){&D::preCollisionCheck}));

        if ((void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions} != (void(D::*)(float, bool)){&D::prepareMoveActions})
            m->registerHook(getBase()+0x183660, extract((void(D::*)(float, bool)){&D::prepareMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processColors} != (void(D::*)()){&D::processColors})
            m->registerHook(getBase()+0x180e70, extract((void(D::*)()){&D::processColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions} != (void(D::*)()){&D::processCopyColorPulseActions})
            m->registerHook(getBase()+0x181530, extract((void(D::*)()){&D::processCopyColorPulseActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors} != (void(D::*)()){&D::processInheritedColors})
            m->registerHook(getBase()+0x181190, extract((void(D::*)()){&D::processInheritedColors}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions} != (void(D::*)()){&D::processPulseActions})
            m->registerHook(getBase()+0x181040, extract((void(D::*)()){&D::processPulseActions}));

        if ((void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger} != (void(D::*)(int, int, int, bool, bool, int)){&D::registerCollisionTrigger})
            m->registerHook(getBase()+0x182b70, extract((void(D::*)(int, int, int, bool, bool, int)){&D::registerCollisionTrigger}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions} != (void(D::*)()){&D::removeAllPulseActions})
            m->registerHook(getBase()+0x1825e0, extract((void(D::*)()){&D::removeAllPulseActions}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction} != (void(D::*)(int)){&D::removeColorAction})
            m->registerHook(getBase()+0x181d60, extract((void(D::*)(int)){&D::removeColorAction}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x180690, extract((void(D::*)()){&D::reset}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache} != (void(D::*)()){&D::resetColorCache})
            m->registerHook(getBase()+0x185280, extract((void(D::*)()){&D::resetColorCache}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetEffects} != (void(D::*)()){&D::resetEffects})
            m->registerHook(getBase()+0x1807d0, extract((void(D::*)()){&D::resetEffects}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions} != (void(D::*)()){&D::resetMoveActions})
            m->registerHook(getBase()+0x180940, extract((void(D::*)()){&D::resetMoveActions}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x1853f0, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs} != (void(D::*)()){&D::resetTriggeredIDs})
            m->registerHook(getBase()+0x182630, extract((void(D::*)()){&D::resetTriggeredIDs}));

        if ((void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger} != (void(D::*)(int, int, bool, int, bool, int)){&D::runCountTrigger})
            m->registerHook(getBase()+0x1858d0, extract((void(D::*)(int, int, bool, int, bool, int)){&D::runCountTrigger}));

        if ((void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger} != (void(D::*)(int, bool, int)){&D::runDeathTrigger})
            m->registerHook(getBase()+0x1857a0, extract((void(D::*)(int, bool, int)){&D::runDeathTrigger}));

        if ((void($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup} != (void(D::*)(int, float, float, int)){&D::runOpacityActionOnGroup})
            m->registerHook(getBase()+0x1845d0, extract((void(D::*)(int, float, float, int)){&D::runOpacityActionOnGroup}));

        if ((void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect} != (void(D::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&D::runPulseEffect})
            m->registerHook(getBase()+0x184890, extract((void(D::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&D::runPulseEffect}));

        if ((void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand} != (void(D::*)(int, bool, TouchTriggerType, bool, int)){&D::runTouchTriggerCommand})
            m->registerHook(getBase()+0x185460, extract((void(D::*)(int, bool, TouchTriggerType, bool, int)){&D::runTouchTriggerCommand}));

        if ((void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction} != (void(D::*)(ColorAction*, int)){&D::setColorAction})
            m->registerHook(getBase()+0x181d00, extract((void(D::*)(ColorAction*, int)){&D::setColorAction}));

        if ((void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing} != (void(D::*)(int, int, bool)){&D::setFollowing})
            m->registerHook(getBase()+0x185e00, extract((void(D::*)(int, int, bool)){&D::setFollowing}));

        if ((void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString} != (void(D::*)(std::string)){&D::setupFromString})
            m->registerHook(getBase()+0x186290, extract((void(D::*)(std::string)){&D::setupFromString}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            m->registerHook(getBase()+0x180e40, extract((void(D::*)(int)){&D::shouldBlend}));

        if ((void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup} != (void(D::*)(int, float, int)){&D::spawnGroup})
            m->registerHook(getBase()+0x1852a0, extract((void(D::*)(int, float, int)){&D::spawnGroup}));

        if ((void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger} != (void(D::*)(EffectGameObject*)){&D::stopActionsForTrigger})
            m->registerHook(getBase()+0x183150, extract((void(D::*)(EffectGameObject*)){&D::stopActionsForTrigger}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup} != (void(D::*)(int)){&D::stopMoveActionsForGroup})
            m->registerHook(getBase()+0x1830e0, extract((void(D::*)(int)){&D::stopMoveActionsForGroup}));

        if ((void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID} != (void(D::*)(int)){&D::storeTriggeredID})
            m->registerHook(getBase()+0x185380, extract((void(D::*)(int)){&D::storeTriggeredID}));

        if ((void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            m->registerHook(getBase()+0x182c80, extract((void(D::*)(int, bool)){&D::toggleGroup}));

        if ((void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain} != (void(D::*)(InheritanceNode*)){&D::traverseInheritanceChain})
            m->registerHook(getBase()+0x181850, extract((void(D::*)(InheritanceNode*)){&D::traverseInheritanceChain}));

        if ((void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects} != (void(D::*)()){&D::updateActiveOpacityEffects})
            m->registerHook(getBase()+0x1847e0, extract((void(D::*)()){&D::updateActiveOpacityEffects}));

        if ((void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction} != (void(D::*)(ColorAction*)){&D::updateColorAction})
            m->registerHook(getBase()+0x184560, extract((void(D::*)(ColorAction*)){&D::updateColorAction}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects} != (void(D::*)(float)){&D::updateColorEffects})
            m->registerHook(getBase()+0x181f40, extract((void(D::*)(float)){&D::updateColorEffects}));

        if ((void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::updateColors})
            m->registerHook(getBase()+0x180a40, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::updateColors}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects} != (void(D::*)(float)){&D::updateEffects})
            m->registerHook(getBase()+0x181df0, extract((void(D::*)(float)){&D::updateEffects}));

        if ((void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction} != (void(D::*)(OpacityEffectAction*)){&D::updateOpacityAction})
            m->registerHook(getBase()+0x184780, extract((void(D::*)(OpacityEffectAction*)){&D::updateOpacityAction}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects} != (void(D::*)(float)){&D::updateOpacityEffects})
            m->registerHook(getBase()+0x1823e0, extract((void(D::*)(float)){&D::updateOpacityEffects}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects} != (void(D::*)(float)){&D::updatePulseEffects})
            m->registerHook(getBase()+0x182130, extract((void(D::*)(float)){&D::updatePulseEffects}));

        if ((void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers} != (void(D::*)(float)){&D::updateSpawnTriggers})
            m->registerHook(getBase()+0x182510, extract((void(D::*)(float)){&D::updateSpawnTriggers}));

        if ((void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing} != (void(D::*)(int, int)){&D::wasFollowing})
            m->registerHook(getBase()+0x185e60, extract((void(D::*)(int, int)){&D::wasFollowing}));

        if ((void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop} != (void(D::*)(InheritanceNode*, int)){&D::wouldCreateLoop})
            m->registerHook(getBase()+0x181820, extract((void(D::*)(InheritanceNode*, int)){&D::wouldCreateLoop}));
    }
};


template<class D>
class $GJFollowCommandLayer : public GJFollowCommandLayer, public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJFollowCommandLayer* __thistype;

    static GJFollowCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x16a550))(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c8f0))(this, p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c9e0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x16d480))(this, p0);
    }

    void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16cfe0))(this);
    }

    void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16d1c0))(this);
    }

    void apply_hooks() override {
        if ((GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create} != (GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x16a550, (GJFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x16c8f0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x16c9e0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x16d480, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x16cfe0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x16d1c0, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJGameLevel : public GJGameLevel, public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJGameLevel* __thistype;

    static GJGameLevel* create() {
        return reinterpret_cast<GJGameLevel*(*)()>(m->getOriginal(getBase()+0x2b83e0))();
    }

    void getAudioFileName() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2dbe70))(this);
    }

    void getCoinKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
    }

    void getLengthKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2dbba0))(this, p0);
    }

    void getNormalPercent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8b20))(this);
    }

    void levelWasAltered() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2db530))(this);
    }

    void savePercentage(int p0, bool p1, int p2, int p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, int, bool)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        if ((GJGameLevel*(*)()){&$GJGameLevel::create} != (GJGameLevel*(*)()){&D::create})
            m->registerHook(getBase()+0x2b83e0, (GJGameLevel*(*)()){&D::create});

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName} != (void(D::*)()){&D::getAudioFileName})
            m->registerHook(getBase()+0x2dbe70, extract((void(D::*)()){&D::getAudioFileName}));

        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey} != (void(D::*)(int)){&D::getCoinKey})
            m->registerHook(getBase()+0x2ce360, extract((void(D::*)(int)){&D::getCoinKey}));

        if ((void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey} != (void(D::*)(int)){&D::getLengthKey})
            m->registerHook(getBase()+0x2dbba0, extract((void(D::*)(int)){&D::getLengthKey}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent} != (void(D::*)()){&D::getNormalPercent})
            m->registerHook(getBase()+0x2b8b20, extract((void(D::*)()){&D::getNormalPercent}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered} != (void(D::*)()){&D::levelWasAltered})
            m->registerHook(getBase()+0x2db530, extract((void(D::*)()){&D::levelWasAltered}));

        if ((void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage} != (void(D::*)(int, bool, int, int, bool)){&D::savePercentage})
            m->registerHook(getBase()+0x2db700, extract((void(D::*)(int, bool, int, int, bool)){&D::savePercentage}));
    }
};


template<class D>
class $GJGroundLayer : public GJGroundLayer, public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJGroundLayer* __thistype;

    static GJGroundLayer* create(int p0, int p1) {
        return reinterpret_cast<GJGroundLayer*(*)(int, int)>(m->getOriginal(getBase()+0x355c00))(p0, p1);
    }

    void deactivateGround() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356a40))(this);
    }

    void getGroundY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356ac0))(this);
    }

    void updateGround01Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356640))(this, p0);
    }

    void updateGround02Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356710))(this, p0);
    }

    void updateGroundPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
    }

    void updateGroundWidth() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356790))(this);
    }

    void apply_hooks() override {
        if ((GJGroundLayer*(*)(int, int)){&$GJGroundLayer::create} != (GJGroundLayer*(*)(int, int)){&D::create})
            m->registerHook(getBase()+0x355c00, (GJGroundLayer*(*)(int, int)){&D::create});

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround} != (void(D::*)()){&D::deactivateGround})
            m->registerHook(getBase()+0x356a40, extract((void(D::*)()){&D::deactivateGround}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY} != (void(D::*)()){&D::getGroundY})
            m->registerHook(getBase()+0x356ac0, extract((void(D::*)()){&D::getGroundY}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround01Color})
            m->registerHook(getBase()+0x356640, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateGround01Color}));

        if ((void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateGround02Color})
            m->registerHook(getBase()+0x356710, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateGround02Color}));

        if ((void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos} != (void(D::*)(cocos2d::CCPoint)){&D::updateGroundPos})
            m->registerHook(getBase()+0x3566c0, extract((void(D::*)(cocos2d::CCPoint)){&D::updateGroundPos}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x356790, extract((void(D::*)()){&D::updateGroundWidth}));
    }
};


template<class D>
class $GJMoveCommandLayer : public GJMoveCommandLayer, public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJMoveCommandLayer* __thistype;

    static GJMoveCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36f8a0))(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
    }

    void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374970))(this);
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x373350))(this, p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374470))(this, p0);
    }

    void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374430))(this, p0);
    }

    void textInputReturn(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374c10))(this, p0);
    }

    void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
    }

    void updateEditorLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374110))(this);
    }

    void updateMoveTargetElements() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373ac0))(this);
    }

    void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374050))(this);
    }

    void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374230))(this);
    }

    void updateTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373680))(this);
    }

    void updateTextInputLabel2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373760))(this);
    }

    void updateValueXLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373840))(this);
    }

    void updateValueYLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373950))(this);
    }

    void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create} != (GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x36f8a0, (GJMoveCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x36fac0, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x374970, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x373350, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x3734c0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x374470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(getBase()+0x374430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(getBase()+0x374c10, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(getBase()+0x374b50, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x374110, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements} != (void(D::*)()){&D::updateMoveTargetElements})
            m->registerHook(getBase()+0x373ac0, extract((void(D::*)()){&D::updateMoveTargetElements}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x374050, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x374230, extract((void(D::*)()){&D::updateTargetGroupID2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x373680, extract((void(D::*)()){&D::updateTextInputLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2} != (void(D::*)()){&D::updateTextInputLabel2})
            m->registerHook(getBase()+0x373760, extract((void(D::*)()){&D::updateTextInputLabel2}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel} != (void(D::*)()){&D::updateValueXLabel})
            m->registerHook(getBase()+0x373840, extract((void(D::*)()){&D::updateValueXLabel}));

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel} != (void(D::*)()){&D::updateValueYLabel})
            m->registerHook(getBase()+0x373950, extract((void(D::*)()){&D::updateValueYLabel}));

        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(getBase()+0x373c20, extract((void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));
    }
};


template<class D>
class $GJPFollowCommandLayer : public GJPFollowCommandLayer, public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJPFollowCommandLayer* __thistype;

    static GJPFollowCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1aea20))(p0, p1);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1b1dc0))(this, p0);
    }

    void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1b1a60))(this);
    }

    void apply_hooks() override {
        if ((GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create} != (GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1aea20, (GJPFollowCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1b1dc0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x1b1a60, extract((void(D::*)()){&D::updateTargetGroupID}));
    }
};


template<class D>
class $GJRobotSprite : public GJRobotSprite, public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJRobotSprite* __thistype;

    static GJRobotSprite* create() {
        return reinterpret_cast<GJRobotSprite*(*)()>(m->getOriginal(getBase()+0x34ac00))();
    }

    void updateColor02(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
    }

    void updateFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
    }

    void apply_hooks() override {
        if ((GJRobotSprite*(*)()){&$GJRobotSprite::create} != (GJRobotSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34ac00, (GJRobotSprite*(*)()){&D::create});

        if ((void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateColor02})
            m->registerHook(getBase()+0x34bbd0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateColor02}));

        if ((void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame} != (void(D::*)(int)){&D::updateFrame})
            m->registerHook(getBase()+0x34bdd0, extract((void(D::*)(int)){&D::updateFrame}));
    }
};


template<class D>
class $GJRotateCommandLayer : public GJRotateCommandLayer, public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJRotateCommandLayer* __thistype;

    static GJRotateCommandLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1ba0))(p0, p1);
    }

    void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4bb0))(this, p0);
    }

    void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4ca0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x58d0))(this, p0);
    }

    void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x54b0))(this);
    }

    void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5690))(this);
    }

    void apply_hooks() override {
        if ((GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create} != (GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1ba0, (GJRotateCommandLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID})
            m->registerHook(getBase()+0x4bb0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID}));

        if ((void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2})
            m->registerHook(getBase()+0x4ca0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateGroupID2}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x58d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID} != (void(D::*)()){&D::updateTargetGroupID})
            m->registerHook(getBase()+0x54b0, extract((void(D::*)()){&D::updateTargetGroupID}));

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2} != (void(D::*)()){&D::updateTargetGroupID2})
            m->registerHook(getBase()+0x5690, extract((void(D::*)()){&D::updateTargetGroupID2}));
    }
};


template<class D>
class $GJSearchObject : public GJSearchObject, public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJSearchObject* __thistype;

    static GJSearchObject* create(SearchType p0) {
        return reinterpret_cast<GJSearchObject*(*)(SearchType)>(m->getOriginal(getBase()+0x2df120))(p0);
    }

    static GJSearchObject* create(SearchType p0, std::string p1, std::string p2, std::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, int p17, int p18) {
        return reinterpret_cast<GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)>(m->getOriginal(getBase()+0x2dee30))(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    void getPageObject(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2df9a0))(this, p0);
    }

    void apply_hooks() override {
        if ((GJSearchObject*(*)(SearchType)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType)){&D::create})
            m->registerHook(getBase()+0x2df120, (GJSearchObject*(*)(SearchType)){&D::create});

        if ((GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create} != (GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&D::create})
            m->registerHook(getBase()+0x2dee30, (GJSearchObject*(*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&D::create});

        if ((void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject} != (void(D::*)(int)){&D::getPageObject})
            m->registerHook(getBase()+0x2df9a0, extract((void(D::*)(int)){&D::getPageObject}));
    }
};


template<class D>
class $GJSpecialColorSelect : public GJSpecialColorSelect, public $CacBase {
 public:
    $GJSpecialColorSelect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJSpecialColorSelect* __thistype;

    void textForColorIdx(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x383a50))(this, p0);
    }

    void apply_hooks() override {
        if ((void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx} != (void(D::*)(int)){&D::textForColorIdx})
            m->registerHook(getBase()+0x383a50, extract((void(D::*)(int)){&D::textForColorIdx}));
    }
};


template<class D>
class $GJSpiderSprite : public GJSpiderSprite, public $CacBase {
 public:
    $GJSpiderSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJSpiderSprite* __thistype;

    static GJSpiderSprite* create() {
        return reinterpret_cast<GJSpiderSprite*(*)()>(m->getOriginal(getBase()+0x34c5b0))();
    }

    void apply_hooks() override {
        if ((GJSpiderSprite*(*)()){&$GJSpiderSprite::create} != (GJSpiderSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x34c5b0, (GJSpiderSprite*(*)()){&D::create});
    }
};


template<class D>
class $GManager : public GManager, public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GManager* __thistype;

    void save() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26f300))(this);
    }

    void saveData(DS_Dictionary* p0, std::string p1) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*, std::string)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
    }

    void saveGMTo(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($GManager::*)()){&$GManager::save} != (void(D::*)()){&D::save})
            m->registerHook(getBase()+0x26f300, extract((void(D::*)()){&D::save}));

        if ((void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData} != (void(D::*)(DS_Dictionary*, std::string)){&D::saveData})
            m->registerHook(getBase()+0x26f4b0, extract((void(D::*)(DS_Dictionary*, std::string)){&D::saveData}));

        if ((void($GManager::*)(std::string)){&$GManager::saveGMTo} != (void(D::*)(std::string)){&D::saveGMTo})
            m->registerHook(getBase()+0x26f3b0, extract((void(D::*)(std::string)){&D::saveGMTo}));
    }
};


template<class D>
class $GameLevelManager : public GameLevelManager, public $CacBase {
 public:
    $GameLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameLevelManager* __thistype;

    void createNewLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8180))(this);
    }

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2a8340))(this);
    }

    void apply_hooks() override {
        if ((void($GameLevelManager::*)()){&$GameLevelManager::createNewLevel} != (void(D::*)()){&D::createNewLevel})
            m->registerHook(getBase()+0x2b8180, extract((void(D::*)()){&D::createNewLevel}));

        if ((void($GameLevelManager::*)()){&$GameLevelManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x2a8340, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $GameManager : public GameManager, public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameManager* __thistype;

    void accountStatusChanged() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
    }

    void colorForIdx(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
    }

    void didExitPlayscene() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0230))(this);
    }

    void doQuickSave() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
    }

    void fadeInMusic(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
    }

    void getBGTexture(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
    }

    void getFontFile(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
    }

    void getGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
    }

    void getIntGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
    }

    void getUGV(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
    }

    void loadDeathEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
    }

    void loadFont(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
    }

    void reloadAll(bool p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
    }

    void reloadAllStep5() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
    }

    void reportPercentageForLevel(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
    }

    void setGameVariable(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
    }

    void setIntGameVariable(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x1cd0e0))(this, p0, p1);
    }

    void setUGV(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
    }

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2b30))(this);
    }

    void apply_hooks() override {
        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(getBase()+0x1cdad0, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((void($GameManager::*)(int)){&$GameManager::colorForIdx} != (void(D::*)(int)){&D::colorForIdx})
            m->registerHook(getBase()+0x1cbc80, extract((void(D::*)(int)){&D::colorForIdx}));

        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            m->registerHook(getBase()+0x1d0230, extract((void(D::*)()){&D::didExitPlayscene}));

        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            m->registerHook(getBase()+0x1d0200, extract((void(D::*)()){&D::doQuickSave}));

        if ((void($GameManager::*)(char const*)){&$GameManager::fadeInMusic} != (void(D::*)(char const*)){&D::fadeInMusic})
            m->registerHook(getBase()+0x1c2ff0, extract((void(D::*)(char const*)){&D::fadeInMusic}));

        if ((void($GameManager::*)(int)){&$GameManager::getBGTexture} != (void(D::*)(int)){&D::getBGTexture})
            m->registerHook(getBase()+0x1cca00, extract((void(D::*)(int)){&D::getBGTexture}));

        if ((void($GameManager::*)(int)){&$GameManager::getFontFile} != (void(D::*)(int)){&D::getFontFile})
            m->registerHook(getBase()+0x1cc5f0, extract((void(D::*)(int)){&D::getFontFile}));

        if ((void($GameManager::*)(char const*)){&$GameManager::getGameVariable} != (void(D::*)(char const*)){&D::getGameVariable})
            m->registerHook(getBase()+0x1cccd0, extract((void(D::*)(char const*)){&D::getGameVariable}));

        if ((void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable} != (void(D::*)(char const*)){&D::getIntGameVariable})
            m->registerHook(getBase()+0x1cd1d0, extract((void(D::*)(char const*)){&D::getIntGameVariable}));

        if ((void($GameManager::*)(char const*)){&$GameManager::getUGV} != (void(D::*)(char const*)){&D::getUGV})
            m->registerHook(getBase()+0x1ccfa0, extract((void(D::*)(char const*)){&D::getUGV}));

        if ((void($GameManager::*)(int)){&$GameManager::loadDeathEffect} != (void(D::*)(int)){&D::loadDeathEffect})
            m->registerHook(getBase()+0x1cc690, extract((void(D::*)(int)){&D::loadDeathEffect}));

        if ((void($GameManager::*)(int)){&$GameManager::loadFont} != (void(D::*)(int)){&D::loadFont})
            m->registerHook(getBase()+0x1cc550, extract((void(D::*)(int)){&D::loadFont}));

        if ((void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll} != (void(D::*)(bool, bool, bool)){&D::reloadAll})
            m->registerHook(getBase()+0x1d08a0, extract((void(D::*)(bool, bool, bool)){&D::reloadAll}));

        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            m->registerHook(getBase()+0x1d0b00, extract((void(D::*)()){&D::reloadAllStep5}));

        if ((void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel} != (void(D::*)(int, int, bool)){&D::reportPercentageForLevel})
            m->registerHook(getBase()+0x1c5b00, extract((void(D::*)(int, int, bool)){&D::reportPercentageForLevel}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable} != (void(D::*)(char const*, bool)){&D::setGameVariable})
            m->registerHook(getBase()+0x1cca80, extract((void(D::*)(char const*, bool)){&D::setGameVariable}));

        if ((void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable} != (void(D::*)(char const*, int)){&D::setIntGameVariable})
            m->registerHook(getBase()+0x1cd0e0, extract((void(D::*)(char const*, int)){&D::setIntGameVariable}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setUGV} != (void(D::*)(char const*, bool)){&D::setUGV})
            m->registerHook(getBase()+0x1cce50, extract((void(D::*)(char const*, bool)){&D::setUGV}));

        if ((void($GameManager::*)()){&$GameManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x1c2b30, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $GameObject : public GameObject, public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameObject* __thistype;

    void activateObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2faf60))(this);
    }

    void activatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a20))(this, p0);
    }

    void addColorSprite() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7fe0))(this);
    }

    void addColorSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
    }

    void addMainSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
    }

    void addToGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
    }

    void addToTempOffset(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
    }

    void calculateOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b20))(this);
    }

    void calculateSpawnXPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
    }

    void canChangeCustomColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342db0))(this);
    }

    void colorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
    }

    void commonSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5570))(this);
    }

    void copyGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
    }

    static GameObject* createWithFrame(char const* p0) {
        return reinterpret_cast<GameObject*(*)(char const*)>(m->getOriginal(getBase()+0x2f5490))(p0);
    }

    static GameObject* createWithKey(int p0) {
        return reinterpret_cast<GameObject*(*)(int)>(m->getOriginal(getBase()+0x2f4ce0))(p0);
    }

    void customSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fbba0))(this);
    }

    void deactivateObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
    }

    void destroyObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
    }

    void determineSlopeDirection() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33a9e0))(this);
    }

    void getActiveColorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
    }

    void getBallFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
    }

    void getBoxOffset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3353d0))(this);
    }

    void getColorIndex() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b90))(this);
    }

    void getDidUpdateLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a20))(this);
    }

    void getGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
    }

    void getLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3439d0))(this);
    }

    void getMainColorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x334c30))(this);
    }

    void getObjectRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352b0))(this);
    }

    void getObjectRect(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
    }

    void getObjectRect2(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
    }

    void getObjectRectDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1d0))(this);
    }

    void getObjectTextureRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3355b0))(this);
    }

    void getObjectZOrder() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337d70))(this);
    }

    void getOrientedRectDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1f0))(this);
    }

    void getRScaleX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e50))(this);
    }

    void getRScaleY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e80))(this);
    }

    void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d3d0))(this);
    }

    void getSecondaryColorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x341c20))(this);
    }

    void getSectionIdx() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a00))(this);
    }

    void getStartPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc230))(this);
    }

    void getType() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc210))(this);
    }

    void groupWasDisabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b110))(this);
    }

    void groupWasEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b0f0))(this);
    }

    void hasBeenActivated() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342a80))(this);
    }

    void hasBeenActivatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a50))(this, p0);
    }

    void hasSecondaryColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342f80))(this);
    }

    void ignoreEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352a0))(this);
    }

    void ignoreFade() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335290))(this);
    }

    bool initWithTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
    }

    void isBasicTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343d10))(this);
    }

    void isColorTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b40))(this);
    }

    void isFlipX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a40))(this);
    }

    void isFlipY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a50))(this);
    }

    void isSpawnableTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a60))(this);
    }

    void isSpecialObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343c40))(this);
    }

    void objectFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x33b720))(this, p0, p1);
    }

    void playShineEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
    }

    void powerOffObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369c0))(this);
    }

    void powerOnObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369a0))(this);
    }

    void quickUpdatePosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335790))(this);
    }

    void removeFromGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
    }

    void removeGlow() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7f70))(this);
    }

    void resetGroupDisabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa7e0))(this);
    }

    void saveActiveColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d250))(this);
    }

    void selectObject(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x341f90))(this, p0);
    }

    void setChildColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341f20))(this, p0);
    }

    void setDefaultMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
    }

    void setDidUpdateLastPosition(bool const& p0) {
        return reinterpret_cast<void(*)(decltype(this), bool const&)>(m->getOriginal(getBase()+0x343a30))(this, p0);
    }

    void setGlowColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
    }

    void setGlowOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x336200))(this, p0);
    }

    void setLastPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
    }

    void setMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x342e70))(this, p0);
    }

    void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341c90))(this, p0);
    }

    void setObjectRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
    }

    void setOrientedRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc200))(this, p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x335850))(this, p0);
    }

    void setRScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335e10))(this, p0);
    }

    void setRScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
    }

    void setRScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335d60))(this, p0);
    }

    void setSectionIdx(int const& p0) {
        return reinterpret_cast<void(*)(decltype(this), int const&)>(m->getOriginal(getBase()+0x343a10))(this, p0);
    }

    void setStartPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
    }

    void setType(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0xdc220))(this, p0);
    }

    void setupCoinArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
    }

    void setupCustomSprites() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x307f60))(this);
    }

    void slopeFloorTop() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342800))(this);
    }

    void slopeWallLeft() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3427e0))(this);
    }

    void spawnXPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1b0))(this);
    }

    void triggerActivated(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x336990))(this, p0);
    }

    void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
    }

    void updateCustomScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
    }

    void updateMainColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343340))(this);
    }

    void updateOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b50))(this);
    }

    void updateSecondaryColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343740))(this);
    }

    void updateStartPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa590))(this);
    }

    void updateStartValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa800))(this);
    }

    void updateState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369e0))(this);
    }

    void updateSyncedAnimation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x337f00))(this, p0);
    }

    void apply_hooks() override {
        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(getBase()+0x2faf60, extract((void(D::*)()){&D::activateObject}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer} != (void(D::*)(GameObject*)){&D::activatedByPlayer})
            m->registerHook(getBase()+0x342a20, extract((void(D::*)(GameObject*)){&D::activatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::addColorSprite} != (void(D::*)()){&D::addColorSprite})
            m->registerHook(getBase()+0x2f7fe0, extract((void(D::*)()){&D::addColorSprite}));

        if ((void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent} != (void(D::*)(bool)){&D::addColorSpriteToParent})
            m->registerHook(getBase()+0x2fb470, extract((void(D::*)(bool)){&D::addColorSpriteToParent}));

        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(getBase()+0x33a5b0, extract((void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(getBase()+0x33ad00, extract((void(D::*)(int)){&D::addToGroup}));

        if ((void($GameObject::*)(float, float)){&$GameObject::addToTempOffset} != (void(D::*)(float, float)){&D::addToTempOffset})
            m->registerHook(getBase()+0x335700, extract((void(D::*)(float, float)){&D::addToTempOffset}));

        if ((void($GameObject::*)()){&$GameObject::calculateOrientedBox} != (void(D::*)()){&D::calculateOrientedBox})
            m->registerHook(getBase()+0x342b20, extract((void(D::*)()){&D::calculateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(getBase()+0x336970, extract((void(D::*)()){&D::calculateSpawnXPos}));

        if ((void($GameObject::*)()){&$GameObject::canChangeCustomColor} != (void(D::*)()){&D::canChangeCustomColor})
            m->registerHook(getBase()+0x342db0, extract((void(D::*)()){&D::canChangeCustomColor}));

        if ((void($GameObject::*)(int, bool)){&$GameObject::colorForMode} != (void(D::*)(int, bool)){&D::colorForMode})
            m->registerHook(getBase()+0x343460, extract((void(D::*)(int, bool)){&D::colorForMode}));

        if ((void($GameObject::*)()){&$GameObject::commonSetup} != (void(D::*)()){&D::commonSetup})
            m->registerHook(getBase()+0x2f5570, extract((void(D::*)()){&D::commonSetup}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::copyGroups} != (void(D::*)(GameObject*)){&D::copyGroups})
            m->registerHook(getBase()+0x33ae30, extract((void(D::*)(GameObject*)){&D::copyGroups}));

        if ((GameObject*(*)(char const*)){&$GameObject::createWithFrame} != (GameObject*(*)(char const*)){&D::createWithFrame})
            m->registerHook(getBase()+0x2f5490, (GameObject*(*)(char const*)){&D::createWithFrame});

        if ((GameObject*(*)(int)){&$GameObject::createWithKey} != (GameObject*(*)(int)){&D::createWithKey})
            m->registerHook(getBase()+0x2f4ce0, (GameObject*(*)(int)){&D::createWithKey});

        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(getBase()+0x2fbba0, extract((void(D::*)()){&D::customSetup}));

        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(getBase()+0x2fb8f0, extract((void(D::*)(bool)){&D::deactivateObject}));

        if ((void($GameObject::*)()){&$GameObject::destroyObject} != (void(D::*)()){&D::destroyObject})
            m->registerHook(getBase()+0x336a00, extract((void(D::*)()){&D::destroyObject}));

        if ((void($GameObject::*)()){&$GameObject::determineSlopeDirection} != (void(D::*)()){&D::determineSlopeDirection})
            m->registerHook(getBase()+0x33a9e0, extract((void(D::*)()){&D::determineSlopeDirection}));

        if ((void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode} != (void(D::*)(int, bool)){&D::getActiveColorForMode})
            m->registerHook(getBase()+0x343860, extract((void(D::*)(int, bool)){&D::getActiveColorForMode}));

        if ((void($GameObject::*)(int)){&$GameObject::getBallFrame} != (void(D::*)(int)){&D::getBallFrame})
            m->registerHook(getBase()+0x341bf0, extract((void(D::*)(int)){&D::getBallFrame}));

        if ((void($GameObject::*)()){&$GameObject::getBoxOffset} != (void(D::*)()){&D::getBoxOffset})
            m->registerHook(getBase()+0x3353d0, extract((void(D::*)()){&D::getBoxOffset}));

        if ((void($GameObject::*)()){&$GameObject::getColorIndex} != (void(D::*)()){&D::getColorIndex})
            m->registerHook(getBase()+0x343b90, extract((void(D::*)()){&D::getColorIndex}));

        if ((void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition} != (void(D::*)()){&D::getDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a20, extract((void(D::*)()){&D::getDidUpdateLastPosition}));

        if ((void($GameObject::*)(int)){&$GameObject::getGroupID} != (void(D::*)(int)){&D::getGroupID})
            m->registerHook(getBase()+0x33ae10, extract((void(D::*)(int)){&D::getGroupID}));

        if ((void($GameObject::*)()){&$GameObject::getLastPosition} != (void(D::*)()){&D::getLastPosition})
            m->registerHook(getBase()+0x3439d0, extract((void(D::*)()){&D::getLastPosition}));

        if ((void($GameObject::*)()){&$GameObject::getMainColorMode} != (void(D::*)()){&D::getMainColorMode})
            m->registerHook(getBase()+0x334c30, extract((void(D::*)()){&D::getMainColorMode}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRect} != (void(D::*)()){&D::getObjectRect})
            m->registerHook(getBase()+0x3352b0, extract((void(D::*)()){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            m->registerHook(getBase()+0x3352d0, extract((void(D::*)(float, float)){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            m->registerHook(getBase()+0x3354e0, extract((void(D::*)(float, float)){&D::getObjectRect2}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            m->registerHook(getBase()+0xdc1d0, extract((void(D::*)()){&D::getObjectRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            m->registerHook(getBase()+0x3355b0, extract((void(D::*)()){&D::getObjectTextureRect}));

        if ((void($GameObject::*)()){&$GameObject::getObjectZOrder} != (void(D::*)()){&D::getObjectZOrder})
            m->registerHook(getBase()+0x337d70, extract((void(D::*)()){&D::getObjectZOrder}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            m->registerHook(getBase()+0xdc1f0, extract((void(D::*)()){&D::getOrientedRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            m->registerHook(getBase()+0x335e50, extract((void(D::*)()){&D::getRScaleX}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            m->registerHook(getBase()+0x335e80, extract((void(D::*)()){&D::getRScaleY}));

        if ((void($GameObject::*)()){&$GameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x33d3d0, extract((void(D::*)()){&D::getSaveString}));

        if ((void($GameObject::*)()){&$GameObject::getSecondaryColorMode} != (void(D::*)()){&D::getSecondaryColorMode})
            m->registerHook(getBase()+0x341c20, extract((void(D::*)()){&D::getSecondaryColorMode}));

        if ((void($GameObject::*)()){&$GameObject::getSectionIdx} != (void(D::*)()){&D::getSectionIdx})
            m->registerHook(getBase()+0x343a00, extract((void(D::*)()){&D::getSectionIdx}));

        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            m->registerHook(getBase()+0xdc230, extract((void(D::*)()){&D::getStartPos}));

        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            m->registerHook(getBase()+0xdc210, extract((void(D::*)()){&D::getType}));

        if ((void($GameObject::*)()){&$GameObject::groupWasDisabled} != (void(D::*)()){&D::groupWasDisabled})
            m->registerHook(getBase()+0x33b110, extract((void(D::*)()){&D::groupWasDisabled}));

        if ((void($GameObject::*)()){&$GameObject::groupWasEnabled} != (void(D::*)()){&D::groupWasEnabled})
            m->registerHook(getBase()+0x33b0f0, extract((void(D::*)()){&D::groupWasEnabled}));

        if ((void($GameObject::*)()){&$GameObject::hasBeenActivated} != (void(D::*)()){&D::hasBeenActivated})
            m->registerHook(getBase()+0x342a80, extract((void(D::*)()){&D::hasBeenActivated}));

        if ((void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer} != (void(D::*)(GameObject*)){&D::hasBeenActivatedByPlayer})
            m->registerHook(getBase()+0x342a50, extract((void(D::*)(GameObject*)){&D::hasBeenActivatedByPlayer}));

        if ((void($GameObject::*)()){&$GameObject::hasSecondaryColor} != (void(D::*)()){&D::hasSecondaryColor})
            m->registerHook(getBase()+0x342f80, extract((void(D::*)()){&D::hasSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::ignoreEnter} != (void(D::*)()){&D::ignoreEnter})
            m->registerHook(getBase()+0x3352a0, extract((void(D::*)()){&D::ignoreEnter}));

        if ((void($GameObject::*)()){&$GameObject::ignoreFade} != (void(D::*)()){&D::ignoreFade})
            m->registerHook(getBase()+0x335290, extract((void(D::*)()){&D::ignoreFade}));

        if ((bool($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(getBase()+0x2f56a0, extract((bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($GameObject::*)()){&$GameObject::isBasicTrigger} != (void(D::*)()){&D::isBasicTrigger})
            m->registerHook(getBase()+0x343d10, extract((void(D::*)()){&D::isBasicTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isColorTrigger} != (void(D::*)()){&D::isColorTrigger})
            m->registerHook(getBase()+0x343b40, extract((void(D::*)()){&D::isColorTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            m->registerHook(getBase()+0x335a40, extract((void(D::*)()){&D::isFlipX}));

        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            m->registerHook(getBase()+0x335a50, extract((void(D::*)()){&D::isFlipY}));

        if ((void($GameObject::*)()){&$GameObject::isSpawnableTrigger} != (void(D::*)()){&D::isSpawnableTrigger})
            m->registerHook(getBase()+0x343a60, extract((void(D::*)()){&D::isSpawnableTrigger}));

        if ((void($GameObject::*)()){&$GameObject::isSpecialObject} != (void(D::*)()){&D::isSpecialObject})
            m->registerHook(getBase()+0x343c40, extract((void(D::*)()){&D::isSpecialObject}));

        if ((void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString} != (void(D::*)(std::string, bool)){&D::objectFromString})
            m->registerHook(getBase()+0x33b720, extract((void(D::*)(std::string, bool)){&D::objectFromString}));

        if ((void($GameObject::*)()){&$GameObject::playShineEffect} != (void(D::*)()){&D::playShineEffect})
            m->registerHook(getBase()+0x2fa9d0, extract((void(D::*)()){&D::playShineEffect}));

        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(getBase()+0x3369c0, extract((void(D::*)()){&D::powerOffObject}));

        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(getBase()+0x3369a0, extract((void(D::*)()){&D::powerOnObject}));

        if ((void($GameObject::*)()){&$GameObject::quickUpdatePosition} != (void(D::*)()){&D::quickUpdatePosition})
            m->registerHook(getBase()+0x335790, extract((void(D::*)()){&D::quickUpdatePosition}));

        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(getBase()+0x33ada0, extract((void(D::*)(int)){&D::removeFromGroup}));

        if ((void($GameObject::*)()){&$GameObject::removeGlow} != (void(D::*)()){&D::removeGlow})
            m->registerHook(getBase()+0x2f7f70, extract((void(D::*)()){&D::removeGlow}));

        if ((void($GameObject::*)()){&$GameObject::resetGroupDisabled} != (void(D::*)()){&D::resetGroupDisabled})
            m->registerHook(getBase()+0x2fa7e0, extract((void(D::*)()){&D::resetGroupDisabled}));

        if ((void($GameObject::*)()){&$GameObject::saveActiveColors} != (void(D::*)()){&D::saveActiveColors})
            m->registerHook(getBase()+0x33d250, extract((void(D::*)()){&D::saveActiveColors}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject} != (void(D::*)(cocos2d::_ccColor3B)){&D::selectObject})
            m->registerHook(getBase()+0x341f90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::selectObject}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            m->registerHook(getBase()+0x341f20, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor}));

        if ((void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode} != (void(D::*)(int)){&D::setDefaultMainColorMode})
            m->registerHook(getBase()+0x304fc0, extract((void(D::*)(int)){&D::setDefaultMainColorMode}));

        if ((void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition} != (void(D::*)(bool const&)){&D::setDidUpdateLastPosition})
            m->registerHook(getBase()+0x343a30, extract((void(D::*)(bool const&)){&D::setDidUpdateLastPosition}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            m->registerHook(getBase()+0x341ed0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor}));

        if ((void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity} != (void(D::*)(unsigned char)){&D::setGlowOpacity})
            m->registerHook(getBase()+0x336200, extract((void(D::*)(unsigned char)){&D::setGlowOpacity}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setLastPosition})
            m->registerHook(getBase()+0x3439e0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setLastPosition}));

        if ((void($GameObject::*)(int)){&$GameObject::setMainColorMode} != (void(D::*)(int)){&D::setMainColorMode})
            m->registerHook(getBase()+0x342e70, extract((void(D::*)(int)){&D::setMainColorMode}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(getBase()+0x341c90, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            m->registerHook(getBase()+0xdc1e0, extract((void(D::*)(bool)){&D::setObjectRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            m->registerHook(getBase()+0xdc200, extract((void(D::*)(bool)){&D::setOrientedRectDirty}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x335850, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(getBase()+0x335e10, extract((void(D::*)(float)){&D::setRScale}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            m->registerHook(getBase()+0x335cb0, extract((void(D::*)(float)){&D::setRScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            m->registerHook(getBase()+0x335d60, extract((void(D::*)(float)){&D::setRScaleY}));

        if ((void($GameObject::*)(int const&)){&$GameObject::setSectionIdx} != (void(D::*)(int const&)){&D::setSectionIdx})
            m->registerHook(getBase()+0x343a10, extract((void(D::*)(int const&)){&D::setSectionIdx}));

        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(getBase()+0x2fa520, extract((void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            m->registerHook(getBase()+0xdc220, extract((void(D::*)(GameObjectType)){&D::setType}));

        if ((void($GameObject::*)()){&$GameObject::setupCoinArt} != (void(D::*)()){&D::setupCoinArt})
            m->registerHook(getBase()+0x337dd0, extract((void(D::*)()){&D::setupCoinArt}));

        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(getBase()+0x307f60, extract((void(D::*)()){&D::setupCustomSprites}));

        if ((void($GameObject::*)()){&$GameObject::slopeFloorTop} != (void(D::*)()){&D::slopeFloorTop})
            m->registerHook(getBase()+0x342800, extract((void(D::*)()){&D::slopeFloorTop}));

        if ((void($GameObject::*)()){&$GameObject::slopeWallLeft} != (void(D::*)()){&D::slopeWallLeft})
            m->registerHook(getBase()+0x3427e0, extract((void(D::*)()){&D::slopeWallLeft}));

        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(getBase()+0xdc1b0, extract((void(D::*)()){&D::spawnXPosition}));

        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(getBase()+0x336990, extract((void(D::*)(float)){&D::triggerActivated}));

        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(getBase()+0x2fa8f0, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($GameObject::*)(float)){&$GameObject::updateCustomScale} != (void(D::*)(float)){&D::updateCustomScale})
            m->registerHook(getBase()+0x335eb0, extract((void(D::*)(float)){&D::updateCustomScale}));

        if ((void($GameObject::*)()){&$GameObject::updateMainColor} != (void(D::*)()){&D::updateMainColor})
            m->registerHook(getBase()+0x343340, extract((void(D::*)()){&D::updateMainColor}));

        if ((void($GameObject::*)()){&$GameObject::updateOrientedBox} != (void(D::*)()){&D::updateOrientedBox})
            m->registerHook(getBase()+0x342b50, extract((void(D::*)()){&D::updateOrientedBox}));

        if ((void($GameObject::*)()){&$GameObject::updateSecondaryColor} != (void(D::*)()){&D::updateSecondaryColor})
            m->registerHook(getBase()+0x343740, extract((void(D::*)()){&D::updateSecondaryColor}));

        if ((void($GameObject::*)()){&$GameObject::updateStartPos} != (void(D::*)()){&D::updateStartPos})
            m->registerHook(getBase()+0x2fa590, extract((void(D::*)()){&D::updateStartPos}));

        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            m->registerHook(getBase()+0x2fa800, extract((void(D::*)()){&D::updateStartValues}));

        if ((void($GameObject::*)()){&$GameObject::updateState} != (void(D::*)()){&D::updateState})
            m->registerHook(getBase()+0x3369e0, extract((void(D::*)()){&D::updateState}));

        if ((void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation} != (void(D::*)(float)){&D::updateSyncedAnimation})
            m->registerHook(getBase()+0x337f00, extract((void(D::*)(float)){&D::updateSyncedAnimation}));
    }
};


template<class D>
class $GameObjectCopy : public GameObjectCopy, public $CacBase {
 public:
    $GameObjectCopy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameObjectCopy* __thistype;

    static GameObjectCopy* create(GameObject* p0) {
        return reinterpret_cast<GameObjectCopy*(*)(GameObject*)>(m->getOriginal(getBase()+0x975a0))(p0);
    }

    void resetObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x976a0))(this);
    }

    void apply_hooks() override {
        if ((GameObjectCopy*(*)(GameObject*)){&$GameObjectCopy::create} != (GameObjectCopy*(*)(GameObject*)){&D::create})
            m->registerHook(getBase()+0x975a0, (GameObjectCopy*(*)(GameObject*)){&D::create});

        if ((void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x976a0, extract((void(D::*)()){&D::resetObject}));
    }
};


template<class D>
class $GameSoundManager : public GameSoundManager, public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameSoundManager* __thistype;

    void disableMetering() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d80))(this);
    }

    void enableMetering() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d00))(this);
    }

    void getMeteringValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362db0))(this);
    }

    void playBackgroundMusic(std::string p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, bool)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
    }

    void playEffect(std::string p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float, float, float)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
    }

    void sharedManager() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3610f0))(this);
    }

    void stopBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
    }

    void apply_hooks() override {
        if ((void($GameSoundManager::*)()){&$GameSoundManager::disableMetering} != (void(D::*)()){&D::disableMetering})
            m->registerHook(getBase()+0x362d80, extract((void(D::*)()){&D::disableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::enableMetering} != (void(D::*)()){&D::enableMetering})
            m->registerHook(getBase()+0x362d00, extract((void(D::*)()){&D::enableMetering}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue} != (void(D::*)()){&D::getMeteringValue})
            m->registerHook(getBase()+0x362db0, extract((void(D::*)()){&D::getMeteringValue}));

        if ((void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic} != (void(D::*)(std::string, bool, bool)){&D::playBackgroundMusic})
            m->registerHook(getBase()+0x362070, extract((void(D::*)(std::string, bool, bool)){&D::playBackgroundMusic}));

        if ((void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect} != (void(D::*)(std::string, float, float, float)){&D::playEffect})
            m->registerHook(getBase()+0x3623d0, extract((void(D::*)(std::string, float, float, float)){&D::playEffect}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::sharedManager} != (void(D::*)()){&D::sharedManager})
            m->registerHook(getBase()+0x3610f0, extract((void(D::*)()){&D::sharedManager}));

        if ((void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic} != (void(D::*)()){&D::stopBackgroundMusic})
            m->registerHook(getBase()+0x362130, extract((void(D::*)()){&D::stopBackgroundMusic}));
    }
};


template<class D>
class $GameStatsManager : public GameStatsManager, public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameStatsManager* __thistype;

    void awardCurrencyForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43600))(this, p0);
    }

    void awardDiamondsForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43c60))(this, p0);
    }

    void awardSecretKey() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x4b1e0))(this);
    }

    void getSecretCoinKey(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x429f0))(this, p0);
    }

    void getStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d310))(this, p0);
    }

    void hasPendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42730))(this, p0);
    }

    void hasSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x40730))(this, p0);
    }

    void hasUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x427e0))(this, p0);
    }

    void incrementStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
    }

    void incrementStat(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
    }

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x38f20))(this);
    }

    void storePendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42940))(this, p0);
    }

    void storeSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42a10))(this, p0);
    }

    void storeUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42890))(this, p0);
    }

    void apply_hooks() override {
        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel} != (void(D::*)(GJGameLevel*)){&D::awardCurrencyForLevel})
            m->registerHook(getBase()+0x43600, extract((void(D::*)(GJGameLevel*)){&D::awardCurrencyForLevel}));

        if ((void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel} != (void(D::*)(GJGameLevel*)){&D::awardDiamondsForLevel})
            m->registerHook(getBase()+0x43c60, extract((void(D::*)(GJGameLevel*)){&D::awardDiamondsForLevel}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey} != (void(D::*)()){&D::awardSecretKey})
            m->registerHook(getBase()+0x4b1e0, extract((void(D::*)()){&D::awardSecretKey}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey} != (void(D::*)(char const*)){&D::getSecretCoinKey})
            m->registerHook(getBase()+0x429f0, extract((void(D::*)(char const*)){&D::getSecretCoinKey}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat} != (void(D::*)(char const*)){&D::getStat})
            m->registerHook(getBase()+0x3d310, extract((void(D::*)(char const*)){&D::getStat}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin} != (void(D::*)(char const*)){&D::hasPendingUserCoin})
            m->registerHook(getBase()+0x42730, extract((void(D::*)(char const*)){&D::hasPendingUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin} != (void(D::*)(char const*)){&D::hasSecretCoin})
            m->registerHook(getBase()+0x40730, extract((void(D::*)(char const*)){&D::hasSecretCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin} != (void(D::*)(char const*)){&D::hasUserCoin})
            m->registerHook(getBase()+0x427e0, extract((void(D::*)(char const*)){&D::hasUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6d0, extract((void(D::*)(char const*)){&D::incrementStat}));

        if ((void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat} != (void(D::*)(char const*, int)){&D::incrementStat})
            m->registerHook(getBase()+0x3d6e0, extract((void(D::*)(char const*, int)){&D::incrementStat}));

        if ((void($GameStatsManager::*)()){&$GameStatsManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x38f20, extract((void(D::*)()){&D::sharedState}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin} != (void(D::*)(char const*)){&D::storePendingUserCoin})
            m->registerHook(getBase()+0x42940, extract((void(D::*)(char const*)){&D::storePendingUserCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin} != (void(D::*)(char const*)){&D::storeSecretCoin})
            m->registerHook(getBase()+0x42a10, extract((void(D::*)(char const*)){&D::storeSecretCoin}));

        if ((void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin} != (void(D::*)(char const*)){&D::storeUserCoin})
            m->registerHook(getBase()+0x42890, extract((void(D::*)(char const*)){&D::storeUserCoin}));
    }
};


template<class D>
class $GameToolbox : public GameToolbox, public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameToolbox* __thistype;

    void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x28bdd0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

    void getRelativeOffset(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x28c060))(this, p0, p1);
    }

    void multipliedColorValue(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x28cb90))(this, p0, p1, p2);
    }

    void stringSetupToDict(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d700))(this, p0, p1);
    }

    void stringSetupToMap(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d4c0))(this, p0, p1);
    }

    void transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x28c950))(this, p0, p1);
    }

    void transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, float, float, float)>(m->getOriginal(getBase()+0x28c930))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton} != (void(D::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&D::createToggleButton})
            m->registerHook(getBase()+0x28bdd0, extract((void(D::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&D::createToggleButton}));

        if ((void($GameToolbox::*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x28c060, extract((void(D::*)(GameObject*, cocos2d::CCPoint)){&D::getRelativeOffset}));

        if ((void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue} != (void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::multipliedColorValue})
            m->registerHook(getBase()+0x28cb90, extract((void(D::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&D::multipliedColorValue}));

        if ((void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict} != (void(D::*)(std::string, char const*)){&D::stringSetupToDict})
            m->registerHook(getBase()+0x28d700, extract((void(D::*)(std::string, char const*)){&D::stringSetupToDict}));

        if ((void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap} != (void(D::*)(std::string, char const*)){&D::stringSetupToMap})
            m->registerHook(getBase()+0x28d4c0, extract((void(D::*)(std::string, char const*)){&D::stringSetupToMap}));

        if ((void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor} != (void(D::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&D::transformColor})
            m->registerHook(getBase()+0x28c950, extract((void(D::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&D::transformColor}));

        if ((void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor} != (void(D::*)(cocos2d::_ccColor3B const&, float, float, float)){&D::transformColor})
            m->registerHook(getBase()+0x28c930, extract((void(D::*)(cocos2d::_ccColor3B const&, float, float, float)){&D::transformColor}));
    }
};


template<class D>
class $GravityEffectSprite : public GravityEffectSprite, public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GravityEffectSprite* __thistype;

    static GravityEffectSprite* create() {
        return reinterpret_cast<GravityEffectSprite*(*)()>(m->getOriginal(getBase()+0x6d0a0))();
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x80b20))(this);
    }

    void updateSpritesColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
    }

    void apply_hooks() override {
        if ((GravityEffectSprite*(*)()){&$GravityEffectSprite::create} != (GravityEffectSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x6d0a0, (GravityEffectSprite*(*)()){&D::create});

        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x80b20, extract((bool(D::*)()){&D::init}));

        if ((void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateSpritesColor})
            m->registerHook(getBase()+0x7ce30, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateSpritesColor}));
    }
};


template<class D>
class $GroupCommandObject : public GroupCommandObject, public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GroupCommandObject* __thistype;

    static GroupCommandObject* create() {
        return reinterpret_cast<GroupCommandObject*(*)()>(m->getOriginal(getBase()+0x18b460))();
    }

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x16ece0))(this, p0);
    }

    void easeToText(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
    }

    void getEasedAction(cocos2d::CCActionInterval* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, int, float)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
    }

    void runMoveCommand(cocos2d::CCPoint p0, float p1, int p2, float p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, int, float, bool, bool)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
    }

    void runRotateCommand(float p0, float p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, bool)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        if ((GroupCommandObject*(*)()){&$GroupCommandObject::create} != (GroupCommandObject*(*)()){&D::create})
            m->registerHook(getBase()+0x18b460, (GroupCommandObject*(*)()){&D::create});

        if ((void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x16ece0, extract((void(D::*)(std::string)){&D::createFromString}));

        if ((void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText} != (void(D::*)(int)){&D::easeToText})
            m->registerHook(getBase()+0x16ecb0, extract((void(D::*)(int)){&D::easeToText}));

        if ((void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction} != (void(D::*)(cocos2d::CCActionInterval*, int, float)){&D::getEasedAction})
            m->registerHook(getBase()+0x16e7b0, extract((void(D::*)(cocos2d::CCActionInterval*, int, float)){&D::getEasedAction}));

        if ((void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand} != (void(D::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&D::runMoveCommand})
            m->registerHook(getBase()+0x16e640, extract((void(D::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&D::runMoveCommand}));

        if ((void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand} != (void(D::*)(float, float, int, float, bool)){&D::runRotateCommand})
            m->registerHook(getBase()+0x16e8f0, extract((void(D::*)(float, float, int, float, bool)){&D::runRotateCommand}));
    }
};


template<class D>
class $HardStreak : public HardStreak, public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef HardStreak* __thistype;

    void addPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x5c950))(this, p0);
    }

    void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c930))(this);
    }

    void resumeStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c210))(this);
    }

    void stopStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c8f0))(this);
    }

    void apply_hooks() override {
        if ((void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint} != (void(D::*)(cocos2d::CCPoint)){&D::addPoint})
            m->registerHook(getBase()+0x5c950, extract((void(D::*)(cocos2d::CCPoint)){&D::addPoint}));

        if ((void($HardStreak::*)()){&$HardStreak::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x5c930, extract((void(D::*)()){&D::reset}));

        if ((void($HardStreak::*)()){&$HardStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            m->registerHook(getBase()+0x5c210, extract((void(D::*)()){&D::resumeStroke}));

        if ((void($HardStreak::*)()){&$HardStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            m->registerHook(getBase()+0x5c8f0, extract((void(D::*)()){&D::stopStroke}));
    }
};


template<class D>
class $InfoLayer : public InfoLayer, public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef InfoLayer* __thistype;

    void loadPage(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
    }

    void onRefreshComments(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x459b60))(this, p0);
    }

    void apply_hooks() override {
        if ((void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage} != (void(D::*)(int, bool)){&D::loadPage})
            m->registerHook(getBase()+0x458fb0, extract((void(D::*)(int, bool)){&D::loadPage}));

        if ((void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments} != (void(D::*)(cocos2d::CCObject*)){&D::onRefreshComments})
            m->registerHook(getBase()+0x459b60, extract((void(D::*)(cocos2d::CCObject*)){&D::onRefreshComments}));
    }
};


template<class D>
class $LabelGameObject : public LabelGameObject, public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LabelGameObject* __thistype;

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5520))(this);
    }

    void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
    }

    void apply_hooks() override {
        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x2f5520, extract((bool(D::*)()){&D::init}));

        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(getBase()+0xdbca0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));
    }
};


template<class D>
class $LevelBrowserLayer : public LevelBrowserLayer, public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelBrowserLayer* __thistype;

    void loadPage(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x253650))(this, p0);
    }

    void scene(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x2511d0))(this, p0);
    }

    void setIDPopupClosed(SetIDPopup* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(getBase()+0x2554f0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage} != (void(D::*)(GJSearchObject*)){&D::loadPage})
            m->registerHook(getBase()+0x253650, extract((void(D::*)(GJSearchObject*)){&D::loadPage}));

        if ((void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene} != (void(D::*)(GJSearchObject*)){&D::scene})
            m->registerHook(getBase()+0x2511d0, extract((void(D::*)(GJSearchObject*)){&D::scene}));

        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(getBase()+0x2554f0, extract((void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $LevelEditorLayer : public LevelEditorLayer, public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelEditorLayer* __thistype;

    void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
    }

    void addObjectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x94640))(this, p0);
    }

    void addSpecial(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x94f30))(this, p0);
    }

    void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0x9dab0))(this, p0, p1, p2);
    }

    void addToRedoList(UndoObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), UndoObject*)>(m->getOriginal(getBase()+0x96f80))(this, p0);
    }

    void addToUndoList(UndoObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), UndoObject*, bool)>(m->getOriginal(getBase()+0x94e20))(this, p0, p1);
    }

    void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x9c590))(this, p0, p1, p2, p3, p4, p5);
    }

    void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
    }

    static LevelEditorLayer* create(GJGameLevel* p0) {
        return reinterpret_cast<LevelEditorLayer*(*)(GJGameLevel*)>(m->getOriginal(getBase()+0x90fb0))(p0);
    }

    void createBackground() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x929f0))(this);
    }

    void createGroundLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92840))(this);
    }

    void createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
    }

    void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x92230))(this, p0);
    }

    void createObjectsFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa2a70))(this);
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xa04e0))(this, p0, p1, p2);
    }

    void getLastObjectX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c860))(this);
    }

    void getLevelString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97790))(this);
    }

    void getNextColorChannel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a610))(this);
    }

    void getNextFreeBlockID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a4e0))(this, p0);
    }

    void getNextFreeGroupID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
    }

    void getNextFreeItemID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a390))(this, p0);
    }

    void getObjectRect(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96240))(this, p0, p1);
    }

    void getRelativeOffset(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x96840))(this, p0);
    }

    void handleAction(bool p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
    }

    bool init(GJGameLevel* p0) {
        return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x91010))(this, p0);
    }

    void levelSettingsUpdated() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93f30))(this);
    }

    void objectAtPosition(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x960c0))(this, p0);
    }

    void objectMoved(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x999f0))(this, p0);
    }

    void objectsInRect(cocos2d::CCRect p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, bool)>(m->getOriginal(getBase()+0x95e60))(this, p0, p1);
    }

    void onPlaytest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa06b0))(this);
    }

    void onStopPlaytest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa1780))(this);
    }

    void playMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa13c0))(this);
    }

    void recreateGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9dbf0))(this);
    }

    void redoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
    }

    void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
    }

    void removeAllObjectsOfType(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x96d40))(this, p0);
    }

    void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0x9db60))(this, p0, p1);
    }

    void removeObject(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
    }

    void removeSpecial(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x969c0))(this, p0);
    }

    void resetMovingObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9ddc0))(this);
    }

    void resetObjectVector() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c4b0))(this);
    }

    void resetToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9aa70))(this);
    }

    void resetToggledGroupsAndObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c3c0))(this);
    }

    void resetUnusedColorChannels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a870))(this);
    }

    void rotationForSlopeNearObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x95cd0))(this, p0);
    }

    void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
    }

    void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x90f20))(this, p0);
    }

    void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
    }

    void sortStickyGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92b10))(this);
    }

    void stopTriggersInGroup(int p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
    }

    void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c7d0))(this, p0);
    }

    void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
    }

    void toggleGroupPreview(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
    }

    void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
    }

    void undoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
    }

    void updateBGAndGColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9b9b0))(this);
    }

    void updateBlendValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bc60))(this);
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
    }

    void updateEditorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93b50))(this);
    }

    void updateGameObjectsNew() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9adc0))(this);
    }

    void updateGround(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x93a60))(this, p0);
    }

    void updateGroundWidth() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92af0))(this);
    }

    void updateOptions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x91ed0))(this);
    }

    void updateToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bb10))(this);
    }

    void updateVisibility(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x92c70))(this, p0);
    }

    void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c800))(this, p0);
    }

    void apply_hooks() override {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect})
            m->registerHook(getBase()+0x9b520, extract((void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect}));

        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString} != (void(D::*)(std::string)){&D::addObjectFromString})
            m->registerHook(getBase()+0x94640, extract((void(D::*)(std::string)){&D::addObjectFromString}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject*)){&D::addSpecial})
            m->registerHook(getBase()+0x94f30, extract((void(D::*)(GameObject*)){&D::addSpecial}));

        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(getBase()+0x9dab0, extract((void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject*)){&D::addToRedoList})
            m->registerHook(getBase()+0x96f80, extract((void(D::*)(UndoObject*)){&D::addToRedoList}));

        if ((void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject*, bool)){&D::addToUndoList})
            m->registerHook(getBase()+0x94e20, extract((void(D::*)(UndoObject*, bool)){&D::addToUndoList}));

        if ((void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(getBase()+0xa2780, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0x9c590, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(getBase()+0x9e620, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((LevelEditorLayer*(*)(GJGameLevel*)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(getBase()+0x90fb0, (LevelEditorLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            m->registerHook(getBase()+0x929f0, extract((void(D::*)()){&D::createBackground}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            m->registerHook(getBase()+0x92840, extract((void(D::*)()){&D::createGroundLayer}));

        if ((void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject} != (void(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject})
            m->registerHook(getBase()+0x957c0, extract((void(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject}));

        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x92230, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::string, bool)){&D::createObjectsFromString})
            m->registerHook(getBase()+0x94730, extract((void(D::*)(std::string, bool)){&D::createObjectsFromString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0xa2a70, extract((void(D::*)()){&D::draw}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0xa04e0, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            m->registerHook(getBase()+0x9c860, extract((void(D::*)()){&D::getLastObjectX}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            m->registerHook(getBase()+0x97790, extract((void(D::*)()){&D::getLevelString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            m->registerHook(getBase()+0x9a610, extract((void(D::*)()){&D::getNextColorChannel}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID})
            m->registerHook(getBase()+0x9a4e0, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID})
            m->registerHook(getBase()+0x9a1b0, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID})
            m->registerHook(getBase()+0x9a390, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject*, bool)){&D::getObjectRect})
            m->registerHook(getBase()+0x96240, extract((void(D::*)(GameObject*, bool)){&D::getObjectRect}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject*)){&D::getRelativeOffset})
            m->registerHook(getBase()+0x96840, extract((void(D::*)(GameObject*)){&D::getRelativeOffset}));

        if ((void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction} != (void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction})
            m->registerHook(getBase()+0x97020, extract((void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction}));

        if ((bool($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(getBase()+0x91010, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            m->registerHook(getBase()+0x93f30, extract((void(D::*)()){&D::levelSettingsUpdated}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition})
            m->registerHook(getBase()+0x960c0, extract((void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject*)){&D::objectMoved})
            m->registerHook(getBase()+0x999f0, extract((void(D::*)(GameObject*)){&D::objectMoved}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect})
            m->registerHook(getBase()+0x95e60, extract((void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            m->registerHook(getBase()+0xa06b0, extract((void(D::*)()){&D::onPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            m->registerHook(getBase()+0xa1780, extract((void(D::*)()){&D::onStopPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            m->registerHook(getBase()+0xa13c0, extract((void(D::*)()){&D::playMusic}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            m->registerHook(getBase()+0x9dbf0, extract((void(D::*)()){&D::recreateGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            m->registerHook(getBase()+0x97750, extract((void(D::*)()){&D::redoLastAction}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x93d80, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(int)){&D::removeAllObjectsOfType})
            m->registerHook(getBase()+0x96d40, extract((void(D::*)(int)){&D::removeAllObjectsOfType}));

        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(getBase()+0x9db60, extract((void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject*, bool)){&D::removeObject})
            m->registerHook(getBase()+0x96890, extract((void(D::*)(GameObject*, bool)){&D::removeObject}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject*)){&D::removeSpecial})
            m->registerHook(getBase()+0x969c0, extract((void(D::*)(GameObject*)){&D::removeSpecial}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            m->registerHook(getBase()+0x9ddc0, extract((void(D::*)()){&D::resetMovingObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            m->registerHook(getBase()+0x9c4b0, extract((void(D::*)()){&D::resetObjectVector}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(getBase()+0x9aa70, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            m->registerHook(getBase()+0x9c3c0, extract((void(D::*)()){&D::resetToggledGroupsAndObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            m->registerHook(getBase()+0x9a870, extract((void(D::*)()){&D::resetUnusedColorChannels}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject*)){&D::rotationForSlopeNearObject})
            m->registerHook(getBase()+0x95cd0, extract((void(D::*)(GameObject*)){&D::rotationForSlopeNearObject}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect})
            m->registerHook(getBase()+0x9bd30, extract((void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect}));

        if ((void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(getBase()+0x90f20, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(getBase()+0xa0ca0, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            m->registerHook(getBase()+0x92b10, extract((void(D::*)()){&D::sortStickyGroups}));

        if ((void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(int, float)){&D::stopTriggersInGroup})
            m->registerHook(getBase()+0x9c030, extract((void(D::*)(int, float)){&D::stopTriggersInGroup}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x9c7d0, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(getBase()+0xa0200, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(int, bool)){&D::toggleGroupPreview})
            m->registerHook(getBase()+0x9bea0, extract((void(D::*)(int, bool)){&D::toggleGroupPreview}));

        if ((void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors})
            m->registerHook(getBase()+0x9ab50, extract((void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            m->registerHook(getBase()+0x97770, extract((void(D::*)()){&D::undoLastAction}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0xa1b70, extract((void(D::*)(float)){&D::update}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            m->registerHook(getBase()+0x9b9b0, extract((void(D::*)()){&D::updateBGAndGColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            m->registerHook(getBase()+0x9bc60, extract((void(D::*)()){&D::updateBlendValues}));

        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0x9c200, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(getBase()+0xa1a60, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            m->registerHook(getBase()+0x93b50, extract((void(D::*)()){&D::updateEditorMode}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            m->registerHook(getBase()+0x9adc0, extract((void(D::*)()){&D::updateGameObjectsNew}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround} != (void(D::*)(float)){&D::updateGround})
            m->registerHook(getBase()+0x93a60, extract((void(D::*)(float)){&D::updateGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(getBase()+0x92af0, extract((void(D::*)()){&D::updateGroundWidth}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            m->registerHook(getBase()+0x91ed0, extract((void(D::*)()){&D::updateOptions}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            m->registerHook(getBase()+0x9bb10, extract((void(D::*)()){&D::updateToggledGroups}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(float)){&D::updateVisibility})
            m->registerHook(getBase()+0x92c70, extract((void(D::*)(float)){&D::updateVisibility}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x9c800, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $LevelSettingsLayer : public LevelSettingsLayer, public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelSettingsLayer* __thistype;

    static LevelSettingsLayer* create(LevelSettingsObject* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa7c30))(p0, p1);
    }

    void apply_hooks() override {
        if ((LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create} != (LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&D::create})
            m->registerHook(getBase()+0xa7c30, (LevelSettingsLayer*(*)(LevelSettingsObject*, LevelEditorLayer*)){&D::create});
    }
};


template<class D>
class $LevelSettingsObject : public LevelSettingsObject, public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelSettingsObject* __thistype;

    static LevelSettingsObject* create() {
        return reinterpret_cast<LevelSettingsObject*(*)()>(m->getOriginal(getBase()+0x92760))();
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0xa5690))(this);
    }

    void objectFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa5810))(this, p0);
    }

    void objectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x945a0))(this, p0);
    }

    void setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
    }

    void apply_hooks() override {
        if ((LevelSettingsObject*(*)()){&$LevelSettingsObject::create} != (LevelSettingsObject*(*)()){&D::create})
            m->registerHook(getBase()+0x92760, (LevelSettingsObject*(*)()){&D::create});

        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0xa5690, extract((bool(D::*)()){&D::init}));

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::objectFromDict})
            m->registerHook(getBase()+0xa5810, extract((void(D::*)(cocos2d::CCDictionary*)){&D::objectFromDict}));

        if ((void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString} != (void(D::*)(std::string)){&D::objectFromString})
            m->registerHook(getBase()+0x945a0, extract((void(D::*)(std::string)){&D::objectFromString}));

        if ((void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode} != (void(D::*)(cocos2d::CCDictionary*)){&D::setupColorsFromLegacyMode})
            m->registerHook(getBase()+0xa6a30, extract((void(D::*)(cocos2d::CCDictionary*)){&D::setupColorsFromLegacyMode}));
    }
};


template<class D>
class $LevelTools : public LevelTools, public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelTools* __thistype;

    void getAudioString(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x293880))(this, p0);
    }

    void verifyLevelIntegrity(std::string p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, int)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
    }

    void xPosForTime(float p0, cocos2d::CCArray* p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCArray*, int)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($LevelTools::*)(int)){&$LevelTools::getAudioString} != (void(D::*)(int)){&D::getAudioString})
            m->registerHook(getBase()+0x293880, extract((void(D::*)(int)){&D::getAudioString}));

        if ((void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity} != (void(D::*)(std::string, int)){&D::verifyLevelIntegrity})
            m->registerHook(getBase()+0x294360, extract((void(D::*)(std::string, int)){&D::verifyLevelIntegrity}));

        if ((void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime} != (void(D::*)(float, cocos2d::CCArray*, int)){&D::xPosForTime})
            m->registerHook(getBase()+0x293d90, extract((void(D::*)(float, cocos2d::CCArray*, int)){&D::xPosForTime}));
    }
};


template<class D>
class $LoadingLayer : public LoadingLayer, public $CacBase {
 public:
    $LoadingLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LoadingLayer* __thistype;

    void loadAssets() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1dfb20))(this);
    }

    void apply_hooks() override {
        if ((void($LoadingLayer::*)()){&$LoadingLayer::loadAssets} != (void(D::*)()){&D::loadAssets})
            m->registerHook(getBase()+0x1dfb20, extract((void(D::*)()){&D::loadAssets}));
    }
};


template<class D>
class $LocalLevelManager : public LocalLevelManager, public $CacBase {
 public:
    $LocalLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LocalLevelManager* __thistype;

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35dd60))(this);
    }

    void apply_hooks() override {
        if ((void($LocalLevelManager::*)()){&$LocalLevelManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x35dd60, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $MenuGameLayer : public MenuGameLayer, public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MenuGameLayer* __thistype;

    void resetPlayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28fdc0))(this);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
    }

    void apply_hooks() override {
        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer} != (void(D::*)()){&D::resetPlayer})
            m->registerHook(getBase()+0x28fdc0, extract((void(D::*)()){&D::resetPlayer}));

        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x28fa70, extract((void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MenuLayer* __thistype;

    void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3160))(this);
    }

    void onMoreGames(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
    }

    void onQuit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
    }

    void apply_hooks() override {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x1d3160, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            m->registerHook(getBase()+0x1d2ad0, extract((void(D::*)(cocos2d::CCObject*)){&D::onMoreGames}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            m->registerHook(getBase()+0x1d2b40, extract((void(D::*)(cocos2d::CCObject*)){&D::onQuit}));
    }
};


template<class D>
class $MoreVideoOptionsLayer : public MoreVideoOptionsLayer, public $CacBase {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MoreVideoOptionsLayer* __thistype;

    static MoreVideoOptionsLayer* create() {
        return reinterpret_cast<MoreVideoOptionsLayer*(*)()>(m->getOriginal(getBase()+0x443c10))();
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
    }

    void apply_hooks() override {
        if ((MoreVideoOptionsLayer*(*)()){&$MoreVideoOptionsLayer::create} != (MoreVideoOptionsLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x443c10, (MoreVideoOptionsLayer*(*)()){&D::create});

        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x444150, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $MusicDownloadManager : public MusicDownloadManager, public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MusicDownloadManager* __thistype;

    void incrementPriorityForSong(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
    }

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2ee4c0))(this);
    }

    void apply_hooks() override {
        if ((void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong} != (void(D::*)(int)){&D::incrementPriorityForSong})
            m->registerHook(getBase()+0x2ef750, extract((void(D::*)(int)){&D::incrementPriorityForSong}));

        if ((void($MusicDownloadManager::*)()){&$MusicDownloadManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x2ee4c0, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $OBB2D : public OBB2D, public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef OBB2D* __thistype;

    void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
    }

    static OBB2D* create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<OBB2D*(*)(cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a890))(p0, p1, p2, p3);
    }

    void getBoundingRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35b2b0))(this);
    }

    void overlaps(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0a0))(this, p0);
    }

    void overlaps1Way(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter})
            m->registerHook(getBase()+0x35a9c0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter}));

        if ((OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create})
            m->registerHook(getBase()+0x35a890, (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create});

        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            m->registerHook(getBase()+0x35b2b0, extract((void(D::*)()){&D::getBoundingRect}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps} != (void(D::*)(OBB2D*)){&D::overlaps})
            m->registerHook(getBase()+0x35b0a0, extract((void(D::*)(OBB2D*)){&D::overlaps}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D*)){&D::overlaps1Way})
            m->registerHook(getBase()+0x35b0d0, extract((void(D::*)(OBB2D*)){&D::overlaps1Way}));
    }
};


template<class D>
class $ObjectToolbox : public ObjectToolbox, public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ObjectToolbox* __thistype;

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2d80))(this);
    }

    void intKeyToFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
    }

    void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2bc0))(this);
    }

    void apply_hooks() override {
        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x3b2d80, extract((bool(D::*)()){&D::init}));

        if ((void($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame} != (void(D::*)(int)){&D::intKeyToFrame})
            m->registerHook(getBase()+0x4173b0, extract((void(D::*)(int)){&D::intKeyToFrame}));

        if ((void($ObjectToolbox::*)()){&$ObjectToolbox::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(getBase()+0x3b2bc0, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $OpacityEffectAction : public OpacityEffectAction, public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef OpacityEffectAction* __thistype;

    static OpacityEffectAction* create(float p0, float p1, float p2, int p3) {
        return reinterpret_cast<OpacityEffectAction*(*)(float, float, float, int)>(m->getOriginal(getBase()+0x1789f0))(p0, p1, p2, p3);
    }

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x178c10))(this, p0);
    }

    bool init(float p0, float p1, float p2, int p3) {
        return reinterpret_cast<bool(*)(decltype(this), float, float, float, int)>(m->getOriginal(getBase()+0x178b00))(this, p0, p1, p2, p3);
    }

    void step(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x178b90))(this, p0);
    }

    void apply_hooks() override {
        if ((OpacityEffectAction*(*)(float, float, float, int)){&$OpacityEffectAction::create} != (OpacityEffectAction*(*)(float, float, float, int)){&D::create})
            m->registerHook(getBase()+0x1789f0, (OpacityEffectAction*(*)(float, float, float, int)){&D::create});

        if ((void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x178c10, extract((void(D::*)(std::string)){&D::createFromString}));

        if ((bool($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init} != (bool(D::*)(float, float, float, int)){&D::init})
            m->registerHook(getBase()+0x178b00, extract((bool(D::*)(float, float, float, int)){&D::init}));

        if ((void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step} != (void(D::*)(float)){&D::step})
            m->registerHook(getBase()+0x178b90, extract((void(D::*)(float)){&D::step}));
    }
};


template<class D>
class $PauseLayer : public PauseLayer, public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PauseLayer* __thistype;

    static PauseLayer* create(bool p0) {
        return reinterpret_cast<PauseLayer*(*)(bool)>(m->getOriginal(getBase()+0x20b1e0))(p0);
    }

    void onEdit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x20c630))(this, p0);
    }

    void apply_hooks() override {
        if ((PauseLayer*(*)(bool)){&$PauseLayer::create} != (PauseLayer*(*)(bool)){&D::create})
            m->registerHook(getBase()+0x20b1e0, (PauseLayer*(*)(bool)){&D::create});

        if ((void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit} != (void(D::*)(cocos2d::CCObject*)){&D::onEdit})
            m->registerHook(getBase()+0x20c630, extract((void(D::*)(cocos2d::CCObject*)){&D::onEdit}));
    }
};


template<class D>
class $PlatformToolbox : public PlatformToolbox, public $CacBase {
 public:
    $PlatformToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlatformToolbox* __thistype;

    void hideCursor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c340))(this);
    }

    void showCursor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c360))(this);
    }

    void apply_hooks() override {
        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor} != (void(D::*)()){&D::hideCursor})
            m->registerHook(getBase()+0x27c340, extract((void(D::*)()){&D::hideCursor}));

        if ((void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor} != (void(D::*)()){&D::showCursor})
            m->registerHook(getBase()+0x27c360, extract((void(D::*)()){&D::showCursor}));
    }
};


template<class D>
class $PlayLayer : public PlayLayer, public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayLayer* __thistype;

    void addCircle(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
    }

    void addObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x70e50))(this, p0);
    }

    void addToGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77680))(this, p0);
    }

    void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
    }

    void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
    }

    void animateInGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
    }

    void animateOutGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6f350))(this, p0);
    }

    void animateOutGroundFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7de80))(this);
    }

    void applyEnterEffect(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c310))(this, p0);
    }

    void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
    }

    void cameraMoveX(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
    }

    void cameraMoveY(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
    }

    void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
    }

    void circleWaveWillBeRemoved(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e110))(this, p0);
    }

    void claimParticle(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
    }

    void clearPickedUpItems() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cfa0))(this);
    }

    void colorObject(int p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
    }

    void commitJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x737e0))(this);
    }

    static PlayLayer* create(GJGameLevel* p0) {
        return reinterpret_cast<PlayLayer*(*)(GJGameLevel*)>(m->getOriginal(getBase()+0x6b590))(p0);
    }

    void createCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e470))(this);
    }

    void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x6d130))(this, p0);
    }

    void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
    }

    void currencyWillExit(CurrencyRewardLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(getBase()+0x7e070))(this, p0);
    }

    void delayedResetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e050))(this);
    }

    void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
    }

    void dialogClosed(DialogLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d160))(this);
    }

    void enterDualMode(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
    }

    void exitAirMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7dd40))(this);
    }

    void exitBirdMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
    }

    void exitDartMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
    }

    void exitFlyMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
    }

    void exitRobotMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de20))(this, p0);
    }

    void exitRollMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de60))(this, p0);
    }

    void exitSpiderMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de40))(this, p0);
    }

    void flipFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e150))(this);
    }

    void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
    }

    void flipObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76130))(this);
    }

    void fullReset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f8e0))(this);
    }

    void getLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f840))(this);
    }

    void getMaxPortalY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b4e0))(this);
    }

    void getMinPortalY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b550))(this);
    }

    void getObjectsState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e9d0))(this);
    }

    void getOtherPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
    }

    void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
    }

    void getParticleKey2(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x767b0))(this, p0);
    }

    void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
    }

    void getTempMilliTime() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x778e0))(this);
    }

    void gravityEffectFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cec0))(this);
    }

    void hasItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
    }

    void hasUniqueCoin(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77510))(this, p0);
    }

    void incrementJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ff40))(this);
    }

    bool init(GJGameLevel* p0) {
        return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
    }

    void isFlipping() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76100))(this);
    }

    void levelComplete() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72b80))(this);
    }

    void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
    }

    void loadDefaultColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ef30))(this);
    }

    void loadFromCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7f000))(this, p0);
    }

    void loadLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7efc0))(this);
    }

    void loadSavedObjectsState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
    }

    void markCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef60))(this);
    }

    void moveCameraToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x7c980))(this, p0);
    }

    void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x806e0))(this);
    }

    void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80710))(this);
    }

    void onQuit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72710))(this);
    }

    void optimizeColorGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dad0))(this);
    }

    void optimizeOpacityGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dc20))(this);
    }

    void optimizeSaveRequiredGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dd70))(this);
    }

    void pauseGame(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x802d0))(this, p0);
    }

    void pickupItem(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
    }

    void playAnimationCommand(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
    }

    void playEndAnimationToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x759a0))(this, p0);
    }

    void playExitDualEffect(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
    }

    void playFlashEffect(float p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
    }

    void playGravityEffect(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
    }

    void playSpeedParticle(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77030))(this, p0);
    }

    void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
    }

    void prepareSpawnObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fc00))(this);
    }

    void processItems() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x735c0))(this);
    }

    void processLoadedMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a7c0))(this);
    }

    void recordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
    }

    void registerActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77620))(this, p0);
    }

    void registerStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777b0))(this, p0);
    }

    void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x727b0))(this);
    }

    void removeFromGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77750))(this, p0);
    }

    void removeLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f870))(this);
    }

    void removePlayer2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d630))(this);
    }

    void resetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
    }

    void resume() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80480))(this);
    }

    void resumeAndRestart() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80400))(this);
    }

    void saveRecordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
    }

    void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b500))(this, p0);
    }

    void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0x6f560))(this, p0);
    }

    void setupReplay(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
    }

    void shakeCamera(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
    }

    void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x771b0))(this, p0);
    }

    void showCompleteEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x738e0))(this);
    }

    void showCompleteText() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73be0))(this);
    }

    void showEndLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74450))(this);
    }

    void showHint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7deb0))(this);
    }

    void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
    }

    void showRetryLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ba0))(this);
    }

    void showTwoPlayerGuide() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6df00))(this);
    }

    void sortGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d9e0))(this);
    }

    void spawnCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73820))(this);
    }

    void spawnFirework() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74200))(this);
    }

    void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
    }

    void spawnPlayer2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d170))(this);
    }

    void startGame() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x726b0))(this);
    }

    void startMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72910))(this);
    }

    void startRecording() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fec0))(this);
    }

    void startRecordingDelayed() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fed0))(this);
    }

    void stopCameraShake() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75900))(this);
    }

    void stopRecording() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d090))(this);
    }

    void storeCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
    }

    void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
    }

    void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
    }

    void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
    }

    void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
    }

    void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d120))(this, p0);
    }

    void timeForXPos2(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
    }

    void toggleBGEffectVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
    }

    void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
    }

    void toggleFlipped(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
    }

    void toggleGhostEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
    }

    void toggleGlitter(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x70e00))(this, p0);
    }

    void togglePracticeMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
    }

    void toggleProgressbar() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6eeb0))(this);
    }

    void tryStartRecord() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fe00))(this);
    }

    void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
    }

    void unregisterActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77660))(this, p0);
    }

    void unregisterStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777f0))(this, p0);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77900))(this, p0);
    }

    void updateAttempts() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcd0))(this);
    }

    void updateCamera(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
    }

    void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
    }

    void updateEffectPositions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a6d0))(this);
    }

    void updateLevelColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6f1e0))(this);
    }

    void updateMoveObjectsLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a720))(this);
    }

    void updateProgressbar() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ed70))(this);
    }

    void updateReplay(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x78b60))(this, p0);
    }

    void updateTimeMod(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
    }

    void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
    }

    void updateVisibility() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6fb90))(this);
    }

    void vfDChk() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcb0))(this);
    }

    void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ef0))(this);
    }

    void visitWithColorFlash() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x761f0))(this);
    }

    void willSwitchToMode(int p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
    }

    void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d140))(this, p0);
    }

    void apply_hooks() override {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave*)){&D::addCircle})
            m->registerHook(getBase()+0x7e0f0, extract((void(D::*)(CCCircleWave*)){&D::addCircle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject} != (void(D::*)(GameObject*)){&D::addObject})
            m->registerHook(getBase()+0x70e50, extract((void(D::*)(GameObject*)){&D::addObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject*)){&D::addToGroupOld})
            m->registerHook(getBase()+0x77680, extract((void(D::*)(GameObject*)){&D::addToGroupOld}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            m->registerHook(getBase()+0x7cfc0, extract((void(D::*)(GameObject*)){&D::addToSpeedObjects}));

        if ((void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(getBase()+0x7d710, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround} != (void(D::*)(bool)){&D::animateInGround})
            m->registerHook(getBase()+0x7d9d0, extract((void(D::*)(bool)){&D::animateInGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround} != (void(D::*)(bool)){&D::animateOutGround})
            m->registerHook(getBase()+0x6f350, extract((void(D::*)(bool)){&D::animateOutGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            m->registerHook(getBase()+0x7de80, extract((void(D::*)()){&D::animateOutGroundFinished}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject*)){&D::applyEnterEffect})
            m->registerHook(getBase()+0x7c310, extract((void(D::*)(GameObject*)){&D::applyEnterEffect}));

        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(getBase()+0x7aa10, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX} != (void(D::*)(float, float, float)){&D::cameraMoveX})
            m->registerHook(getBase()+0x7cbe0, extract((void(D::*)(float, float, float)){&D::cameraMoveX}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY} != (void(D::*)(float, float, float)){&D::cameraMoveY})
            m->registerHook(getBase()+0x7cc60, extract((void(D::*)(float, float, float)){&D::cameraMoveY}));

        if ((void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(getBase()+0x78c90, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            m->registerHook(getBase()+0x7e110, extract((void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle} != (void(D::*)(std::string)){&D::claimParticle})
            m->registerHook(getBase()+0x76ba0, extract((void(D::*)(std::string)){&D::claimParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            m->registerHook(getBase()+0x7cfa0, extract((void(D::*)()){&D::clearPickedUpItems}));

        if ((void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject} != (void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject})
            m->registerHook(getBase()+0x77810, extract((void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            m->registerHook(getBase()+0x737e0, extract((void(D::*)()){&D::commitJumps}));

        if ((PlayLayer*(*)(GJGameLevel*)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(getBase()+0x6b590, (PlayLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            m->registerHook(getBase()+0x7e470, extract((void(D::*)()){&D::createCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(getBase()+0x6d130, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle})
            m->registerHook(getBase()+0x76800, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle}));

        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(getBase()+0x7e070, extract((void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            m->registerHook(getBase()+0x7e050, extract((void(D::*)()){&D::delayedResetLevel}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer})
            m->registerHook(getBase()+0x7ab80, extract((void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer}));

        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(getBase()+0x7e0b0, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x7d160, extract((void(D::*)()){&D::draw}));

        if ((void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject*, bool)){&D::enterDualMode})
            m->registerHook(getBase()+0x7d6a0, extract((void(D::*)(GameObject*, bool)){&D::enterDualMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            m->registerHook(getBase()+0x7dd40, extract((void(D::*)()){&D::exitAirMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject*)){&D::exitBirdMode})
            m->registerHook(getBase()+0x7dd80, extract((void(D::*)(PlayerObject*)){&D::exitBirdMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject*)){&D::exitDartMode})
            m->registerHook(getBase()+0x7ddd0, extract((void(D::*)(PlayerObject*)){&D::exitDartMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject*)){&D::exitFlyMode})
            m->registerHook(getBase()+0x7dcf0, extract((void(D::*)(PlayerObject*)){&D::exitFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject*)){&D::exitRobotMode})
            m->registerHook(getBase()+0x7de20, extract((void(D::*)(PlayerObject*)){&D::exitRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject*)){&D::exitRollMode})
            m->registerHook(getBase()+0x7de60, extract((void(D::*)(PlayerObject*)){&D::exitRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject*)){&D::exitSpiderMode})
            m->registerHook(getBase()+0x7de40, extract((void(D::*)(PlayerObject*)){&D::exitSpiderMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            m->registerHook(getBase()+0x7e150, extract((void(D::*)()){&D::flipFinished}));

        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0x7cd10, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            m->registerHook(getBase()+0x76130, extract((void(D::*)()){&D::flipObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            m->registerHook(getBase()+0x7f8e0, extract((void(D::*)()){&D::fullReset}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            m->registerHook(getBase()+0x7f840, extract((void(D::*)()){&D::getLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            m->registerHook(getBase()+0x7b4e0, extract((void(D::*)()){&D::getMaxPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            m->registerHook(getBase()+0x7b550, extract((void(D::*)()){&D::getMinPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            m->registerHook(getBase()+0x7e9d0, extract((void(D::*)()){&D::getObjectsState}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject*)){&D::getOtherPlayer})
            m->registerHook(getBase()+0x7dcc0, extract((void(D::*)(PlayerObject*)){&D::getOtherPlayer}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey})
            m->registerHook(getBase()+0x764d0, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::string)){&D::getParticleKey2})
            m->registerHook(getBase()+0x767b0, extract((void(D::*)(std::string)){&D::getParticleKey2}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod})
            m->registerHook(getBase()+0x7c2a0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            m->registerHook(getBase()+0x778e0, extract((void(D::*)()){&D::getTempMilliTime}));

        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            m->registerHook(getBase()+0x7cec0, extract((void(D::*)()){&D::gravityEffectFinished}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::hasItem} != (void(D::*)(int)){&D::hasItem})
            m->registerHook(getBase()+0x7cee0, extract((void(D::*)(int)){&D::hasItem}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject*)){&D::hasUniqueCoin})
            m->registerHook(getBase()+0x77510, extract((void(D::*)(GameObject*)){&D::hasUniqueCoin}));

        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x7ff40, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(getBase()+0x6b5f0, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            m->registerHook(getBase()+0x76100, extract((void(D::*)()){&D::isFlipping}));

        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            m->registerHook(getBase()+0x72b80, extract((void(D::*)()){&D::levelComplete}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash})
            m->registerHook(getBase()+0x75cc0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash})
            m->registerHook(getBase()+0x75bf0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            m->registerHook(getBase()+0x6ef30, extract((void(D::*)()){&D::loadDefaultColors}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x7f000, extract((void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            m->registerHook(getBase()+0x7efc0, extract((void(D::*)()){&D::loadLastCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::string)){&D::loadSavedObjectsState})
            m->registerHook(getBase()+0x7f3d0, extract((void(D::*)(std::string)){&D::loadSavedObjectsState}));

        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            m->registerHook(getBase()+0x7ef60, extract((void(D::*)()){&D::markCheckpoint}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos})
            m->registerHook(getBase()+0x7c980, extract((void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(getBase()+0x806e0, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(getBase()+0x80710, extract((void(D::*)()){&D::onExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            m->registerHook(getBase()+0x72710, extract((void(D::*)()){&D::onQuit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            m->registerHook(getBase()+0x6dad0, extract((void(D::*)()){&D::optimizeColorGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            m->registerHook(getBase()+0x6dc20, extract((void(D::*)()){&D::optimizeOpacityGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            m->registerHook(getBase()+0x6dd70, extract((void(D::*)()){&D::optimizeSaveRequiredGroups}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame} != (void(D::*)(bool)){&D::pauseGame})
            m->registerHook(getBase()+0x802d0, extract((void(D::*)(bool)){&D::pauseGame}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject*)){&D::pickupItem})
            m->registerHook(getBase()+0x7c1d0, extract((void(D::*)(GameObject*)){&D::pickupItem}));

        if ((void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand} != (void(D::*)(int, int)){&D::playAnimationCommand})
            m->registerHook(getBase()+0x75930, extract((void(D::*)(int, int)){&D::playAnimationCommand}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos})
            m->registerHook(getBase()+0x759a0, extract((void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject*)){&D::playExitDualEffect})
            m->registerHook(getBase()+0x7d1d0, extract((void(D::*)(PlayerObject*)){&D::playExitDualEffect}));

        if ((void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect} != (void(D::*)(float, int, float)){&D::playFlashEffect})
            m->registerHook(getBase()+0x75e50, extract((void(D::*)(float, int, float)){&D::playFlashEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect} != (void(D::*)(bool)){&D::playGravityEffect})
            m->registerHook(getBase()+0x7b5a0, extract((void(D::*)(bool)){&D::playGravityEffect}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle} != (void(D::*)(float)){&D::playSpeedParticle})
            m->registerHook(getBase()+0x77030, extract((void(D::*)(float)){&D::playSpeedParticle}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode})
            m->registerHook(getBase()+0x7b820, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            m->registerHook(getBase()+0x7fc00, extract((void(D::*)()){&D::prepareSpawnObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            m->registerHook(getBase()+0x735c0, extract((void(D::*)()){&D::processItems}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            m->registerHook(getBase()+0x7a7c0, extract((void(D::*)()){&D::processLoadedMoveActions}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction} != (void(D::*)(bool, PlayerObject*)){&D::recordAction})
            m->registerHook(getBase()+0x7e190, extract((void(D::*)(bool, PlayerObject*)){&D::recordAction}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject*)){&D::registerActiveObject})
            m->registerHook(getBase()+0x77620, extract((void(D::*)(GameObject*)){&D::registerActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject*)){&D::registerStateObject})
            m->registerHook(getBase()+0x777b0, extract((void(D::*)(GameObject*)){&D::registerStateObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x727b0, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject*)){&D::removeFromGroupOld})
            m->registerHook(getBase()+0x77750, extract((void(D::*)(GameObject*)){&D::removeFromGroupOld}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            m->registerHook(getBase()+0x7f870, extract((void(D::*)()){&D::removeLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            m->registerHook(getBase()+0x7d630, extract((void(D::*)()){&D::removePlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            m->registerHook(getBase()+0x71c50, extract((void(D::*)()){&D::resetLevel}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            m->registerHook(getBase()+0x80480, extract((void(D::*)()){&D::resume}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            m->registerHook(getBase()+0x80400, extract((void(D::*)()){&D::resumeAndRestart}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction} != (void(D::*)(bool, PlayerObject*)){&D::saveRecordAction})
            m->registerHook(getBase()+0x78750, extract((void(D::*)(bool, PlayerObject*)){&D::saveRecordAction}));

        if ((void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(getBase()+0x6b500, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(getBase()+0x6f560, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay} != (void(D::*)(std::string)){&D::setupReplay})
            m->registerHook(getBase()+0x7e1e0, extract((void(D::*)(std::string)){&D::setupReplay}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera} != (void(D::*)(float, float, float)){&D::shakeCamera})
            m->registerHook(getBase()+0x744a0, extract((void(D::*)(float, float, float)){&D::shakeCamera}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            m->registerHook(getBase()+0x771b0, extract((void(D::*)(int)){&D::shouldBlend}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            m->registerHook(getBase()+0x738e0, extract((void(D::*)()){&D::showCompleteEffect}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            m->registerHook(getBase()+0x73be0, extract((void(D::*)()){&D::showCompleteText}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            m->registerHook(getBase()+0x74450, extract((void(D::*)()){&D::showEndLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            m->registerHook(getBase()+0x7deb0, extract((void(D::*)()){&D::showHint}));

        if ((void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest} != (void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest})
            m->registerHook(getBase()+0x74580, extract((void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            m->registerHook(getBase()+0x75ba0, extract((void(D::*)()){&D::showRetryLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            m->registerHook(getBase()+0x6df00, extract((void(D::*)()){&D::showTwoPlayerGuide}));

        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            m->registerHook(getBase()+0x6d9e0, extract((void(D::*)()){&D::sortGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x73820, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            m->registerHook(getBase()+0x74200, extract((void(D::*)()){&D::spawnFirework}));

        if ((void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle} != (void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle})
            m->registerHook(getBase()+0x76330, extract((void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            m->registerHook(getBase()+0x7d170, extract((void(D::*)()){&D::spawnPlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            m->registerHook(getBase()+0x726b0, extract((void(D::*)()){&D::startGame}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            m->registerHook(getBase()+0x72910, extract((void(D::*)()){&D::startMusic}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            m->registerHook(getBase()+0x7fec0, extract((void(D::*)()){&D::startRecording}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            m->registerHook(getBase()+0x7fed0, extract((void(D::*)()){&D::startRecordingDelayed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            m->registerHook(getBase()+0x75900, extract((void(D::*)()){&D::stopCameraShake}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            m->registerHook(getBase()+0x6d090, extract((void(D::*)()){&D::stopRecording}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject*)){&D::storeCheckpoint})
            m->registerHook(getBase()+0x7ef10, extract((void(D::*)(CheckpointObject*)){&D::storeCheckpoint}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode})
            m->registerHook(getBase()+0x7baf0, extract((void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode})
            m->registerHook(getBase()+0x7bc80, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode})
            m->registerHook(getBase()+0x7bbe0, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode})
            m->registerHook(getBase()+0x7bd20, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(getBase()+0x7d120, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2} != (void(D::*)(float, bool)){&D::timeForXPos2})
            m->registerHook(getBase()+0x293eb0, extract((void(D::*)(float, bool)){&D::timeForXPos2}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(bool)){&D::toggleBGEffectVisibility})
            m->registerHook(getBase()+0x7fe80, extract((void(D::*)(bool)){&D::toggleBGEffectVisibility}));

        if ((void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(getBase()+0x7bf90, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped} != (void(D::*)(bool, bool)){&D::toggleFlipped})
            m->registerHook(getBase()+0x7bdc0, extract((void(D::*)(bool, bool)){&D::toggleFlipped}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(int)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x7fe40, extract((void(D::*)(int)){&D::toggleGhostEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter} != (void(D::*)(bool)){&D::toggleGlitter})
            m->registerHook(getBase()+0x70e00, extract((void(D::*)(bool)){&D::toggleGlitter}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode} != (void(D::*)(bool)){&D::togglePracticeMode})
            m->registerHook(getBase()+0x7f9e0, extract((void(D::*)(bool)){&D::togglePracticeMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            m->registerHook(getBase()+0x6eeb0, extract((void(D::*)()){&D::toggleProgressbar}));

        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            m->registerHook(getBase()+0x7fe00, extract((void(D::*)()){&D::tryStartRecord}));

        if ((void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle})
            m->registerHook(getBase()+0x76e00, extract((void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject*)){&D::unregisterActiveObject})
            m->registerHook(getBase()+0x77660, extract((void(D::*)(GameObject*)){&D::unregisterActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject*)){&D::unregisterStateObject})
            m->registerHook(getBase()+0x777f0, extract((void(D::*)(GameObject*)){&D::unregisterStateObject}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x77900, extract((void(D::*)(float)){&D::update}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            m->registerHook(getBase()+0x7fcd0, extract((void(D::*)()){&D::updateAttempts}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateCamera} != (void(D::*)(float)){&D::updateCamera})
            m->registerHook(getBase()+0x6e2b0, extract((void(D::*)(float)){&D::updateCamera}));

        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(getBase()+0x7c7f0, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(getBase()+0x7caa0, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            m->registerHook(getBase()+0x7a6d0, extract((void(D::*)()){&D::updateEffectPositions}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            m->registerHook(getBase()+0x6f1e0, extract((void(D::*)()){&D::updateLevelColors}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            m->registerHook(getBase()+0x7a720, extract((void(D::*)()){&D::updateMoveObjectsLastPosition}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            m->registerHook(getBase()+0x6ed70, extract((void(D::*)()){&D::updateProgressbar}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateReplay} != (void(D::*)(float)){&D::updateReplay})
            m->registerHook(getBase()+0x78b60, extract((void(D::*)(float)){&D::updateReplay}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod} != (void(D::*)(float, bool)){&D::updateTimeMod})
            m->registerHook(getBase()+0x786f0, extract((void(D::*)(float, bool)){&D::updateTimeMod}));

        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(getBase()+0x7ffb0, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            m->registerHook(getBase()+0x6fb90, extract((void(D::*)()){&D::updateVisibility}));

        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            m->registerHook(getBase()+0x7fcb0, extract((void(D::*)()){&D::vfDChk}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0x75ef0, extract((void(D::*)()){&D::visit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            m->registerHook(getBase()+0x761f0, extract((void(D::*)()){&D::visitWithColorFlash}));

        if ((void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode} != (void(D::*)(int, PlayerObject*)){&D::willSwitchToMode})
            m->registerHook(getBase()+0x7b9e0, extract((void(D::*)(int, PlayerObject*)){&D::willSwitchToMode}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(getBase()+0x7d140, extract((void(D::*)(float)){&D::xPosForTime}));
    }
};


template<class D>
class $PlayerCheckpoint : public PlayerCheckpoint, public $CacBase {
 public:
    $PlayerCheckpoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayerCheckpoint* __thistype;

    static PlayerCheckpoint* create() {
        return reinterpret_cast<PlayerCheckpoint*(*)()>(m->getOriginal(getBase()+0x7e8c0))();
    }

    void apply_hooks() override {
        if ((PlayerCheckpoint*(*)()){&$PlayerCheckpoint::create} != (PlayerCheckpoint*(*)()){&D::create})
            m->registerHook(getBase()+0x7e8c0, (PlayerCheckpoint*(*)()){&D::create});
    }
};


template<class D>
class $PlayerObject : public PlayerObject, public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayerObject* __thistype;

    void activateStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21aef0))(this);
    }

    void addAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
    }

    void addToTouchedRings(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22b800))(this, p0);
    }

    void animationFinished(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
    }

    void boostPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
    }

    void bumpPlayer(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
    }

    void buttonDown(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
    }

    void checkSnapJumpToObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
    }

    void collidedWithObject(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
    }

    void collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
    }

    void collidedWithSlope(float p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, bool)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
    }

    void convertToClosestRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21c860))(this, p0);
    }

    void copyAttributes(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
    }

    static PlayerObject* create(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<PlayerObject*(*)(int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x217260))(p0, p1, p2);
    }

    void deactivateParticle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a540))(this);
    }

    void deactivateStreak(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218b30))(this, p0);
    }

    void fadeOutStreak2(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x225890))(this, p0);
    }

    void flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
    }

    void flipGravity(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
    }

    void flipMod() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4c0))(this);
    }

    void getActiveMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b950))(this);
    }

    void getModifiedSlopeYVel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21bff0))(this);
    }

    void getOldPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a830))(this, p0);
    }

    void getOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dee0))(this);
    }

    void getRealPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d5f0))(this);
    }

    void getSecondColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cee0))(this);
    }

    void gravityDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e930))(this);
    }

    void gravityUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e900))(this);
    }

    void hardFlipGravity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b860))(this);
    }

    void hitGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x220a30))(this, p0);
    }

    void incrementJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c050))(this);
    }

    bool init(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<bool(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
    }

    void isBoostValid(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d650))(this, p0);
    }

    void isFlying() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4e0))(this);
    }

    void isSafeFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
    }

    void isSafeMode(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
    }

    void isSafeSpiderFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221be0))(this, p0);
    }

    void levelFlipFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b060))(this);
    }

    void levelFlipping() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a510))(this);
    }

    void levelWillFlip() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b020))(this);
    }

    void loadFromCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e420))(this, p0);
    }

    void lockPlayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d680))(this);
    }

    void logValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x221220))(this);
    }

    void modeDidChange() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bfd0))(this);
    }

    void placeStreakPoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21af90))(this);
    }

    void playBurstEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c780))(this);
    }

    void playDeathEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225930))(this);
    }

    void playDynamicSpiderRun() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222ec0))(this);
    }

    void playerDestroyed(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
    }

    void playerIsFalling() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c730))(this);
    }

    void playerTeleported() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b840))(this);
    }

    void playingEndEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d7e0))(this);
    }

    void postCollision(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
    }

    void preCollision() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ccc0))(this);
    }

    void preSlopeCollision(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
    }

    void propellPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
    }

    void pushButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
    }

    void pushDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbd0))(this);
    }

    void pushPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
    }

    void releaseButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
    }

    void removeAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218ac0))(this);
    }

    void removePendingCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2237b0))(this);
    }

    void resetAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21adb0))(this);
    }

    void resetCollisionLog() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cc20))(this);
    }

    void resetObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223170))(this);
    }

    void resetPlayerIcon() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22be00))(this);
    }

    void resetStateVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223760))(this);
    }

    void resetStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ae10))(this);
    }

    void ringJump(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
    }

    void runBallRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
    }

    void runBallRotation2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cb10))(this);
    }

    void runNormalRotation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c960))(this);
    }

    void runRotateAction(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c570))(this, p0);
    }

    void saveToCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
    }

    void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
    }

    void setFlipX(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e720))(this, p0);
    }

    void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
    }

    void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x22d400))(this, p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
    }

    void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
    }

    void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e870))(this, p0);
    }

    void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
    }

    void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e830))(this, p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x219610))(this, p0);
    }

    void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
    }

    void setupStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218720))(this);
    }

    void spawnCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225480))(this);
    }

    void spawnCircle2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2252a0))(this);
    }

    void spawnDualCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2255c0))(this);
    }

    void spawnFromPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
    }

    void spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
    }

    void spawnScaleCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2251b0))(this);
    }

    void specialGroundHit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbf0))(this);
    }

    void speedDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e970))(this);
    }

    void speedUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e950))(this);
    }

    void spiderTestJump(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21b160))(this, p0);
    }

    void startDashing(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x221d70))(this, p0);
    }

    void stopBurstEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22c680))(this);
    }

    void stopDashing() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222990))(this);
    }

    void stopRotation(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c830))(this, p0);
    }

    void storeCollision(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
    }

    void switchedToMode(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
    }

    void testForMoving(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
    }

    void toggleBirdMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224070))(this, p0);
    }

    void toggleDartMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
    }

    void toggleFlyMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223820))(this, p0);
    }

    void toggleGhostEffect(GhostType p0) {
        return reinterpret_cast<void(*)(decltype(this), GhostType)>(m->getOriginal(getBase()+0x225000))(this, p0);
    }

    void togglePlayerScale(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
    }

    void toggleRobotMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223c70))(this, p0);
    }

    void toggleRollMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223b20))(this, p0);
    }

    void toggleSpiderMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224830))(this, p0);
    }

    void toggleVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
    }

    void touchedObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22e660))(this, p0);
    }

    void tryPlaceCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a950))(this);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
    }

    void updateCheckpointMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218980))(this, p0);
    }

    void updateCheckpointTest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a890))(this);
    }

    void updateCollide(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
    }

    void updateCollideBottom(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
    }

    void updateCollideTop(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
    }

    void updateDashAnimation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a570))(this);
    }

    void updateDashArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222520))(this);
    }

    void updateGlowColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cf10))(this);
    }

    void updateJump(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x219680))(this, p0);
    }

    void updateJumpVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a740))(this);
    }

    void updatePlayerBirdFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
    }

    void updatePlayerDartFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c260))(this, p0);
    }

    void updatePlayerFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c470))(this, p0);
    }

    void updatePlayerGlow() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bc50))(this);
    }

    void updatePlayerRobotFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d620))(this, p0);
    }

    void updatePlayerRollFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
    }

    void updatePlayerScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b8b0))(this);
    }

    void updatePlayerShipFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
    }

    void updatePlayerSpiderFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d650))(this, p0);
    }

    void updatePlayerSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218440))(this, p0);
    }

    void updateRobotAnimationSpeed() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df40))(this);
    }

    void updateRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
    }

    void updateRotation(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
    }

    void updateShipRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221310))(this, p0);
    }

    void updateShipSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218510))(this, p0);
    }

    void updateSlopeRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221030))(this, p0);
    }

    void updateSlopeYVelocity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e920))(this, p0);
    }

    void updateSpecial(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a790))(this, p0);
    }

    void updateStateVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a770))(this);
    }

    void updateTimeMod(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
    }

    void usingWallLimitedMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df00))(this);
    }

    void yStartDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e9b0))(this);
    }

    void yStartUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e990))(this);
    }

    void apply_hooks() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::activateStreak} != (void(D::*)()){&D::activateStreak})
            m->registerHook(getBase()+0x21aef0, extract((void(D::*)()){&D::activateStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::addAllParticles} != (void(D::*)()){&D::addAllParticles})
            m->registerHook(getBase()+0x2189b0, extract((void(D::*)()){&D::addAllParticles}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings} != (void(D::*)(GameObject*)){&D::addToTouchedRings})
            m->registerHook(getBase()+0x22b800, extract((void(D::*)(GameObject*)){&D::addToTouchedRings}));

        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(getBase()+0x22e9d0, extract((void(D::*)(char const*)){&D::animationFinished}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer} != (void(D::*)(float)){&D::boostPlayer})
            m->registerHook(getBase()+0x21d6b0, extract((void(D::*)(float)){&D::boostPlayer}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer} != (void(D::*)(float, int)){&D::bumpPlayer})
            m->registerHook(getBase()+0x22d890, extract((void(D::*)(float, int)){&D::bumpPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown} != (void(D::*)(PlayerButton)){&D::buttonDown})
            m->registerHook(getBase()+0x22b7e0, extract((void(D::*)(PlayerButton)){&D::buttonDown}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject} != (void(D::*)(GameObject*)){&D::checkSnapJumpToObject})
            m->registerHook(getBase()+0x2217f0, extract((void(D::*)(GameObject*)){&D::checkSnapJumpToObject}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21d880, extract((void(D::*)(float, GameObject*)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject} != (void(D::*)(float, GameObject*, cocos2d::CCRect)){&D::collidedWithObject})
            m->registerHook(getBase()+0x21f0b0, extract((void(D::*)(float, GameObject*, cocos2d::CCRect)){&D::collidedWithObject}));

        if ((void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope} != (void(D::*)(float, GameObject*, bool)){&D::collidedWithSlope})
            m->registerHook(getBase()+0x21d8d0, extract((void(D::*)(float, GameObject*, bool)){&D::collidedWithSlope}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation} != (void(D::*)(float)){&D::convertToClosestRotation})
            m->registerHook(getBase()+0x21c860, extract((void(D::*)(float)){&D::convertToClosestRotation}));

        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes} != (void(D::*)(PlayerObject*)){&D::copyAttributes})
            m->registerHook(getBase()+0x22dc70, extract((void(D::*)(PlayerObject*)){&D::copyAttributes}));

        if ((PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create} != (PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&D::create})
            m->registerHook(getBase()+0x217260, (PlayerObject*(*)(int, int, cocos2d::CCLayer*)){&D::create});

        if ((void($PlayerObject::*)()){&$PlayerObject::deactivateParticle} != (void(D::*)()){&D::deactivateParticle})
            m->registerHook(getBase()+0x21a540, extract((void(D::*)()){&D::deactivateParticle}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak} != (void(D::*)(bool)){&D::deactivateStreak})
            m->registerHook(getBase()+0x218b30, extract((void(D::*)(bool)){&D::deactivateStreak}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2} != (void(D::*)(float)){&D::fadeOutStreak2})
            m->registerHook(getBase()+0x225890, extract((void(D::*)(float)){&D::fadeOutStreak2}));

        if ((void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer} != (void(D::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::flashPlayer})
            m->registerHook(getBase()+0x221c80, extract((void(D::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&D::flashPlayer}));

        if ((void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity} != (void(D::*)(bool, bool)){&D::flipGravity})
            m->registerHook(getBase()+0x21c090, extract((void(D::*)(bool, bool)){&D::flipGravity}));

        if ((void($PlayerObject::*)()){&$PlayerObject::flipMod} != (void(D::*)()){&D::flipMod})
            m->registerHook(getBase()+0x21a4c0, extract((void(D::*)()){&D::flipMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getActiveMode} != (void(D::*)()){&D::getActiveMode})
            m->registerHook(getBase()+0x22b950, extract((void(D::*)()){&D::getActiveMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel} != (void(D::*)()){&D::getModifiedSlopeYVel})
            m->registerHook(getBase()+0x21bff0, extract((void(D::*)()){&D::getModifiedSlopeYVel}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition} != (void(D::*)(float)){&D::getOldPosition})
            m->registerHook(getBase()+0x21a830, extract((void(D::*)(float)){&D::getOldPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(getBase()+0x22dee0, extract((void(D::*)()){&D::getOrientedBox}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(getBase()+0x22d5f0, extract((void(D::*)()){&D::getRealPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getSecondColor} != (void(D::*)()){&D::getSecondColor})
            m->registerHook(getBase()+0x22cee0, extract((void(D::*)()){&D::getSecondColor}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityDown} != (void(D::*)()){&D::gravityDown})
            m->registerHook(getBase()+0x22e930, extract((void(D::*)()){&D::gravityDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::gravityUp} != (void(D::*)()){&D::gravityUp})
            m->registerHook(getBase()+0x22e900, extract((void(D::*)()){&D::gravityUp}));

        if ((void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity} != (void(D::*)()){&D::hardFlipGravity})
            m->registerHook(getBase()+0x22b860, extract((void(D::*)()){&D::hardFlipGravity}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::hitGround} != (void(D::*)(bool)){&D::hitGround})
            m->registerHook(getBase()+0x220a30, extract((void(D::*)(bool)){&D::hitGround}));

        if ((void($PlayerObject::*)()){&$PlayerObject::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(getBase()+0x21c050, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init} != (bool(D::*)(int, int, cocos2d::CCLayer*)){&D::init})
            m->registerHook(getBase()+0x2172e0, extract((bool(D::*)(int, int, cocos2d::CCLayer*)){&D::init}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid} != (void(D::*)(float)){&D::isBoostValid})
            m->registerHook(getBase()+0x21d650, extract((void(D::*)(float)){&D::isBoostValid}));

        if ((void($PlayerObject::*)()){&$PlayerObject::isFlying} != (void(D::*)()){&D::isFlying})
            m->registerHook(getBase()+0x21a4e0, extract((void(D::*)()){&D::isFlying}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip} != (void(D::*)(float)){&D::isSafeFlip})
            m->registerHook(getBase()+0x2209f0, extract((void(D::*)(float)){&D::isSafeFlip}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode} != (void(D::*)(float)){&D::isSafeMode})
            m->registerHook(getBase()+0x2209b0, extract((void(D::*)(float)){&D::isSafeMode}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip} != (void(D::*)(float)){&D::isSafeSpiderFlip})
            m->registerHook(getBase()+0x221be0, extract((void(D::*)(float)){&D::isSafeSpiderFlip}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished} != (void(D::*)()){&D::levelFlipFinished})
            m->registerHook(getBase()+0x21b060, extract((void(D::*)()){&D::levelFlipFinished}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelFlipping} != (void(D::*)()){&D::levelFlipping})
            m->registerHook(getBase()+0x21a510, extract((void(D::*)()){&D::levelFlipping}));

        if ((void($PlayerObject::*)()){&$PlayerObject::levelWillFlip} != (void(D::*)()){&D::levelWillFlip})
            m->registerHook(getBase()+0x21b020, extract((void(D::*)()){&D::levelWillFlip}));

        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::loadFromCheckpoint})
            m->registerHook(getBase()+0x22e420, extract((void(D::*)(PlayerCheckpoint*)){&D::loadFromCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::lockPlayer} != (void(D::*)()){&D::lockPlayer})
            m->registerHook(getBase()+0x22d680, extract((void(D::*)()){&D::lockPlayer}));

        if ((void($PlayerObject::*)()){&$PlayerObject::logValues} != (void(D::*)()){&D::logValues})
            m->registerHook(getBase()+0x221220, extract((void(D::*)()){&D::logValues}));

        if ((void($PlayerObject::*)()){&$PlayerObject::modeDidChange} != (void(D::*)()){&D::modeDidChange})
            m->registerHook(getBase()+0x22bfd0, extract((void(D::*)()){&D::modeDidChange}));

        if ((void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint} != (void(D::*)()){&D::placeStreakPoint})
            m->registerHook(getBase()+0x21af90, extract((void(D::*)()){&D::placeStreakPoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playBurstEffect} != (void(D::*)()){&D::playBurstEffect})
            m->registerHook(getBase()+0x21c780, extract((void(D::*)()){&D::playBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDeathEffect} != (void(D::*)()){&D::playDeathEffect})
            m->registerHook(getBase()+0x225930, extract((void(D::*)()){&D::playDeathEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun} != (void(D::*)()){&D::playDynamicSpiderRun})
            m->registerHook(getBase()+0x222ec0, extract((void(D::*)()){&D::playDynamicSpiderRun}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed} != (void(D::*)(bool)){&D::playerDestroyed})
            m->registerHook(getBase()+0x2256d0, extract((void(D::*)(bool)){&D::playerDestroyed}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerIsFalling} != (void(D::*)()){&D::playerIsFalling})
            m->registerHook(getBase()+0x21c730, extract((void(D::*)()){&D::playerIsFalling}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playerTeleported} != (void(D::*)()){&D::playerTeleported})
            m->registerHook(getBase()+0x22b840, extract((void(D::*)()){&D::playerTeleported}));

        if ((void($PlayerObject::*)()){&$PlayerObject::playingEndEffect} != (void(D::*)()){&D::playingEndEffect})
            m->registerHook(getBase()+0x22d7e0, extract((void(D::*)()){&D::playingEndEffect}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::postCollision} != (void(D::*)(float)){&D::postCollision})
            m->registerHook(getBase()+0x21cd10, extract((void(D::*)(float)){&D::postCollision}));

        if ((void($PlayerObject::*)()){&$PlayerObject::preCollision} != (void(D::*)()){&D::preCollision})
            m->registerHook(getBase()+0x21ccc0, extract((void(D::*)()){&D::preCollision}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision} != (void(D::*)(float, GameObject*)){&D::preSlopeCollision})
            m->registerHook(getBase()+0x21ec80, extract((void(D::*)(float, GameObject*)){&D::preSlopeCollision}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer} != (void(D::*)(float)){&D::propellPlayer})
            m->registerHook(getBase()+0x22d8e0, extract((void(D::*)(float)){&D::propellPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton} != (void(D::*)(PlayerButton)){&D::pushButton})
            m->registerHook(getBase()+0x22aa00, extract((void(D::*)(PlayerButton)){&D::pushButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::pushDown} != (void(D::*)()){&D::pushDown})
            m->registerHook(getBase()+0x22dbd0, extract((void(D::*)()){&D::pushDown}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer} != (void(D::*)(float)){&D::pushPlayer})
            m->registerHook(getBase()+0x22dbb0, extract((void(D::*)(float)){&D::pushPlayer}));

        if ((void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton} != (void(D::*)(PlayerButton)){&D::releaseButton})
            m->registerHook(getBase()+0x22b6f0, extract((void(D::*)(PlayerButton)){&D::releaseButton}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removeAllParticles} != (void(D::*)()){&D::removeAllParticles})
            m->registerHook(getBase()+0x218ac0, extract((void(D::*)()){&D::removeAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint} != (void(D::*)()){&D::removePendingCheckpoint})
            m->registerHook(getBase()+0x2237b0, extract((void(D::*)()){&D::removePendingCheckpoint}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetAllParticles} != (void(D::*)()){&D::resetAllParticles})
            m->registerHook(getBase()+0x21adb0, extract((void(D::*)()){&D::resetAllParticles}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog} != (void(D::*)()){&D::resetCollisionLog})
            m->registerHook(getBase()+0x21cc20, extract((void(D::*)()){&D::resetCollisionLog}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(getBase()+0x223170, extract((void(D::*)()){&D::resetObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon} != (void(D::*)()){&D::resetPlayerIcon})
            m->registerHook(getBase()+0x22be00, extract((void(D::*)()){&D::resetPlayerIcon}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStateVariables} != (void(D::*)()){&D::resetStateVariables})
            m->registerHook(getBase()+0x223760, extract((void(D::*)()){&D::resetStateVariables}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetStreak} != (void(D::*)()){&D::resetStreak})
            m->registerHook(getBase()+0x21ae10, extract((void(D::*)()){&D::resetStreak}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump} != (void(D::*)(GameObject*)){&D::ringJump})
            m->registerHook(getBase()+0x22abf0, extract((void(D::*)(GameObject*)){&D::ringJump}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation} != (void(D::*)(float)){&D::runBallRotation})
            m->registerHook(getBase()+0x21ca10, extract((void(D::*)(float)){&D::runBallRotation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runBallRotation2} != (void(D::*)()){&D::runBallRotation2})
            m->registerHook(getBase()+0x21cb10, extract((void(D::*)()){&D::runBallRotation2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::runNormalRotation} != (void(D::*)()){&D::runNormalRotation})
            m->registerHook(getBase()+0x21c960, extract((void(D::*)()){&D::runNormalRotation}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction} != (void(D::*)(bool)){&D::runRotateAction})
            m->registerHook(getBase()+0x21c570, extract((void(D::*)(bool)){&D::runRotateAction}));

        if ((void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint} != (void(D::*)(PlayerCheckpoint*)){&D::saveToCheckpoint})
            m->registerHook(getBase()+0x22e2f0, extract((void(D::*)(PlayerCheckpoint*)){&D::saveToCheckpoint}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(getBase()+0x22cdf0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(getBase()+0x22e720, extract((void(D::*)(bool)){&D::setFlipX}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(getBase()+0x22e7b0, extract((void(D::*)(bool)){&D::setFlipY}));

        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(getBase()+0x22d400, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x22c8b0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(getBase()+0x22e6e0, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(getBase()+0x22e870, extract((void(D::*)(float)){&D::setScale}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(getBase()+0x22e7f0, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(getBase()+0x22e830, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            m->registerHook(getBase()+0x219610, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(getBase()+0x22e8b0, extract((void(D::*)(bool)){&D::setVisible}));

        if ((void($PlayerObject::*)()){&$PlayerObject::setupStreak} != (void(D::*)()){&D::setupStreak})
            m->registerHook(getBase()+0x218720, extract((void(D::*)()){&D::setupStreak}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(getBase()+0x225480, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnCircle2} != (void(D::*)()){&D::spawnCircle2})
            m->registerHook(getBase()+0x2252a0, extract((void(D::*)()){&D::spawnCircle2}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle} != (void(D::*)()){&D::spawnDualCircle})
            m->registerHook(getBase()+0x2255c0, extract((void(D::*)()){&D::spawnDualCircle}));

        if ((void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer} != (void(D::*)(PlayerObject*)){&D::spawnFromPlayer})
            m->registerHook(getBase()+0x22dde0, extract((void(D::*)(PlayerObject*)){&D::spawnFromPlayer}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle} != (void(D::*)(cocos2d::_ccColor3B, float)){&D::spawnPortalCircle})
            m->registerHook(getBase()+0x225350, extract((void(D::*)(cocos2d::_ccColor3B, float)){&D::spawnPortalCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle} != (void(D::*)()){&D::spawnScaleCircle})
            m->registerHook(getBase()+0x2251b0, extract((void(D::*)()){&D::spawnScaleCircle}));

        if ((void($PlayerObject::*)()){&$PlayerObject::specialGroundHit} != (void(D::*)()){&D::specialGroundHit})
            m->registerHook(getBase()+0x22dbf0, extract((void(D::*)()){&D::specialGroundHit}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedDown} != (void(D::*)()){&D::speedDown})
            m->registerHook(getBase()+0x22e970, extract((void(D::*)()){&D::speedDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::speedUp} != (void(D::*)()){&D::speedUp})
            m->registerHook(getBase()+0x22e950, extract((void(D::*)()){&D::speedUp}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump} != (void(D::*)(bool)){&D::spiderTestJump})
            m->registerHook(getBase()+0x21b160, extract((void(D::*)(bool)){&D::spiderTestJump}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing} != (void(D::*)(GameObject*)){&D::startDashing})
            m->registerHook(getBase()+0x221d70, extract((void(D::*)(GameObject*)){&D::startDashing}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect} != (void(D::*)()){&D::stopBurstEffect})
            m->registerHook(getBase()+0x22c680, extract((void(D::*)()){&D::stopBurstEffect}));

        if ((void($PlayerObject::*)()){&$PlayerObject::stopDashing} != (void(D::*)()){&D::stopDashing})
            m->registerHook(getBase()+0x222990, extract((void(D::*)()){&D::stopDashing}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation} != (void(D::*)(bool)){&D::stopRotation})
            m->registerHook(getBase()+0x21c830, extract((void(D::*)(bool)){&D::stopRotation}));

        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision} != (void(D::*)(bool, int)){&D::storeCollision})
            m->registerHook(getBase()+0x21cc60, extract((void(D::*)(bool, int)){&D::storeCollision}));

        if ((void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode} != (void(D::*)(GameObjectType)){&D::switchedToMode})
            m->registerHook(getBase()+0x22b9a0, extract((void(D::*)(GameObjectType)){&D::switchedToMode}));

        if ((void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving} != (void(D::*)(float, GameObject*)){&D::testForMoving})
            m->registerHook(getBase()+0x21eb70, extract((void(D::*)(float, GameObject*)){&D::testForMoving}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode} != (void(D::*)(bool)){&D::toggleBirdMode})
            m->registerHook(getBase()+0x224070, extract((void(D::*)(bool)){&D::toggleBirdMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode} != (void(D::*)(bool)){&D::toggleDartMode})
            m->registerHook(getBase()+0x2243f0, extract((void(D::*)(bool)){&D::toggleDartMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode} != (void(D::*)(bool)){&D::toggleFlyMode})
            m->registerHook(getBase()+0x223820, extract((void(D::*)(bool)){&D::toggleFlyMode}));

        if ((void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect} != (void(D::*)(GhostType)){&D::toggleGhostEffect})
            m->registerHook(getBase()+0x225000, extract((void(D::*)(GhostType)){&D::toggleGhostEffect}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale} != (void(D::*)(bool)){&D::togglePlayerScale})
            m->registerHook(getBase()+0x224bd0, extract((void(D::*)(bool)){&D::togglePlayerScale}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode} != (void(D::*)(bool)){&D::toggleRobotMode})
            m->registerHook(getBase()+0x223c70, extract((void(D::*)(bool)){&D::toggleRobotMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode} != (void(D::*)(bool)){&D::toggleRollMode})
            m->registerHook(getBase()+0x223b20, extract((void(D::*)(bool)){&D::toggleRollMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode} != (void(D::*)(bool)){&D::toggleSpiderMode})
            m->registerHook(getBase()+0x224830, extract((void(D::*)(bool)){&D::toggleSpiderMode}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility} != (void(D::*)(bool)){&D::toggleVisibility})
            m->registerHook(getBase()+0x21abf0, extract((void(D::*)(bool)){&D::toggleVisibility}));

        if ((void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject} != (void(D::*)(GameObject*)){&D::touchedObject})
            m->registerHook(getBase()+0x22e660, extract((void(D::*)(GameObject*)){&D::touchedObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint} != (void(D::*)()){&D::tryPlaceCheckpoint})
            m->registerHook(getBase()+0x21a950, extract((void(D::*)()){&D::tryPlaceCheckpoint}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x218bf0, extract((void(D::*)(float)){&D::update}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode} != (void(D::*)(bool)){&D::updateCheckpointMode})
            m->registerHook(getBase()+0x218980, extract((void(D::*)(bool)){&D::updateCheckpointMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest} != (void(D::*)()){&D::updateCheckpointTest})
            m->registerHook(getBase()+0x21a890, extract((void(D::*)()){&D::updateCheckpointTest}));

        if ((void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide} != (void(D::*)(bool, int)){&D::updateCollide})
            m->registerHook(getBase()+0x220f10, extract((void(D::*)(bool, int)){&D::updateCollide}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom} != (void(D::*)(float, int)){&D::updateCollideBottom})
            m->registerHook(getBase()+0x221790, extract((void(D::*)(float, int)){&D::updateCollideBottom}));

        if ((void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop} != (void(D::*)(float, int)){&D::updateCollideTop})
            m->registerHook(getBase()+0x221c20, extract((void(D::*)(float, int)){&D::updateCollideTop}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation} != (void(D::*)()){&D::updateDashAnimation})
            m->registerHook(getBase()+0x21a570, extract((void(D::*)()){&D::updateDashAnimation}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateDashArt} != (void(D::*)()){&D::updateDashArt})
            m->registerHook(getBase()+0x222520, extract((void(D::*)()){&D::updateDashArt}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateGlowColor} != (void(D::*)()){&D::updateGlowColor})
            m->registerHook(getBase()+0x22cf10, extract((void(D::*)()){&D::updateGlowColor}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateJump} != (void(D::*)(float)){&D::updateJump})
            m->registerHook(getBase()+0x219680, extract((void(D::*)(float)){&D::updateJump}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables} != (void(D::*)()){&D::updateJumpVariables})
            m->registerHook(getBase()+0x21a740, extract((void(D::*)()){&D::updateJumpVariables}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame} != (void(D::*)(int)){&D::updatePlayerBirdFrame})
            m->registerHook(getBase()+0x22bfe0, extract((void(D::*)(int)){&D::updatePlayerBirdFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame} != (void(D::*)(int)){&D::updatePlayerDartFrame})
            m->registerHook(getBase()+0x22c260, extract((void(D::*)(int)){&D::updatePlayerDartFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame} != (void(D::*)(int)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x22c470, extract((void(D::*)(int)){&D::updatePlayerFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow} != (void(D::*)()){&D::updatePlayerGlow})
            m->registerHook(getBase()+0x22bc50, extract((void(D::*)()){&D::updatePlayerGlow}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame} != (void(D::*)(int)){&D::updatePlayerRobotFrame})
            m->registerHook(getBase()+0x22d620, extract((void(D::*)(int)){&D::updatePlayerRobotFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame} != (void(D::*)(int)){&D::updatePlayerRollFrame})
            m->registerHook(getBase()+0x22c6a0, extract((void(D::*)(int)){&D::updatePlayerRollFrame}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale} != (void(D::*)()){&D::updatePlayerScale})
            m->registerHook(getBase()+0x22b8b0, extract((void(D::*)()){&D::updatePlayerScale}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame} != (void(D::*)(int)){&D::updatePlayerShipFrame})
            m->registerHook(getBase()+0x22ba40, extract((void(D::*)(int)){&D::updatePlayerShipFrame}));

        if ((void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame} != (void(D::*)(int)){&D::updatePlayerSpiderFrame})
            m->registerHook(getBase()+0x22d650, extract((void(D::*)(int)){&D::updatePlayerSpiderFrame}));

        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra} != (void(D::*)(std::string)){&D::updatePlayerSpriteExtra})
            m->registerHook(getBase()+0x218440, extract((void(D::*)(std::string)){&D::updatePlayerSpriteExtra}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed} != (void(D::*)()){&D::updateRobotAnimationSpeed})
            m->registerHook(getBase()+0x22df40, extract((void(D::*)()){&D::updateRobotAnimationSpeed}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateRotation} != (void(D::*)(float)){&D::updateRotation})
            m->registerHook(getBase()+0x2214b0, extract((void(D::*)(float)){&D::updateRotation}));

        if ((void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation} != (void(D::*)(float, float)){&D::updateRotation})
            m->registerHook(getBase()+0x221230, extract((void(D::*)(float, float)){&D::updateRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation} != (void(D::*)(float)){&D::updateShipRotation})
            m->registerHook(getBase()+0x221310, extract((void(D::*)(float)){&D::updateShipRotation}));

        if ((void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra} != (void(D::*)(std::string)){&D::updateShipSpriteExtra})
            m->registerHook(getBase()+0x218510, extract((void(D::*)(std::string)){&D::updateShipSpriteExtra}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation} != (void(D::*)(float)){&D::updateSlopeRotation})
            m->registerHook(getBase()+0x221030, extract((void(D::*)(float)){&D::updateSlopeRotation}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity} != (void(D::*)(float)){&D::updateSlopeYVelocity})
            m->registerHook(getBase()+0x22e920, extract((void(D::*)(float)){&D::updateSlopeYVelocity}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial} != (void(D::*)(float)){&D::updateSpecial})
            m->registerHook(getBase()+0x21a790, extract((void(D::*)(float)){&D::updateSpecial}));

        if ((void($PlayerObject::*)()){&$PlayerObject::updateStateVariables} != (void(D::*)()){&D::updateStateVariables})
            m->registerHook(getBase()+0x21a770, extract((void(D::*)()){&D::updateStateVariables}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod} != (void(D::*)(float)){&D::updateTimeMod})
            m->registerHook(getBase()+0x2185e0, extract((void(D::*)(float)){&D::updateTimeMod}));

        if ((void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode} != (void(D::*)()){&D::usingWallLimitedMode})
            m->registerHook(getBase()+0x22df00, extract((void(D::*)()){&D::usingWallLimitedMode}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartDown} != (void(D::*)()){&D::yStartDown})
            m->registerHook(getBase()+0x22e9b0, extract((void(D::*)()){&D::yStartDown}));

        if ((void($PlayerObject::*)()){&$PlayerObject::yStartUp} != (void(D::*)()){&D::yStartUp})
            m->registerHook(getBase()+0x22e990, extract((void(D::*)()){&D::yStartUp}));
    }
};


template<class D>
class $PulseEffectAction : public PulseEffectAction, public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PulseEffectAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x179e90))(this, p0);
    }

    void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17a850))(this);
    }

    void apply_hooks() override {
        if ((void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x179e90, extract((void(D::*)(std::string)){&D::createFromString}));

        if ((void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(getBase()+0x17a850, extract((void(D::*)()){&D::getSaveString}));
    }
};


template<class D>
class $RetryLevelLayer : public RetryLevelLayer, public $CacBase {
 public:
    $RetryLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef RetryLevelLayer* __thistype;

    static RetryLevelLayer* create() {
        return reinterpret_cast<RetryLevelLayer*(*)()>(m->getOriginal(getBase()+0x28dd60))();
    }

    void apply_hooks() override {
        if ((RetryLevelLayer*(*)()){&$RetryLevelLayer::create} != (RetryLevelLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x28dd60, (RetryLevelLayer*(*)()){&D::create});
    }
};


template<class D>
class $SetGroupIDLayer : public SetGroupIDLayer, public $CacBase {
 public:
    $SetGroupIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetGroupIDLayer* __thistype;

    void onNextGroupID1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1967a0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x197af0))(this, p0);
    }

    void updateGroupIDLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x197260))(this);
    }

    void apply_hooks() override {
        if ((void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1} != (void(D::*)(cocos2d::CCObject*)){&D::onNextGroupID1})
            m->registerHook(getBase()+0x1967a0, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextGroupID1}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x197af0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel} != (void(D::*)()){&D::updateGroupIDLabel})
            m->registerHook(getBase()+0x197260, extract((void(D::*)()){&D::updateGroupIDLabel}));
    }
};


template<class D>
class $SetIDLayer : public SetIDLayer, public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetIDLayer* __thistype;

    static SetIDLayer* create(GameObject* p0) {
        return reinterpret_cast<SetIDLayer*(*)(GameObject*)>(m->getOriginal(getBase()+0x168f20))(p0);
    }

    void apply_hooks() override {
        if ((SetIDLayer*(*)(GameObject*)){&$SetIDLayer::create} != (SetIDLayer*(*)(GameObject*)){&D::create})
            m->registerHook(getBase()+0x168f20, (SetIDLayer*(*)(GameObject*)){&D::create});
    }
};


template<class D>
class $SetItemIDLayer : public SetItemIDLayer, public $CacBase {
 public:
    $SetItemIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetItemIDLayer* __thistype;

    static SetItemIDLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x5a830))(p0, p1);
    }

    void apply_hooks() override {
        if ((SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create} != (SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x5a830, (SetItemIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});
    }
};


template<class D>
class $SetTargetIDLayer : public SetTargetIDLayer, public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetTargetIDLayer* __thistype;

    static SetTargetIDLayer* create(EffectGameObject* p0, cocos2d::CCArray* p1, std::string p2) {
        return reinterpret_cast<SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)>(m->getOriginal(getBase()+0x159d20))(p0, p1, p2);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15aed0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15b6c0))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15b4a0))(this);
    }

    void apply_hooks() override {
        if ((SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create} != (SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&D::create})
            m->registerHook(getBase()+0x159d20, (SetTargetIDLayer*(*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&D::create});

        if ((void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15aed0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x15b6c0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15b4a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupAnimationPopup : public SetupAnimationPopup, public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupAnimationPopup* __thistype;

    static SetupAnimationPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x208b70))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x209fc0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x20ab30))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20a910))(this);
    }

    void apply_hooks() override {
        if ((SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create} != (SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x208b70, (SetupAnimationPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x209fc0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x20ab30, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x20a910, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCollisionTriggerPopup : public SetupCollisionTriggerPopup, public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupCollisionTriggerPopup* __thistype;

    static SetupCollisionTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1d6120))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d77b0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1d84d0))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d82b0))(this);
    }

    void apply_hooks() override {
        if ((SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create} != (SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1d6120, (SetupCollisionTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1d77b0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1d84d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1d82b0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupCountTriggerPopup : public SetupCountTriggerPopup, public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupCountTriggerPopup* __thistype;

    static SetupCountTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x15c6c0))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15dd40))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15e9a0))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15e8a0))(this);
    }

    void apply_hooks() override {
        if ((SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create} != (SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x15c6c0, (SetupCountTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x15dd40, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x15e9a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x15e8a0, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInstantCountPopup : public SetupInstantCountPopup, public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupInstantCountPopup* __thistype;

    static SetupInstantCountPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x352c10))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x354520))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x355270))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x355170))(this);
    }

    void apply_hooks() override {
        if ((SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create} != (SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x352c10, (SetupInstantCountPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x354520, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x355270, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x355170, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupInteractObjectPopup : public SetupInteractObjectPopup, public $CacBase {
 public:
    $SetupInteractObjectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupInteractObjectPopup* __thistype;

    static SetupInteractObjectPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x29a400))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x29bbc0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x29c2b0))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x29c120))(this);
    }

    void apply_hooks() override {
        if ((SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create} != (SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x29a400, (SetupInteractObjectPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x29bbc0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x29c2b0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x29c120, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupObjectTogglePopup : public SetupObjectTogglePopup, public $CacBase {
 public:
    $SetupObjectTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupObjectTogglePopup* __thistype;

    static SetupObjectTogglePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0860))(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0a40))(this, p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1c1c40))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1c2660))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2440))(this);
    }

    void apply_hooks() override {
        if ((SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create} != (SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1c0860, (SetupObjectTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x1c0a40, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x1c1c40, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1c2660, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1c2440, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupOpacityPopup : public SetupOpacityPopup, public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupOpacityPopup* __thistype;

    static SetupOpacityPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x32b70))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x340a0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x34a60))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34760))(this);
    }

    void apply_hooks() override {
        if ((SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create} != (SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x32b70, (SetupOpacityPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x340a0, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x34a60, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x34760, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupPickupTriggerPopup : public SetupPickupTriggerPopup, public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupPickupTriggerPopup* __thistype;

    static SetupPickupTriggerPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x35e70))(p0, p1);
    }

    void onItemIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37100))(this, p0);
    }

    void onNextItemID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37260))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x37ca0))(this, p0);
    }

    void updateItemID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x37ab0))(this);
    }

    void apply_hooks() override {
        if ((SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create} != (SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x35e70, (SetupPickupTriggerPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onItemIDArrow})
            m->registerHook(getBase()+0x37100, extract((void(D::*)(cocos2d::CCObject*)){&D::onItemIDArrow}));

        if ((void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID} != (void(D::*)(cocos2d::CCObject*)){&D::onNextItemID})
            m->registerHook(getBase()+0x37260, extract((void(D::*)(cocos2d::CCObject*)){&D::onNextItemID}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x37ca0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID} != (void(D::*)()){&D::updateItemID})
            m->registerHook(getBase()+0x37ab0, extract((void(D::*)()){&D::updateItemID}));
    }
};


template<class D>
class $SetupPulsePopup : public SetupPulsePopup, public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupPulsePopup* __thistype;

    void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
    }

    static SetupPulsePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e6d40))(p0, p1);
    }

    bool init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
    }

    void onSelectPulseMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
    }

    void onSelectTargetMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eac30))(this, p0);
    }

    void onUpdateCustomColor(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eaef0))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1ec960))(this, p0);
    }

    void updateCopyColorTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebf20))(this);
    }

    void updateEditorLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ec310))(this);
    }

    void updateFadeOutLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebbe0))(this);
    }

    void updateTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1eb8d0))(this);
    }

    void apply_hooks() override {
        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(getBase()+0x1ec680, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create} != (SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1e6d40, (SetupPulsePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((bool($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init} != (bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init})
            m->registerHook(getBase()+0x1e7010, extract((bool(D::*)(EffectGameObject*, cocos2d::CCArray*)){&D::init}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectPulseMode})
            m->registerHook(getBase()+0x1eb020, extract((void(D::*)(cocos2d::CCObject*)){&D::onSelectPulseMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode} != (void(D::*)(cocos2d::CCObject*)){&D::onSelectTargetMode})
            m->registerHook(getBase()+0x1eac30, extract((void(D::*)(cocos2d::CCObject*)){&D::onSelectTargetMode}));

        if ((void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor} != (void(D::*)(cocos2d::CCObject*)){&D::onUpdateCustomColor})
            m->registerHook(getBase()+0x1eaef0, extract((void(D::*)(cocos2d::CCObject*)){&D::onUpdateCustomColor}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1ec960, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel} != (void(D::*)()){&D::updateCopyColorTextInputLabel})
            m->registerHook(getBase()+0x1ebf20, extract((void(D::*)()){&D::updateCopyColorTextInputLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel} != (void(D::*)()){&D::updateEditorLabel})
            m->registerHook(getBase()+0x1ec310, extract((void(D::*)()){&D::updateEditorLabel}));

        if ((void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel} != (void(D::*)(bool)){&D::updateFadeOutLabel})
            m->registerHook(getBase()+0x1eba20, extract((void(D::*)(bool)){&D::updateFadeOutLabel}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x1ebbe0, extract((void(D::*)()){&D::updateTargetID}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel} != (void(D::*)()){&D::updateTextInputLabel})
            m->registerHook(getBase()+0x1eb8d0, extract((void(D::*)()){&D::updateTextInputLabel}));
    }
};


template<class D>
class $SetupShakePopup : public SetupShakePopup, public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupShakePopup* __thistype;

    static SetupShakePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x3adc00))(p0, p1);
    }

    void apply_hooks() override {
        if ((SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create} != (SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x3adc00, (SetupShakePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});
    }
};


template<class D>
class $SetupSpawnPopup : public SetupSpawnPopup, public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupSpawnPopup* __thistype;

    static SetupSpawnPopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x139790))(p0, p1);
    }

    void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x13ad80))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x13b990))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13b770))(this);
    }

    void apply_hooks() override {
        if ((SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create} != (SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x139790, (SetupSpawnPopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton} != (void(D::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&D::createToggleButton})
            m->registerHook(getBase()+0x13b0e0, extract((void(D::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&D::createToggleButton}));

        if ((void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x13ad80, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x13b990, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x13b770, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SetupTouchTogglePopup : public SetupTouchTogglePopup, public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupTouchTogglePopup* __thistype;

    static SetupTouchTogglePopup* create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1576a0))(p0, p1);
    }

    void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x158b60))(this, p0);
    }

    void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1596a0))(this, p0);
    }

    void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x159480))(this);
    }

    void apply_hooks() override {
        if ((SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create} != (SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create})
            m->registerHook(getBase()+0x1576a0, (SetupTouchTogglePopup*(*)(EffectGameObject*, cocos2d::CCArray*)){&D::create});

        if ((void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow} != (void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow})
            m->registerHook(getBase()+0x158b60, extract((void(D::*)(cocos2d::CCObject*)){&D::onTargetIDArrow}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(getBase()+0x1596a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID} != (void(D::*)()){&D::updateTargetID})
            m->registerHook(getBase()+0x159480, extract((void(D::*)()){&D::updateTargetID}));
    }
};


template<class D>
class $SimplePlayer : public SimplePlayer, public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SimplePlayer* __thistype;

    static SimplePlayer* create(int p0) {
        return reinterpret_cast<SimplePlayer*(*)(int)>(m->getOriginal(getBase()+0x1b6140))(p0);
    }

    void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
    }

    void updateColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ba1f0))(this);
    }

    void updatePlayerFrame(int p0, IconType p1) {
        return reinterpret_cast<void(*)(decltype(this), int, IconType)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((SimplePlayer*(*)(int)){&$SimplePlayer::create} != (SimplePlayer*(*)(int)){&D::create})
            m->registerHook(getBase()+0x1b6140, (SimplePlayer*(*)(int)){&D::create});

        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor})
            m->registerHook(getBase()+0x1bace0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setSecondColor}));

        if ((void($SimplePlayer::*)()){&$SimplePlayer::updateColors} != (void(D::*)()){&D::updateColors})
            m->registerHook(getBase()+0x1ba1f0, extract((void(D::*)()){&D::updateColors}));

        if ((void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame} != (void(D::*)(int, IconType)){&D::updatePlayerFrame})
            m->registerHook(getBase()+0x1b62f0, extract((void(D::*)(int, IconType)){&D::updatePlayerFrame}));
    }
};


template<class D>
class $Slider : public Slider, public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef Slider* __thistype;

    static Slider* create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) {
        return reinterpret_cast<Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)>(m->getOriginal(getBase()+0x18dd80))(p0, p1, p2, p3, p4, p5, p6);
    }

    static Slider* create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, float p2) {
        return reinterpret_cast<Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, float)>(m->getOriginal(getBase()+0x18dc40))(p0, p1, p2);
    }

    void getValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
    }

    void setBarVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x18e280))(this, p0);
    }

    void setValue(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x18e170))(this, p0);
    }

    void apply_hooks() override {
        if ((Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&D::create})
            m->registerHook(getBase()+0x18dd80, (Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&D::create});

        if ((Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create} != (Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&D::create})
            m->registerHook(getBase()+0x18dc40, (Slider*(*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&D::create});

        if ((void($Slider::*)()){&$Slider::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18e0c0, extract((void(D::*)()){&D::getValue}));

        if ((void($Slider::*)(bool)){&$Slider::setBarVisibility} != (void(D::*)(bool)){&D::setBarVisibility})
            m->registerHook(getBase()+0x18e280, extract((void(D::*)(bool)){&D::setBarVisibility}));

        if ((void($Slider::*)(float)){&$Slider::setValue} != (void(D::*)(float)){&D::setValue})
            m->registerHook(getBase()+0x18e170, extract((void(D::*)(float)){&D::setValue}));
    }
};


template<class D>
class $SliderThumb : public SliderThumb, public $CacBase {
 public:
    $SliderThumb() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SliderThumb* __thistype;

    void getValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18ce80))(this);
    }

    void apply_hooks() override {
        if ((void($SliderThumb::*)()){&$SliderThumb::getValue} != (void(D::*)()){&D::getValue})
            m->registerHook(getBase()+0x18ce80, extract((void(D::*)()){&D::getValue}));
    }
};


template<class D>
class $SpawnTriggerAction : public SpawnTriggerAction, public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SpawnTriggerAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17bf50))(this, p0);
    }

    void apply_hooks() override {
        if ((void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x17bf50, extract((void(D::*)(std::string)){&D::createFromString}));
    }
};


template<class D>
class $SpeedObject : public SpeedObject, public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SpeedObject* __thistype;

    static SpeedObject* create(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<SpeedObject*(*)(GameObject*, int, float)>(m->getOriginal(getBase()+0x77450))(p0, p1, p2);
    }

    bool init(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<bool(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((SpeedObject*(*)(GameObject*, int, float)){&$SpeedObject::create} != (SpeedObject*(*)(GameObject*, int, float)){&D::create})
            m->registerHook(getBase()+0x77450, (SpeedObject*(*)(GameObject*, int, float)){&D::create});

        if ((bool($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init} != (bool(D::*)(GameObject*, int, float)){&D::init})
            m->registerHook(getBase()+0x77400, extract((bool(D::*)(GameObject*, int, float)){&D::init}));
    }
};


template<class D>
class $TeleportPortalObject : public TeleportPortalObject, public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TeleportPortalObject* __thistype;

    static TeleportPortalObject* create(char const* p0) {
        return reinterpret_cast<TeleportPortalObject*(*)(char const*)>(m->getOriginal(getBase()+0xdaa50))(p0);
    }

    void getTeleportXOff(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xdac20))(this, p0);
    }

    void apply_hooks() override {
        if ((TeleportPortalObject*(*)(char const*)){&$TeleportPortalObject::create} != (TeleportPortalObject*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0xdaa50, (TeleportPortalObject*(*)(char const*)){&D::create});

        if ((void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff} != (void(D::*)(cocos2d::CCNode*)){&D::getTeleportXOff})
            m->registerHook(getBase()+0xdac20, extract((void(D::*)(cocos2d::CCNode*)){&D::getTeleportXOff}));
    }
};


template<class D>
class $TextArea : public TextArea, public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TextArea* __thistype;

    static TextArea* create(std::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) {
        return reinterpret_cast<TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)>(m->getOriginal(getBase()+0x19eb40))(p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
        if ((TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create} != (TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&D::create})
            m->registerHook(getBase()+0x19eb40, (TextArea*(*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&D::create});
    }
};


template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TextInputDelegate* __thistype;

    void allowTextInput(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6210))(this, p0);
    }

    void textInputOpened(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6200))(this, p0);
    }

    void apply_hooks() override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            m->registerHook(getBase()+0x6210, extract((void(D::*)(CCTextInputNode*)){&D::allowTextInput}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(getBase()+0x6200, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));
    }
};


template<class D>
class $ToggleTriggerAction : public ToggleTriggerAction, public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ToggleTriggerAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1765e0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x1765e0, extract((void(D::*)(std::string)){&D::createFromString}));
    }
};


template<class D>
class $TouchToggleAction : public TouchToggleAction, public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef TouchToggleAction* __thistype;

    void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x177e10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString} != (void(D::*)(std::string)){&D::createFromString})
            m->registerHook(getBase()+0x177e10, extract((void(D::*)(std::string)){&D::createFromString}));
    }
};


template<class D>
class $UILayer : public UILayer, public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef UILayer* __thistype;

    static UILayer* create() {
        return reinterpret_cast<UILayer*(*)()>(m->getOriginal(getBase()+0x27fd10))();
    }

    void disableMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280960))(this);
    }

    void enableMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280940))(this);
    }

    void pCommand(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x280830))(this, p0);
    }

    void toggleCheckpointsMenu(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x280430))(this, p0);
    }

    void apply_hooks() override {
        if ((UILayer*(*)()){&$UILayer::create} != (UILayer*(*)()){&D::create})
            m->registerHook(getBase()+0x27fd10, (UILayer*(*)()){&D::create});

        if ((void($UILayer::*)()){&$UILayer::disableMenu} != (void(D::*)()){&D::disableMenu})
            m->registerHook(getBase()+0x280960, extract((void(D::*)()){&D::disableMenu}));

        if ((void($UILayer::*)()){&$UILayer::enableMenu} != (void(D::*)()){&D::enableMenu})
            m->registerHook(getBase()+0x280940, extract((void(D::*)()){&D::enableMenu}));

        if ((void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand} != (void(D::*)(cocos2d::CCNode*)){&D::pCommand})
            m->registerHook(getBase()+0x280830, extract((void(D::*)(cocos2d::CCNode*)){&D::pCommand}));

        if ((void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu} != (void(D::*)(bool)){&D::toggleCheckpointsMenu})
            m->registerHook(getBase()+0x280430, extract((void(D::*)(bool)){&D::toggleCheckpointsMenu}));
    }
};


template<class D>
class $UndoObject : public UndoObject, public $CacBase {
 public:
    $UndoObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef UndoObject* __thistype;

    static UndoObject* create(GameObject* p0, UndoCommand p1) {
        return reinterpret_cast<UndoObject*(*)(GameObject*, UndoCommand)>(m->getOriginal(getBase()+0x94ea0))(p0, p1);
    }

    static UndoObject* createWithArray(cocos2d::CCArray* p0, UndoCommand p1) {
        return reinterpret_cast<UndoObject*(*)(cocos2d::CCArray*, UndoCommand)>(m->getOriginal(getBase()+0x96ee0))(p0, p1);
    }

    void apply_hooks() override {
        if ((UndoObject*(*)(GameObject*, UndoCommand)){&$UndoObject::create} != (UndoObject*(*)(GameObject*, UndoCommand)){&D::create})
            m->registerHook(getBase()+0x94ea0, (UndoObject*(*)(GameObject*, UndoCommand)){&D::create});

        if ((UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray} != (UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&D::createWithArray})
            m->registerHook(getBase()+0x96ee0, (UndoObject*(*)(cocos2d::CCArray*, UndoCommand)){&D::createWithArray});
    }
};


template<class D>
class $CCActionTween : public CCActionTween, public $CacBase {
 public:
    $CCActionTween() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCActionTween* __thistype;

    static CCActionTween* create(float p0, char const* p1, float p2, float p3) {
        return reinterpret_cast<CCActionTween*(*)(float, char const*, float, float)>(m->getOriginal(getBase()+0x447590))(p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((CCActionTween*(*)(float, char const*, float, float)){&$CCActionTween::create} != (CCActionTween*(*)(float, char const*, float, float)){&D::create})
            m->registerHook(getBase()+0x447590, (CCActionTween*(*)(float, char const*, float, float)){&D::create});
    }
};


template<class D>
class $CCAnimate : public CCAnimate, public $CacBase {
 public:
    $CCAnimate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimate* __thistype;

    static CCAnimate* create(cocos2d::CCAnimation* p0) {
        return reinterpret_cast<CCAnimate*(*)(cocos2d::CCAnimation*)>(m->getOriginal(getBase()+0x1f8fc0))(p0);
    }

    void apply_hooks() override {
        if ((CCAnimate*(*)(cocos2d::CCAnimation*)){&$CCAnimate::create} != (CCAnimate*(*)(cocos2d::CCAnimation*)){&D::create})
            m->registerHook(getBase()+0x1f8fc0, (CCAnimate*(*)(cocos2d::CCAnimation*)){&D::create});
    }
};


template<class D>
class $CCAnimation : public CCAnimation, public $CacBase {
 public:
    $CCAnimation() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCAnimation* __thistype;

    static CCAnimation* createWithSpriteFrames(cocos2d::CCArray* p0, float p1) {
        return reinterpret_cast<CCAnimation*(*)(cocos2d::CCArray*, float)>(m->getOriginal(getBase()+0x140df0))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCAnimation*(*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames} != (CCAnimation*(*)(cocos2d::CCArray*, float)){&D::createWithSpriteFrames})
            m->registerHook(getBase()+0x140df0, (CCAnimation*(*)(cocos2d::CCArray*, float)){&D::createWithSpriteFrames});
    }
};


template<class D>
class $CCArray : public CCArray, public $CacBase {
 public:
    $CCArray() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCArray* __thistype;

    void addObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419f90))(this, p0);
    }

    void addObjectNew(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a450))(this, p0);
    }

    void addObjectsFromArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41a2d0))(this, p0);
    }

    void containsObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a3e0))(this, p0);
    }

    void count() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a2f0))(this);
    }

    static CCArray* create() {
        return reinterpret_cast<CCArray*(*)()>(m->getOriginal(getBase()+0x419cb0))();
    }

    static CCArray* createWithObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<CCArray*(*)(cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419d50))(p0);
    }

    void fastRemoveObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a520))(this, p0);
    }

    void fastRemoveObjectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a500))(this, p0);
    }

    void fastRemoveObjectAtIndexNew(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a510))(this, p0);
    }

    void lastObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a360))(this);
    }

    void objectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a340))(this, p0);
    }

    void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a4f0))(this);
    }

    void removeLastObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x41a470))(this, p0);
    }

    void removeObject(cocos2d::CCObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, bool)>(m->getOriginal(getBase()+0x41a490))(this, p0, p1);
    }

    void removeObjectAtIndex(unsigned int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int, bool)>(m->getOriginal(getBase()+0x41a4b0))(this, p0, p1);
    }

    void stringAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a320))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject} != (void(D::*)(cocos2d::CCObject*)){&D::addObject})
            m->registerHook(getBase()+0x419f90, extract((void(D::*)(cocos2d::CCObject*)){&D::addObject}));

        if ((void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew} != (void(D::*)(cocos2d::CCObject*)){&D::addObjectNew})
            m->registerHook(getBase()+0x41a450, extract((void(D::*)(cocos2d::CCObject*)){&D::addObjectNew}));

        if ((void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray} != (void(D::*)(cocos2d::CCArray*)){&D::addObjectsFromArray})
            m->registerHook(getBase()+0x41a2d0, extract((void(D::*)(cocos2d::CCArray*)){&D::addObjectsFromArray}));

        if ((void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::containsObject} != (void(D::*)(cocos2d::CCObject*)){&D::containsObject})
            m->registerHook(getBase()+0x41a3e0, extract((void(D::*)(cocos2d::CCObject*)){&D::containsObject}));

        if ((void($CCArray::*)()){&$CCArray::count} != (void(D::*)()){&D::count})
            m->registerHook(getBase()+0x41a2f0, extract((void(D::*)()){&D::count}));

        if ((CCArray*(*)()){&$CCArray::create} != (CCArray*(*)()){&D::create})
            m->registerHook(getBase()+0x419cb0, (CCArray*(*)()){&D::create});

        if ((CCArray*(*)(cocos2d::CCObject*)){&$CCArray::createWithObject} != (CCArray*(*)(cocos2d::CCObject*)){&D::createWithObject})
            m->registerHook(getBase()+0x419d50, (CCArray*(*)(cocos2d::CCObject*)){&D::createWithObject});

        if ((void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject} != (void(D::*)(cocos2d::CCObject*)){&D::fastRemoveObject})
            m->registerHook(getBase()+0x41a520, extract((void(D::*)(cocos2d::CCObject*)){&D::fastRemoveObject}));

        if ((void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex} != (void(D::*)(unsigned int)){&D::fastRemoveObjectAtIndex})
            m->registerHook(getBase()+0x41a500, extract((void(D::*)(unsigned int)){&D::fastRemoveObjectAtIndex}));

        if ((void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew} != (void(D::*)(unsigned int)){&D::fastRemoveObjectAtIndexNew})
            m->registerHook(getBase()+0x41a510, extract((void(D::*)(unsigned int)){&D::fastRemoveObjectAtIndexNew}));

        if ((void($CCArray::*)()){&$CCArray::lastObject} != (void(D::*)()){&D::lastObject})
            m->registerHook(getBase()+0x41a360, extract((void(D::*)()){&D::lastObject}));

        if ((void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex} != (void(D::*)(unsigned int)){&D::objectAtIndex})
            m->registerHook(getBase()+0x41a340, extract((void(D::*)(unsigned int)){&D::objectAtIndex}));

        if ((void($CCArray::*)()){&$CCArray::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x41a4f0, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($CCArray::*)(bool)){&$CCArray::removeLastObject} != (void(D::*)(bool)){&D::removeLastObject})
            m->registerHook(getBase()+0x41a470, extract((void(D::*)(bool)){&D::removeLastObject}));

        if ((void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject} != (void(D::*)(cocos2d::CCObject*, bool)){&D::removeObject})
            m->registerHook(getBase()+0x41a490, extract((void(D::*)(cocos2d::CCObject*, bool)){&D::removeObject}));

        if ((void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex} != (void(D::*)(unsigned int, bool)){&D::removeObjectAtIndex})
            m->registerHook(getBase()+0x41a4b0, extract((void(D::*)(unsigned int, bool)){&D::removeObjectAtIndex}));

        if ((void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex} != (void(D::*)(unsigned int)){&D::stringAtIndex})
            m->registerHook(getBase()+0x41a320, extract((void(D::*)(unsigned int)){&D::stringAtIndex}));
    }
};


template<class D>
class $CCBezierTo : public CCBezierTo, public $CacBase {
 public:
    $CCBezierTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCBezierTo* __thistype;

    static CCBezierTo* create(float p0, cocos2d::_ccBezierConfig const& p1) {
        return reinterpret_cast<CCBezierTo*(*)(float, cocos2d::_ccBezierConfig const&)>(m->getOriginal(getBase()+0x1f6c10))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCBezierTo*(*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create} != (CCBezierTo*(*)(float, cocos2d::_ccBezierConfig const&)){&D::create})
            m->registerHook(getBase()+0x1f6c10, (CCBezierTo*(*)(float, cocos2d::_ccBezierConfig const&)){&D::create});
    }
};


template<class D>
class $CCCallFunc : public CCCallFunc, public $CacBase {
 public:
    $CCCallFunc() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCallFunc* __thistype;

    static CCCallFunc* create(int p0) {
        return reinterpret_cast<CCCallFunc*(*)(int)>(m->getOriginal(getBase()+0x454d90))(p0);
    }

    void apply_hooks() override {
        if ((CCCallFunc*(*)(int)){&$CCCallFunc::create} != (CCCallFunc*(*)(int)){&D::create})
            m->registerHook(getBase()+0x454d90, (CCCallFunc*(*)(int)){&D::create});
    }
};


template<class D>
class $CCCopying : public CCCopying, public $CacBase {
 public:
    $CCCopying() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCCopying* __thistype;

    void copyWithZone(cocos2d::CCZone* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCZone*)>(m->getOriginal(getBase()+0x250c90))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone} != (void(D::*)(cocos2d::CCZone*)){&D::copyWithZone})
            m->registerHook(getBase()+0x250c90, extract((void(D::*)(cocos2d::CCZone*)){&D::copyWithZone}));
    }
};


template<class D>
class $CCDelayTime : public CCDelayTime, public $CacBase {
 public:
    $CCDelayTime() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDelayTime* __thistype;

    static CCDelayTime* create(float p0) {
        return reinterpret_cast<CCDelayTime*(*)(float)>(m->getOriginal(getBase()+0x1f4380))(p0);
    }

    void apply_hooks() override {
        if ((CCDelayTime*(*)(float)){&$CCDelayTime::create} != (CCDelayTime*(*)(float)){&D::create})
            m->registerHook(getBase()+0x1f4380, (CCDelayTime*(*)(float)){&D::create});
    }
};


template<class D>
class $CCDictionary : public CCDictionary, public $CacBase {
 public:
    $CCDictionary() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDictionary* __thistype;

    void allKeys() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190450))(this);
    }

    void count() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190430))(this);
    }

    static CCDictionary* create() {
        return reinterpret_cast<CCDictionary*(*)()>(m->getOriginal(getBase()+0x192650))();
    }

    void objectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190bb0))(this, p0);
    }

    void objectForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x190870))(this, p0);
    }

    void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190220))(this);
    }

    void removeObjectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x1921d0))(this, p0);
    }

    void setObject(cocos2d::CCObject* p0, long p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, long)>(m->getOriginal(getBase()+0x191790))(this, p0, p1);
    }

    void setObject(cocos2d::CCObject* p0, std::string const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string const&)>(m->getOriginal(getBase()+0x190dc0))(this, p0, p1);
    }

    void valueForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190cf0))(this, p0);
    }

    void valueForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x1907a0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCDictionary::*)()){&$CCDictionary::allKeys} != (void(D::*)()){&D::allKeys})
            m->registerHook(getBase()+0x190450, extract((void(D::*)()){&D::allKeys}));

        if ((void($CCDictionary::*)()){&$CCDictionary::count} != (void(D::*)()){&D::count})
            m->registerHook(getBase()+0x190430, extract((void(D::*)()){&D::count}));

        if ((CCDictionary*(*)()){&$CCDictionary::create} != (CCDictionary*(*)()){&D::create})
            m->registerHook(getBase()+0x192650, (CCDictionary*(*)()){&D::create});

        if ((void($CCDictionary::*)(long)){&$CCDictionary::objectForKey} != (void(D::*)(long)){&D::objectForKey})
            m->registerHook(getBase()+0x190bb0, extract((void(D::*)(long)){&D::objectForKey}));

        if ((void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey} != (void(D::*)(std::string const&)){&D::objectForKey})
            m->registerHook(getBase()+0x190870, extract((void(D::*)(std::string const&)){&D::objectForKey}));

        if ((void($CCDictionary::*)()){&$CCDictionary::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(getBase()+0x190220, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey} != (void(D::*)(long)){&D::removeObjectForKey})
            m->registerHook(getBase()+0x1921d0, extract((void(D::*)(long)){&D::removeObjectForKey}));

        if ((void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject} != (void(D::*)(cocos2d::CCObject*, long)){&D::setObject})
            m->registerHook(getBase()+0x191790, extract((void(D::*)(cocos2d::CCObject*, long)){&D::setObject}));

        if ((void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject} != (void(D::*)(cocos2d::CCObject*, std::string const&)){&D::setObject})
            m->registerHook(getBase()+0x190dc0, extract((void(D::*)(cocos2d::CCObject*, std::string const&)){&D::setObject}));

        if ((void($CCDictionary::*)(long)){&$CCDictionary::valueForKey} != (void(D::*)(long)){&D::valueForKey})
            m->registerHook(getBase()+0x190cf0, extract((void(D::*)(long)){&D::valueForKey}));

        if ((void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey} != (void(D::*)(std::string const&)){&D::valueForKey})
            m->registerHook(getBase()+0x1907a0, extract((void(D::*)(std::string const&)){&D::valueForKey}));
    }
};


template<class D>
class $CCDirector : public CCDirector, public $CacBase {
 public:
    $CCDirector() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDirector* __thistype;

    void getScreenBottom() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b210))(this);
    }

    void getScreenLeft() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b220))(this);
    }

    void getScreenRight() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b230))(this);
    }

    void getScreenScaleFactorH() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b1e0))(this);
    }

    void getScreenScaleFactorW() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b1f0))(this);
    }

    void getScreenTop() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b200))(this);
    }

    void getTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24afa0))(this);
    }

    void getWinSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24a0f0))(this);
    }

    void pushScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a620))(this, p0);
    }

    void replaceScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a6d0))(this, p0);
    }

    void resetSmoothFixCounter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x249bc0))(this);
    }

    void sharedDirector() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x248cb0))(this);
    }

    void apply_hooks() override {
        if ((void($CCDirector::*)()){&$CCDirector::getScreenBottom} != (void(D::*)()){&D::getScreenBottom})
            m->registerHook(getBase()+0x24b210, extract((void(D::*)()){&D::getScreenBottom}));

        if ((void($CCDirector::*)()){&$CCDirector::getScreenLeft} != (void(D::*)()){&D::getScreenLeft})
            m->registerHook(getBase()+0x24b220, extract((void(D::*)()){&D::getScreenLeft}));

        if ((void($CCDirector::*)()){&$CCDirector::getScreenRight} != (void(D::*)()){&D::getScreenRight})
            m->registerHook(getBase()+0x24b230, extract((void(D::*)()){&D::getScreenRight}));

        if ((void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorH} != (void(D::*)()){&D::getScreenScaleFactorH})
            m->registerHook(getBase()+0x24b1e0, extract((void(D::*)()){&D::getScreenScaleFactorH}));

        if ((void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorW} != (void(D::*)()){&D::getScreenScaleFactorW})
            m->registerHook(getBase()+0x24b1f0, extract((void(D::*)()){&D::getScreenScaleFactorW}));

        if ((void($CCDirector::*)()){&$CCDirector::getScreenTop} != (void(D::*)()){&D::getScreenTop})
            m->registerHook(getBase()+0x24b200, extract((void(D::*)()){&D::getScreenTop}));

        if ((void($CCDirector::*)()){&$CCDirector::getTouchDispatcher} != (void(D::*)()){&D::getTouchDispatcher})
            m->registerHook(getBase()+0x24afa0, extract((void(D::*)()){&D::getTouchDispatcher}));

        if ((void($CCDirector::*)()){&$CCDirector::getWinSize} != (void(D::*)()){&D::getWinSize})
            m->registerHook(getBase()+0x24a0f0, extract((void(D::*)()){&D::getWinSize}));

        if ((void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene} != (void(D::*)(cocos2d::CCScene*)){&D::pushScene})
            m->registerHook(getBase()+0x24a620, extract((void(D::*)(cocos2d::CCScene*)){&D::pushScene}));

        if ((void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene} != (void(D::*)(cocos2d::CCScene*)){&D::replaceScene})
            m->registerHook(getBase()+0x24a6d0, extract((void(D::*)(cocos2d::CCScene*)){&D::replaceScene}));

        if ((void($CCDirector::*)()){&$CCDirector::resetSmoothFixCounter} != (void(D::*)()){&D::resetSmoothFixCounter})
            m->registerHook(getBase()+0x249bc0, extract((void(D::*)()){&D::resetSmoothFixCounter}));

        if ((void($CCDirector::*)()){&$CCDirector::sharedDirector} != (void(D::*)()){&D::sharedDirector})
            m->registerHook(getBase()+0x248cb0, extract((void(D::*)()){&D::sharedDirector}));
    }
};


template<class D>
class $CCDrawNode : public CCDrawNode, public $CacBase {
 public:
    $CCDrawNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCDrawNode* __thistype;

    void clear() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x379e80))(this);
    }

    static CCDrawNode* create() {
        return reinterpret_cast<CCDrawNode*(*)()>(m->getOriginal(getBase()+0x378d00))();
    }

    void drawPolygon(cocos2d::CCPoint* p0, unsigned int p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3797f0))(this, p0, p1, p2, p3, p4);
    }

    void drawSegment(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, float p2, cocos2d::_ccColor4F const& p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3792d0))(this, p0, p1, p2, p3);
    }

    void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x379ea0))(this);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x378e00))(this);
    }

    void setBlendFunc(cocos2d::_ccBlendFunc const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc const&)>(m->getOriginal(getBase()+0x379eb0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCDrawNode::*)()){&$CCDrawNode::clear} != (void(D::*)()){&D::clear})
            m->registerHook(getBase()+0x379e80, extract((void(D::*)()){&D::clear}));

        if ((CCDrawNode*(*)()){&$CCDrawNode::create} != (CCDrawNode*(*)()){&D::create})
            m->registerHook(getBase()+0x378d00, (CCDrawNode*(*)()){&D::create});

        if ((void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon} != (void(D::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&D::drawPolygon})
            m->registerHook(getBase()+0x3797f0, extract((void(D::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&D::drawPolygon}));

        if ((void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment} != (void(D::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&D::drawSegment})
            m->registerHook(getBase()+0x3792d0, extract((void(D::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&D::drawSegment}));

        if ((void($CCDrawNode::*)()){&$CCDrawNode::getBlendFunc} != (void(D::*)()){&D::getBlendFunc})
            m->registerHook(getBase()+0x379ea0, extract((void(D::*)()){&D::getBlendFunc}));

        if ((bool($CCDrawNode::*)()){&$CCDrawNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x378e00, extract((bool(D::*)()){&D::init}));

        if ((void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc const&)){&D::setBlendFunc})
            m->registerHook(getBase()+0x379eb0, extract((void(D::*)(cocos2d::_ccBlendFunc const&)){&D::setBlendFunc}));
    }
};


template<class D>
class $CCEaseElasticOut : public CCEaseElasticOut, public $CacBase {
 public:
    $CCEaseElasticOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseElasticOut* __thistype;

    static CCEaseElasticOut* create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<CCEaseElasticOut*(*)(cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a3080))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCEaseElasticOut*(*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create} != (CCEaseElasticOut*(*)(cocos2d::CCActionInterval*, float)){&D::create})
            m->registerHook(getBase()+0x2a3080, (CCEaseElasticOut*(*)(cocos2d::CCActionInterval*, float)){&D::create});
    }
};


template<class D>
class $CCEaseIn : public CCEaseIn, public $CacBase {
 public:
    $CCEaseIn() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseIn* __thistype;

    static CCEaseIn* create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<CCEaseIn*(*)(cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1960))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCEaseIn*(*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create} != (CCEaseIn*(*)(cocos2d::CCActionInterval*, float)){&D::create})
            m->registerHook(getBase()+0x2a1960, (CCEaseIn*(*)(cocos2d::CCActionInterval*, float)){&D::create});
    }
};


template<class D>
class $CCEaseInOut : public CCEaseInOut, public $CacBase {
 public:
    $CCEaseInOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseInOut* __thistype;

    static CCEaseInOut* create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<CCEaseInOut*(*)(cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1d80))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCEaseInOut*(*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create} != (CCEaseInOut*(*)(cocos2d::CCActionInterval*, float)){&D::create})
            m->registerHook(getBase()+0x2a1d80, (CCEaseInOut*(*)(cocos2d::CCActionInterval*, float)){&D::create});
    }
};


template<class D>
class $CCEaseOut : public CCEaseOut, public $CacBase {
 public:
    $CCEaseOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCEaseOut* __thistype;

    static CCEaseOut* create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<CCEaseOut*(*)(cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1b70))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCEaseOut*(*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create} != (CCEaseOut*(*)(cocos2d::CCActionInterval*, float)){&D::create})
            m->registerHook(getBase()+0x2a1b70, (CCEaseOut*(*)(cocos2d::CCActionInterval*, float)){&D::create});
    }
};


template<class D>
class $CCFadeOut : public CCFadeOut, public $CacBase {
 public:
    $CCFadeOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCFadeOut* __thistype;

    static CCFadeOut* create(float p0) {
        return reinterpret_cast<CCFadeOut*(*)(float)>(m->getOriginal(getBase()+0x1f7d80))(p0);
    }

    void apply_hooks() override {
        if ((CCFadeOut*(*)(float)){&$CCFadeOut::create} != (CCFadeOut*(*)(float)){&D::create})
            m->registerHook(getBase()+0x1f7d80, (CCFadeOut*(*)(float)){&D::create});
    }
};


template<class D>
class $CCFadeTo : public CCFadeTo, public $CacBase {
 public:
    $CCFadeTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCFadeTo* __thistype;

    static CCFadeTo* create(float p0, unsigned char p1) {
        return reinterpret_cast<CCFadeTo*(*)(float, unsigned char)>(m->getOriginal(getBase()+0x1f7ff0))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCFadeTo*(*)(float, unsigned char)){&$CCFadeTo::create} != (CCFadeTo*(*)(float, unsigned char)){&D::create})
            m->registerHook(getBase()+0x1f7ff0, (CCFadeTo*(*)(float, unsigned char)){&D::create});
    }
};


template<class D>
class $CCHide : public CCHide, public $CacBase {
 public:
    $CCHide() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCHide* __thistype;

    static CCHide* create() {
        return reinterpret_cast<CCHide*(*)()>(m->getOriginal(getBase()+0x4543e0))();
    }

    void apply_hooks() override {
        if ((CCHide*(*)()){&$CCHide::create} != (CCHide*(*)()){&D::create})
            m->registerHook(getBase()+0x4543e0, (CCHide*(*)()){&D::create});
    }
};


template<class D>
class $CCImage : public CCImage, public $CacBase {
 public:
    $CCImage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCImage* __thistype;

    bool initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5) {
        return reinterpret_cast<bool(*)(decltype(this), void*, int, cocos2d::CCImage::EImageFormat, int, int, int)>(m->getOriginal(getBase()+0x24fcb0))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        if ((bool($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData} != (bool(D::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&D::initWithImageData})
            m->registerHook(getBase()+0x24fcb0, extract((bool(D::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&D::initWithImageData}));
    }
};


template<class D>
class $CCKeyboardDelegate : public CCKeyboardDelegate, public $CacBase {
 public:
    $CCKeyboardDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCKeyboardDelegate* __thistype;

    void keyUp(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x61a0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(getBase()+0x61a0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $CCLabelBMFont : public CCLabelBMFont, public $CacBase {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLabelBMFont* __thistype;

    static CCLabelBMFont* create(char const* p0, char const* p1) {
        return reinterpret_cast<CCLabelBMFont*(*)(char const*, char const*)>(m->getOriginal(getBase()+0x347660))(p0, p1);
    }

    void limitLabelWidth(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x34a6e0))(this, p0, p1, p2);
    }

    void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x34a5d0))(this, p0);
    }

    void setString(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x3489e0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((CCLabelBMFont*(*)(char const*, char const*)){&$CCLabelBMFont::create} != (CCLabelBMFont*(*)(char const*, char const*)){&D::create})
            m->registerHook(getBase()+0x347660, (CCLabelBMFont*(*)(char const*, char const*)){&D::create});

        if ((void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth} != (void(D::*)(float, float, float)){&D::limitLabelWidth})
            m->registerHook(getBase()+0x34a6e0, extract((void(D::*)(float, float, float)){&D::limitLabelWidth}));

        if ((void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(getBase()+0x34a5d0, extract((void(D::*)(float)){&D::setScale}));

        if ((void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString} != (void(D::*)(char const*, bool)){&D::setString})
            m->registerHook(getBase()+0x3489e0, extract((void(D::*)(char const*, bool)){&D::setString}));
    }
};


template<class D>
class $CCLayer : public CCLayer, public $CacBase {
 public:
    $CCLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayer* __thistype;

    void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2734d0))(this, p0, p1);
    }

    void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273650))(this, p0, p1);
    }

    void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2735d0))(this, p0, p1);
    }

    void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273550))(this, p0, p1);
    }

    void ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2736d0))(this, p0, p1);
    }

    void ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273850))(this, p0, p1);
    }

    void ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2737d0))(this, p0, p1);
    }

    void ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273750))(this, p0, p1);
    }

    static CCLayer* create() {
        return reinterpret_cast<CCLayer*(*)()>(m->getOriginal(getBase()+0x272a00))();
    }

    void didAccelerate(cocos2d::CCAcceleration* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAcceleration*)>(m->getOriginal(getBase()+0x272ea0))(this, p0);
    }

    void getTouchMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e10))(this);
    }

    void getTouchPriority() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e00))(this);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x2729a0))(this);
    }

    void isAccelerometerEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e20))(this);
    }

    void isKeyboardEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273010))(this);
    }

    void isKeypadEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272f70))(this);
    }

    void isMouseEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273090))(this);
    }

    void isTouchEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272ce0))(this);
    }

    void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273160))(this);
    }

    void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x273280))(this, p0);
    }

    void keyMenuClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273200))(this);
    }

    void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273300))(this);
    }

    void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273490))(this);
    }

    void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2733c0))(this);
    }

    void registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, bool)>(m->getOriginal(getBase()+0x272bd0))(this, p0, p1, p2, p3);
    }

    void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272b40))(this);
    }

    void setAccelerometerEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272e30))(this, p0);
    }

    void setAccelerometerInterval(double p0) {
        return reinterpret_cast<void(*)(decltype(this), double)>(m->getOriginal(getBase()+0x272e70))(this, p0);
    }

    void setKeyboardEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x273020))(this, p0);
    }

    void setKeypadEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272f80))(this, p0);
    }

    void setMouseEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2730a0))(this, p0);
    }

    void setTouchEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272cf0))(this, p0);
    }

    void setTouchMode(cocos2d::ccTouchesMode p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccTouchesMode)>(m->getOriginal(getBase()+0x272d60))(this, p0);
    }

    void setTouchPriority(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x272db0))(this, p0);
    }

    void unregisterScriptTouchHandler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272c30))(this);
    }

    void apply_hooks() override {
        if ((void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(getBase()+0x2734d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(getBase()+0x273650, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(getBase()+0x2735d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(getBase()+0x273550, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan} != (void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesBegan})
            m->registerHook(getBase()+0x2736d0, extract((void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesBegan}));

        if ((void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled} != (void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesCancelled})
            m->registerHook(getBase()+0x273850, extract((void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesCancelled}));

        if ((void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded} != (void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesEnded})
            m->registerHook(getBase()+0x2737d0, extract((void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesEnded}));

        if ((void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved} != (void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesMoved})
            m->registerHook(getBase()+0x273750, extract((void(D::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&D::ccTouchesMoved}));

        if ((CCLayer*(*)()){&$CCLayer::create} != (CCLayer*(*)()){&D::create})
            m->registerHook(getBase()+0x272a00, (CCLayer*(*)()){&D::create});

        if ((void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate} != (void(D::*)(cocos2d::CCAcceleration*)){&D::didAccelerate})
            m->registerHook(getBase()+0x272ea0, extract((void(D::*)(cocos2d::CCAcceleration*)){&D::didAccelerate}));

        if ((void($CCLayer::*)()){&$CCLayer::getTouchMode} != (void(D::*)()){&D::getTouchMode})
            m->registerHook(getBase()+0x272e10, extract((void(D::*)()){&D::getTouchMode}));

        if ((void($CCLayer::*)()){&$CCLayer::getTouchPriority} != (void(D::*)()){&D::getTouchPriority})
            m->registerHook(getBase()+0x272e00, extract((void(D::*)()){&D::getTouchPriority}));

        if ((bool($CCLayer::*)()){&$CCLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x2729a0, extract((bool(D::*)()){&D::init}));

        if ((void($CCLayer::*)()){&$CCLayer::isAccelerometerEnabled} != (void(D::*)()){&D::isAccelerometerEnabled})
            m->registerHook(getBase()+0x272e20, extract((void(D::*)()){&D::isAccelerometerEnabled}));

        if ((void($CCLayer::*)()){&$CCLayer::isKeyboardEnabled} != (void(D::*)()){&D::isKeyboardEnabled})
            m->registerHook(getBase()+0x273010, extract((void(D::*)()){&D::isKeyboardEnabled}));

        if ((void($CCLayer::*)()){&$CCLayer::isKeypadEnabled} != (void(D::*)()){&D::isKeypadEnabled})
            m->registerHook(getBase()+0x272f70, extract((void(D::*)()){&D::isKeypadEnabled}));

        if ((void($CCLayer::*)()){&$CCLayer::isMouseEnabled} != (void(D::*)()){&D::isMouseEnabled})
            m->registerHook(getBase()+0x273090, extract((void(D::*)()){&D::isMouseEnabled}));

        if ((void($CCLayer::*)()){&$CCLayer::isTouchEnabled} != (void(D::*)()){&D::isTouchEnabled})
            m->registerHook(getBase()+0x272ce0, extract((void(D::*)()){&D::isTouchEnabled}));

        if ((void($CCLayer::*)()){&$CCLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(getBase()+0x273160, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(getBase()+0x273280, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($CCLayer::*)()){&$CCLayer::keyMenuClicked} != (void(D::*)()){&D::keyMenuClicked})
            m->registerHook(getBase()+0x273200, extract((void(D::*)()){&D::keyMenuClicked}));

        if ((void($CCLayer::*)()){&$CCLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(getBase()+0x273300, extract((void(D::*)()){&D::onEnter}));

        if ((void($CCLayer::*)()){&$CCLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(getBase()+0x273490, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($CCLayer::*)()){&$CCLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(getBase()+0x2733c0, extract((void(D::*)()){&D::onExit}));

        if ((void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler} != (void(D::*)(int, bool, int, bool)){&D::registerScriptTouchHandler})
            m->registerHook(getBase()+0x272bd0, extract((void(D::*)(int, bool, int, bool)){&D::registerScriptTouchHandler}));

        if ((void($CCLayer::*)()){&$CCLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(getBase()+0x272b40, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled} != (void(D::*)(bool)){&D::setAccelerometerEnabled})
            m->registerHook(getBase()+0x272e30, extract((void(D::*)(bool)){&D::setAccelerometerEnabled}));

        if ((void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval} != (void(D::*)(double)){&D::setAccelerometerInterval})
            m->registerHook(getBase()+0x272e70, extract((void(D::*)(double)){&D::setAccelerometerInterval}));

        if ((void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled} != (void(D::*)(bool)){&D::setKeyboardEnabled})
            m->registerHook(getBase()+0x273020, extract((void(D::*)(bool)){&D::setKeyboardEnabled}));

        if ((void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled} != (void(D::*)(bool)){&D::setKeypadEnabled})
            m->registerHook(getBase()+0x272f80, extract((void(D::*)(bool)){&D::setKeypadEnabled}));

        if ((void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled} != (void(D::*)(bool)){&D::setMouseEnabled})
            m->registerHook(getBase()+0x2730a0, extract((void(D::*)(bool)){&D::setMouseEnabled}));

        if ((void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled} != (void(D::*)(bool)){&D::setTouchEnabled})
            m->registerHook(getBase()+0x272cf0, extract((void(D::*)(bool)){&D::setTouchEnabled}));

        if ((void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode} != (void(D::*)(cocos2d::ccTouchesMode)){&D::setTouchMode})
            m->registerHook(getBase()+0x272d60, extract((void(D::*)(cocos2d::ccTouchesMode)){&D::setTouchMode}));

        if ((void($CCLayer::*)(int)){&$CCLayer::setTouchPriority} != (void(D::*)(int)){&D::setTouchPriority})
            m->registerHook(getBase()+0x272db0, extract((void(D::*)(int)){&D::setTouchPriority}));

        if ((void($CCLayer::*)()){&$CCLayer::unregisterScriptTouchHandler} != (void(D::*)()){&D::unregisterScriptTouchHandler})
            m->registerHook(getBase()+0x272c30, extract((void(D::*)()){&D::unregisterScriptTouchHandler}));
    }
};


template<class D>
class $CCLayerColor : public CCLayerColor, public $CacBase {
 public:
    $CCLayerColor() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayerColor* __thistype;

    static CCLayerColor* create(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<CCLayerColor*(*)(cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x2745e0))(p0, p1, p2);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274b50))(this);
    }

    void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274480))(this);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x274800))(this);
    }

    bool initWithColor(cocos2d::_ccColor4B const& p0) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::_ccColor4B const&)>(m->getOriginal(getBase()+0x2749a0))(this, p0);
    }

    bool initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x274850))(this, p0, p1, p2);
    }

    void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x2744a0))(this, p0);
    }

    void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x274c20))(this, p0);
    }

    void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2749f0))(this, p0);
    }

    void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x274db0))(this, p0);
    }

    void updateColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274ae0))(this);
    }

    void apply_hooks() override {
        if ((CCLayerColor*(*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create} != (CCLayerColor*(*)(cocos2d::_ccColor4B const&, float, float)){&D::create})
            m->registerHook(getBase()+0x2745e0, (CCLayerColor*(*)(cocos2d::_ccColor4B const&, float, float)){&D::create});

        if ((void($CCLayerColor::*)()){&$CCLayerColor::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x274b50, extract((void(D::*)()){&D::draw}));

        if ((void($CCLayerColor::*)()){&$CCLayerColor::getBlendFunc} != (void(D::*)()){&D::getBlendFunc})
            m->registerHook(getBase()+0x274480, extract((void(D::*)()){&D::getBlendFunc}));

        if ((bool($CCLayerColor::*)()){&$CCLayerColor::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x274800, extract((bool(D::*)()){&D::init}));

        if ((bool($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor} != (bool(D::*)(cocos2d::_ccColor4B const&)){&D::initWithColor})
            m->registerHook(getBase()+0x2749a0, extract((bool(D::*)(cocos2d::_ccColor4B const&)){&D::initWithColor}));

        if ((bool($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor} != (bool(D::*)(cocos2d::_ccColor4B const&, float, float)){&D::initWithColor})
            m->registerHook(getBase()+0x274850, extract((bool(D::*)(cocos2d::_ccColor4B const&, float, float)){&D::initWithColor}));

        if ((void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            m->registerHook(getBase()+0x2744a0, extract((void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc}));

        if ((void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(getBase()+0x274c20, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));

        if ((void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize} != (void(D::*)(cocos2d::CCSize const&)){&D::setContentSize})
            m->registerHook(getBase()+0x2749f0, extract((void(D::*)(cocos2d::CCSize const&)){&D::setContentSize}));

        if ((void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(getBase()+0x274db0, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($CCLayerColor::*)()){&$CCLayerColor::updateColor} != (void(D::*)()){&D::updateColor})
            m->registerHook(getBase()+0x274ae0, extract((void(D::*)()){&D::updateColor}));
    }
};


template<class D>
class $CCLayerRGBA : public CCLayerRGBA, public $CacBase {
 public:
    $CCLayerRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLayerRGBA* __thistype;

    void getColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273d60))(this);
    }

    void getDisplayedColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273d80))(this);
    }

    void getDisplayedOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273c00))(this);
    }

    void getOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273be0))(this);
    }

    void isCascadeColorEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274230))(this);
    }

    void isCascadeOpacityEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2741f0))(this);
    }

    void isOpacityModifyRGB() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6190))(this);
    }

    void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274250))(this, p0);
    }

    void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274210))(this, p0);
    }

    void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6180))(this, p0);
    }

    void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x2740b0))(this, p0);
    }

    void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x273f20))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::getColor} != (void(D::*)()){&D::getColor})
            m->registerHook(getBase()+0x273d60, extract((void(D::*)()){&D::getColor}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedColor} != (void(D::*)()){&D::getDisplayedColor})
            m->registerHook(getBase()+0x273d80, extract((void(D::*)()){&D::getDisplayedColor}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedOpacity} != (void(D::*)()){&D::getDisplayedOpacity})
            m->registerHook(getBase()+0x273c00, extract((void(D::*)()){&D::getDisplayedOpacity}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::getOpacity} != (void(D::*)()){&D::getOpacity})
            m->registerHook(getBase()+0x273be0, extract((void(D::*)()){&D::getOpacity}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeColorEnabled} != (void(D::*)()){&D::isCascadeColorEnabled})
            m->registerHook(getBase()+0x274230, extract((void(D::*)()){&D::isCascadeColorEnabled}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeOpacityEnabled} != (void(D::*)()){&D::isCascadeOpacityEnabled})
            m->registerHook(getBase()+0x2741f0, extract((void(D::*)()){&D::isCascadeOpacityEnabled}));

        if ((void($CCLayerRGBA::*)()){&$CCLayerRGBA::isOpacityModifyRGB} != (void(D::*)()){&D::isOpacityModifyRGB})
            m->registerHook(getBase()+0x6190, extract((void(D::*)()){&D::isOpacityModifyRGB}));

        if ((void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled} != (void(D::*)(bool)){&D::setCascadeColorEnabled})
            m->registerHook(getBase()+0x274250, extract((void(D::*)(bool)){&D::setCascadeColorEnabled}));

        if ((void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled} != (void(D::*)(bool)){&D::setCascadeOpacityEnabled})
            m->registerHook(getBase()+0x274210, extract((void(D::*)(bool)){&D::setCascadeOpacityEnabled}));

        if ((void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB} != (void(D::*)(bool)){&D::setOpacityModifyRGB})
            m->registerHook(getBase()+0x6180, extract((void(D::*)(bool)){&D::setOpacityModifyRGB}));

        if ((void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::updateDisplayedColor})
            m->registerHook(getBase()+0x2740b0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::updateDisplayedColor}));

        if ((void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity} != (void(D::*)(unsigned char)){&D::updateDisplayedOpacity})
            m->registerHook(getBase()+0x273f20, extract((void(D::*)(unsigned char)){&D::updateDisplayedOpacity}));
    }
};


template<class D>
class $CCMenu : public CCMenu, public $CacBase {
 public:
    $CCMenu() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenu* __thistype;

    void alignItemsHorizontallyWithPadding(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x4393e0))(this, p0);
    }

    static CCMenu* create() {
        return reinterpret_cast<CCMenu*(*)()>(m->getOriginal(getBase()+0x438720))();
    }

    static CCMenu* createWithArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<CCMenu*(*)(cocos2d::CCArray*)>(m->getOriginal(getBase()+0x4387e0))(p0);
    }

    static CCMenu* createWithItem(cocos2d::CCMenuItem* p0) {
        return reinterpret_cast<CCMenu*(*)(cocos2d::CCMenuItem*)>(m->getOriginal(getBase()+0x438b80))(p0);
    }

    void apply_hooks() override {
        if ((void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding} != (void(D::*)(float)){&D::alignItemsHorizontallyWithPadding})
            m->registerHook(getBase()+0x4393e0, extract((void(D::*)(float)){&D::alignItemsHorizontallyWithPadding}));

        if ((CCMenu*(*)()){&$CCMenu::create} != (CCMenu*(*)()){&D::create})
            m->registerHook(getBase()+0x438720, (CCMenu*(*)()){&D::create});

        if ((CCMenu*(*)(cocos2d::CCArray*)){&$CCMenu::createWithArray} != (CCMenu*(*)(cocos2d::CCArray*)){&D::createWithArray})
            m->registerHook(getBase()+0x4387e0, (CCMenu*(*)(cocos2d::CCArray*)){&D::createWithArray});

        if ((CCMenu*(*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem} != (CCMenu*(*)(cocos2d::CCMenuItem*)){&D::createWithItem})
            m->registerHook(getBase()+0x438b80, (CCMenu*(*)(cocos2d::CCMenuItem*)){&D::createWithItem});
    }
};


template<class D>
class $CCMotionStreak : public CCMotionStreak, public $CacBase {
 public:
    $CCMotionStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMotionStreak* __thistype;

    void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2ee190))(this);
    }

    void resumeStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2edb30))(this);
    }

    void stopStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2edb20))(this);
    }

    void apply_hooks() override {
        if ((void($CCMotionStreak::*)()){&$CCMotionStreak::reset} != (void(D::*)()){&D::reset})
            m->registerHook(getBase()+0x2ee190, extract((void(D::*)()){&D::reset}));

        if ((void($CCMotionStreak::*)()){&$CCMotionStreak::resumeStroke} != (void(D::*)()){&D::resumeStroke})
            m->registerHook(getBase()+0x2edb30, extract((void(D::*)()){&D::resumeStroke}));

        if ((void($CCMotionStreak::*)()){&$CCMotionStreak::stopStroke} != (void(D::*)()){&D::stopStroke})
            m->registerHook(getBase()+0x2edb20, extract((void(D::*)()){&D::stopStroke}));
    }
};


template<class D>
class $CCMouseDelegate : public CCMouseDelegate, public $CacBase {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMouseDelegate* __thistype;

    void rightKeyDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61b0))(this);
    }

    void rightKeyUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61c0))(this);
    }

    void scrollWheel(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x61d0))(this, p0, p1);
    }

    void apply_hooks() override {
        if ((void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyDown} != (void(D::*)()){&D::rightKeyDown})
            m->registerHook(getBase()+0x61b0, extract((void(D::*)()){&D::rightKeyDown}));

        if ((void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyUp} != (void(D::*)()){&D::rightKeyUp})
            m->registerHook(getBase()+0x61c0, extract((void(D::*)()){&D::rightKeyUp}));

        if ((void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            m->registerHook(getBase()+0x61d0, extract((void(D::*)(float, float)){&D::scrollWheel}));
    }
};


template<class D>
class $CCMoveBy : public CCMoveBy, public $CacBase {
 public:
    $CCMoveBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMoveBy* __thistype;

    static CCMoveBy* create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<CCMoveBy*(*)(float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f50e0))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCMoveBy*(*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create} != (CCMoveBy*(*)(float, cocos2d::CCPoint const&)){&D::create})
            m->registerHook(getBase()+0x1f50e0, (CCMoveBy*(*)(float, cocos2d::CCPoint const&)){&D::create});
    }
};


template<class D>
class $CCMoveTo : public CCMoveTo, public $CacBase {
 public:
    $CCMoveTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMoveTo* __thistype;

    static CCMoveTo* create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<CCMoveTo*(*)(float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f54d0))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCMoveTo*(*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create} != (CCMoveTo*(*)(float, cocos2d::CCPoint const&)){&D::create})
            m->registerHook(getBase()+0x1f54d0, (CCMoveTo*(*)(float, cocos2d::CCPoint const&)){&D::create});
    }
};


template<class D>
class $CCNode : public CCNode, public $CacBase {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNode* __thistype;

    void _setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x122990))(this, p0);
    }

    void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x1233d0))(this, p0);
    }

    void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1233b0))(this, p0, p1);
    }

    void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1232a0))(this, p0, p1, p2);
    }

    void addComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a40))(this, p0);
    }

    void cleanup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123100))(this);
    }

    void convertToNodeSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124750))(this, p0);
    }

    void convertToWorldSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124790))(this, p0);
    }

    static CCNode* create() {
        return reinterpret_cast<CCNode*(*)()>(m->getOriginal(getBase()+0x1230a0))();
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123840))(this);
    }

    void getActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ee0))(this, p0);
    }

    void getActionManager() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123e50))(this);
    }

    void getAnchorPoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d80))(this);
    }

    void getAnchorPointInPoints() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d70))(this);
    }

    void getCamera() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122cb0))(this);
    }

    void getChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123220))(this, p0);
    }

    void getChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122c80))(this);
    }

    void getChildrenCount() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122c90))(this);
    }

    void getContentSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122e00))(this);
    }

    void getGLServerState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f90))(this);
    }

    void getGrid() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d00))(this);
    }

    void getOrderOfArrival() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f50))(this);
    }

    void getParent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ed0))(this);
    }

    void getPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b60))(this);
    }

    void getPosition(float* p0, float* p1) {
        return reinterpret_cast<void(*)(decltype(this), float*, float*)>(m->getOriginal(getBase()+0x122b90))(this, p0, p1);
    }

    void getPositionX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122be0))(this);
    }

    void getPositionY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122bf0))(this);
    }

    void getRotation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a00))(this);
    }

    void getRotationX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a50))(this);
    }

    void getRotationY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a80))(this);
    }

    void getScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ab0))(this);
    }

    void getScaleX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b00))(this);
    }

    void getScaleY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b30))(this);
    }

    void getScaledContentSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122e10))(this);
    }

    void getScheduler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123f70))(this);
    }

    void getShaderProgram() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f70))(this);
    }

    void getSkewX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122920))(this);
    }

    void getSkewY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122950))(this);
    }

    void getUserData() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f30))(this);
    }

    void getUserObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f80))(this);
    }

    void getVertexZ() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1229e0))(this);
    }

    void getZOrder() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122980))(this);
    }

    void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122f00))(this, p0);
    }

    bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x122910))(this);
    }

    void isIgnoreAnchorPointForPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ef0))(this);
    }

    void isRunning() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ec0))(this);
    }

    void isVisible() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d50))(this);
    }

    void nodeToParentTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124210))(this);
    }

    void nodeToWorldTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124670))(this);
    }

    void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123a90))(this);
    }

    void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123b90))(this);
    }

    void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123ca0))(this);
    }

    void onExitTransitionDidStart() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123c00))(this);
    }

    void parentToNodeTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1245d0))(this);
    }

    void pauseSchedulerAndActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123d60))(this);
    }

    void registerScriptHandler(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123d90))(this, p0);
    }

    void removeAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123600))(this);
    }

    void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123620))(this, p0);
    }

    void removeAllComponents() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124aa0))(this);
    }

    void removeChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x123460))(this, p0);
    }

    void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x123480))(this, p0, p1);
    }

    void removeChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1235a0))(this, p0);
    }

    void removeChildByTag(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x1235c0))(this, p0, p1);
    }

    void removeComponent(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x124a60))(this, p0);
    }

    void removeComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a80))(this, p0);
    }

    void removeFromParent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1233f0))(this);
    }

    void removeFromParentAndCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123410))(this, p0);
    }

    void removeMeAndCleanup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123440))(this);
    }

    void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x123760))(this, p0, p1);
    }

    void resumeSchedulerAndActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123b60))(this);
    }

    void runAction(cocos2d::CCAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAction*)>(m->getOriginal(getBase()+0x123e60))(this, p0);
    }

    void schedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x1240b0))(this, p0);
    }

    void schedule(Cacao::CC_SCHED p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, float)>(m->getOriginal(getBase()+0x124120))(this, p0, p1);
    }

    void scheduleUpdate() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123f80))(this);
    }

    void setActionManager(cocos2d::CCActionManager* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionManager*)>(m->getOriginal(getBase()+0x123e00))(this, p0);
    }

    void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122d90))(this, p0);
    }

    void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x122e50))(this, p0);
    }

    void setGLServerState(cocos2d::ccGLServerState p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccGLServerState)>(m->getOriginal(getBase()+0x122fa0))(this, p0);
    }

    void setGrid(cocos2d::CCGridBase* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGridBase*)>(m->getOriginal(getBase()+0x122d10))(this, p0);
    }

    void setOrderOfArrival(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x122f60))(this, p0);
    }

    void setParent(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x122ee0))(this, p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122b70))(this, p0);
    }

    void setPosition(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ba0))(this, p0, p1);
    }

    void setPositionX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c00))(this, p0);
    }

    void setPositionY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c40))(this, p0);
    }

    void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a10))(this, p0);
    }

    void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a60))(this, p0);
    }

    void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a90))(this, p0);
    }

    void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122ac0))(this, p0);
    }

    void setScale(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ae0))(this, p0, p1);
    }

    void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b10))(this, p0);
    }

    void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b40))(this, p0);
    }

    void setScheduler(cocos2d::CCScheduler* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScheduler*)>(m->getOriginal(getBase()+0x123f20))(this, p0);
    }

    void setShaderProgram(cocos2d::CCGLProgram* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGLProgram*)>(m->getOriginal(getBase()+0x122ff0))(this, p0);
    }

    void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122930))(this, p0);
    }

    void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122960))(this, p0);
    }

    void setUserData(void* p0) {
        return reinterpret_cast<void(*)(decltype(this), void*)>(m->getOriginal(getBase()+0x122f40))(this, p0);
    }

    void setUserObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x122fb0))(this, p0);
    }

    void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1229f0))(this, p0);
    }

    void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122d60))(this, p0);
    }

    void setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1229a0))(this, p0);
    }

    void sortAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1237b0))(this);
    }

    void stopActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ec0))(this, p0);
    }

    void stopAllActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123190))(this);
    }

    void unregisterScriptHandler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123dc0))(this);
    }

    void unschedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x124180))(this, p0);
    }

    void unscheduleAllSelectors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1231b0))(this);
    }

    void unscheduleUpdate() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124060))(this);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1241a0))(this, p0);
    }

    void updateTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1249d0))(this);
    }

    void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x1249c0))(this, p0, p1);
    }

    void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123850))(this);
    }

    void worldToNodeTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124710))(this);
    }

    void apply_hooks() override {
        if ((void($CCNode::*)(int)){&$CCNode::_setZOrder} != (void(D::*)(int)){&D::_setZOrder})
            m->registerHook(getBase()+0x122990, extract((void(D::*)(int)){&D::_setZOrder}));

        if ((void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild} != (void(D::*)(cocos2d::CCNode*)){&D::addChild})
            m->registerHook(getBase()+0x1233d0, extract((void(D::*)(cocos2d::CCNode*)){&D::addChild}));

        if ((void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild} != (void(D::*)(cocos2d::CCNode*, int)){&D::addChild})
            m->registerHook(getBase()+0x1233b0, extract((void(D::*)(cocos2d::CCNode*, int)){&D::addChild}));

        if ((void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild} != (void(D::*)(cocos2d::CCNode*, int, int)){&D::addChild})
            m->registerHook(getBase()+0x1232a0, extract((void(D::*)(cocos2d::CCNode*, int, int)){&D::addChild}));

        if ((void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent} != (void(D::*)(cocos2d::CCComponent*)){&D::addComponent})
            m->registerHook(getBase()+0x124a40, extract((void(D::*)(cocos2d::CCComponent*)){&D::addComponent}));

        if ((void($CCNode::*)()){&$CCNode::cleanup} != (void(D::*)()){&D::cleanup})
            m->registerHook(getBase()+0x123100, extract((void(D::*)()){&D::cleanup}));

        if ((void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace} != (void(D::*)(cocos2d::CCPoint const&)){&D::convertToNodeSpace})
            m->registerHook(getBase()+0x124750, extract((void(D::*)(cocos2d::CCPoint const&)){&D::convertToNodeSpace}));

        if ((void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace} != (void(D::*)(cocos2d::CCPoint const&)){&D::convertToWorldSpace})
            m->registerHook(getBase()+0x124790, extract((void(D::*)(cocos2d::CCPoint const&)){&D::convertToWorldSpace}));

        if ((CCNode*(*)()){&$CCNode::create} != (CCNode*(*)()){&D::create})
            m->registerHook(getBase()+0x1230a0, (CCNode*(*)()){&D::create});

        if ((void($CCNode::*)()){&$CCNode::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x123840, extract((void(D::*)()){&D::draw}));

        if ((void($CCNode::*)(int)){&$CCNode::getActionByTag} != (void(D::*)(int)){&D::getActionByTag})
            m->registerHook(getBase()+0x123ee0, extract((void(D::*)(int)){&D::getActionByTag}));

        if ((void($CCNode::*)()){&$CCNode::getActionManager} != (void(D::*)()){&D::getActionManager})
            m->registerHook(getBase()+0x123e50, extract((void(D::*)()){&D::getActionManager}));

        if ((void($CCNode::*)()){&$CCNode::getAnchorPoint} != (void(D::*)()){&D::getAnchorPoint})
            m->registerHook(getBase()+0x122d80, extract((void(D::*)()){&D::getAnchorPoint}));

        if ((void($CCNode::*)()){&$CCNode::getAnchorPointInPoints} != (void(D::*)()){&D::getAnchorPointInPoints})
            m->registerHook(getBase()+0x122d70, extract((void(D::*)()){&D::getAnchorPointInPoints}));

        if ((void($CCNode::*)()){&$CCNode::getCamera} != (void(D::*)()){&D::getCamera})
            m->registerHook(getBase()+0x122cb0, extract((void(D::*)()){&D::getCamera}));

        if ((void($CCNode::*)(int)){&$CCNode::getChildByTag} != (void(D::*)(int)){&D::getChildByTag})
            m->registerHook(getBase()+0x123220, extract((void(D::*)(int)){&D::getChildByTag}));

        if ((void($CCNode::*)()){&$CCNode::getChildren} != (void(D::*)()){&D::getChildren})
            m->registerHook(getBase()+0x122c80, extract((void(D::*)()){&D::getChildren}));

        if ((void($CCNode::*)()){&$CCNode::getChildrenCount} != (void(D::*)()){&D::getChildrenCount})
            m->registerHook(getBase()+0x122c90, extract((void(D::*)()){&D::getChildrenCount}));

        if ((void($CCNode::*)()){&$CCNode::getContentSize} != (void(D::*)()){&D::getContentSize})
            m->registerHook(getBase()+0x122e00, extract((void(D::*)()){&D::getContentSize}));

        if ((void($CCNode::*)()){&$CCNode::getGLServerState} != (void(D::*)()){&D::getGLServerState})
            m->registerHook(getBase()+0x122f90, extract((void(D::*)()){&D::getGLServerState}));

        if ((void($CCNode::*)()){&$CCNode::getGrid} != (void(D::*)()){&D::getGrid})
            m->registerHook(getBase()+0x122d00, extract((void(D::*)()){&D::getGrid}));

        if ((void($CCNode::*)()){&$CCNode::getOrderOfArrival} != (void(D::*)()){&D::getOrderOfArrival})
            m->registerHook(getBase()+0x122f50, extract((void(D::*)()){&D::getOrderOfArrival}));

        if ((void($CCNode::*)()){&$CCNode::getParent} != (void(D::*)()){&D::getParent})
            m->registerHook(getBase()+0x122ed0, extract((void(D::*)()){&D::getParent}));

        if ((void($CCNode::*)()){&$CCNode::getPosition} != (void(D::*)()){&D::getPosition})
            m->registerHook(getBase()+0x122b60, extract((void(D::*)()){&D::getPosition}));

        if ((void($CCNode::*)(float*, float*)){&$CCNode::getPosition} != (void(D::*)(float*, float*)){&D::getPosition})
            m->registerHook(getBase()+0x122b90, extract((void(D::*)(float*, float*)){&D::getPosition}));

        if ((void($CCNode::*)()){&$CCNode::getPositionX} != (void(D::*)()){&D::getPositionX})
            m->registerHook(getBase()+0x122be0, extract((void(D::*)()){&D::getPositionX}));

        if ((void($CCNode::*)()){&$CCNode::getPositionY} != (void(D::*)()){&D::getPositionY})
            m->registerHook(getBase()+0x122bf0, extract((void(D::*)()){&D::getPositionY}));

        if ((void($CCNode::*)()){&$CCNode::getRotation} != (void(D::*)()){&D::getRotation})
            m->registerHook(getBase()+0x122a00, extract((void(D::*)()){&D::getRotation}));

        if ((void($CCNode::*)()){&$CCNode::getRotationX} != (void(D::*)()){&D::getRotationX})
            m->registerHook(getBase()+0x122a50, extract((void(D::*)()){&D::getRotationX}));

        if ((void($CCNode::*)()){&$CCNode::getRotationY} != (void(D::*)()){&D::getRotationY})
            m->registerHook(getBase()+0x122a80, extract((void(D::*)()){&D::getRotationY}));

        if ((void($CCNode::*)()){&$CCNode::getScale} != (void(D::*)()){&D::getScale})
            m->registerHook(getBase()+0x122ab0, extract((void(D::*)()){&D::getScale}));

        if ((void($CCNode::*)()){&$CCNode::getScaleX} != (void(D::*)()){&D::getScaleX})
            m->registerHook(getBase()+0x122b00, extract((void(D::*)()){&D::getScaleX}));

        if ((void($CCNode::*)()){&$CCNode::getScaleY} != (void(D::*)()){&D::getScaleY})
            m->registerHook(getBase()+0x122b30, extract((void(D::*)()){&D::getScaleY}));

        if ((void($CCNode::*)()){&$CCNode::getScaledContentSize} != (void(D::*)()){&D::getScaledContentSize})
            m->registerHook(getBase()+0x122e10, extract((void(D::*)()){&D::getScaledContentSize}));

        if ((void($CCNode::*)()){&$CCNode::getScheduler} != (void(D::*)()){&D::getScheduler})
            m->registerHook(getBase()+0x123f70, extract((void(D::*)()){&D::getScheduler}));

        if ((void($CCNode::*)()){&$CCNode::getShaderProgram} != (void(D::*)()){&D::getShaderProgram})
            m->registerHook(getBase()+0x122f70, extract((void(D::*)()){&D::getShaderProgram}));

        if ((void($CCNode::*)()){&$CCNode::getSkewX} != (void(D::*)()){&D::getSkewX})
            m->registerHook(getBase()+0x122920, extract((void(D::*)()){&D::getSkewX}));

        if ((void($CCNode::*)()){&$CCNode::getSkewY} != (void(D::*)()){&D::getSkewY})
            m->registerHook(getBase()+0x122950, extract((void(D::*)()){&D::getSkewY}));

        if ((void($CCNode::*)()){&$CCNode::getUserData} != (void(D::*)()){&D::getUserData})
            m->registerHook(getBase()+0x122f30, extract((void(D::*)()){&D::getUserData}));

        if ((void($CCNode::*)()){&$CCNode::getUserObject} != (void(D::*)()){&D::getUserObject})
            m->registerHook(getBase()+0x122f80, extract((void(D::*)()){&D::getUserObject}));

        if ((void($CCNode::*)()){&$CCNode::getVertexZ} != (void(D::*)()){&D::getVertexZ})
            m->registerHook(getBase()+0x1229e0, extract((void(D::*)()){&D::getVertexZ}));

        if ((void($CCNode::*)()){&$CCNode::getZOrder} != (void(D::*)()){&D::getZOrder})
            m->registerHook(getBase()+0x122980, extract((void(D::*)()){&D::getZOrder}));

        if ((void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition} != (void(D::*)(bool)){&D::ignoreAnchorPointForPosition})
            m->registerHook(getBase()+0x122f00, extract((void(D::*)(bool)){&D::ignoreAnchorPointForPosition}));

        if ((bool($CCNode::*)()){&$CCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(getBase()+0x122910, extract((bool(D::*)()){&D::init}));

        if ((void($CCNode::*)()){&$CCNode::isIgnoreAnchorPointForPosition} != (void(D::*)()){&D::isIgnoreAnchorPointForPosition})
            m->registerHook(getBase()+0x122ef0, extract((void(D::*)()){&D::isIgnoreAnchorPointForPosition}));

        if ((void($CCNode::*)()){&$CCNode::isRunning} != (void(D::*)()){&D::isRunning})
            m->registerHook(getBase()+0x122ec0, extract((void(D::*)()){&D::isRunning}));

        if ((void($CCNode::*)()){&$CCNode::isVisible} != (void(D::*)()){&D::isVisible})
            m->registerHook(getBase()+0x122d50, extract((void(D::*)()){&D::isVisible}));

        if ((void($CCNode::*)()){&$CCNode::nodeToParentTransform} != (void(D::*)()){&D::nodeToParentTransform})
            m->registerHook(getBase()+0x124210, extract((void(D::*)()){&D::nodeToParentTransform}));

        if ((void($CCNode::*)()){&$CCNode::nodeToWorldTransform} != (void(D::*)()){&D::nodeToWorldTransform})
            m->registerHook(getBase()+0x124670, extract((void(D::*)()){&D::nodeToWorldTransform}));

        if ((void($CCNode::*)()){&$CCNode::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(getBase()+0x123a90, extract((void(D::*)()){&D::onEnter}));

        if ((void($CCNode::*)()){&$CCNode::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(getBase()+0x123b90, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($CCNode::*)()){&$CCNode::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(getBase()+0x123ca0, extract((void(D::*)()){&D::onExit}));

        if ((void($CCNode::*)()){&$CCNode::onExitTransitionDidStart} != (void(D::*)()){&D::onExitTransitionDidStart})
            m->registerHook(getBase()+0x123c00, extract((void(D::*)()){&D::onExitTransitionDidStart}));

        if ((void($CCNode::*)()){&$CCNode::parentToNodeTransform} != (void(D::*)()){&D::parentToNodeTransform})
            m->registerHook(getBase()+0x1245d0, extract((void(D::*)()){&D::parentToNodeTransform}));

        if ((void($CCNode::*)()){&$CCNode::pauseSchedulerAndActions} != (void(D::*)()){&D::pauseSchedulerAndActions})
            m->registerHook(getBase()+0x123d60, extract((void(D::*)()){&D::pauseSchedulerAndActions}));

        if ((void($CCNode::*)(int)){&$CCNode::registerScriptHandler} != (void(D::*)(int)){&D::registerScriptHandler})
            m->registerHook(getBase()+0x123d90, extract((void(D::*)(int)){&D::registerScriptHandler}));

        if ((void($CCNode::*)()){&$CCNode::removeAllChildren} != (void(D::*)()){&D::removeAllChildren})
            m->registerHook(getBase()+0x123600, extract((void(D::*)()){&D::removeAllChildren}));

        if ((void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup} != (void(D::*)(bool)){&D::removeAllChildrenWithCleanup})
            m->registerHook(getBase()+0x123620, extract((void(D::*)(bool)){&D::removeAllChildrenWithCleanup}));

        if ((void($CCNode::*)()){&$CCNode::removeAllComponents} != (void(D::*)()){&D::removeAllComponents})
            m->registerHook(getBase()+0x124aa0, extract((void(D::*)()){&D::removeAllComponents}));

        if ((void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild} != (void(D::*)(cocos2d::CCNode*)){&D::removeChild})
            m->registerHook(getBase()+0x123460, extract((void(D::*)(cocos2d::CCNode*)){&D::removeChild}));

        if ((void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild} != (void(D::*)(cocos2d::CCNode*, bool)){&D::removeChild})
            m->registerHook(getBase()+0x123480, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::removeChild}));

        if ((void($CCNode::*)(int)){&$CCNode::removeChildByTag} != (void(D::*)(int)){&D::removeChildByTag})
            m->registerHook(getBase()+0x1235a0, extract((void(D::*)(int)){&D::removeChildByTag}));

        if ((void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag} != (void(D::*)(int, bool)){&D::removeChildByTag})
            m->registerHook(getBase()+0x1235c0, extract((void(D::*)(int, bool)){&D::removeChildByTag}));

        if ((void($CCNode::*)(char const*)){&$CCNode::removeComponent} != (void(D::*)(char const*)){&D::removeComponent})
            m->registerHook(getBase()+0x124a60, extract((void(D::*)(char const*)){&D::removeComponent}));

        if ((void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent} != (void(D::*)(cocos2d::CCComponent*)){&D::removeComponent})
            m->registerHook(getBase()+0x124a80, extract((void(D::*)(cocos2d::CCComponent*)){&D::removeComponent}));

        if ((void($CCNode::*)()){&$CCNode::removeFromParent} != (void(D::*)()){&D::removeFromParent})
            m->registerHook(getBase()+0x1233f0, extract((void(D::*)()){&D::removeFromParent}));

        if ((void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup} != (void(D::*)(bool)){&D::removeFromParentAndCleanup})
            m->registerHook(getBase()+0x123410, extract((void(D::*)(bool)){&D::removeFromParentAndCleanup}));

        if ((void($CCNode::*)()){&$CCNode::removeMeAndCleanup} != (void(D::*)()){&D::removeMeAndCleanup})
            m->registerHook(getBase()+0x123440, extract((void(D::*)()){&D::removeMeAndCleanup}));

        if ((void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild} != (void(D::*)(cocos2d::CCNode*, int)){&D::reorderChild})
            m->registerHook(getBase()+0x123760, extract((void(D::*)(cocos2d::CCNode*, int)){&D::reorderChild}));

        if ((void($CCNode::*)()){&$CCNode::resumeSchedulerAndActions} != (void(D::*)()){&D::resumeSchedulerAndActions})
            m->registerHook(getBase()+0x123b60, extract((void(D::*)()){&D::resumeSchedulerAndActions}));

        if ((void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction} != (void(D::*)(cocos2d::CCAction*)){&D::runAction})
            m->registerHook(getBase()+0x123e60, extract((void(D::*)(cocos2d::CCAction*)){&D::runAction}));

        if ((void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule} != (void(D::*)(Cacao::CC_SCHED)){&D::schedule})
            m->registerHook(getBase()+0x1240b0, extract((void(D::*)(Cacao::CC_SCHED)){&D::schedule}));

        if ((void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule} != (void(D::*)(Cacao::CC_SCHED, float)){&D::schedule})
            m->registerHook(getBase()+0x124120, extract((void(D::*)(Cacao::CC_SCHED, float)){&D::schedule}));

        if ((void($CCNode::*)()){&$CCNode::scheduleUpdate} != (void(D::*)()){&D::scheduleUpdate})
            m->registerHook(getBase()+0x123f80, extract((void(D::*)()){&D::scheduleUpdate}));

        if ((void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager} != (void(D::*)(cocos2d::CCActionManager*)){&D::setActionManager})
            m->registerHook(getBase()+0x123e00, extract((void(D::*)(cocos2d::CCActionManager*)){&D::setActionManager}));

        if ((void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint} != (void(D::*)(cocos2d::CCPoint const&)){&D::setAnchorPoint})
            m->registerHook(getBase()+0x122d90, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setAnchorPoint}));

        if ((void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize} != (void(D::*)(cocos2d::CCSize const&)){&D::setContentSize})
            m->registerHook(getBase()+0x122e50, extract((void(D::*)(cocos2d::CCSize const&)){&D::setContentSize}));

        if ((void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState} != (void(D::*)(cocos2d::ccGLServerState)){&D::setGLServerState})
            m->registerHook(getBase()+0x122fa0, extract((void(D::*)(cocos2d::ccGLServerState)){&D::setGLServerState}));

        if ((void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid} != (void(D::*)(cocos2d::CCGridBase*)){&D::setGrid})
            m->registerHook(getBase()+0x122d10, extract((void(D::*)(cocos2d::CCGridBase*)){&D::setGrid}));

        if ((void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival} != (void(D::*)(unsigned int)){&D::setOrderOfArrival})
            m->registerHook(getBase()+0x122f60, extract((void(D::*)(unsigned int)){&D::setOrderOfArrival}));

        if ((void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent} != (void(D::*)(cocos2d::CCNode*)){&D::setParent})
            m->registerHook(getBase()+0x122ee0, extract((void(D::*)(cocos2d::CCNode*)){&D::setParent}));

        if ((void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x122b70, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCNode::*)(float, float)){&$CCNode::setPosition} != (void(D::*)(float, float)){&D::setPosition})
            m->registerHook(getBase()+0x122ba0, extract((void(D::*)(float, float)){&D::setPosition}));

        if ((void($CCNode::*)(float)){&$CCNode::setPositionX} != (void(D::*)(float)){&D::setPositionX})
            m->registerHook(getBase()+0x122c00, extract((void(D::*)(float)){&D::setPositionX}));

        if ((void($CCNode::*)(float)){&$CCNode::setPositionY} != (void(D::*)(float)){&D::setPositionY})
            m->registerHook(getBase()+0x122c40, extract((void(D::*)(float)){&D::setPositionY}));

        if ((void($CCNode::*)(float)){&$CCNode::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(getBase()+0x122a10, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($CCNode::*)(float)){&$CCNode::setRotationX} != (void(D::*)(float)){&D::setRotationX})
            m->registerHook(getBase()+0x122a60, extract((void(D::*)(float)){&D::setRotationX}));

        if ((void($CCNode::*)(float)){&$CCNode::setRotationY} != (void(D::*)(float)){&D::setRotationY})
            m->registerHook(getBase()+0x122a90, extract((void(D::*)(float)){&D::setRotationY}));

        if ((void($CCNode::*)(float)){&$CCNode::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(getBase()+0x122ac0, extract((void(D::*)(float)){&D::setScale}));

        if ((void($CCNode::*)(float, float)){&$CCNode::setScale} != (void(D::*)(float, float)){&D::setScale})
            m->registerHook(getBase()+0x122ae0, extract((void(D::*)(float, float)){&D::setScale}));

        if ((void($CCNode::*)(float)){&$CCNode::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(getBase()+0x122b10, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($CCNode::*)(float)){&$CCNode::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(getBase()+0x122b40, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler} != (void(D::*)(cocos2d::CCScheduler*)){&D::setScheduler})
            m->registerHook(getBase()+0x123f20, extract((void(D::*)(cocos2d::CCScheduler*)){&D::setScheduler}));

        if ((void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram} != (void(D::*)(cocos2d::CCGLProgram*)){&D::setShaderProgram})
            m->registerHook(getBase()+0x122ff0, extract((void(D::*)(cocos2d::CCGLProgram*)){&D::setShaderProgram}));

        if ((void($CCNode::*)(float)){&$CCNode::setSkewX} != (void(D::*)(float)){&D::setSkewX})
            m->registerHook(getBase()+0x122930, extract((void(D::*)(float)){&D::setSkewX}));

        if ((void($CCNode::*)(float)){&$CCNode::setSkewY} != (void(D::*)(float)){&D::setSkewY})
            m->registerHook(getBase()+0x122960, extract((void(D::*)(float)){&D::setSkewY}));

        if ((void($CCNode::*)(void*)){&$CCNode::setUserData} != (void(D::*)(void*)){&D::setUserData})
            m->registerHook(getBase()+0x122f40, extract((void(D::*)(void*)){&D::setUserData}));

        if ((void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject} != (void(D::*)(cocos2d::CCObject*)){&D::setUserObject})
            m->registerHook(getBase()+0x122fb0, extract((void(D::*)(cocos2d::CCObject*)){&D::setUserObject}));

        if ((void($CCNode::*)(float)){&$CCNode::setVertexZ} != (void(D::*)(float)){&D::setVertexZ})
            m->registerHook(getBase()+0x1229f0, extract((void(D::*)(float)){&D::setVertexZ}));

        if ((void($CCNode::*)(bool)){&$CCNode::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(getBase()+0x122d60, extract((void(D::*)(bool)){&D::setVisible}));

        if ((void($CCNode::*)(int)){&$CCNode::setZOrder} != (void(D::*)(int)){&D::setZOrder})
            m->registerHook(getBase()+0x1229a0, extract((void(D::*)(int)){&D::setZOrder}));

        if ((void($CCNode::*)()){&$CCNode::sortAllChildren} != (void(D::*)()){&D::sortAllChildren})
            m->registerHook(getBase()+0x1237b0, extract((void(D::*)()){&D::sortAllChildren}));

        if ((void($CCNode::*)(int)){&$CCNode::stopActionByTag} != (void(D::*)(int)){&D::stopActionByTag})
            m->registerHook(getBase()+0x123ec0, extract((void(D::*)(int)){&D::stopActionByTag}));

        if ((void($CCNode::*)()){&$CCNode::stopAllActions} != (void(D::*)()){&D::stopAllActions})
            m->registerHook(getBase()+0x123190, extract((void(D::*)()){&D::stopAllActions}));

        if ((void($CCNode::*)()){&$CCNode::unregisterScriptHandler} != (void(D::*)()){&D::unregisterScriptHandler})
            m->registerHook(getBase()+0x123dc0, extract((void(D::*)()){&D::unregisterScriptHandler}));

        if ((void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule} != (void(D::*)(Cacao::CC_SCHED)){&D::unschedule})
            m->registerHook(getBase()+0x124180, extract((void(D::*)(Cacao::CC_SCHED)){&D::unschedule}));

        if ((void($CCNode::*)()){&$CCNode::unscheduleAllSelectors} != (void(D::*)()){&D::unscheduleAllSelectors})
            m->registerHook(getBase()+0x1231b0, extract((void(D::*)()){&D::unscheduleAllSelectors}));

        if ((void($CCNode::*)()){&$CCNode::unscheduleUpdate} != (void(D::*)()){&D::unscheduleUpdate})
            m->registerHook(getBase()+0x124060, extract((void(D::*)()){&D::unscheduleUpdate}));

        if ((void($CCNode::*)(float)){&$CCNode::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x1241a0, extract((void(D::*)(float)){&D::update}));

        if ((void($CCNode::*)()){&$CCNode::updateTransform} != (void(D::*)()){&D::updateTransform})
            m->registerHook(getBase()+0x1249d0, extract((void(D::*)()){&D::updateTransform}));

        if ((void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(getBase()+0x1249c0, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((void($CCNode::*)()){&$CCNode::visit} != (void(D::*)()){&D::visit})
            m->registerHook(getBase()+0x123850, extract((void(D::*)()){&D::visit}));

        if ((void($CCNode::*)()){&$CCNode::worldToNodeTransform} != (void(D::*)()){&D::worldToNodeTransform})
            m->registerHook(getBase()+0x124710, extract((void(D::*)()){&D::worldToNodeTransform}));
    }
};


template<class D>
class $CCNodeRGBA : public CCNodeRGBA, public $CacBase {
 public:
    $CCNodeRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNodeRGBA* __thistype;

    void getColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125020))(this);
    }

    void getDisplayedColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125040))(this);
    }

    void getDisplayedOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124cf0))(this);
    }

    void getOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124cd0))(this);
    }

    void isCascadeColorEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125320))(this);
    }

    void isCascadeOpacityEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124fe0))(this);
    }

    void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125340))(this, p0);
    }

    void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125000))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::getColor} != (void(D::*)()){&D::getColor})
            m->registerHook(getBase()+0x125020, extract((void(D::*)()){&D::getColor}));

        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedColor} != (void(D::*)()){&D::getDisplayedColor})
            m->registerHook(getBase()+0x125040, extract((void(D::*)()){&D::getDisplayedColor}));

        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedOpacity} != (void(D::*)()){&D::getDisplayedOpacity})
            m->registerHook(getBase()+0x124cf0, extract((void(D::*)()){&D::getDisplayedOpacity}));

        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::getOpacity} != (void(D::*)()){&D::getOpacity})
            m->registerHook(getBase()+0x124cd0, extract((void(D::*)()){&D::getOpacity}));

        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeColorEnabled} != (void(D::*)()){&D::isCascadeColorEnabled})
            m->registerHook(getBase()+0x125320, extract((void(D::*)()){&D::isCascadeColorEnabled}));

        if ((void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeOpacityEnabled} != (void(D::*)()){&D::isCascadeOpacityEnabled})
            m->registerHook(getBase()+0x124fe0, extract((void(D::*)()){&D::isCascadeOpacityEnabled}));

        if ((void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled} != (void(D::*)(bool)){&D::setCascadeColorEnabled})
            m->registerHook(getBase()+0x125340, extract((void(D::*)(bool)){&D::setCascadeColorEnabled}));

        if ((void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled} != (void(D::*)(bool)){&D::setCascadeOpacityEnabled})
            m->registerHook(getBase()+0x125000, extract((void(D::*)(bool)){&D::setCascadeOpacityEnabled}));
    }
};


template<class D>
class $CCObject : public CCObject, public $CacBase {
 public:
    $CCObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCObject* __thistype;

    void acceptVisitor(cocos2d::CCDataVisitor& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDataVisitor&)>(m->getOriginal(getBase()+0x250f30))(this, p0);
    }

    void autorelease() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ed0))(this);
    }

    void canEncode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250f90))(this);
    }

    void encodeWithCoder(DS_Dictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(getBase()+0x250f70))(this, p0);
    }

    void getTag() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250f50))(this);
    }

    void isEqual(cocos2d::CCObject const* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject const*)>(m->getOriginal(getBase()+0x250f20))(this, p0);
    }

    void release() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ea0))(this);
    }

    void retain() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ec0))(this);
    }

    void setTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x250f60))(this, p0);
    }

    void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x32660))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor} != (void(D::*)(cocos2d::CCDataVisitor&)){&D::acceptVisitor})
            m->registerHook(getBase()+0x250f30, extract((void(D::*)(cocos2d::CCDataVisitor&)){&D::acceptVisitor}));

        if ((void($CCObject::*)()){&$CCObject::autorelease} != (void(D::*)()){&D::autorelease})
            m->registerHook(getBase()+0x250ed0, extract((void(D::*)()){&D::autorelease}));

        if ((void($CCObject::*)()){&$CCObject::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(getBase()+0x250f90, extract((void(D::*)()){&D::canEncode}));

        if ((void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(getBase()+0x250f70, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($CCObject::*)()){&$CCObject::getTag} != (void(D::*)()){&D::getTag})
            m->registerHook(getBase()+0x250f50, extract((void(D::*)()){&D::getTag}));

        if ((void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual} != (void(D::*)(cocos2d::CCObject const*)){&D::isEqual})
            m->registerHook(getBase()+0x250f20, extract((void(D::*)(cocos2d::CCObject const*)){&D::isEqual}));

        if ((void($CCObject::*)()){&$CCObject::release} != (void(D::*)()){&D::release})
            m->registerHook(getBase()+0x250ea0, extract((void(D::*)()){&D::release}));

        if ((void($CCObject::*)()){&$CCObject::retain} != (void(D::*)()){&D::retain})
            m->registerHook(getBase()+0x250ec0, extract((void(D::*)()){&D::retain}));

        if ((void($CCObject::*)(int)){&$CCObject::setTag} != (void(D::*)(int)){&D::setTag})
            m->registerHook(getBase()+0x250f60, extract((void(D::*)(int)){&D::setTag}));

        if ((void($CCObject::*)(float)){&$CCObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(getBase()+0x32660, extract((void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $CCParticleSystem : public CCParticleSystem, public $CacBase {
 public:
    $CCParticleSystem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCParticleSystem* __thistype;

    void resetSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd50))(this);
    }

    void resumeSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd40))(this);
    }

    void stopSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd10))(this);
    }

    void apply_hooks() override {
        if ((void($CCParticleSystem::*)()){&$CCParticleSystem::resetSystem} != (void(D::*)()){&D::resetSystem})
            m->registerHook(getBase()+0x46bd50, extract((void(D::*)()){&D::resetSystem}));

        if ((void($CCParticleSystem::*)()){&$CCParticleSystem::resumeSystem} != (void(D::*)()){&D::resumeSystem})
            m->registerHook(getBase()+0x46bd40, extract((void(D::*)()){&D::resumeSystem}));

        if ((void($CCParticleSystem::*)()){&$CCParticleSystem::stopSystem} != (void(D::*)()){&D::stopSystem})
            m->registerHook(getBase()+0x46bd10, extract((void(D::*)()){&D::stopSystem}));
    }
};


template<class D>
class $CCParticleSystemQuad : public CCParticleSystemQuad, public $CacBase {
 public:
    $CCParticleSystemQuad() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCParticleSystemQuad* __thistype;

    static CCParticleSystemQuad* create(char const* p0) {
        return reinterpret_cast<CCParticleSystemQuad*(*)(char const*)>(m->getOriginal(getBase()+0x36b000))(p0);
    }

    void apply_hooks() override {
        if ((CCParticleSystemQuad*(*)(char const*)){&$CCParticleSystemQuad::create} != (CCParticleSystemQuad*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x36b000, (CCParticleSystemQuad*(*)(char const*)){&D::create});
    }
};


template<class D>
class $CCPoint : public CCPoint, public $CacBase {
 public:
    $CCPoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCPoint* __thistype;

    void equals(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1371d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCPoint::*)(cocos2d::CCPoint const&)){&$CCPoint::equals} != (void(D::*)(cocos2d::CCPoint const&)){&D::equals})
            m->registerHook(getBase()+0x1371d0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::equals}));
    }
};


template<class D>
class $CCRect : public CCRect, public $CacBase {
 public:
    $CCRect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRect* __thistype;

    void containsPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1377b0))(this, p0);
    }

    void equals(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1376a0))(this, p0);
    }

    void getMaxX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137710))(this);
    }

    void getMaxY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137760))(this);
    }

    void getMinX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137750))(this);
    }

    void getMinY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1377a0))(this);
    }

    void intersectsRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x137800))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCRect::*)(cocos2d::CCPoint const&)){&$CCRect::containsPoint} != (void(D::*)(cocos2d::CCPoint const&)){&D::containsPoint})
            m->registerHook(getBase()+0x1377b0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::containsPoint}));

        if ((void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::equals} != (void(D::*)(cocos2d::CCRect const&)){&D::equals})
            m->registerHook(getBase()+0x1376a0, extract((void(D::*)(cocos2d::CCRect const&)){&D::equals}));

        if ((void($CCRect::*)()){&$CCRect::getMaxX} != (void(D::*)()){&D::getMaxX})
            m->registerHook(getBase()+0x137710, extract((void(D::*)()){&D::getMaxX}));

        if ((void($CCRect::*)()){&$CCRect::getMaxY} != (void(D::*)()){&D::getMaxY})
            m->registerHook(getBase()+0x137760, extract((void(D::*)()){&D::getMaxY}));

        if ((void($CCRect::*)()){&$CCRect::getMinX} != (void(D::*)()){&D::getMinX})
            m->registerHook(getBase()+0x137750, extract((void(D::*)()){&D::getMinX}));

        if ((void($CCRect::*)()){&$CCRect::getMinY} != (void(D::*)()){&D::getMinY})
            m->registerHook(getBase()+0x1377a0, extract((void(D::*)()){&D::getMinY}));

        if ((void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::intersectsRect} != (void(D::*)(cocos2d::CCRect const&)){&D::intersectsRect})
            m->registerHook(getBase()+0x137800, extract((void(D::*)(cocos2d::CCRect const&)){&D::intersectsRect}));
    }
};


template<class D>
class $CCRenderTexture : public CCRenderTexture, public $CacBase {
 public:
    $CCRenderTexture() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRenderTexture* __thistype;

    void begin() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35ce10))(this);
    }

    static CCRenderTexture* create(int p0, int p1, cocos2d::CCTexture2DPixelFormat p2) {
        return reinterpret_cast<CCRenderTexture*(*)(int, int, cocos2d::CCTexture2DPixelFormat)>(m->getOriginal(getBase()+0x35c720))(p0, p1, p2);
    }

    void end() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35d2c0))(this);
    }

    void newCCImage(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x35d7d0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCRenderTexture::*)()){&$CCRenderTexture::begin} != (void(D::*)()){&D::begin})
            m->registerHook(getBase()+0x35ce10, extract((void(D::*)()){&D::begin}));

        if ((CCRenderTexture*(*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create} != (CCRenderTexture*(*)(int, int, cocos2d::CCTexture2DPixelFormat)){&D::create})
            m->registerHook(getBase()+0x35c720, (CCRenderTexture*(*)(int, int, cocos2d::CCTexture2DPixelFormat)){&D::create});

        if ((void($CCRenderTexture::*)()){&$CCRenderTexture::end} != (void(D::*)()){&D::end})
            m->registerHook(getBase()+0x35d2c0, extract((void(D::*)()){&D::end}));

        if ((void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage} != (void(D::*)(bool)){&D::newCCImage})
            m->registerHook(getBase()+0x35d7d0, extract((void(D::*)(bool)){&D::newCCImage}));
    }
};


template<class D>
class $CCRepeatForever : public CCRepeatForever, public $CacBase {
 public:
    $CCRepeatForever() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRepeatForever* __thistype;

    static CCRepeatForever* create(cocos2d::CCActionInterval* p0) {
        return reinterpret_cast<CCRepeatForever*(*)(cocos2d::CCActionInterval*)>(m->getOriginal(getBase()+0x1f3920))(p0);
    }

    void apply_hooks() override {
        if ((CCRepeatForever*(*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create} != (CCRepeatForever*(*)(cocos2d::CCActionInterval*)){&D::create})
            m->registerHook(getBase()+0x1f3920, (CCRepeatForever*(*)(cocos2d::CCActionInterval*)){&D::create});
    }
};


template<class D>
class $CCRotateBy : public CCRotateBy, public $CacBase {
 public:
    $CCRotateBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCRotateBy* __thistype;

    static CCRotateBy* create(float p0, float p1) {
        return reinterpret_cast<CCRotateBy*(*)(float, float)>(m->getOriginal(getBase()+0x1f4c50))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCRotateBy*(*)(float, float)){&$CCRotateBy::create} != (CCRotateBy*(*)(float, float)){&D::create})
            m->registerHook(getBase()+0x1f4c50, (CCRotateBy*(*)(float, float)){&D::create});
    }
};


template<class D>
class $CCScaleTo : public CCScaleTo, public $CacBase {
 public:
    $CCScaleTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScaleTo* __thistype;

    static CCScaleTo* create(float p0, float p1) {
        return reinterpret_cast<CCScaleTo*(*)(float, float)>(m->getOriginal(getBase()+0x1f6ff0))(p0, p1);
    }

    static CCScaleTo* create(float p0, float p1, float p2) {
        return reinterpret_cast<CCScaleTo*(*)(float, float, float)>(m->getOriginal(getBase()+0x1f70f0))(p0, p1, p2);
    }

    void apply_hooks() override {
        if ((CCScaleTo*(*)(float, float)){&$CCScaleTo::create} != (CCScaleTo*(*)(float, float)){&D::create})
            m->registerHook(getBase()+0x1f6ff0, (CCScaleTo*(*)(float, float)){&D::create});

        if ((CCScaleTo*(*)(float, float, float)){&$CCScaleTo::create} != (CCScaleTo*(*)(float, float, float)){&D::create})
            m->registerHook(getBase()+0x1f70f0, (CCScaleTo*(*)(float, float, float)){&D::create});
    }
};


template<class D>
class $CCScene : public CCScene, public $CacBase {
 public:
    $CCScene() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScene* __thistype;

    static CCScene* create() {
        return reinterpret_cast<CCScene*(*)()>(m->getOriginal(getBase()+0x13c140))();
    }

    void apply_hooks() override {
        if ((CCScene*(*)()){&$CCScene::create} != (CCScene*(*)()){&D::create})
            m->registerHook(getBase()+0x13c140, (CCScene*(*)()){&D::create});
    }
};


template<class D>
class $CCScheduler : public CCScheduler, public $CacBase {
 public:
    $CCScheduler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScheduler* __thistype;

    void scheduleSelector(Cacao::CC_SCHED p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)>(m->getOriginal(getBase()+0x242b20))(this, p0, p1, p2, p3, p4, p5);
    }

    void scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, int, bool)>(m->getOriginal(getBase()+0x2438d0))(this, p0, p1, p2);
    }

    void unscheduleAllForTarget(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x243e40))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector} != (void(D::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&D::scheduleSelector})
            m->registerHook(getBase()+0x242b20, extract((void(D::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&D::scheduleSelector}));

        if ((void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget} != (void(D::*)(cocos2d::CCObject*, int, bool)){&D::scheduleUpdateForTarget})
            m->registerHook(getBase()+0x2438d0, extract((void(D::*)(cocos2d::CCObject*, int, bool)){&D::scheduleUpdateForTarget}));

        if ((void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget} != (void(D::*)(cocos2d::CCObject*)){&D::unscheduleAllForTarget})
            m->registerHook(getBase()+0x243e40, extract((void(D::*)(cocos2d::CCObject*)){&D::unscheduleAllForTarget}));
    }
};


template<class D>
class $CCSprite : public CCSprite, public $CacBase {
 public:
    $CCSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSprite* __thistype;

    void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x134190))(this, p0);
    }

    void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1341a0))(this, p0, p1);
    }

    void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1341b0))(this, p0, p1, p2);
    }

    static CCSprite* create() {
        return reinterpret_cast<CCSprite*(*)()>(m->getOriginal(getBase()+0x132df0))();
    }

    static CCSprite* create(char const* p0) {
        return reinterpret_cast<CCSprite*(*)(char const*)>(m->getOriginal(getBase()+0x132a80))(p0);
    }

    static CCSprite* createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<CCSprite*(*)(cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x132cb0))(p0);
    }

    static CCSprite* createWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<CCSprite*(*)(char const*)>(m->getOriginal(getBase()+0x132dc0))(p0);
    }

    void displayFrame() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135760))(this);
    }

    void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x134070))(this);
    }

    void getBatchNode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135910))(this);
    }

    void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x505a0))(this);
    }

    void getTexture() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135c00))(this);
    }

    void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134b60))(this, p0);
    }

    bool initWithFile(char const* p0) {
        return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x133180))(this, p0);
    }

    bool initWithFile(char const* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<bool(*)(decltype(this), char const*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133210))(this, p0, p1);
    }

    bool initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x133270))(this, p0);
    }

    bool initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1330f0))(this, p0, p1);
    }

    bool initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(getBase()+0x132f10))(this, p0, p1, p2);
    }

    void isDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x505b0))(this);
    }

    void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x1356d0))(this, p0);
    }

    void isOpacityModifyRGB() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135350))(this);
    }

    void refreshTextureRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x133520))(this);
    }

    void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134340))(this, p0);
    }

    void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x134300))(this, p0, p1);
    }

    void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x134270))(this, p0, p1);
    }

    void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134af0))(this, p0);
    }

    void setBatchNode(cocos2d::CCSpriteBatchNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteBatchNode*)>(m->getOriginal(getBase()+0x135920))(this, p0);
    }

    void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x50590))(this, p0);
    }

    void setChildOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x134f50))(this, p0);
    }

    void setDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x505c0))(this, p0);
    }

    void setDirtyRecursively(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1345b0))(this, p0);
    }

    void setDisplayFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x135610))(this, p0);
    }

    void setDisplayFrameWithAnimationName(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x135680))(this, p0, p1);
    }

    void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134c30))(this, p0);
    }

    void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x135200))(this, p0);
    }

    void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134650))(this, p0);
    }

    void setReorderChildDirtyRecursively() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x134550))(this);
    }

    void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134740))(this, p0);
    }

    void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1347b0))(this, p0);
    }

    void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134820))(this, p0);
    }

    void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134890))(this, p0);
    }

    void setTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x135a90))(this, p0);
    }

    void setTextureCoords(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133910))(this, p0);
    }

    void setTextureRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133560))(this, p0);
    }

    void setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&, bool, cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x133580))(this, p0, p1, p2);
    }

    void setVertexRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1338f0))(this, p0);
    }

    void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134a80))(this, p0);
    }

    void sortAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1343f0))(this);
    }

    void updateBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135a20))(this);
    }

    void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x135370))(this, p0);
    }

    void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x1354c0))(this, p0);
    }

    void updateTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x133b70))(this);
    }

    void apply_hooks() override {
        if ((void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild} != (void(D::*)(cocos2d::CCNode*)){&D::addChild})
            m->registerHook(getBase()+0x134190, extract((void(D::*)(cocos2d::CCNode*)){&D::addChild}));

        if ((void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild} != (void(D::*)(cocos2d::CCNode*, int)){&D::addChild})
            m->registerHook(getBase()+0x1341a0, extract((void(D::*)(cocos2d::CCNode*, int)){&D::addChild}));

        if ((void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild} != (void(D::*)(cocos2d::CCNode*, int, int)){&D::addChild})
            m->registerHook(getBase()+0x1341b0, extract((void(D::*)(cocos2d::CCNode*, int, int)){&D::addChild}));

        if ((CCSprite*(*)()){&$CCSprite::create} != (CCSprite*(*)()){&D::create})
            m->registerHook(getBase()+0x132df0, (CCSprite*(*)()){&D::create});

        if ((CCSprite*(*)(char const*)){&$CCSprite::create} != (CCSprite*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x132a80, (CCSprite*(*)(char const*)){&D::create});

        if ((CCSprite*(*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame} != (CCSprite*(*)(cocos2d::CCSpriteFrame*)){&D::createWithSpriteFrame})
            m->registerHook(getBase()+0x132cb0, (CCSprite*(*)(cocos2d::CCSpriteFrame*)){&D::createWithSpriteFrame});

        if ((CCSprite*(*)(char const*)){&$CCSprite::createWithSpriteFrameName} != (CCSprite*(*)(char const*)){&D::createWithSpriteFrameName})
            m->registerHook(getBase()+0x132dc0, (CCSprite*(*)(char const*)){&D::createWithSpriteFrameName});

        if ((void($CCSprite::*)()){&$CCSprite::displayFrame} != (void(D::*)()){&D::displayFrame})
            m->registerHook(getBase()+0x135760, extract((void(D::*)()){&D::displayFrame}));

        if ((void($CCSprite::*)()){&$CCSprite::draw} != (void(D::*)()){&D::draw})
            m->registerHook(getBase()+0x134070, extract((void(D::*)()){&D::draw}));

        if ((void($CCSprite::*)()){&$CCSprite::getBatchNode} != (void(D::*)()){&D::getBatchNode})
            m->registerHook(getBase()+0x135910, extract((void(D::*)()){&D::getBatchNode}));

        if ((void($CCSprite::*)()){&$CCSprite::getBlendFunc} != (void(D::*)()){&D::getBlendFunc})
            m->registerHook(getBase()+0x505a0, extract((void(D::*)()){&D::getBlendFunc}));

        if ((void($CCSprite::*)()){&$CCSprite::getTexture} != (void(D::*)()){&D::getTexture})
            m->registerHook(getBase()+0x135c00, extract((void(D::*)()){&D::getTexture}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition} != (void(D::*)(bool)){&D::ignoreAnchorPointForPosition})
            m->registerHook(getBase()+0x134b60, extract((void(D::*)(bool)){&D::ignoreAnchorPointForPosition}));

        if ((bool($CCSprite::*)(char const*)){&$CCSprite::initWithFile} != (bool(D::*)(char const*)){&D::initWithFile})
            m->registerHook(getBase()+0x133180, extract((bool(D::*)(char const*)){&D::initWithFile}));

        if ((bool($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile} != (bool(D::*)(char const*, cocos2d::CCRect const&)){&D::initWithFile})
            m->registerHook(getBase()+0x133210, extract((bool(D::*)(char const*, cocos2d::CCRect const&)){&D::initWithFile}));

        if ((bool($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame} != (bool(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame})
            m->registerHook(getBase()+0x133270, extract((bool(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame}));

        if ((bool($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture})
            m->registerHook(getBase()+0x1330f0, extract((bool(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture}));

        if ((bool($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture})
            m->registerHook(getBase()+0x132f10, extract((bool(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture}));

        if ((void($CCSprite::*)()){&$CCSprite::isDirty} != (void(D::*)()){&D::isDirty})
            m->registerHook(getBase()+0x505b0, extract((void(D::*)()){&D::isDirty}));

        if ((void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed})
            m->registerHook(getBase()+0x1356d0, extract((void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed}));

        if ((void($CCSprite::*)()){&$CCSprite::isOpacityModifyRGB} != (void(D::*)()){&D::isOpacityModifyRGB})
            m->registerHook(getBase()+0x135350, extract((void(D::*)()){&D::isOpacityModifyRGB}));

        if ((void($CCSprite::*)()){&$CCSprite::refreshTextureRect} != (void(D::*)()){&D::refreshTextureRect})
            m->registerHook(getBase()+0x133520, extract((void(D::*)()){&D::refreshTextureRect}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup} != (void(D::*)(bool)){&D::removeAllChildrenWithCleanup})
            m->registerHook(getBase()+0x134340, extract((void(D::*)(bool)){&D::removeAllChildrenWithCleanup}));

        if ((void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild} != (void(D::*)(cocos2d::CCNode*, bool)){&D::removeChild})
            m->registerHook(getBase()+0x134300, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::removeChild}));

        if ((void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild} != (void(D::*)(cocos2d::CCNode*, int)){&D::reorderChild})
            m->registerHook(getBase()+0x134270, extract((void(D::*)(cocos2d::CCNode*, int)){&D::reorderChild}));

        if ((void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint} != (void(D::*)(cocos2d::CCPoint const&)){&D::setAnchorPoint})
            m->registerHook(getBase()+0x134af0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setAnchorPoint}));

        if ((void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode} != (void(D::*)(cocos2d::CCSpriteBatchNode*)){&D::setBatchNode})
            m->registerHook(getBase()+0x135920, extract((void(D::*)(cocos2d::CCSpriteBatchNode*)){&D::setBatchNode}));

        if ((void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            m->registerHook(getBase()+0x50590, extract((void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc}));

        if ((void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity} != (void(D::*)(unsigned char)){&D::setChildOpacity})
            m->registerHook(getBase()+0x134f50, extract((void(D::*)(unsigned char)){&D::setChildOpacity}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::setDirty} != (void(D::*)(bool)){&D::setDirty})
            m->registerHook(getBase()+0x505c0, extract((void(D::*)(bool)){&D::setDirty}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively} != (void(D::*)(bool)){&D::setDirtyRecursively})
            m->registerHook(getBase()+0x1345b0, extract((void(D::*)(bool)){&D::setDirtyRecursively}));

        if ((void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame})
            m->registerHook(getBase()+0x135610, extract((void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame}));

        if ((void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName} != (void(D::*)(char const*, int)){&D::setDisplayFrameWithAnimationName})
            m->registerHook(getBase()+0x135680, extract((void(D::*)(char const*, int)){&D::setDisplayFrameWithAnimationName}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(getBase()+0x134c30, extract((void(D::*)(bool)){&D::setFlipY}));

        if ((void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB} != (void(D::*)(bool)){&D::setOpacityModifyRGB})
            m->registerHook(getBase()+0x135200, extract((void(D::*)(bool)){&D::setOpacityModifyRGB}));

        if ((void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(getBase()+0x134650, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCSprite::*)()){&$CCSprite::setReorderChildDirtyRecursively} != (void(D::*)()){&D::setReorderChildDirtyRecursively})
            m->registerHook(getBase()+0x134550, extract((void(D::*)()){&D::setReorderChildDirtyRecursively}));

        if ((void($CCSprite::*)(float)){&$CCSprite::setRotationX} != (void(D::*)(float)){&D::setRotationX})
            m->registerHook(getBase()+0x134740, extract((void(D::*)(float)){&D::setRotationX}));

        if ((void($CCSprite::*)(float)){&$CCSprite::setRotationY} != (void(D::*)(float)){&D::setRotationY})
            m->registerHook(getBase()+0x1347b0, extract((void(D::*)(float)){&D::setRotationY}));

        if ((void($CCSprite::*)(float)){&$CCSprite::setSkewX} != (void(D::*)(float)){&D::setSkewX})
            m->registerHook(getBase()+0x134820, extract((void(D::*)(float)){&D::setSkewX}));

        if ((void($CCSprite::*)(float)){&$CCSprite::setSkewY} != (void(D::*)(float)){&D::setSkewY})
            m->registerHook(getBase()+0x134890, extract((void(D::*)(float)){&D::setSkewY}));

        if ((void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::setTexture})
            m->registerHook(getBase()+0x135a90, extract((void(D::*)(cocos2d::CCTexture2D*)){&D::setTexture}));

        if ((void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords} != (void(D::*)(cocos2d::CCRect const&)){&D::setTextureCoords})
            m->registerHook(getBase()+0x133910, extract((void(D::*)(cocos2d::CCRect const&)){&D::setTextureCoords}));

        if ((void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect} != (void(D::*)(cocos2d::CCRect const&)){&D::setTextureRect})
            m->registerHook(getBase()+0x133560, extract((void(D::*)(cocos2d::CCRect const&)){&D::setTextureRect}));

        if ((void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect} != (void(D::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&D::setTextureRect})
            m->registerHook(getBase()+0x133580, extract((void(D::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&D::setTextureRect}));

        if ((void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect} != (void(D::*)(cocos2d::CCRect const&)){&D::setVertexRect})
            m->registerHook(getBase()+0x1338f0, extract((void(D::*)(cocos2d::CCRect const&)){&D::setVertexRect}));

        if ((void($CCSprite::*)(float)){&$CCSprite::setVertexZ} != (void(D::*)(float)){&D::setVertexZ})
            m->registerHook(getBase()+0x134a80, extract((void(D::*)(float)){&D::setVertexZ}));

        if ((void($CCSprite::*)()){&$CCSprite::sortAllChildren} != (void(D::*)()){&D::sortAllChildren})
            m->registerHook(getBase()+0x1343f0, extract((void(D::*)()){&D::sortAllChildren}));

        if ((void($CCSprite::*)()){&$CCSprite::updateBlendFunc} != (void(D::*)()){&D::updateBlendFunc})
            m->registerHook(getBase()+0x135a20, extract((void(D::*)()){&D::updateBlendFunc}));

        if ((void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::updateDisplayedColor})
            m->registerHook(getBase()+0x135370, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::updateDisplayedColor}));

        if ((void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity} != (void(D::*)(unsigned char)){&D::updateDisplayedOpacity})
            m->registerHook(getBase()+0x1354c0, extract((void(D::*)(unsigned char)){&D::updateDisplayedOpacity}));

        if ((void($CCSprite::*)()){&$CCSprite::updateTransform} != (void(D::*)()){&D::updateTransform})
            m->registerHook(getBase()+0x133b70, extract((void(D::*)()){&D::updateTransform}));
    }
};


template<class D>
class $CCSpriteBatchNode : public CCSpriteBatchNode, public $CacBase {
 public:
    $CCSpriteBatchNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpriteBatchNode* __thistype;

    static CCSpriteBatchNode* createWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) {
        return reinterpret_cast<CCSpriteBatchNode*(*)(cocos2d::CCTexture2D*, unsigned int)>(m->getOriginal(getBase()+0xbb310))(p0, p1);
    }

    void getUsedAtlasCapacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xbc6b0))(this);
    }

    void increaseAtlasCapacity(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0xbc670))(this, p0);
    }

    void apply_hooks() override {
        if ((CCSpriteBatchNode*(*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture} != (CCSpriteBatchNode*(*)(cocos2d::CCTexture2D*, unsigned int)){&D::createWithTexture})
            m->registerHook(getBase()+0xbb310, (CCSpriteBatchNode*(*)(cocos2d::CCTexture2D*, unsigned int)){&D::createWithTexture});

        if ((void($CCSpriteBatchNode::*)()){&$CCSpriteBatchNode::getUsedAtlasCapacity} != (void(D::*)()){&D::getUsedAtlasCapacity})
            m->registerHook(getBase()+0xbc6b0, extract((void(D::*)()){&D::getUsedAtlasCapacity}));

        if ((void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity} != (void(D::*)(unsigned int)){&D::increaseAtlasCapacity})
            m->registerHook(getBase()+0xbc670, extract((void(D::*)(unsigned int)){&D::increaseAtlasCapacity}));
    }
};


template<class D>
class $CCSpriteFrameCache : public CCSpriteFrameCache, public $CacBase {
 public:
    $CCSpriteFrameCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCSpriteFrameCache* __thistype;

    void addSpriteFramesWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x199a10))(this, p0);
    }

    void sharedSpriteFrameCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x198970))(this);
    }

    void spriteFrameByName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x19a7e0))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile} != (void(D::*)(char const*)){&D::addSpriteFramesWithFile})
            m->registerHook(getBase()+0x199a10, extract((void(D::*)(char const*)){&D::addSpriteFramesWithFile}));

        if ((void($CCSpriteFrameCache::*)()){&$CCSpriteFrameCache::sharedSpriteFrameCache} != (void(D::*)()){&D::sharedSpriteFrameCache})
            m->registerHook(getBase()+0x198970, extract((void(D::*)()){&D::sharedSpriteFrameCache}));

        if ((void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName} != (void(D::*)(char const*)){&D::spriteFrameByName})
            m->registerHook(getBase()+0x19a7e0, extract((void(D::*)(char const*)){&D::spriteFrameByName}));
    }
};


template<class D>
class $CCString : public CCString, public $CacBase {
 public:
    $CCString() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCString* __thistype;

    void boolValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c810))(this);
    }

    void doubleValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c7f0))(this);
    }

    void floatValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c7d0))(this);
    }

    void getCString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c470))(this);
    }

    void intValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c780))(this);
    }

    void apply_hooks() override {
        if ((void($CCString::*)()){&$CCString::boolValue} != (void(D::*)()){&D::boolValue})
            m->registerHook(getBase()+0x44c810, extract((void(D::*)()){&D::boolValue}));

        if ((void($CCString::*)()){&$CCString::doubleValue} != (void(D::*)()){&D::doubleValue})
            m->registerHook(getBase()+0x44c7f0, extract((void(D::*)()){&D::doubleValue}));

        if ((void($CCString::*)()){&$CCString::floatValue} != (void(D::*)()){&D::floatValue})
            m->registerHook(getBase()+0x44c7d0, extract((void(D::*)()){&D::floatValue}));

        if ((void($CCString::*)()){&$CCString::getCString} != (void(D::*)()){&D::getCString})
            m->registerHook(getBase()+0x44c470, extract((void(D::*)()){&D::getCString}));

        if ((void($CCString::*)()){&$CCString::intValue} != (void(D::*)()){&D::intValue})
            m->registerHook(getBase()+0x44c780, extract((void(D::*)()){&D::intValue}));
    }
};


template<class D>
class $CCTexture2D : public CCTexture2D, public $CacBase {
 public:
    $CCTexture2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTexture2D* __thistype;

    bool initWithImage(cocos2d::CCImage* p0) {
        return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCImage*)>(m->getOriginal(getBase()+0x246940))(this, p0);
    }

    void setTexParameters(cocos2d::_ccTexParams* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccTexParams*)>(m->getOriginal(getBase()+0x247980))(this, p0);
    }

    void apply_hooks() override {
        if ((bool($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage} != (bool(D::*)(cocos2d::CCImage*)){&D::initWithImage})
            m->registerHook(getBase()+0x246940, extract((bool(D::*)(cocos2d::CCImage*)){&D::initWithImage}));

        if ((void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters} != (void(D::*)(cocos2d::_ccTexParams*)){&D::setTexParameters})
            m->registerHook(getBase()+0x247980, extract((void(D::*)(cocos2d::_ccTexParams*)){&D::setTexParameters}));
    }
};


template<class D>
class $CCTextureCache : public CCTextureCache, public $CacBase {
 public:
    $CCTextureCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTextureCache* __thistype;

    void addImage(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x358120))(this, p0, p1);
    }

    void sharedTextureCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356e00))(this);
    }

    void apply_hooks() override {
        if ((void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage} != (void(D::*)(char const*, bool)){&D::addImage})
            m->registerHook(getBase()+0x358120, extract((void(D::*)(char const*, bool)){&D::addImage}));

        if ((void($CCTextureCache::*)()){&$CCTextureCache::sharedTextureCache} != (void(D::*)()){&D::sharedTextureCache})
            m->registerHook(getBase()+0x356e00, extract((void(D::*)()){&D::sharedTextureCache}));
    }
};


template<class D>
class $CCTintTo : public CCTintTo, public $CacBase {
 public:
    $CCTintTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTintTo* __thistype;

    static CCTintTo* create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) {
        return reinterpret_cast<CCTintTo*(*)(float, unsigned char, unsigned char, unsigned char)>(m->getOriginal(getBase()+0x1f82a0))(p0, p1, p2, p3);
    }

    void apply_hooks() override {
        if ((CCTintTo*(*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create} != (CCTintTo*(*)(float, unsigned char, unsigned char, unsigned char)){&D::create})
            m->registerHook(getBase()+0x1f82a0, (CCTintTo*(*)(float, unsigned char, unsigned char, unsigned char)){&D::create});
    }
};


template<class D>
class $CCTouchDispatcher : public CCTouchDispatcher, public $CacBase {
 public:
    $CCTouchDispatcher() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTouchDispatcher* __thistype;

    void decrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f70))(this, p0);
    }

    void incrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f60))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio} != (void(D::*)(int)){&D::decrementForcePrio})
            m->registerHook(getBase()+0x280f70, extract((void(D::*)(int)){&D::decrementForcePrio}));

        if ((void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio} != (void(D::*)(int)){&D::incrementForcePrio})
            m->registerHook(getBase()+0x280f60, extract((void(D::*)(int)){&D::incrementForcePrio}));
    }
};


template<class D>
class $CCTransitionFade : public CCTransitionFade, public $CacBase {
 public:
    $CCTransitionFade() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTransitionFade* __thistype;

    static CCTransitionFade* create(float p0, cocos2d::CCScene* p1) {
        return reinterpret_cast<CCTransitionFade*(*)(float, cocos2d::CCScene*)>(m->getOriginal(getBase()+0x8ea30))(p0, p1);
    }

    void apply_hooks() override {
        if ((CCTransitionFade*(*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create} != (CCTransitionFade*(*)(float, cocos2d::CCScene*)){&D::create})
            m->registerHook(getBase()+0x8ea30, (CCTransitionFade*(*)(float, cocos2d::CCScene*)){&D::create});
    }
};


template<class D>
class $ZipUtils : public ZipUtils, public $CacBase {
 public:
    $ZipUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ZipUtils* __thistype;

    void compressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xe9a50))(this, p0, p1, p2);
    }

    void decompressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xea380))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        if ((void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::compressString} != (void(D::*)(std::string, bool, int)){&D::compressString})
            m->registerHook(getBase()+0xe9a50, extract((void(D::*)(std::string, bool, int)){&D::compressString}));

        if ((void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString} != (void(D::*)(std::string, bool, int)){&D::decompressString})
            m->registerHook(getBase()+0xea380, extract((void(D::*)(std::string, bool, int)){&D::decompressString}));
    }
};


template<class D>
class $CCControlColourPicker : public CCControlColourPicker, public $CacBase {
 public:
    $CCControlColourPicker() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCControlColourPicker* __thistype;

    void setColorValue(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1aac10))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColorValue})
            m->registerHook(getBase()+0x1aac10, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColorValue}));
    }
};


template<class D>
class $CCControlUtils : public CCControlUtils, public $CacBase {
 public:
    $CCControlUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCControlUtils* __thistype;

    void HSVfromRGB(cocos2d::extension::RGBA p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::RGBA)>(m->getOriginal(getBase()+0x1e6750))(this, p0);
    }

    void RGBfromHSV(cocos2d::extension::HSV p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::HSV)>(m->getOriginal(getBase()+0x1e6850))(this, p0);
    }

    void apply_hooks() override {
        if ((void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB} != (void(D::*)(cocos2d::extension::RGBA)){&D::HSVfromRGB})
            m->registerHook(getBase()+0x1e6750, extract((void(D::*)(cocos2d::extension::RGBA)){&D::HSVfromRGB}));

        if ((void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV} != (void(D::*)(cocos2d::extension::HSV)){&D::RGBfromHSV})
            m->registerHook(getBase()+0x1e6850, extract((void(D::*)(cocos2d::extension::HSV)){&D::RGBfromHSV}));
    }
};


template<class D>
class $CCScale9Sprite : public CCScale9Sprite, public $CacBase {
 public:
    $CCScale9Sprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCScale9Sprite* __thistype;

    static CCScale9Sprite* create(char const* p0) {
        return reinterpret_cast<CCScale9Sprite*(*)(char const*)>(m->getOriginal(getBase()+0x2130d0))(p0);
    }

    static CCScale9Sprite* create(char const* p0, cocos2d::CCRect p1) {
        return reinterpret_cast<CCScale9Sprite*(*)(char const*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x212ef0))(p0, p1);
    }

    void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2127c0))(this, p0);
    }

    void apply_hooks() override {
        if ((CCScale9Sprite*(*)(char const*)){&$CCScale9Sprite::create} != (CCScale9Sprite*(*)(char const*)){&D::create})
            m->registerHook(getBase()+0x2130d0, (CCScale9Sprite*(*)(char const*)){&D::create});

        if ((CCScale9Sprite*(*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create} != (CCScale9Sprite*(*)(char const*, cocos2d::CCRect)){&D::create})
            m->registerHook(getBase()+0x212ef0, (CCScale9Sprite*(*)(char const*, cocos2d::CCRect)){&D::create});

        if ((void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize} != (void(D::*)(cocos2d::CCSize const&)){&D::setContentSize})
            m->registerHook(getBase()+0x2127c0, extract((void(D::*)(cocos2d::CCSize const&)){&D::setContentSize}));
    }
};
