//Copyright camila314 & alk1m123 2021. Autogenerated using a python script
#pragma once // but if u want it to be more crossplatform. u need to use c standard.

#ifdef __APPLE__
#include <platform/macos/CacKitUtil.hpp>
#endif

#include <Cacao.hpp>


template<class D>
class $ArtistCell : public ArtistCell, public $CacBase {
public:
    dupable ~$ArtistCell() override {}

    dupable bool init() {
        if ((bool($ArtistCell::*)()){&$ArtistCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c7c0))(this);
        else return ArtistCell::init();
    }

    dupable void draw() {
        if ((void($ArtistCell::*)()){&$ArtistCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c980))(this);
        else return ArtistCell::draw();
    }

    dupable $ArtistCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ArtistCell::*)()){&$ArtistCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c7c0, extract((bool(D::*)()){&D::init}));

        if ((void($ArtistCell::*)()){&$ArtistCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c980, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $GJItemIcon : public GJItemIcon, public $CacBase {
public:
    dupable ~$GJItemIcon() override {}

    dupable void setOpacity(unsigned char p0) {
        if ((void($GJItemIcon::*)(unsigned char)){&$GJItemIcon::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1bd9d0))(this, p0);
        else return GJItemIcon::setOpacity(p0);
    }

    dupable $GJItemIcon() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJItemIcon::*)(unsigned char)){&$GJItemIcon::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1bd9d0, extract((void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $GJUserCell : public GJUserCell, public $CacBase {
public:
    dupable ~$GJUserCell() override {}

    dupable bool init() {
        if ((bool($GJUserCell::*)()){&$GJUserCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11e180))(this);
        else return GJUserCell::init();
    }

    dupable void draw() {
        if ((void($GJUserCell::*)()){&$GJUserCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11e790))(this);
        else return GJUserCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJUserCell::*)(FLAlertLayer*, bool)){&$GJUserCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11e860))(this, p0, p1);
        else return GJUserCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11eae0))(this, p0, p1);
        else return GJUserCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11ecb0))(this, p0, p1);
        else return GJUserCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($GJUserCell::*)(UploadActionPopup*)){&$GJUserCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x11edb0))(this, p0);
        else return GJUserCell::onClosePopup(p0);
    }

    dupable $GJUserCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserCell::*)()){&$GJUserCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11e180, extract((bool(D::*)()){&D::init}));

        if ((void($GJUserCell::*)()){&$GJUserCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11e790, extract((void(D::*)()){&D::draw}));

        if ((void($GJUserCell::*)(FLAlertLayer*, bool)){&$GJUserCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11e860, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x11eae0, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x11ecb0, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJUserCell::*)(UploadActionPopup*)){&$GJUserCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x11edb0, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GameObject : public GameObject, public $CacBase {
public:
    dupable ~$GameObject() override {}

    dupable void update(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2fbb90))(this, p0);
        else return GameObject::update(p0);
    }

    dupable void setScaleX(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335b00))(this, p0);
        else return GameObject::setScaleX(p0);
    }

    dupable void setScaleY(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335b90))(this, p0);
        else return GameObject::setScaleY(p0);
    }

    dupable void setScale(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335c20))(this, p0);
        else return GameObject::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x335850))(this, p0);
        else return GameObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x336280))(this, p0);
        else return GameObject::setVisible(p0);
    }

    dupable void setRotation(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335970))(this, p0);
        else return GameObject::setRotation(p0);
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($GameObject::*)(unsigned char)){&$GameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x335f10))(this, p0);
        else return GameObject::setOpacity(p0);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0) {
        if ((void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x2f56a0))(this, p0);
        else return GameObject::initWithTexture(p0);
    }

    dupable void setChildColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341f20))(this, p0);
        else return GameObject::setChildColor(p0);
    }

    dupable void setFlipX(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x335a60))(this, p0);
        else return GameObject::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x335ab0))(this, p0);
        else return GameObject::setFlipY(p0);
    }

    dupable void customSetup() {
        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fbba0))(this);
        else return GameObject::customSetup();
    }

    dupable void setupCustomSprites() {
        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x307f60))(this);
        else return GameObject::setupCustomSprites();
    }

    dupable void addMainSpriteToParent(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x33a5b0))(this, p0);
        else return GameObject::addMainSpriteToParent(p0);
    }

    dupable void resetObject() {
        if ((void($GameObject::*)()){&$GameObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fa620))(this);
        else return GameObject::resetObject();
    }

    dupable void triggerObject(GJBaseGameLayer* p0) {
        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0x2fa8f0))(this, p0);
        else return GameObject::triggerObject(p0);
    }

    dupable void activateObject() {
        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2faf60))(this);
        else return GameObject::activateObject();
    }

    dupable void deactivateObject(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2fb8f0))(this, p0);
        else return GameObject::deactivateObject(p0);
    }

    dupable void getObjectRect() {
        if ((void($GameObject::*)()){&$GameObject::getObjectRect} != (void(D::*)()){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3352b0))(this);
        else return GameObject::getObjectRect();
    }

    dupable void getObjectRect(float p0, float p1) {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x3352d0))(this, p0, p1);
        else return GameObject::getObjectRect(p0, p1);
    }

    dupable void getObjectRect2(float p0, float p1) {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x3354e0))(this, p0, p1);
        else return GameObject::getObjectRect2(p0, p1);
    }

    dupable void getObjectTextureRect() {
        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3355b0))(this);
        else return GameObject::getObjectTextureRect();
    }

    dupable void getRealPosition() {
        if ((void($GameObject::*)()){&$GameObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335750))(this);
        else return GameObject::getRealPosition();
    }

    dupable void setStartPos(cocos2d::CCPoint p0) {
        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x2fa520))(this, p0);
        else return GameObject::setStartPos(p0);
    }

    dupable void updateStartValues() {
        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fa800))(this);
        else return GameObject::updateStartValues();
    }

    dupable void getSaveString() {
        if ((void($GameObject::*)()){&$GameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x33d3d0))(this);
        else return GameObject::getSaveString();
    }

    dupable void isFlipX() {
        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335a40))(this);
        else return GameObject::isFlipX();
    }

    dupable void isFlipY() {
        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335a50))(this);
        else return GameObject::isFlipY();
    }

    dupable void setRScaleX(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335cb0))(this, p0);
        else return GameObject::setRScaleX(p0);
    }

    dupable void setRScaleY(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335d60))(this, p0);
        else return GameObject::setRScaleY(p0);
    }

    dupable void setRScale(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335e10))(this, p0);
        else return GameObject::setRScale(p0);
    }

    dupable void getRScaleX() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335e50))(this);
        else return GameObject::getRScaleX();
    }

    dupable void getRScaleY() {
        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335e80))(this);
        else return GameObject::getRScaleY();
    }

    dupable void calculateSpawnXPos() {
        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x336970))(this);
        else return GameObject::calculateSpawnXPos();
    }

    dupable void triggerActivated(float p0) {
        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x336990))(this, p0);
        else return GameObject::triggerActivated(p0);
    }

    dupable void powerOnObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3369a0))(this);
        else return GameObject::powerOnObject();
    }

    dupable void powerOffObject() {
        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3369c0))(this);
        else return GameObject::powerOffObject();
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341c90))(this, p0);
        else return GameObject::setObjectColor(p0);
    }

    dupable void setGlowColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341ed0))(this, p0);
        else return GameObject::setGlowColor(p0);
    }

    dupable void getOrientedBox() {
        if ((void($GameObject::*)()){&$GameObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x342ad0))(this);
        else return GameObject::getOrientedBox();
    }

    dupable void addToGroup(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x33ad00))(this, p0);
        else return GameObject::addToGroup(p0);
    }

    dupable void removeFromGroup(int p0) {
        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x33ada0))(this, p0);
        else return GameObject::removeFromGroup(p0);
    }

    dupable void spawnXPosition() {
        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1b0))(this);
        else return GameObject::spawnXPosition();
    }

    dupable void getObjectRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1d0))(this);
        else return GameObject::getObjectRectDirty();
    }

    dupable void setObjectRectDirty(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdc1e0))(this, p0);
        else return GameObject::setObjectRectDirty(p0);
    }

    dupable void getOrientedRectDirty() {
        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1f0))(this);
        else return GameObject::getOrientedRectDirty();
    }

    dupable void setOrientedRectDirty(bool p0) {
        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdc200))(this, p0);
        else return GameObject::setOrientedRectDirty(p0);
    }

    dupable void getType() {
        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc210))(this);
        else return GameObject::getType();
    }

    dupable void setType(GameObjectType p0) {
        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(base+0xdc220))(this, p0);
        else return GameObject::setType(p0);
    }

    dupable void getStartPos() {
        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc230))(this);
        else return GameObject::getStartPos();
    }

    dupable $GameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GameObject::*)(float)){&$GameObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x2fbb90, extract((void(D::*)(float)){&D::update}));

        if ((void($GameObject::*)(float)){&$GameObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x335b00, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x335b90, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($GameObject::*)(float)){&$GameObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x335c20, extract((void(D::*)(float)){&D::setScale}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x335850, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($GameObject::*)(bool)){&$GameObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x336280, extract((void(D::*)(bool)){&D::setVisible}));

        if ((void($GameObject::*)(float)){&$GameObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x335970, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($GameObject::*)(unsigned char)){&$GameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x335f10, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x2f56a0, extract((void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            m->registerHook(base+0x341f20, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor}));

        if ((void($GameObject::*)(bool)){&$GameObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x335a60, extract((void(D::*)(bool)){&D::setFlipX}));

        if ((void($GameObject::*)(bool)){&$GameObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x335ab0, extract((void(D::*)(bool)){&D::setFlipY}));

        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x2fbba0, extract((void(D::*)()){&D::customSetup}));

        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(base+0x307f60, extract((void(D::*)()){&D::setupCustomSprites}));

        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(base+0x33a5b0, extract((void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($GameObject::*)()){&$GameObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0x2fa620, extract((void(D::*)()){&D::resetObject}));

        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0x2fa8f0, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(base+0x2faf60, extract((void(D::*)()){&D::activateObject}));

        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(base+0x2fb8f0, extract((void(D::*)(bool)){&D::deactivateObject}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRect} != (void(D::*)()){&D::getObjectRect})
            m->registerHook(base+0x3352b0, extract((void(D::*)()){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            m->registerHook(base+0x3352d0, extract((void(D::*)(float, float)){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            m->registerHook(base+0x3354e0, extract((void(D::*)(float, float)){&D::getObjectRect2}));

        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            m->registerHook(base+0x3355b0, extract((void(D::*)()){&D::getObjectTextureRect}));

        if ((void($GameObject::*)()){&$GameObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(base+0x335750, extract((void(D::*)()){&D::getRealPosition}));

        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(base+0x2fa520, extract((void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            m->registerHook(base+0x2fa800, extract((void(D::*)()){&D::updateStartValues}));

        if ((void($GameObject::*)()){&$GameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0x33d3d0, extract((void(D::*)()){&D::getSaveString}));

        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            m->registerHook(base+0x335a40, extract((void(D::*)()){&D::isFlipX}));

        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            m->registerHook(base+0x335a50, extract((void(D::*)()){&D::isFlipY}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            m->registerHook(base+0x335cb0, extract((void(D::*)(float)){&D::setRScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            m->registerHook(base+0x335d60, extract((void(D::*)(float)){&D::setRScaleY}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(base+0x335e10, extract((void(D::*)(float)){&D::setRScale}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            m->registerHook(base+0x335e50, extract((void(D::*)()){&D::getRScaleX}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            m->registerHook(base+0x335e80, extract((void(D::*)()){&D::getRScaleY}));

        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(base+0x336970, extract((void(D::*)()){&D::calculateSpawnXPos}));

        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0x336990, extract((void(D::*)(float)){&D::triggerActivated}));

        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(base+0x3369a0, extract((void(D::*)()){&D::powerOnObject}));

        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(base+0x3369c0, extract((void(D::*)()){&D::powerOffObject}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0x341c90, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            m->registerHook(base+0x341ed0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(base+0x342ad0, extract((void(D::*)()){&D::getOrientedBox}));

        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(base+0x33ad00, extract((void(D::*)(int)){&D::addToGroup}));

        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(base+0x33ada0, extract((void(D::*)(int)){&D::removeFromGroup}));

        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(base+0xdc1b0, extract((void(D::*)()){&D::spawnXPosition}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            m->registerHook(base+0xdc1d0, extract((void(D::*)()){&D::getObjectRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            m->registerHook(base+0xdc1e0, extract((void(D::*)(bool)){&D::setObjectRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            m->registerHook(base+0xdc1f0, extract((void(D::*)()){&D::getOrientedRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            m->registerHook(base+0xdc200, extract((void(D::*)(bool)){&D::setOrientedRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            m->registerHook(base+0xdc210, extract((void(D::*)()){&D::getType}));

        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            m->registerHook(base+0xdc220, extract((void(D::*)(GameObjectType)){&D::setType}));

        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            m->registerHook(base+0xdc230, extract((void(D::*)()){&D::getStartPos}));
    }
};


template<class D>
class $GaragePage : public GaragePage, public $CacBase {
public:
    dupable ~$GaragePage() override {}

    dupable void listButtonBarSwitchedPage(ListButtonBar* p0, int p1) {
        if ((void($GaragePage::*)(ListButtonBar*, int)){&$GaragePage::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            return reinterpret_cast<void(*)(decltype(this), ListButtonBar*, int)>(m->getOriginal(base+0x1bc2f0))(this, p0, p1);
        else return GaragePage::listButtonBarSwitchedPage(p0, p1);
    }

    dupable $GaragePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GaragePage::*)(ListButtonBar*, int)){&$GaragePage::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            m->registerHook(base+0x1bc2f0, extract((void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage}));
    }
};


template<class D>
class $HardStreak : public HardStreak, public $CacBase {
public:
    dupable ~$HardStreak() override {}

    dupable bool init() {
        if ((bool($HardStreak::*)()){&$HardStreak::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x5c090))(this);
        else return HardStreak::init();
    }

    dupable $HardStreak() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($HardStreak::*)()){&$HardStreak::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x5c090, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $PauseLayer : public PauseLayer, public $CacBase {
public:
    dupable ~$PauseLayer() override {}

    dupable void keyBackClicked() {
        if ((void($PauseLayer::*)()){&$PauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20cd80))(this);
        else return PauseLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x20cc80))(this, p0);
        else return PauseLayer::keyDown(p0);
    }

    dupable void customSetup() {
        if ((void($PauseLayer::*)()){&$PauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20b300))(this);
        else return PauseLayer::customSetup();
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) {
        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x20cd60))(this, p0);
        else return PauseLayer::keyUp(p0);
    }

    dupable $PauseLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PauseLayer::*)()){&$PauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20cd80, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x20cc80, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($PauseLayer::*)()){&$PauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x20b300, extract((void(D::*)()){&D::customSetup}));

        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x20cd60, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $RingObject : public RingObject, public $CacBase {
public:
    dupable ~$RingObject() override {}

    dupable void setScale(float p0) {
        if ((void($RingObject::*)(float)){&$RingObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6fb0))(this, p0);
        else return RingObject::setScale(p0);
    }

    dupable void setRotation(float p0) {
        if ((void($RingObject::*)(float)){&$RingObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc7010))(this, p0);
        else return RingObject::setRotation(p0);
    }

    dupable void resetObject() {
        if ((void($RingObject::*)()){&$RingObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6f90))(this);
        else return RingObject::resetObject();
    }

    dupable void getSaveString() {
        if ((void($RingObject::*)()){&$RingObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc73a0))(this);
        else return RingObject::getSaveString();
    }

    dupable void setRScale(float p0) {
        if ((void($RingObject::*)(float)){&$RingObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6fe0))(this, p0);
        else return RingObject::setRScale(p0);
    }

    dupable void triggerActivated(float p0) {
        if ((void($RingObject::*)(float)){&$RingObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6e10))(this, p0);
        else return RingObject::triggerActivated(p0);
    }

    dupable void powerOnObject() {
        if ((void($RingObject::*)()){&$RingObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6e20))(this);
        else return RingObject::powerOnObject();
    }

    dupable void powerOffObject() {
        if ((void($RingObject::*)()){&$RingObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6f70))(this);
        else return RingObject::powerOffObject();
    }

    dupable $RingObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RingObject::*)(float)){&$RingObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0xc6fb0, extract((void(D::*)(float)){&D::setScale}));

        if ((void($RingObject::*)(float)){&$RingObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0xc7010, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($RingObject::*)()){&$RingObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0xc6f90, extract((void(D::*)()){&D::resetObject}));

        if ((void($RingObject::*)()){&$RingObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xc73a0, extract((void(D::*)()){&D::getSaveString}));

        if ((void($RingObject::*)(float)){&$RingObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(base+0xc6fe0, extract((void(D::*)(float)){&D::setRScale}));

        if ((void($RingObject::*)(float)){&$RingObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0xc6e10, extract((void(D::*)(float)){&D::triggerActivated}));

        if ((void($RingObject::*)()){&$RingObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(base+0xc6e20, extract((void(D::*)()){&D::powerOnObject}));

        if ((void($RingObject::*)()){&$RingObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(base+0xc6f70, extract((void(D::*)()){&D::powerOffObject}));
    }
};


template<class D>
class $SetIDLayer : public SetIDLayer, public $CacBase {
public:
    dupable ~$SetIDLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SetIDLayer::*)()){&$SetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169670))(this);
        else return SetIDLayer::keyBackClicked();
    }

    dupable $SetIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetIDLayer::*)()){&$SetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x169670, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetIDPopup : public SetIDPopup, public $CacBase {
public:
    dupable ~$SetIDPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x155310))(this);
        else return SetIDPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1552c0))(this);
        else return SetIDPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x155140))(this, p0);
        else return SetIDPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x155180))(this, p0);
        else return SetIDPopup::textChanged(p0);
    }

    dupable void valueChanged() {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1552b0))(this);
        else return SetIDPopup::valueChanged();
    }

    dupable $SetIDPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetIDPopup::*)()){&$SetIDPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x155310, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetIDPopup::*)()){&$SetIDPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1552c0, extract((void(D::*)()){&D::show}));

        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x155140, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x155180, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetIDPopup::*)()){&$SetIDPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            m->registerHook(base+0x1552b0, extract((void(D::*)()){&D::valueChanged}));
    }
};


template<class D>
class $ShardsPage : public ShardsPage, public $CacBase {
public:
    dupable ~$ShardsPage() override {}

    dupable bool init() {
        if ((bool($ShardsPage::*)()){&$ShardsPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x27d610))(this);
        else return ShardsPage::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($ShardsPage::*)()){&$ShardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fc40))(this);
        else return ShardsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($ShardsPage::*)()){&$ShardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fbd0))(this);
        else return ShardsPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($ShardsPage::*)()){&$ShardsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fa30))(this);
        else return ShardsPage::show();
    }

    dupable $ShardsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ShardsPage::*)()){&$ShardsPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x27d610, extract((bool(D::*)()){&D::init}));

        if ((void($ShardsPage::*)()){&$ShardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x27fc40, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ShardsPage::*)()){&$ShardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x27fbd0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ShardsPage::*)()){&$ShardsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x27fa30, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $SongsLayer : public SongsLayer, public $CacBase {
public:
    dupable ~$SongsLayer() override {}

    dupable void customSetup() {
        if ((void($SongsLayer::*)()){&$SongsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29ec80))(this);
        else return SongsLayer::customSetup();
    }

    dupable $SongsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongsLayer::*)()){&$SongsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x29ec80, extract((void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $StatsLayer : public StatsLayer, public $CacBase {
public:
    dupable ~$StatsLayer() override {}

    dupable void customSetup() {
        if ((void($StatsLayer::*)()){&$StatsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x59df0))(this);
        else return StatsLayer::customSetup();
    }

    dupable $StatsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($StatsLayer::*)()){&$StatsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x59df0, extract((void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $UndoObject : public UndoObject, public $CacBase {
public:
    dupable ~$UndoObject() override {}

    dupable $UndoObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
public:
    dupable ~$AppDelegate() override {}

    dupable void applicationDidFinishLaunching() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (void(D::*)()){&D::applicationDidFinishLaunching})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa900))(this);
        else return AppDelegate::applicationDidFinishLaunching();
    }

    dupable void applicationDidEnterBackground() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aabe0))(this);
        else return AppDelegate::applicationDidEnterBackground();
    }

    dupable void applicationWillEnterForeground() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aac80))(this);
        else return AppDelegate::applicationWillEnterForeground();
    }

    dupable void applicationWillBecomeActive() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (void(D::*)()){&D::applicationWillBecomeActive})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aab30))(this);
        else return AppDelegate::applicationWillBecomeActive();
    }

    dupable void applicationWillResignActive() {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (void(D::*)()){&D::applicationWillResignActive})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aab50))(this);
        else return AppDelegate::applicationWillResignActive();
    }

    dupable void trySaveGame() {
        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aaf10))(this);
        else return AppDelegate::trySaveGame();
    }

    dupable void willSwitchToScene(cocos2d::CCScene* p0) {
        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(base+0x3aaf40))(this, p0);
        else return AppDelegate::willSwitchToScene(p0);
    }

    dupable $AppDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (void(D::*)()){&D::applicationDidFinishLaunching})
            m->registerHook(base+0x3aa900, extract((void(D::*)()){&D::applicationDidFinishLaunching}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            m->registerHook(base+0x3aabe0, extract((void(D::*)()){&D::applicationDidEnterBackground}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            m->registerHook(base+0x3aac80, extract((void(D::*)()){&D::applicationWillEnterForeground}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (void(D::*)()){&D::applicationWillBecomeActive})
            m->registerHook(base+0x3aab30, extract((void(D::*)()){&D::applicationWillBecomeActive}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (void(D::*)()){&D::applicationWillResignActive})
            m->registerHook(base+0x3aab50, extract((void(D::*)()){&D::applicationWillResignActive}));

        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            m->registerHook(base+0x3aaf10, extract((void(D::*)()){&D::trySaveGame}));

        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            m->registerHook(base+0x3aaf40, extract((void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene}));
    }
};


template<class D>
class $CCCountdown : public CCCountdown, public $CacBase {
public:
    dupable ~$CCCountdown() override {}

    dupable bool init() {
        if ((bool($CCCountdown::*)()){&$CCCountdown::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x468870))(this);
        else return CCCountdown::init();
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($CCCountdown::*)(unsigned char)){&$CCCountdown::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x468c70))(this, p0);
        else return CCCountdown::setOpacity(p0);
    }

    dupable $CCCountdown() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCCountdown::*)()){&$CCCountdown::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x468870, extract((bool(D::*)()){&D::init}));

        if ((void($CCCountdown::*)(unsigned char)){&$CCCountdown::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x468c70, extract((void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
public:
    dupable ~$CCMoveCNode() override {}

    dupable bool init() {
        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18b3d0))(this);
        else return CCMoveCNode::init();
    }

    dupable $CCMoveCNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18b3d0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CommentCell : public CommentCell, public $CacBase {
public:
    dupable ~$CommentCell() override {}

    dupable bool init() {
        if ((bool($CommentCell::*)()){&$CommentCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11ce80))(this);
        else return CommentCell::init();
    }

    dupable void draw() {
        if ((void($CommentCell::*)()){&$CommentCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11d1f0))(this);
        else return CommentCell::draw();
    }

    dupable void likedItem(LikeItemType p0, int p1, bool p2) {
        if ((void($CommentCell::*)(LikeItemType, int, bool)){&$CommentCell::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            return reinterpret_cast<void(*)(decltype(this), LikeItemType, int, bool)>(m->getOriginal(base+0x11d2c0))(this, p0, p1, p2);
        else return CommentCell::likedItem(p0, p1, p2);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($CommentCell::*)(FLAlertLayer*, bool)){&$CommentCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11d4b0))(this, p0, p1);
        else return CommentCell::FLAlert_Clicked(p0, p1);
    }

    dupable $CommentCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CommentCell::*)()){&$CommentCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11ce80, extract((bool(D::*)()){&D::init}));

        if ((void($CommentCell::*)()){&$CommentCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11d1f0, extract((void(D::*)()){&D::draw}));

        if ((void($CommentCell::*)(LikeItemType, int, bool)){&$CommentCell::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            m->registerHook(base+0x11d2c0, extract((void(D::*)(LikeItemType, int, bool)){&D::likedItem}));

        if ((void($CommentCell::*)(FLAlertLayer*, bool)){&$CommentCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11d4b0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $DialogLayer : public DialogLayer, public $CacBase {
public:
    dupable ~$DialogLayer() override {}

    dupable void onEnter() {
        if ((void($DialogLayer::*)()){&$DialogLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x205900))(this);
        else return DialogLayer::onEnter();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205790))(this, p0, p1);
        else return DialogLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205820))(this, p0, p1);
        else return DialogLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2057e0))(this, p0, p1);
        else return DialogLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205840))(this, p0, p1);
        else return DialogLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($DialogLayer::*)()){&$DialogLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x205890))(this);
        else return DialogLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($DialogLayer::*)()){&$DialogLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2056a0))(this);
        else return DialogLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($DialogLayer::*)(cocos2d::enumKeyCodes)){&$DialogLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x205ce0))(this, p0);
        else return DialogLayer::keyDown(p0);
    }

    dupable void fadeInTextFinished(TextArea* p0) {
        if ((void($DialogLayer::*)(TextArea*)){&$DialogLayer::fadeInTextFinished} != (void(D::*)(TextArea*)){&D::fadeInTextFinished})
            return reinterpret_cast<void(*)(decltype(this), TextArea*)>(m->getOriginal(base+0x205930))(this, p0);
        else return DialogLayer::fadeInTextFinished(p0);
    }

    dupable $DialogLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DialogLayer::*)()){&$DialogLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x205900, extract((void(D::*)()){&D::onEnter}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x205790, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x205820, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2057e0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x205840, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($DialogLayer::*)()){&$DialogLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x205890, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($DialogLayer::*)()){&$DialogLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2056a0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($DialogLayer::*)(cocos2d::enumKeyCodes)){&$DialogLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x205ce0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($DialogLayer::*)(TextArea*)){&$DialogLayer::fadeInTextFinished} != (void(D::*)(TextArea*)){&D::fadeInTextFinished})
            m->registerHook(base+0x205930, extract((void(D::*)(TextArea*)){&D::fadeInTextFinished}));
    }
};


template<class D>
class $GJGameLevel : public GJGameLevel, public $CacBase {
public:
    dupable ~$GJGameLevel() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) {
        if ((void($GJGameLevel::*)(DS_Dictionary*)){&$GJGameLevel::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x2dd1c0))(this, p0);
        else return GJGameLevel::encodeWithCoder(p0);
    }

    dupable void canEncode() {
        if ((void($GJGameLevel::*)()){&$GJGameLevel::canEncode} != (void(D::*)()){&D::canEncode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2ddae0))(this);
        else return GJGameLevel::canEncode();
    }

    dupable bool init() {
        if ((bool($GJGameLevel::*)()){&$GJGameLevel::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2db310))(this);
        else return GJGameLevel::init();
    }

    dupable $GJGameLevel() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJGameLevel::*)(DS_Dictionary*)){&$GJGameLevel::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x2dd1c0, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($GJGameLevel::*)()){&$GJGameLevel::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(base+0x2ddae0, extract((void(D::*)()){&D::canEncode}));

        if ((bool($GJGameLevel::*)()){&$GJGameLevel::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2db310, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJListLayer : public GJListLayer, public $CacBase {
public:
    dupable ~$GJListLayer() override {}

    dupable $GJListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJScoreCell : public GJScoreCell, public $CacBase {
public:
    dupable ~$GJScoreCell() override {}

    dupable bool init() {
        if ((bool($GJScoreCell::*)()){&$GJScoreCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11d710))(this);
        else return GJScoreCell::init();
    }

    dupable void draw() {
        if ((void($GJScoreCell::*)()){&$GJScoreCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11d9b0))(this);
        else return GJScoreCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJScoreCell::*)(FLAlertLayer*, bool)){&$GJScoreCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11d8e0))(this, p0, p1);
        else return GJScoreCell::FLAlert_Clicked(p0, p1);
    }

    dupable $GJScoreCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJScoreCell::*)()){&$GJScoreCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11d710, extract((bool(D::*)()){&D::init}));

        if ((void($GJScoreCell::*)()){&$GJScoreCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11d9b0, extract((void(D::*)()){&D::draw}));

        if ((void($GJScoreCell::*)(FLAlertLayer*, bool)){&$GJScoreCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11d8e0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJShopLayer : public GJShopLayer, public $CacBase {
public:
    dupable ~$GJShopLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJShopLayer::*)()){&$GJShopLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1a2370))(this);
        else return GJShopLayer::keyBackClicked();
    }

    dupable void didPurchaseItem(GJStoreItem* p0) {
        if ((void($GJShopLayer::*)(GJStoreItem*)){&$GJShopLayer::didPurchaseItem} != (void(D::*)(GJStoreItem*)){&D::didPurchaseItem})
            return reinterpret_cast<void(*)(decltype(this), GJStoreItem*)>(m->getOriginal(base+0x1a1ae0))(this, p0);
        else return GJShopLayer::didPurchaseItem(p0);
    }

    dupable $GJShopLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJShopLayer::*)()){&$GJShopLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1a2370, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJShopLayer::*)(GJStoreItem*)){&$GJShopLayer::didPurchaseItem} != (void(D::*)(GJStoreItem*)){&D::didPurchaseItem})
            m->registerHook(base+0x1a1ae0, extract((void(D::*)(GJStoreItem*)){&D::didPurchaseItem}));
    }
};


template<class D>
class $GJUserScore : public GJUserScore, public $CacBase {
public:
    dupable ~$GJUserScore() override {}

    dupable bool init() {
        if ((bool($GJUserScore::*)()){&$GJUserScore::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2de5a0))(this);
        else return GJUserScore::init();
    }

    dupable $GJUserScore() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserScore::*)()){&$GJUserScore::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2de5a0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJWorldNode : public GJWorldNode, public $CacBase {
public:
    dupable ~$GJWorldNode() override {}

    dupable $GJWorldNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GameManager : public GameManager, public $CacBase {
public:
    dupable ~$GameManager() override {}

    dupable void update(float p0) {
        if ((void($GameManager::*)(float)){&$GameManager::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1d0270))(this, p0);
        else return GameManager::update(p0);
    }

    dupable bool init() {
        if ((bool($GameManager::*)()){&$GameManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1c2ec0))(this);
        else return GameManager::init();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) {
        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x1cfd90))(this, p0);
        else return GameManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) {
        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x1ce7f0))(this, p0);
        else return GameManager::dataLoaded(p0);
    }

    dupable void firstLoad() {
        if ((void($GameManager::*)()){&$GameManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1cf6a0))(this);
        else return GameManager::firstLoad();
    }

    dupable $GameManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GameManager::*)(float)){&$GameManager::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x1d0270, extract((void(D::*)(float)){&D::update}));

        if ((bool($GameManager::*)()){&$GameManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1c2ec0, extract((bool(D::*)()){&D::init}));

        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x1cfd90, extract((void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x1ce7f0, extract((void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($GameManager::*)()){&$GameManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x1cf6a0, extract((void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $MapPackCell : public MapPackCell, public $CacBase {
public:
    dupable ~$MapPackCell() override {}

    dupable bool init() {
        if ((bool($MapPackCell::*)()){&$MapPackCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11a9c0))(this);
        else return MapPackCell::init();
    }

    dupable void draw() {
        if ((void($MapPackCell::*)()){&$MapPackCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11ae80))(this);
        else return MapPackCell::draw();
    }

    dupable $MapPackCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MapPackCell::*)()){&$MapPackCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11a9c0, extract((bool(D::*)()){&D::init}));

        if ((void($MapPackCell::*)()){&$MapPackCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11ae80, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ProfilePage : public ProfilePage, public $CacBase {
public:
    dupable ~$ProfilePage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($ProfilePage::*)()){&$ProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x464a60))(this);
        else return ProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($ProfilePage::*)()){&$ProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4637e0))(this);
        else return ProfilePage::keyBackClicked();
    }

    dupable void show() {
        if ((void($ProfilePage::*)()){&$ProfilePage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4639c0))(this);
        else return ProfilePage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($ProfilePage::*)(FLAlertLayer*, bool)){&$ProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x463340))(this, p0, p1);
        else return ProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void updateUserScoreFinished() {
        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x463850))(this);
        else return ProfilePage::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() {
        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x463920))(this);
        else return ProfilePage::updateUserScoreFailed();
    }

    dupable void getUserInfoFinished(GJUserScore* p0) {
        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::getUserInfoFinished} != (void(D::*)(GJUserScore*)){&D::getUserInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), GJUserScore*)>(m->getOriginal(base+0x463cd0))(this, p0);
        else return ProfilePage::getUserInfoFinished(p0);
    }

    dupable void getUserInfoFailed(int p0) {
        if ((void($ProfilePage::*)(int)){&$ProfilePage::getUserInfoFailed} != (void(D::*)(int)){&D::getUserInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x463fb0))(this, p0);
        else return ProfilePage::getUserInfoFailed(p0);
    }

    dupable void userInfoChanged(GJUserScore* p0) {
        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::userInfoChanged} != (void(D::*)(GJUserScore*)){&D::userInfoChanged})
            return reinterpret_cast<void(*)(decltype(this), GJUserScore*)>(m->getOriginal(base+0x464070))(this, p0);
        else return ProfilePage::userInfoChanged(p0);
    }

    dupable void loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($ProfilePage::*)(cocos2d::CCArray*, char const*)){&$ProfilePage::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x464250))(this, p0, p1);
        else return ProfilePage::loadCommentsFinished(p0, p1);
    }

    dupable void loadCommentsFailed(char const* p0) {
        if ((void($ProfilePage::*)(char const*)){&$ProfilePage::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x464340))(this, p0);
        else return ProfilePage::loadCommentsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($ProfilePage::*)(std::string, char const*)){&$ProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x464410))(this, p0, p1);
        else return ProfilePage::setupPageInfo(p0, p1);
    }

    dupable void commentUploadFinished(int p0) {
        if ((void($ProfilePage::*)(int)){&$ProfilePage::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x464770))(this, p0);
        else return ProfilePage::commentUploadFinished(p0);
    }

    dupable void commentUploadFailed(int p0, CommentError p1) {
        if ((void($ProfilePage::*)(int, CommentError)){&$ProfilePage::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), int, CommentError)>(m->getOriginal(base+0x464800))(this, p0, p1);
        else return ProfilePage::commentUploadFailed(p0, p1);
    }

    dupable void commentDeleteFailed(int p0, int p1) {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::commentDeleteFailed} != (void(D::*)(int, int)){&D::commentDeleteFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x4648e0))(this, p0, p1);
        else return ProfilePage::commentDeleteFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($ProfilePage::*)(UploadActionPopup*)){&$ProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x463510))(this, p0);
        else return ProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x463570))(this, p0, p1);
        else return ProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x463710))(this, p0, p1);
        else return ProfilePage::uploadActionFailed(p0, p1);
    }

    dupable $ProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ProfilePage::*)()){&$ProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x464a60, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ProfilePage::*)()){&$ProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4637e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ProfilePage::*)()){&$ProfilePage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x4639c0, extract((void(D::*)()){&D::show}));

        if ((void($ProfilePage::*)(FLAlertLayer*, bool)){&$ProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x463340, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x463850, extract((void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x463920, extract((void(D::*)()){&D::updateUserScoreFailed}));

        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::getUserInfoFinished} != (void(D::*)(GJUserScore*)){&D::getUserInfoFinished})
            m->registerHook(base+0x463cd0, extract((void(D::*)(GJUserScore*)){&D::getUserInfoFinished}));

        if ((void($ProfilePage::*)(int)){&$ProfilePage::getUserInfoFailed} != (void(D::*)(int)){&D::getUserInfoFailed})
            m->registerHook(base+0x463fb0, extract((void(D::*)(int)){&D::getUserInfoFailed}));

        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::userInfoChanged} != (void(D::*)(GJUserScore*)){&D::userInfoChanged})
            m->registerHook(base+0x464070, extract((void(D::*)(GJUserScore*)){&D::userInfoChanged}));

        if ((void($ProfilePage::*)(cocos2d::CCArray*, char const*)){&$ProfilePage::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            m->registerHook(base+0x464250, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished}));

        if ((void($ProfilePage::*)(char const*)){&$ProfilePage::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            m->registerHook(base+0x464340, extract((void(D::*)(char const*)){&D::loadCommentsFailed}));

        if ((void($ProfilePage::*)(std::string, char const*)){&$ProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x464410, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($ProfilePage::*)(int)){&$ProfilePage::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            m->registerHook(base+0x464770, extract((void(D::*)(int)){&D::commentUploadFinished}));

        if ((void($ProfilePage::*)(int, CommentError)){&$ProfilePage::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            m->registerHook(base+0x464800, extract((void(D::*)(int, CommentError)){&D::commentUploadFailed}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::commentDeleteFailed} != (void(D::*)(int, int)){&D::commentDeleteFailed})
            m->registerHook(base+0x4648e0, extract((void(D::*)(int, int)){&D::commentDeleteFailed}));

        if ((void($ProfilePage::*)(UploadActionPopup*)){&$ProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x463510, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x463570, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x463710, extract((void(D::*)(int, int)){&D::uploadActionFailed}));
    }
};


template<class D>
class $RewardsPage : public RewardsPage, public $CacBase {
public:
    dupable ~$RewardsPage() override {}

    dupable bool init() {
        if ((bool($RewardsPage::*)()){&$RewardsPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xf3800))(this);
        else return RewardsPage::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($RewardsPage::*)()){&$RewardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf5040))(this);
        else return RewardsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($RewardsPage::*)()){&$RewardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4fd0))(this);
        else return RewardsPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($RewardsPage::*)()){&$RewardsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4e70))(this);
        else return RewardsPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($RewardsPage::*)(FLAlertLayer*, bool)){&$RewardsPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xf4fb0))(this, p0, p1);
        else return RewardsPage::FLAlert_Clicked(p0, p1);
    }

    dupable void rewardsStatusFinished(int p0) {
        if ((void($RewardsPage::*)(int)){&$RewardsPage::rewardsStatusFinished} != (void(D::*)(int)){&D::rewardsStatusFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xf4ae0))(this, p0);
        else return RewardsPage::rewardsStatusFinished(p0);
    }

    dupable void rewardsStatusFailed() {
        if ((void($RewardsPage::*)()){&$RewardsPage::rewardsStatusFailed} != (void(D::*)()){&D::rewardsStatusFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4d70))(this);
        else return RewardsPage::rewardsStatusFailed();
    }

    dupable $RewardsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($RewardsPage::*)()){&$RewardsPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xf3800, extract((bool(D::*)()){&D::init}));

        if ((void($RewardsPage::*)()){&$RewardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0xf5040, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($RewardsPage::*)()){&$RewardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf4fd0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($RewardsPage::*)()){&$RewardsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0xf4e70, extract((void(D::*)()){&D::show}));

        if ((void($RewardsPage::*)(FLAlertLayer*, bool)){&$RewardsPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xf4fb0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($RewardsPage::*)(int)){&$RewardsPage::rewardsStatusFinished} != (void(D::*)(int)){&D::rewardsStatusFinished})
            m->registerHook(base+0xf4ae0, extract((void(D::*)(int)){&D::rewardsStatusFinished}));

        if ((void($RewardsPage::*)()){&$RewardsPage::rewardsStatusFailed} != (void(D::*)()){&D::rewardsStatusFailed})
            m->registerHook(base+0xf4d70, extract((void(D::*)()){&D::rewardsStatusFailed}));
    }
};


template<class D>
class $SecretLayer : public SecretLayer, public $CacBase {
public:
    dupable ~$SecretLayer() override {}

    dupable bool init() {
        if ((bool($SecretLayer::*)()){&$SecretLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x363340))(this);
        else return SecretLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($SecretLayer::*)()){&$SecretLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x368450))(this);
        else return SecretLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x366d30))(this, p0);
        else return SecretLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x366f30))(this, p0);
        else return SecretLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x367050))(this, p0);
        else return SecretLayer::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($SecretLayer::*)(FLAlertLayer*, bool)){&$SecretLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x366d10))(this, p0, p1);
        else return SecretLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $SecretLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer::*)()){&$SecretLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x363340, extract((bool(D::*)()){&D::init}));

        if ((void($SecretLayer::*)()){&$SecretLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x368450, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x366d30, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x366f30, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x367050, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer::*)(FLAlertLayer*, bool)){&$SecretLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x366d10, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $SpeedObject : public SpeedObject, public $CacBase {
public:
    dupable ~$SpeedObject() override {}

    dupable $SpeedObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $UploadPopup : public UploadPopup, public $CacBase {
public:
    dupable ~$UploadPopup() override {}

    dupable void keyBackClicked() {
        if ((void($UploadPopup::*)()){&$UploadPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12c600))(this);
        else return UploadPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($UploadPopup::*)()){&$UploadPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12c5a0))(this);
        else return UploadPopup::show();
    }

    dupable void levelUploadFinished(GJGameLevel* p0) {
        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFinished} != (void(D::*)(GJGameLevel*)){&D::levelUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x12c080))(this, p0);
        else return UploadPopup::levelUploadFinished(p0);
    }

    dupable void levelUploadFailed(GJGameLevel* p0) {
        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFailed} != (void(D::*)(GJGameLevel*)){&D::levelUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x12c340))(this, p0);
        else return UploadPopup::levelUploadFailed(p0);
    }

    dupable $UploadPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadPopup::*)()){&$UploadPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12c600, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($UploadPopup::*)()){&$UploadPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x12c5a0, extract((void(D::*)()){&D::show}));

        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFinished} != (void(D::*)(GJGameLevel*)){&D::levelUploadFinished})
            m->registerHook(base+0x12c080, extract((void(D::*)(GJGameLevel*)){&D::levelUploadFinished}));

        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFailed} != (void(D::*)(GJGameLevel*)){&D::levelUploadFailed})
            m->registerHook(base+0x12c340, extract((void(D::*)(GJGameLevel*)){&D::levelUploadFailed}));
    }
};


template<class D>
class $AccountLayer : public AccountLayer, public $CacBase {
public:
    dupable ~$AccountLayer() override {}

    dupable void customSetup() {
        if ((void($AccountLayer::*)()){&$AccountLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x81c20))(this);
        else return AccountLayer::customSetup();
    }

    dupable void layerHidden() {
        if ((void($AccountLayer::*)()){&$AccountLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83950))(this);
        else return AccountLayer::layerHidden();
    }

    dupable void backupAccountFinished() {
        if ((void($AccountLayer::*)()){&$AccountLayer::backupAccountFinished} != (void(D::*)()){&D::backupAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x830e0))(this);
        else return AccountLayer::backupAccountFinished();
    }

    dupable void backupAccountFailed(BackupAccountError p0) {
        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::backupAccountFailed} != (void(D::*)(BackupAccountError)){&D::backupAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), BackupAccountError)>(m->getOriginal(base+0x832d0))(this, p0);
        else return AccountLayer::backupAccountFailed(p0);
    }

    dupable void syncAccountFinished() {
        if ((void($AccountLayer::*)()){&$AccountLayer::syncAccountFinished} != (void(D::*)()){&D::syncAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83490))(this);
        else return AccountLayer::syncAccountFinished();
    }

    dupable void syncAccountFailed(BackupAccountError p0) {
        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::syncAccountFailed} != (void(D::*)(BackupAccountError)){&D::syncAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), BackupAccountError)>(m->getOriginal(base+0x83630))(this, p0);
        else return AccountLayer::syncAccountFailed(p0);
    }

    dupable void accountStatusChanged() {
        if ((void($AccountLayer::*)()){&$AccountLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x830b0))(this);
        else return AccountLayer::accountStatusChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($AccountLayer::*)(FLAlertLayer*, bool)){&$AccountLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x83830))(this, p0, p1);
        else return AccountLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $AccountLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountLayer::*)()){&$AccountLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x81c20, extract((void(D::*)()){&D::customSetup}));

        if ((void($AccountLayer::*)()){&$AccountLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x83950, extract((void(D::*)()){&D::layerHidden}));

        if ((void($AccountLayer::*)()){&$AccountLayer::backupAccountFinished} != (void(D::*)()){&D::backupAccountFinished})
            m->registerHook(base+0x830e0, extract((void(D::*)()){&D::backupAccountFinished}));

        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::backupAccountFailed} != (void(D::*)(BackupAccountError)){&D::backupAccountFailed})
            m->registerHook(base+0x832d0, extract((void(D::*)(BackupAccountError)){&D::backupAccountFailed}));

        if ((void($AccountLayer::*)()){&$AccountLayer::syncAccountFinished} != (void(D::*)()){&D::syncAccountFinished})
            m->registerHook(base+0x83490, extract((void(D::*)()){&D::syncAccountFinished}));

        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::syncAccountFailed} != (void(D::*)(BackupAccountError)){&D::syncAccountFailed})
            m->registerHook(base+0x83630, extract((void(D::*)(BackupAccountError)){&D::syncAccountFailed}));

        if ((void($AccountLayer::*)()){&$AccountLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(base+0x830b0, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((void($AccountLayer::*)(FLAlertLayer*, bool)){&$AccountLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x83830, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $BoomListView : public BoomListView, public $CacBase {
public:
    dupable ~$BoomListView() override {}

    dupable void draw() {
        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18f790))(this);
        else return BoomListView::draw();
    }

    dupable void setupList() {
        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18ef90))(this);
        else return BoomListView::setupList();
    }

    dupable void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f030))(this, p0, p1, p2);
        else return BoomListView::TableViewWillDisplayCellForRowAtIndexPath(p0, p1, p2);
    }

    dupable void cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f070))(this, p0, p1);
        else return BoomListView::cellHeightForRowAtIndexPath(p0, p1);
    }

    dupable void didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f090))(this, p0, p1);
        else return BoomListView::didSelectRowAtIndexPath(p0, p1);
    }

    dupable void numberOfRowsInSection(unsigned int p0, TableView* p1) {
        if ((void($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (void(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            return reinterpret_cast<void(*)(decltype(this), unsigned int, TableView*)>(m->getOriginal(base+0x18f0b0))(this, p0, p1);
        else return BoomListView::numberOfRowsInSection(p0, p1);
    }

    dupable void numberOfSectionsInTableView(TableView* p0) {
        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            return reinterpret_cast<void(*)(decltype(this), TableView*)>(m->getOriginal(base+0x18f0e0))(this, p0);
        else return BoomListView::numberOfSectionsInTableView(p0);
    }

    dupable void cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f100))(this, p0, p1);
        else return BoomListView::cellForRowAtIndexPath(p0, p1);
    }

    dupable void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {
        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), TableView*, TableViewCellEditingStyle, CCIndexPath&)>(m->getOriginal(base+0x18f770))(this, p0, p1, p2);
        else return BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2);
    }

    dupable void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f050))(this, p0, p1, p2);
        else return BoomListView::TableViewWillReloadCellForRowAtIndexPath(p0, p1, p2);
    }

    dupable void getListCell(char const* p0) {
        if ((void($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x18f200))(this, p0);
        else return BoomListView::getListCell(p0);
    }

    dupable void loadCell(TableViewCell* p0, int p1) {
        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x18f4a0))(this, p0, p1);
        else return BoomListView::loadCell(p0, p1);
    }

    dupable $BoomListView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18f790, extract((void(D::*)()){&D::draw}));

        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x18ef90, extract((void(D::*)()){&D::setupList}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x18f030, extract((void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            m->registerHook(base+0x18f070, extract((void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            m->registerHook(base+0x18f090, extract((void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath}));

        if ((void($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (void(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            m->registerHook(base+0x18f0b0, extract((void(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection}));

        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            m->registerHook(base+0x18f0e0, extract((void(D::*)(TableView*)){&D::numberOfSectionsInTableView}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            m->registerHook(base+0x18f100, extract((void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath}));

        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            m->registerHook(base+0x18f770, extract((void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            m->registerHook(base+0x18f050, extract((void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath}));

        if ((void($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x18f200, extract((void(D::*)(char const*)){&D::getListCell}));

        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x18f4a0, extract((void(D::*)(TableViewCell*, int)){&D::loadCell}));
    }
};


template<class D>
class $CCBlockLayer : public CCBlockLayer, public $CacBase {
public:
    dupable ~$CCBlockLayer() override {}

    dupable bool init() {
        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2a59c0))(this);
        else return CCBlockLayer::init();
    }

    dupable void draw() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5c20))(this);
        else return CCBlockLayer::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c50))(this, p0, p1);
        else return CCBlockLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5cb0))(this, p0, p1);
        else return CCBlockLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c70))(this, p0, p1);
        else return CCBlockLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c90))(this, p0, p1);
        else return CCBlockLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5ad0))(this);
        else return CCBlockLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5b10))(this);
        else return CCBlockLayer::keyBackClicked();
    }

    dupable void customSetup() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a70))(this);
        else return CCBlockLayer::customSetup();
    }

    dupable void enterLayer() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5aa0))(this);
        else return CCBlockLayer::enterLayer();
    }

    dupable void exitLayer() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5b40))(this);
        else return CCBlockLayer::exitLayer();
    }

    dupable void showLayer(bool p0) {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5b90))(this, p0);
        else return CCBlockLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5ba0))(this, p0);
        else return CCBlockLayer::hideLayer(p0);
    }

    dupable void layerVisible() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bc0))(this);
        else return CCBlockLayer::layerVisible();
    }

    dupable void layerHidden() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5be0))(this);
        else return CCBlockLayer::layerHidden();
    }

    dupable void enterAnimFinished() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bb0))(this);
        else return CCBlockLayer::enterAnimFinished();
    }

    dupable void disableUI() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a80))(this);
        else return CCBlockLayer::disableUI();
    }

    dupable void enableUI() {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a90))(this);
        else return CCBlockLayer::enableUI();
    }

    dupable $CCBlockLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2a59c0, extract((bool(D::*)()){&D::init}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2a5c20, extract((void(D::*)()){&D::draw}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2a5c50, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2a5cb0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2a5c70, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2a5c90, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2a5ad0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2a5b10, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x2a5a70, extract((void(D::*)()){&D::customSetup}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x2a5aa0, extract((void(D::*)()){&D::enterLayer}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            m->registerHook(base+0x2a5b40, extract((void(D::*)()){&D::exitLayer}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x2a5b90, extract((void(D::*)(bool)){&D::showLayer}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x2a5ba0, extract((void(D::*)(bool)){&D::hideLayer}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x2a5bc0, extract((void(D::*)()){&D::layerVisible}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x2a5be0, extract((void(D::*)()){&D::layerHidden}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x2a5bb0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x2a5a80, extract((void(D::*)()){&D::disableUI}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x2a5a90, extract((void(D::*)()){&D::enableUI}));
    }
};


template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
public:
    dupable ~$CCCircleWave() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($CCCircleWave::*)(cocos2d::CCPoint const&)){&$CCCircleWave::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0xbd600))(this, p0);
        else return CCCircleWave::setPosition(p0);
    }

    dupable void removeMeAndCleanup() {
        if ((void($CCCircleWave::*)()){&$CCCircleWave::removeMeAndCleanup} != (void(D::*)()){&D::removeMeAndCleanup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbdac0))(this);
        else return CCCircleWave::removeMeAndCleanup();
    }

    dupable void draw() {
        if ((void($CCCircleWave::*)()){&$CCCircleWave::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbd960))(this);
        else return CCCircleWave::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) {
        if ((void($CCCircleWave::*)(float, char const*)){&$CCCircleWave::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0xbd710))(this, p0, p1);
        else return CCCircleWave::updateTweenAction(p0, p1);
    }

    dupable $CCCircleWave() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCCircleWave::*)(cocos2d::CCPoint const&)){&$CCCircleWave::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0xbd600, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCCircleWave::*)()){&$CCCircleWave::removeMeAndCleanup} != (void(D::*)()){&D::removeMeAndCleanup})
            m->registerHook(base+0xbdac0, extract((void(D::*)()){&D::removeMeAndCleanup}));

        if ((void($CCCircleWave::*)()){&$CCCircleWave::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xbd960, extract((void(D::*)()){&D::draw}));

        if ((void($CCCircleWave::*)(float, char const*)){&$CCCircleWave::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0xbd710, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
public:
    dupable ~$CCLightFlash() override {}

    dupable bool init() {
        if ((bool($CCLightFlash::*)()){&$CCLightFlash::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2958f0))(this);
        else return CCLightFlash::init();
    }

    dupable $CCLightFlash() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCLightFlash::*)()){&$CCLightFlash::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2958f0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CCLightStrip : public CCLightStrip, public $CacBase {
public:
    dupable ~$CCLightStrip() override {}

    dupable void draw() {
        if ((void($CCLightStrip::*)()){&$CCLightStrip::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x296410))(this);
        else return CCLightStrip::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) {
        if ((void($CCLightStrip::*)(float, char const*)){&$CCLightStrip::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x2965a0))(this, p0, p1);
        else return CCLightStrip::updateTweenAction(p0, p1);
    }

    dupable $CCLightStrip() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCLightStrip::*)()){&$CCLightStrip::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x296410, extract((void(D::*)()){&D::draw}));

        if ((void($CCLightStrip::*)(float, char const*)){&$CCLightStrip::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x2965a0, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
public:
    dupable ~$CCSpritePlus() override {}

    dupable void setScaleX(float p0) {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248950))(this, p0);
        else return CCSpritePlus::setScaleX(p0);
    }

    dupable void setScaleY(float p0) {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2489d0))(this, p0);
        else return CCSpritePlus::setScaleY(p0);
    }

    dupable void setScale(float p0) {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248a50))(this, p0);
        else return CCSpritePlus::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($CCSpritePlus::*)(cocos2d::CCPoint const&)){&$CCSpritePlus::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x2486b0))(this, p0);
        else return CCSpritePlus::setPosition(p0);
    }

    dupable void setRotation(float p0) {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248730))(this, p0);
        else return CCSpritePlus::setRotation(p0);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0) {
        if ((void($CCSpritePlus::*)(cocos2d::CCTexture2D*)){&$CCSpritePlus::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x248690))(this, p0);
        else return CCSpritePlus::initWithTexture(p0);
    }

    dupable void initWithSpriteFrameName(char const* p0) {
        if ((void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (void(D::*)(char const*)){&D::initWithSpriteFrameName})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x248670))(this, p0);
        else return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    dupable void setFlipX(bool p0) {
        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2487b0))(this, p0);
        else return CCSpritePlus::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) {
        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x248880))(this, p0);
        else return CCSpritePlus::setFlipY(p0);
    }

    dupable $CCSpritePlus() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x248950, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x2489d0, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x248a50, extract((void(D::*)(float)){&D::setScale}));

        if ((void($CCSpritePlus::*)(cocos2d::CCPoint const&)){&$CCSpritePlus::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x2486b0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x248730, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($CCSpritePlus::*)(cocos2d::CCTexture2D*)){&$CCSpritePlus::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x248690, extract((void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (void(D::*)(char const*)){&D::initWithSpriteFrameName})
            m->registerHook(base+0x248670, extract((void(D::*)(char const*)){&D::initWithSpriteFrameName}));

        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x2487b0, extract((void(D::*)(bool)){&D::setFlipX}));

        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x248880, extract((void(D::*)(bool)){&D::setFlipY}));
    }
};


template<class D>
class $CreatorLayer : public CreatorLayer, public $CacBase {
public:
    dupable ~$CreatorLayer() override {}

    dupable bool init() {
        if ((bool($CreatorLayer::*)()){&$CreatorLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x141c10))(this);
        else return CreatorLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($CreatorLayer::*)()){&$CreatorLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x143950))(this);
        else return CreatorLayer::keyBackClicked();
    }

    dupable void sceneWillResume() {
        if ((void($CreatorLayer::*)()){&$CreatorLayer::sceneWillResume} != (void(D::*)()){&D::sceneWillResume})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1438f0))(this);
        else return CreatorLayer::sceneWillResume();
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($CreatorLayer::*)(DialogLayer*)){&$CreatorLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x143830))(this, p0);
        else return CreatorLayer::dialogClosed(p0);
    }

    dupable $CreatorLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CreatorLayer::*)()){&$CreatorLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x141c10, extract((bool(D::*)()){&D::init}));

        if ((void($CreatorLayer::*)()){&$CreatorLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x143950, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CreatorLayer::*)()){&$CreatorLayer::sceneWillResume} != (void(D::*)()){&D::sceneWillResume})
            m->registerHook(base+0x1438f0, extract((void(D::*)()){&D::sceneWillResume}));

        if ((void($CreatorLayer::*)(DialogLayer*)){&$CreatorLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x143830, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
public:
    dupable ~$FLAlertLayer() override {}

    dupable void onEnter() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f350))(this);
        else return FLAlertLayer::onEnter();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ee40))(this, p0, p1);
        else return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f0a0))(this, p0, p1);
        else return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ef60))(this, p0, p1);
        else return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f020))(this, p0, p1);
        else return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f2e0))(this);
        else return FLAlertLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25ed90))(this);
        else return FLAlertLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x25ece0))(this, p0);
        else return FLAlertLayer::keyDown(p0);
    }

    dupable void show() {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f120))(this);
        else return FLAlertLayer::show();
    }

    dupable $FLAlertLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x25f350, extract((void(D::*)()){&D::onEnter}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x25ee40, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x25f0a0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x25ef60, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x25f020, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25f2e0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25ed90, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x25ece0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x25f120, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $GJHttpResult : public GJHttpResult, public $CacBase {
public:
    dupable ~$GJHttpResult() override {}

    dupable $GJHttpResult() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJRewardItem : public GJRewardItem, public $CacBase {
public:
    dupable ~$GJRewardItem() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) {
        if ((void($GJRewardItem::*)(DS_Dictionary*)){&$GJRewardItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4d7f0))(this, p0);
        else return GJRewardItem::encodeWithCoder(p0);
    }

    dupable void canEncode() {
        if ((void($GJRewardItem::*)()){&$GJRewardItem::canEncode} != (void(D::*)()){&D::canEncode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4d850))(this);
        else return GJRewardItem::canEncode();
    }

    dupable $GJRewardItem() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRewardItem::*)(DS_Dictionary*)){&$GJRewardItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4d7f0, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($GJRewardItem::*)()){&$GJRewardItem::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(base+0x4d850, extract((void(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GauntletNode : public GauntletNode, public $CacBase {
public:
    dupable ~$GauntletNode() override {}

    dupable $GauntletNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $LoadingLayer : public LoadingLayer, public $CacBase {
public:
    dupable ~$LoadingLayer() override {}

    dupable $LoadingLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $OptionsLayer : public OptionsLayer, public $CacBase {
public:
    dupable ~$OptionsLayer() override {}

    dupable void customSetup() {
        if ((void($OptionsLayer::*)()){&$OptionsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43dc70))(this);
        else return OptionsLayer::customSetup();
    }

    dupable void layerHidden() {
        if ((void($OptionsLayer::*)()){&$OptionsLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43f200))(this);
        else return OptionsLayer::layerHidden();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($OptionsLayer::*)(FLAlertLayer*, bool)){&$OptionsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x43f270))(this, p0, p1);
        else return OptionsLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $OptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($OptionsLayer::*)()){&$OptionsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x43dc70, extract((void(D::*)()){&D::customSetup}));

        if ((void($OptionsLayer::*)()){&$OptionsLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x43f200, extract((void(D::*)()){&D::layerHidden}));

        if ((void($OptionsLayer::*)(FLAlertLayer*, bool)){&$OptionsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x43f270, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $PlayerObject : public PlayerObject, public $CacBase {
public:
    dupable ~$PlayerObject() override {}

    dupable void update(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x218bf0))(this, p0);
        else return PlayerObject::update(p0);
    }

    dupable void setScaleX(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e7f0))(this, p0);
        else return PlayerObject::setScaleX(p0);
    }

    dupable void setScaleY(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e830))(this, p0);
        else return PlayerObject::setScaleY(p0);
    }

    dupable void setScale(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e870))(this, p0);
        else return PlayerObject::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x22c8b0))(this, p0);
        else return PlayerObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e8b0))(this, p0);
        else return PlayerObject::setVisible(p0);
    }

    dupable void setRotation(float p0) {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e6e0))(this, p0);
        else return PlayerObject::setRotation(p0);
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x22d400))(this, p0);
        else return PlayerObject::setOpacity(p0);
    }

    dupable void setColor(cocos2d::_ccColor3B const& p0) {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x22cdf0))(this, p0);
        else return PlayerObject::setColor(p0);
    }

    dupable void setFlipX(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e720))(this, p0);
        else return PlayerObject::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e7b0))(this, p0);
        else return PlayerObject::setFlipY(p0);
    }

    dupable void resetObject() {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x223170))(this);
        else return PlayerObject::resetObject();
    }

    dupable void getRealPosition() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x22d5f0))(this);
        else return PlayerObject::getRealPosition();
    }

    dupable void getOrientedBox() {
        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x22dee0))(this);
        else return PlayerObject::getOrientedBox();
    }

    dupable void animationFinished(char const* p0) {
        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x22e9d0))(this, p0);
        else return PlayerObject::animationFinished(p0);
    }

    dupable $PlayerObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x218bf0, extract((void(D::*)(float)){&D::update}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x22e7f0, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x22e830, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x22e870, extract((void(D::*)(float)){&D::setScale}));

        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x22c8b0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x22e8b0, extract((void(D::*)(bool)){&D::setVisible}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x22e6e0, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x22d400, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0x22cdf0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x22e720, extract((void(D::*)(bool)){&D::setFlipX}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x22e7b0, extract((void(D::*)(bool)){&D::setFlipY}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0x223170, extract((void(D::*)()){&D::resetObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(base+0x22d5f0, extract((void(D::*)()){&D::getRealPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(base+0x22dee0, extract((void(D::*)()){&D::getOrientedBox}));

        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x22e9d0, extract((void(D::*)(char const*)){&D::animationFinished}));
    }
};


template<class D>
class $SecretLayer2 : public SecretLayer2, public $CacBase {
public:
    dupable ~$SecretLayer2() override {}

    dupable bool init() {
        if ((bool($SecretLayer2::*)()){&$SecretLayer2::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x25fe70))(this);
        else return SecretLayer2::init();
    }

    dupable void onExit() {
        if ((void($SecretLayer2::*)()){&$SecretLayer2::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x266b30))(this);
        else return SecretLayer2::onExit();
    }

    dupable void keyBackClicked() {
        if ((void($SecretLayer2::*)()){&$SecretLayer2::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x266a30))(this);
        else return SecretLayer2::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265880))(this, p0);
        else return SecretLayer2::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265a80))(this, p0);
        else return SecretLayer2::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265ba0))(this, p0);
        else return SecretLayer2::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($SecretLayer2::*)(FLAlertLayer*, bool)){&$SecretLayer2::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x265860))(this, p0, p1);
        else return SecretLayer2::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($SecretLayer2::*)(DialogLayer*)){&$SecretLayer2::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x264880))(this, p0);
        else return SecretLayer2::dialogClosed(p0);
    }

    dupable $SecretLayer2() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer2::*)()){&$SecretLayer2::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x25fe70, extract((bool(D::*)()){&D::init}));

        if ((void($SecretLayer2::*)()){&$SecretLayer2::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x266b30, extract((void(D::*)()){&D::onExit}));

        if ((void($SecretLayer2::*)()){&$SecretLayer2::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x266a30, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x265880, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x265a80, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x265ba0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer2::*)(FLAlertLayer*, bool)){&$SecretLayer2::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x265860, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($SecretLayer2::*)(DialogLayer*)){&$SecretLayer2::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x264880, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SecretLayer3 : public SecretLayer3, public $CacBase {
public:
    dupable ~$SecretLayer3() override {}

    dupable bool init() {
        if ((bool($SecretLayer3::*)()){&$SecretLayer3::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x267040))(this);
        else return SecretLayer3::init();
    }

    dupable void onExit() {
        if ((void($SecretLayer3::*)()){&$SecretLayer3::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c270))(this);
        else return SecretLayer3::onExit();
    }

    dupable void keyBackClicked() {
        if ((void($SecretLayer3::*)()){&$SecretLayer3::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c240))(this);
        else return SecretLayer3::keyBackClicked();
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($SecretLayer3::*)(DialogLayer*)){&$SecretLayer3::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x26bf10))(this, p0);
        else return SecretLayer3::dialogClosed(p0);
    }

    dupable $SecretLayer3() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer3::*)()){&$SecretLayer3::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x267040, extract((bool(D::*)()){&D::init}));

        if ((void($SecretLayer3::*)()){&$SecretLayer3::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x26c270, extract((void(D::*)()){&D::onExit}));

        if ((void($SecretLayer3::*)()){&$SecretLayer3::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x26c240, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer3::*)(DialogLayer*)){&$SecretLayer3::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x26bf10, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SecretLayer4 : public SecretLayer4, public $CacBase {
public:
    dupable ~$SecretLayer4() override {}

    dupable bool init() {
        if ((bool($SecretLayer4::*)()){&$SecretLayer4::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1ed640))(this);
        else return SecretLayer4::init();
    }

    dupable void onExit() {
        if ((void($SecretLayer4::*)()){&$SecretLayer4::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1f2220))(this);
        else return SecretLayer4::onExit();
    }

    dupable void keyBackClicked() {
        if ((void($SecretLayer4::*)()){&$SecretLayer4::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1f2120))(this);
        else return SecretLayer4::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f0ff0))(this, p0);
        else return SecretLayer4::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f11f0))(this, p0);
        else return SecretLayer4::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f1310))(this, p0);
        else return SecretLayer4::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($SecretLayer4::*)(FLAlertLayer*, bool)){&$SecretLayer4::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1f0fd0))(this, p0, p1);
        else return SecretLayer4::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($SecretLayer4::*)(DialogLayer*)){&$SecretLayer4::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x1f0a90))(this, p0);
        else return SecretLayer4::dialogClosed(p0);
    }

    dupable $SecretLayer4() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer4::*)()){&$SecretLayer4::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1ed640, extract((bool(D::*)()){&D::init}));

        if ((void($SecretLayer4::*)()){&$SecretLayer4::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x1f2220, extract((void(D::*)()){&D::onExit}));

        if ((void($SecretLayer4::*)()){&$SecretLayer4::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1f2120, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1f0ff0, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1f11f0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1f1310, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer4::*)(FLAlertLayer*, bool)){&$SecretLayer4::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1f0fd0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($SecretLayer4::*)(DialogLayer*)){&$SecretLayer4::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x1f0a90, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SetTextPopup : public SetTextPopup, public $CacBase {
public:
    dupable ~$SetTextPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetTextPopup::*)()){&$SetTextPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x157050))(this);
        else return SetTextPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetTextPopup::*)()){&$SetTextPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x157000))(this);
        else return SetTextPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x156ef0))(this, p0);
        else return SetTextPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x156f30))(this, p0);
        else return SetTextPopup::textChanged(p0);
    }

    dupable $SetTextPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetTextPopup::*)()){&$SetTextPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x157050, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetTextPopup::*)()){&$SetTextPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x157000, extract((void(D::*)()){&D::show}));

        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x156ef0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x156f30, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $SimplePlayer : public SimplePlayer, public $CacBase {
public:
    dupable ~$SimplePlayer() override {}

    dupable void setOpacity(unsigned char p0) {
        if ((void($SimplePlayer::*)(unsigned char)){&$SimplePlayer::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1bcc40))(this, p0);
        else return SimplePlayer::setOpacity(p0);
    }

    dupable void setColor(cocos2d::_ccColor3B const& p0) {
        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x1bc9b0))(this, p0);
        else return SimplePlayer::setColor(p0);
    }

    dupable $SimplePlayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SimplePlayer::*)(unsigned char)){&$SimplePlayer::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1bcc40, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0x1bc9b0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));
    }
};


template<class D>
class $SlideInLayer : public SlideInLayer, public $CacBase {
public:
    dupable ~$SlideInLayer() override {}

    dupable bool init() {
        if ((bool($SlideInLayer::*)()){&$SlideInLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x138cf0))(this);
        else return SlideInLayer::init();
    }

    dupable void draw() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1394a0))(this);
        else return SlideInLayer::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1394d0))(this, p0, p1);
        else return SlideInLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x139530))(this, p0, p1);
        else return SlideInLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1394f0))(this, p0, p1);
        else return SlideInLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x139510))(this, p0, p1);
        else return SlideInLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139190))(this);
        else return SlideInLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1391d0))(this);
        else return SlideInLayer::keyBackClicked();
    }

    dupable void customSetup() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139110))(this);
        else return SlideInLayer::customSetup();
    }

    dupable void enterLayer() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139160))(this);
        else return SlideInLayer::enterLayer();
    }

    dupable void exitLayer(cocos2d::CCObject* p0) {
        if ((void($SlideInLayer::*)(cocos2d::CCObject*)){&$SlideInLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x139210))(this, p0);
        else return SlideInLayer::exitLayer(p0);
    }

    dupable void showLayer(bool p0) {
        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x139270))(this, p0);
        else return SlideInLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) {
        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x139360))(this, p0);
        else return SlideInLayer::hideLayer(p0);
    }

    dupable void layerVisible() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139440))(this);
        else return SlideInLayer::layerVisible();
    }

    dupable void layerHidden() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139460))(this);
        else return SlideInLayer::layerHidden();
    }

    dupable void enterAnimFinished() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139430))(this);
        else return SlideInLayer::enterAnimFinished();
    }

    dupable void disableUI() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139120))(this);
        else return SlideInLayer::disableUI();
    }

    dupable void enableUI() {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139140))(this);
        else return SlideInLayer::enableUI();
    }

    dupable $SlideInLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SlideInLayer::*)()){&$SlideInLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x138cf0, extract((bool(D::*)()){&D::init}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x1394a0, extract((void(D::*)()){&D::draw}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x1394d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x139530, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x1394f0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x139510, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x139190, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1391d0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x139110, extract((void(D::*)()){&D::customSetup}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x139160, extract((void(D::*)()){&D::enterLayer}));

        if ((void($SlideInLayer::*)(cocos2d::CCObject*)){&$SlideInLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(base+0x139210, extract((void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x139270, extract((void(D::*)(bool)){&D::showLayer}));

        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x139360, extract((void(D::*)(bool)){&D::hideLayer}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x139440, extract((void(D::*)()){&D::layerVisible}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x139460, extract((void(D::*)()){&D::layerHidden}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x139430, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x139120, extract((void(D::*)()){&D::disableUI}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x139140, extract((void(D::*)()){&D::enableUI}));
    }
};


template<class D>
class $SupportLayer : public SupportLayer, public $CacBase {
public:
    dupable ~$SupportLayer() override {}

    dupable void customSetup() {
        if ((void($SupportLayer::*)()){&$SupportLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d90b0))(this);
        else return SupportLayer::customSetup();
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x1d9de0))(this, p0, p1);
        else return SupportLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x1d9f00))(this, p0, p1);
        else return SupportLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($SupportLayer::*)(UploadActionPopup*)){&$SupportLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x1d9d90))(this, p0);
        else return SupportLayer::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($SupportLayer::*)(FLAlertLayer*, bool)){&$SupportLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1da170))(this, p0, p1);
        else return SupportLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $SupportLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SupportLayer::*)()){&$SupportLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x1d90b0, extract((void(D::*)()){&D::customSetup}));

        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x1d9de0, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x1d9f00, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($SupportLayer::*)(UploadActionPopup*)){&$SupportLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x1d9d90, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($SupportLayer::*)(FLAlertLayer*, bool)){&$SupportLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1da170, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $BoomListLayer : public BoomListLayer, public $CacBase {
public:
    dupable ~$BoomListLayer() override {}

    dupable $BoomListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CCAlertCircle : public CCAlertCircle, public $CacBase {
public:
    dupable ~$CCAlertCircle() override {}

    dupable bool init() {
        if ((bool($CCAlertCircle::*)()){&$CCAlertCircle::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xbdea0))(this);
        else return CCAlertCircle::init();
    }

    dupable void draw() {
        if ((void($CCAlertCircle::*)()){&$CCAlertCircle::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbdf40))(this);
        else return CCAlertCircle::draw();
    }

    dupable $CCAlertCircle() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCAlertCircle::*)()){&$CCAlertCircle::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xbdea0, extract((bool(D::*)()){&D::init}));

        if ((void($CCAlertCircle::*)()){&$CCAlertCircle::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xbdf40, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ChallengeNode : public ChallengeNode, public $CacBase {
public:
    dupable ~$ChallengeNode() override {}

    dupable $ChallengeNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $DrawGridLayer : public DrawGridLayer, public $CacBase {
public:
    dupable ~$DrawGridLayer() override {}

    dupable void update(float p0) {
        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xa3b30))(this, p0);
        else return DrawGridLayer::update(p0);
    }

    dupable $DrawGridLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0xa3b30, extract((void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $EditButtonBar : public EditButtonBar, public $CacBase {
public:
    dupable ~$EditButtonBar() override {}

    dupable $EditButtonBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $ExtendedLayer : public ExtendedLayer, public $CacBase {
public:
    dupable ~$ExtendedLayer() override {}

    dupable bool init() {
        if ((bool($ExtendedLayer::*)()){&$ExtendedLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1e41e0))(this);
        else return ExtendedLayer::init();
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($ExtendedLayer::*)(cocos2d::CCPoint const&)){&$ExtendedLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x1e41f0))(this, p0);
        else return ExtendedLayer::setPosition(p0);
    }

    dupable $ExtendedLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ExtendedLayer::*)()){&$ExtendedLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1e41e0, extract((bool(D::*)()){&D::init}));

        if ((void($ExtendedLayer::*)(cocos2d::CCPoint const&)){&$ExtendedLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x1e41f0, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));
    }
};


template<class D>
class $GJChestSprite : public GJChestSprite, public $CacBase {
public:
    dupable ~$GJChestSprite() override {}

    dupable void setColor(cocos2d::_ccColor3B const& p0) {
        if ((void($GJChestSprite::*)(cocos2d::_ccColor3B const&)){&$GJChestSprite::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xf8270))(this, p0);
        else return GJChestSprite::setColor(p0);
    }

    dupable $GJChestSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJChestSprite::*)(cocos2d::_ccColor3B const&)){&$GJChestSprite::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0xf8270, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));
    }
};


template<class D>
class $GJGarageLayer : public GJGarageLayer, public $CacBase {
public:
    dupable ~$GJGarageLayer() override {}

    dupable bool init() {
        if ((bool($GJGarageLayer::*)()){&$GJGarageLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1b4980))(this);
        else return GJGarageLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bb630))(this);
        else return GJGarageLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b7dc0))(this, p0);
        else return GJGarageLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b8040))(this, p0);
        else return GJGarageLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b82c0))(this, p0);
        else return GJGarageLayer::textChanged(p0);
    }

    dupable void listButtonBarSwitchedPage(ListButtonBar* p0, int p1) {
        if ((void($GJGarageLayer::*)(ListButtonBar*, int)){&$GJGarageLayer::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            return reinterpret_cast<void(*)(decltype(this), ListButtonBar*, int)>(m->getOriginal(base+0x1bad10))(this, p0, p1);
        else return GJGarageLayer::listButtonBarSwitchedPage(p0, p1);
    }

    dupable void updateRate() {
        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::updateRate} != (void(D::*)()){&D::updateRate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bb420))(this);
        else return GJGarageLayer::updateRate();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJGarageLayer::*)(FLAlertLayer*, bool)){&$GJGarageLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1bb050))(this, p0, p1);
        else return GJGarageLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($GJGarageLayer::*)(DialogLayer*)){&$GJGarageLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x1bb160))(this, p0);
        else return GJGarageLayer::dialogClosed(p0);
    }

    dupable $GJGarageLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJGarageLayer::*)()){&$GJGarageLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1b4980, extract((bool(D::*)()){&D::init}));

        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1bb630, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1b7dc0, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1b8040, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1b82c0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJGarageLayer::*)(ListButtonBar*, int)){&$GJGarageLayer::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            m->registerHook(base+0x1bad10, extract((void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage}));

        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::updateRate} != (void(D::*)()){&D::updateRate})
            m->registerHook(base+0x1bb420, extract((void(D::*)()){&D::updateRate}));

        if ((void($GJGarageLayer::*)(FLAlertLayer*, bool)){&$GJGarageLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1bb050, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJGarageLayer::*)(DialogLayer*)){&$GJGarageLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x1bb160, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $GJGroundLayer : public GJGroundLayer, public $CacBase {
public:
    dupable ~$GJGroundLayer() override {}

    dupable void draw() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x356a60))(this);
        else return GJGroundLayer::draw();
    }

    dupable void showGround() {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::showGround} != (void(D::*)()){&D::showGround})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x356920))(this);
        else return GJGroundLayer::showGround();
    }

    dupable void fadeInGround(float p0) {
        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeInGround} != (void(D::*)(float)){&D::fadeInGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x356930))(this, p0);
        else return GJGroundLayer::fadeInGround(p0);
    }

    dupable void fadeOutGround(float p0) {
        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeOutGround} != (void(D::*)(float)){&D::fadeOutGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x356a30))(this, p0);
        else return GJGroundLayer::fadeOutGround(p0);
    }

    dupable $GJGroundLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x356a60, extract((void(D::*)()){&D::draw}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::showGround} != (void(D::*)()){&D::showGround})
            m->registerHook(base+0x356920, extract((void(D::*)()){&D::showGround}));

        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeInGround} != (void(D::*)(float)){&D::fadeInGround})
            m->registerHook(base+0x356930, extract((void(D::*)(float)){&D::fadeInGround}));

        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeOutGround} != (void(D::*)(float)){&D::fadeOutGround})
            m->registerHook(base+0x356a30, extract((void(D::*)(float)){&D::fadeOutGround}));
    }
};


template<class D>
class $GJMessageCell : public GJMessageCell, public $CacBase {
public:
    dupable ~$GJMessageCell() override {}

    dupable bool init() {
        if ((bool($GJMessageCell::*)()){&$GJMessageCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11fc00))(this);
        else return GJMessageCell::init();
    }

    dupable void draw() {
        if ((void($GJMessageCell::*)()){&$GJMessageCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11fef0))(this);
        else return GJMessageCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJMessageCell::*)(FLAlertLayer*, bool)){&$GJMessageCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11ffc0))(this, p0, p1);
        else return GJMessageCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x120180))(this, p0, p1);
        else return GJMessageCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x120310))(this, p0, p1);
        else return GJMessageCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($GJMessageCell::*)(UploadActionPopup*)){&$GJMessageCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x120410))(this, p0);
        else return GJMessageCell::onClosePopup(p0);
    }

    dupable $GJMessageCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJMessageCell::*)()){&$GJMessageCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11fc00, extract((bool(D::*)()){&D::init}));

        if ((void($GJMessageCell::*)()){&$GJMessageCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11fef0, extract((void(D::*)()){&D::draw}));

        if ((void($GJMessageCell::*)(FLAlertLayer*, bool)){&$GJMessageCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11ffc0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x120180, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x120310, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJMessageCell::*)(UploadActionPopup*)){&$GJMessageCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x120410, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJRequestCell : public GJRequestCell, public $CacBase {
public:
    dupable ~$GJRequestCell() override {}

    dupable bool init() {
        if ((bool($GJRequestCell::*)()){&$GJRequestCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11f080))(this);
        else return GJRequestCell::init();
    }

    dupable void draw() {
        if ((void($GJRequestCell::*)()){&$GJRequestCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11f390))(this);
        else return GJRequestCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJRequestCell::*)(FLAlertLayer*, bool)){&$GJRequestCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11f460))(this, p0, p1);
        else return GJRequestCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11f640))(this, p0, p1);
        else return GJRequestCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11f800))(this, p0, p1);
        else return GJRequestCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($GJRequestCell::*)(UploadActionPopup*)){&$GJRequestCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x11f930))(this, p0);
        else return GJRequestCell::onClosePopup(p0);
    }

    dupable $GJRequestCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRequestCell::*)()){&$GJRequestCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11f080, extract((bool(D::*)()){&D::init}));

        if ((void($GJRequestCell::*)()){&$GJRequestCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11f390, extract((void(D::*)()){&D::draw}));

        if ((void($GJRequestCell::*)(FLAlertLayer*, bool)){&$GJRequestCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11f460, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x11f640, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x11f800, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJRequestCell::*)(UploadActionPopup*)){&$GJRequestCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x11f930, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJRobotSprite : public GJRobotSprite, public $CacBase {
public:
    dupable ~$GJRobotSprite() override {}

    dupable bool init() {
        if ((bool($GJRobotSprite::*)()){&$GJRobotSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x34ad50))(this);
        else return GJRobotSprite::init();
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($GJRobotSprite::*)(unsigned char)){&$GJRobotSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x34bcc0))(this, p0);
        else return GJRobotSprite::setOpacity(p0);
    }

    dupable void hideSecondary() {
        if ((void($GJRobotSprite::*)()){&$GJRobotSprite::hideSecondary} != (void(D::*)()){&D::hideSecondary})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34c3b0))(this);
        else return GJRobotSprite::hideSecondary();
    }

    dupable $GJRobotSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRobotSprite::*)()){&$GJRobotSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x34ad50, extract((bool(D::*)()){&D::init}));

        if ((void($GJRobotSprite::*)(unsigned char)){&$GJRobotSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x34bcc0, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($GJRobotSprite::*)()){&$GJRobotSprite::hideSecondary} != (void(D::*)()){&D::hideSecondary})
            m->registerHook(base+0x34c3b0, extract((void(D::*)()){&D::hideSecondary}));
    }
};


template<class D>
class $GJSongBrowser : public GJSongBrowser, public $CacBase {
public:
    dupable ~$GJSongBrowser() override {}

    dupable void customSetup() {
        if ((void($GJSongBrowser::*)()){&$GJSongBrowser::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x368ab0))(this);
        else return GJSongBrowser::customSetup();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJSongBrowser::*)(FLAlertLayer*, bool)){&$GJSongBrowser::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x3690a0))(this, p0, p1);
        else return GJSongBrowser::FLAlert_Clicked(p0, p1);
    }

    dupable $GJSongBrowser() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJSongBrowser::*)()){&$GJSongBrowser::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x368ab0, extract((void(D::*)()){&D::customSetup}));

        if ((void($GJSongBrowser::*)(FLAlertLayer*, bool)){&$GJSongBrowser::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x3690a0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJSpriteColor : public GJSpriteColor, public $CacBase {
public:
    dupable ~$GJSpriteColor() override {}

    dupable bool init() {
        if ((bool($GJSpriteColor::*)()){&$GJSpriteColor::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x343c90))(this);
        else return GJSpriteColor::init();
    }

    dupable $GJSpriteColor() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJSpriteColor::*)()){&$GJSpriteColor::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x343c90, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJUserMessage : public GJUserMessage, public $CacBase {
public:
    dupable ~$GJUserMessage() override {}

    dupable bool init() {
        if ((bool($GJUserMessage::*)()){&$GJUserMessage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2debf0))(this);
        else return GJUserMessage::init();
    }

    dupable $GJUserMessage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserMessage::*)()){&$GJUserMessage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2debf0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GauntletLayer : public GauntletLayer, public $CacBase {
public:
    dupable ~$GauntletLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GauntletLayer::*)()){&$GauntletLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d5e20))(this);
        else return GauntletLayer::keyBackClicked();
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($GauntletLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x1d5410))(this, p0, p1);
        else return GauntletLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) {
        if ((void($GauntletLayer::*)(char const*)){&$GauntletLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1d55d0))(this, p0);
        else return GauntletLayer::loadLevelsFailed(p0);
    }

    dupable $GauntletLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GauntletLayer::*)()){&$GauntletLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d5e20, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GauntletLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x1d5410, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($GauntletLayer::*)(char const*)){&$GauntletLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x1d55d0, extract((void(D::*)(char const*)){&D::loadLevelsFailed}));
    }
};


template<class D>
class $LikeItemLayer : public LikeItemLayer, public $CacBase {
public:
    dupable ~$LikeItemLayer() override {}

    dupable void keyBackClicked() {
        if ((void($LikeItemLayer::*)()){&$LikeItemLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35ff20))(this);
        else return LikeItemLayer::keyBackClicked();
    }

    dupable $LikeItemLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LikeItemLayer::*)()){&$LikeItemLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x35ff20, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $ListButtonBar : public ListButtonBar, public $CacBase {
public:
    dupable ~$ListButtonBar() override {}

    dupable $ListButtonBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $LoadingCircle : public LoadingCircle, public $CacBase {
public:
    dupable ~$LoadingCircle() override {}

    dupable bool init() {
        if ((bool($LoadingCircle::*)()){&$LoadingCircle::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x277f00))(this);
        else return LoadingCircle::init();
    }

    dupable void draw() {
        if ((void($LoadingCircle::*)()){&$LoadingCircle::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x278170))(this);
        else return LoadingCircle::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781d0))(this, p0, p1);
        else return LoadingCircle::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781e0))(this, p0, p1);
        else return LoadingCircle::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781f0))(this, p0, p1);
        else return LoadingCircle::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x278200))(this, p0, p1);
        else return LoadingCircle::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($LoadingCircle::*)()){&$LoadingCircle::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x278190))(this);
        else return LoadingCircle::registerWithTouchDispatcher();
    }

    dupable $LoadingCircle() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LoadingCircle::*)()){&$LoadingCircle::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x277f00, extract((bool(D::*)()){&D::init}));

        if ((void($LoadingCircle::*)()){&$LoadingCircle::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x278170, extract((void(D::*)()){&D::draw}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2781d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2781e0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2781f0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x278200, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($LoadingCircle::*)()){&$LoadingCircle::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x278190, extract((void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $MenuGameLayer : public MenuGameLayer, public $CacBase {
public:
    dupable ~$MenuGameLayer() override {}

    dupable void update(float p0) {
        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x28fa70))(this, p0);
        else return MenuGameLayer::update(p0);
    }

    dupable bool init() {
        if ((bool($MenuGameLayer::*)()){&$MenuGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x28f150))(this);
        else return MenuGameLayer::init();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290650))(this, p0, p1);
        else return MenuGameLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290770))(this, p0, p1);
        else return MenuGameLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290790))(this, p0, p1);
        else return MenuGameLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2907b0))(this, p0, p1);
        else return MenuGameLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2907f0))(this);
        else return MenuGameLayer::registerWithTouchDispatcher();
    }

    dupable $MenuGameLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x28fa70, extract((void(D::*)(float)){&D::update}));

        if ((bool($MenuGameLayer::*)()){&$MenuGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x28f150, extract((bool(D::*)()){&D::init}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x290650, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x290770, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x290790, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2907b0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2907f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $MyLevelsLayer : public MyLevelsLayer, public $CacBase {
public:
    dupable ~$MyLevelsLayer() override {}

    dupable bool init() {
        if ((bool($MyLevelsLayer::*)()){&$MyLevelsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x35470))(this);
        else return MyLevelsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($MyLevelsLayer::*)()){&$MyLevelsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35b90))(this);
        else return MyLevelsLayer::keyBackClicked();
    }

    dupable $MyLevelsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MyLevelsLayer::*)()){&$MyLevelsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x35470, extract((bool(D::*)()){&D::init}));

        if ((void($MyLevelsLayer::*)()){&$MyLevelsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x35b90, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $ObjectDecoder : public ObjectDecoder, public $CacBase {
public:
    dupable ~$ObjectDecoder() override {}

    dupable bool init() {
        if ((bool($ObjectDecoder::*)()){&$ObjectDecoder::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x437f80))(this);
        else return ObjectDecoder::init();
    }

    dupable $ObjectDecoder() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectDecoder::*)()){&$ObjectDecoder::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x437f80, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ObjectManager : public ObjectManager, public $CacBase {
public:
    dupable ~$ObjectManager() override {}

    dupable bool init() {
        if ((bool($ObjectManager::*)()){&$ObjectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x43b280))(this);
        else return ObjectManager::init();
    }

    dupable $ObjectManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectManager::*)()){&$ObjectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x43b280, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ObjectToolbox : public ObjectToolbox, public $CacBase {
public:
    dupable ~$ObjectToolbox() override {}

    dupable bool init() {
        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3b2d80))(this);
        else return ObjectToolbox::init();
    }

    dupable $ObjectToolbox() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3b2d80, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $SongInfoLayer : public SongInfoLayer, public $CacBase {
public:
    dupable ~$SongInfoLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SongInfoLayer::*)()){&$SongInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x36a980))(this);
        else return SongInfoLayer::keyBackClicked();
    }

    dupable $SongInfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongInfoLayer::*)()){&$SongInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x36a980, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TableViewCell : public TableViewCell, public $CacBase {
public:
    dupable ~$TableViewCell() override {}

    dupable $TableViewCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TutorialLayer : public TutorialLayer, public $CacBase {
public:
    dupable ~$TutorialLayer() override {}

    dupable bool init() {
        if ((bool($TutorialLayer::*)()){&$TutorialLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x286e00))(this);
        else return TutorialLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($TutorialLayer::*)()){&$TutorialLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2878d0))(this);
        else return TutorialLayer::keyBackClicked();
    }

    dupable $TutorialLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($TutorialLayer::*)()){&$TutorialLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x286e00, extract((bool(D::*)()){&D::init}));

        if ((void($TutorialLayer::*)()){&$TutorialLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2878d0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TutorialPopup : public TutorialPopup, public $CacBase {
public:
    dupable ~$TutorialPopup() override {}

    dupable void keyBackClicked() {
        if ((void($TutorialPopup::*)()){&$TutorialPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x344ae0))(this);
        else return TutorialPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($TutorialPopup::*)()){&$TutorialPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x344bb0))(this);
        else return TutorialPopup::show();
    }

    dupable $TutorialPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TutorialPopup::*)()){&$TutorialPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x344ae0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($TutorialPopup::*)()){&$TutorialPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x344bb0, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $AchievementBar : public AchievementBar, public $CacBase {
public:
    dupable ~$AchievementBar() override {}

    dupable void setOpacity(unsigned char p0) {
        if ((void($AchievementBar::*)(unsigned char)){&$AchievementBar::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x37b9b0))(this, p0);
        else return AchievementBar::setOpacity(p0);
    }

    dupable $AchievementBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AchievementBar::*)(unsigned char)){&$AchievementBar::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x37b9b0, extract((void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $CCContentLayer : public CCContentLayer, public $CacBase {
public:
    dupable ~$CCContentLayer() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($CCContentLayer::*)(cocos2d::CCPoint const&)){&$CCContentLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x464c60))(this, p0);
        else return CCContentLayer::setPosition(p0);
    }

    dupable $CCContentLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCContentLayer::*)(cocos2d::CCPoint const&)){&$CCContentLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x464c60, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));
    }
};


template<class D>
class $CCCounterLabel : public CCCounterLabel, public $CacBase {
public:
    dupable ~$CCCounterLabel() override {}

    dupable $CCCounterLabel() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $ChallengesPage : public ChallengesPage, public $CacBase {
public:
    dupable ~$ChallengesPage() override {}

    dupable bool init() {
        if ((bool($ChallengesPage::*)()){&$ChallengesPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1db520))(this);
        else return ChallengesPage::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dcc50))(this);
        else return ChallengesPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dcbc0))(this);
        else return ChallengesPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dca10))(this);
        else return ChallengesPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($ChallengesPage::*)(FLAlertLayer*, bool)){&$ChallengesPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1dcba0))(this, p0, p1);
        else return ChallengesPage::FLAlert_Clicked(p0, p1);
    }

    dupable void challengeStatusFinished() {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFinished} != (void(D::*)()){&D::challengeStatusFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dc520))(this);
        else return ChallengesPage::challengeStatusFinished();
    }

    dupable void challengeStatusFailed() {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFailed} != (void(D::*)()){&D::challengeStatusFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dc830))(this);
        else return ChallengesPage::challengeStatusFailed();
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) {
        if ((void($ChallengesPage::*)(CurrencyRewardLayer*)){&$ChallengesPage::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0x1dcdb0))(this, p0);
        else return ChallengesPage::currencyWillExit(p0);
    }

    dupable $ChallengesPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ChallengesPage::*)()){&$ChallengesPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1db520, extract((bool(D::*)()){&D::init}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1dcc50, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1dcbc0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1dca10, extract((void(D::*)()){&D::show}));

        if ((void($ChallengesPage::*)(FLAlertLayer*, bool)){&$ChallengesPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1dcba0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFinished} != (void(D::*)()){&D::challengeStatusFinished})
            m->registerHook(base+0x1dc520, extract((void(D::*)()){&D::challengeStatusFinished}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFailed} != (void(D::*)()){&D::challengeStatusFailed})
            m->registerHook(base+0x1dc830, extract((void(D::*)()){&D::challengeStatusFailed}));

        if ((void($ChallengesPage::*)(CurrencyRewardLayer*)){&$ChallengesPage::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0x1dcdb0, extract((void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));
    }
};


template<class D>
class $CurrencySprite : public CurrencySprite, public $CacBase {
public:
    dupable ~$CurrencySprite() override {}

    dupable $CurrencySprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CustomListView : public CustomListView, public $CacBase {
public:
    dupable ~$CustomListView() override {}

    dupable void setupList() {
        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x116e70))(this);
        else return CustomListView::setupList();
    }

    dupable void getListCell(char const* p0) {
        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x10d560))(this, p0);
        else return CustomListView::getListCell(p0);
    }

    dupable void loadCell(TableViewCell* p0, int p1) {
        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x10e610))(this, p0, p1);
        else return CustomListView::loadCell(p0, p1);
    }

    dupable $CustomListView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x116e70, extract((void(D::*)()){&D::setupList}));

        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x10d560, extract((void(D::*)(char const*)){&D::getListCell}));

        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x10e610, extract((void(D::*)(TableViewCell*, int)){&D::loadCell}));
    }
};


template<class D>
class $CustomSongCell : public CustomSongCell, public $CacBase {
public:
    dupable ~$CustomSongCell() override {}

    dupable bool init() {
        if ((bool($CustomSongCell::*)()){&$CustomSongCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c440))(this);
        else return CustomSongCell::init();
    }

    dupable void draw() {
        if ((void($CustomSongCell::*)()){&$CustomSongCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c5c0))(this);
        else return CustomSongCell::draw();
    }

    dupable $CustomSongCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CustomSongCell::*)()){&$CustomSongCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c440, extract((bool(D::*)()){&D::init}));

        if ((void($CustomSongCell::*)()){&$CustomSongCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c5c0, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $DailyLevelNode : public DailyLevelNode, public $CacBase {
public:
    dupable ~$DailyLevelNode() override {}

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($DailyLevelNode::*)(FLAlertLayer*, bool)){&$DailyLevelNode::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x10b750))(this, p0, p1);
        else return DailyLevelNode::FLAlert_Clicked(p0, p1);
    }

    dupable $DailyLevelNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DailyLevelNode::*)(FLAlertLayer*, bool)){&$DailyLevelNode::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x10b750, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $DailyLevelPage : public DailyLevelPage, public $CacBase {
public:
    dupable ~$DailyLevelPage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a6f0))(this);
        else return DailyLevelPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a660))(this);
        else return DailyLevelPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a4b0))(this);
        else return DailyLevelPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($DailyLevelPage::*)(FLAlertLayer*, bool)){&$DailyLevelPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x10a640))(this, p0, p1);
        else return DailyLevelPage::FLAlert_Clicked(p0, p1);
    }

    dupable void dailyStatusFinished(bool p0) {
        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFinished} != (void(D::*)(bool)){&D::dailyStatusFinished})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x109be0))(this, p0);
        else return DailyLevelPage::dailyStatusFinished(p0);
    }

    dupable void dailyStatusFailed(bool p0) {
        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFailed} != (void(D::*)(bool)){&D::dailyStatusFailed})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x10a090))(this, p0);
        else return DailyLevelPage::dailyStatusFailed(p0);
    }

    dupable void levelDownloadFinished(GJGameLevel* p0) {
        if ((void($DailyLevelPage::*)(GJGameLevel*)){&$DailyLevelPage::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x10a1b0))(this, p0);
        else return DailyLevelPage::levelDownloadFinished(p0);
    }

    dupable void levelDownloadFailed(int p0) {
        if ((void($DailyLevelPage::*)(int)){&$DailyLevelPage::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x10a280))(this, p0);
        else return DailyLevelPage::levelDownloadFailed(p0);
    }

    dupable $DailyLevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x10a6f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x10a660, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x10a4b0, extract((void(D::*)()){&D::show}));

        if ((void($DailyLevelPage::*)(FLAlertLayer*, bool)){&$DailyLevelPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x10a640, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFinished} != (void(D::*)(bool)){&D::dailyStatusFinished})
            m->registerHook(base+0x109be0, extract((void(D::*)(bool)){&D::dailyStatusFinished}));

        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFailed} != (void(D::*)(bool)){&D::dailyStatusFailed})
            m->registerHook(base+0x10a090, extract((void(D::*)(bool)){&D::dailyStatusFailed}));

        if ((void($DailyLevelPage::*)(GJGameLevel*)){&$DailyLevelPage::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            m->registerHook(base+0x10a1b0, extract((void(D::*)(GJGameLevel*)){&D::levelDownloadFinished}));

        if ((void($DailyLevelPage::*)(int)){&$DailyLevelPage::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            m->registerHook(base+0x10a280, extract((void(D::*)(int)){&D::levelDownloadFailed}));
    }
};


template<class D>
class $EditLevelLayer : public EditLevelLayer, public $CacBase {
public:
    dupable ~$EditLevelLayer() override {}

    dupable void keyBackClicked() {
        if ((void($EditLevelLayer::*)()){&$EditLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xe6670))(this);
        else return EditLevelLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($EditLevelLayer::*)(cocos2d::enumKeyCodes)){&$EditLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0xe66a0))(this, p0);
        else return EditLevelLayer::keyDown(p0);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) {
        if ((void($EditLevelLayer::*)(SetIDPopup*, int)){&$EditLevelLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0xe6560))(this, p0, p1);
        else return EditLevelLayer::setIDPopupClosed(p0, p1);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($EditLevelLayer::*)(FLAlertLayer*, bool)){&$EditLevelLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xe5e70))(this, p0, p1);
        else return EditLevelLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe5540))(this, p0);
        else return EditLevelLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe51e0))(this, p0);
        else return EditLevelLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe57a0))(this, p0);
        else return EditLevelLayer::textChanged(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xe6740))(this, p0, p1);
        else return EditLevelLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xe68c0))(this, p0, p1);
        else return EditLevelLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($EditLevelLayer::*)(UploadActionPopup*)){&$EditLevelLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0xe66f0))(this, p0);
        else return EditLevelLayer::onClosePopup(p0);
    }

    dupable $EditLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditLevelLayer::*)()){&$EditLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xe6670, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($EditLevelLayer::*)(cocos2d::enumKeyCodes)){&$EditLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0xe66a0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditLevelLayer::*)(SetIDPopup*, int)){&$EditLevelLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0xe6560, extract((void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));

        if ((void($EditLevelLayer::*)(FLAlertLayer*, bool)){&$EditLevelLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xe5e70, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xe5540, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xe51e0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xe57a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0xe6740, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0xe68c0, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($EditLevelLayer::*)(UploadActionPopup*)){&$EditLevelLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0xe66f0, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJMessagePopup : public GJMessagePopup, public $CacBase {
public:
    dupable ~$GJMessagePopup() override {}

    dupable void keyBackClicked() {
        if ((void($GJMessagePopup::*)()){&$GJMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1504a0))(this);
        else return GJMessagePopup::keyBackClicked();
    }

    dupable void downloadMessageFinished(GJUserMessage* p0) {
        if ((void($GJMessagePopup::*)(GJUserMessage*)){&$GJMessagePopup::downloadMessageFinished} != (void(D::*)(GJUserMessage*)){&D::downloadMessageFinished})
            return reinterpret_cast<void(*)(decltype(this), GJUserMessage*)>(m->getOriginal(base+0x150510))(this, p0);
        else return GJMessagePopup::downloadMessageFinished(p0);
    }

    dupable void downloadMessageFailed(int p0) {
        if ((void($GJMessagePopup::*)(int)){&$GJMessagePopup::downloadMessageFailed} != (void(D::*)(int)){&D::downloadMessageFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1505e0))(this, p0);
        else return GJMessagePopup::downloadMessageFailed(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x150680))(this, p0, p1);
        else return GJMessagePopup::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x150820))(this, p0, p1);
        else return GJMessagePopup::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($GJMessagePopup::*)(UploadActionPopup*)){&$GJMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x150900))(this, p0);
        else return GJMessagePopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJMessagePopup::*)(FLAlertLayer*, bool)){&$GJMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x150a00))(this, p0, p1);
        else return GJMessagePopup::FLAlert_Clicked(p0, p1);
    }

    dupable $GJMessagePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMessagePopup::*)()){&$GJMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1504a0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMessagePopup::*)(GJUserMessage*)){&$GJMessagePopup::downloadMessageFinished} != (void(D::*)(GJUserMessage*)){&D::downloadMessageFinished})
            m->registerHook(base+0x150510, extract((void(D::*)(GJUserMessage*)){&D::downloadMessageFinished}));

        if ((void($GJMessagePopup::*)(int)){&$GJMessagePopup::downloadMessageFailed} != (void(D::*)(int)){&D::downloadMessageFailed})
            m->registerHook(base+0x1505e0, extract((void(D::*)(int)){&D::downloadMessageFailed}));

        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x150680, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x150820, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJMessagePopup::*)(UploadActionPopup*)){&$GJMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x150900, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($GJMessagePopup::*)(FLAlertLayer*, bool)){&$GJMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x150a00, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJOptionsLayer : public GJOptionsLayer, public $CacBase {
public:
    dupable ~$GJOptionsLayer() override {}

    dupable bool init() {
        if ((bool($GJOptionsLayer::*)()){&$GJOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x145c60))(this);
        else return GJOptionsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x147190))(this);
        else return GJOptionsLayer::keyBackClicked();
    }

    dupable void setupOptions() {
        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1464d0))(this);
        else return GJOptionsLayer::setupOptions();
    }

    dupable void onClose(cocos2d::CCObject* p0) {
        if ((void($GJOptionsLayer::*)(cocos2d::CCObject*)){&$GJOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x147160))(this, p0);
        else return GJOptionsLayer::onClose(p0);
    }

    dupable $GJOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJOptionsLayer::*)()){&$GJOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x145c60, extract((bool(D::*)()){&D::init}));

        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x147190, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            m->registerHook(base+0x1464d0, extract((void(D::*)()){&D::setupOptions}));

        if ((void($GJOptionsLayer::*)(cocos2d::CCObject*)){&$GJOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            m->registerHook(base+0x147160, extract((void(D::*)(cocos2d::CCObject*)){&D::onClose}));
    }
};


template<class D>
class $GJRewardObject : public GJRewardObject, public $CacBase {
public:
    dupable ~$GJRewardObject() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) {
        if ((void($GJRewardObject::*)(DS_Dictionary*)){&$GJRewardObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4d170))(this, p0);
        else return GJRewardObject::encodeWithCoder(p0);
    }

    dupable void canEncode() {
        if ((void($GJRewardObject::*)()){&$GJRewardObject::canEncode} != (void(D::*)()){&D::canEncode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4d1f0))(this);
        else return GJRewardObject::canEncode();
    }

    dupable $GJRewardObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRewardObject::*)(DS_Dictionary*)){&$GJRewardObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4d170, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($GJRewardObject::*)()){&$GJRewardObject::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(base+0x4d1f0, extract((void(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GJScaleControl : public GJScaleControl, public $CacBase {
public:
    dupable ~$GJScaleControl() override {}

    dupable bool init() {
        if ((bool($GJScaleControl::*)()){&$GJScaleControl::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x31b30))(this);
        else return GJScaleControl::init();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31d30))(this, p0, p1);
        else return GJScaleControl::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31e60))(this, p0, p1);
        else return GJScaleControl::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31fb0))(this, p0, p1);
        else return GJScaleControl::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x32060))(this, p0, p1);
        else return GJScaleControl::ccTouchCancelled(p0, p1);
    }

    dupable $GJScaleControl() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJScaleControl::*)()){&$GJScaleControl::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x31b30, extract((bool(D::*)()){&D::init}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x31d30, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x31e60, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x31fb0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x32060, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $GJSearchObject : public GJSearchObject, public $CacBase {
public:
    dupable ~$GJSearchObject() override {}

    dupable $GJSearchObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJSpiderSprite : public GJSpiderSprite, public $CacBase {
public:
    dupable ~$GJSpiderSprite() override {}

    dupable bool init() {
        if ((bool($GJSpiderSprite::*)()){&$GJSpiderSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x34c700))(this);
        else return GJSpiderSprite::init();
    }

    dupable $GJSpiderSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJSpiderSprite::*)()){&$GJSpiderSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x34c700, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameObjectCopy : public GameObjectCopy, public $CacBase {
public:
    dupable ~$GameObjectCopy() override {}

    dupable $GameObjectCopy() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $HSVWidgetPopup : public HSVWidgetPopup, public $CacBase {
public:
    dupable ~$HSVWidgetPopup() override {}

    dupable void keyBackClicked() {
        if ((void($HSVWidgetPopup::*)()){&$HSVWidgetPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2371e0))(this);
        else return HSVWidgetPopup::keyBackClicked();
    }

    dupable $HSVWidgetPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($HSVWidgetPopup::*)()){&$HSVWidgetPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2371e0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LevelInfoLayer : public LevelInfoLayer, public $CacBase {
public:
    dupable ~$LevelInfoLayer() override {}

    dupable void keyBackClicked() {
        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x166160))(this);
        else return LevelInfoLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($LevelInfoLayer::*)(cocos2d::enumKeyCodes)){&$LevelInfoLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x166190))(this, p0);
        else return LevelInfoLayer::keyDown(p0);
    }

    dupable void numberInputClosed(NumberInputLayer* p0) {
        if ((void($LevelInfoLayer::*)(NumberInputLayer*)){&$LevelInfoLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            return reinterpret_cast<void(*)(decltype(this), NumberInputLayer*)>(m->getOriginal(base+0x1657a0))(this, p0);
        else return LevelInfoLayer::numberInputClosed(p0);
    }

    dupable void levelDownloadFinished(GJGameLevel* p0) {
        if ((void($LevelInfoLayer::*)(GJGameLevel*)){&$LevelInfoLayer::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x164c00))(this, p0);
        else return LevelInfoLayer::levelDownloadFinished(p0);
    }

    dupable void levelDownloadFailed(int p0) {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x164d50))(this, p0);
        else return LevelInfoLayer::levelDownloadFailed(p0);
    }

    dupable void levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) {
        if ((void($LevelInfoLayer::*)(GJGameLevel*, UpdateResponse)){&$LevelInfoLayer::levelUpdateFinished} != (void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*, UpdateResponse)>(m->getOriginal(base+0x164e60))(this, p0, p1);
        else return LevelInfoLayer::levelUpdateFinished(p0, p1);
    }

    dupable void levelUpdateFailed(int p0) {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelUpdateFailed} != (void(D::*)(int)){&D::levelUpdateFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165010))(this, p0);
        else return LevelInfoLayer::levelUpdateFailed(p0);
    }

    dupable void levelDeleteFinished(int p0) {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFinished} != (void(D::*)(int)){&D::levelDeleteFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165120))(this, p0);
        else return LevelInfoLayer::levelDeleteFinished(p0);
    }

    dupable void levelDeleteFailed(int p0) {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFailed} != (void(D::*)(int)){&D::levelDeleteFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165230))(this, p0);
        else return LevelInfoLayer::levelDeleteFailed(p0);
    }

    dupable void rateLevelClosed() {
        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::rateLevelClosed} != (void(D::*)()){&D::rateLevelClosed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x165e60))(this);
        else return LevelInfoLayer::rateLevelClosed();
    }

    dupable void likedItem(LikeItemType p0, int p1, bool p2) {
        if ((void($LevelInfoLayer::*)(LikeItemType, int, bool)){&$LevelInfoLayer::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            return reinterpret_cast<void(*)(decltype(this), LikeItemType, int, bool)>(m->getOriginal(base+0x165e90))(this, p0, p1, p2);
        else return LevelInfoLayer::likedItem(p0, p1, p2);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($LevelInfoLayer::*)(FLAlertLayer*, bool)){&$LevelInfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x165f90))(this, p0, p1);
        else return LevelInfoLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) {
        if ((void($LevelInfoLayer::*)(SetIDPopup*, int)){&$LevelInfoLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0x163e60))(this, p0, p1);
        else return LevelInfoLayer::setIDPopupClosed(p0, p1);
    }

    dupable $LevelInfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x166160, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelInfoLayer::*)(cocos2d::enumKeyCodes)){&$LevelInfoLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x166190, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelInfoLayer::*)(NumberInputLayer*)){&$LevelInfoLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            m->registerHook(base+0x1657a0, extract((void(D::*)(NumberInputLayer*)){&D::numberInputClosed}));

        if ((void($LevelInfoLayer::*)(GJGameLevel*)){&$LevelInfoLayer::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            m->registerHook(base+0x164c00, extract((void(D::*)(GJGameLevel*)){&D::levelDownloadFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            m->registerHook(base+0x164d50, extract((void(D::*)(int)){&D::levelDownloadFailed}));

        if ((void($LevelInfoLayer::*)(GJGameLevel*, UpdateResponse)){&$LevelInfoLayer::levelUpdateFinished} != (void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished})
            m->registerHook(base+0x164e60, extract((void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelUpdateFailed} != (void(D::*)(int)){&D::levelUpdateFailed})
            m->registerHook(base+0x165010, extract((void(D::*)(int)){&D::levelUpdateFailed}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFinished} != (void(D::*)(int)){&D::levelDeleteFinished})
            m->registerHook(base+0x165120, extract((void(D::*)(int)){&D::levelDeleteFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFailed} != (void(D::*)(int)){&D::levelDeleteFailed})
            m->registerHook(base+0x165230, extract((void(D::*)(int)){&D::levelDeleteFailed}));

        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::rateLevelClosed} != (void(D::*)()){&D::rateLevelClosed})
            m->registerHook(base+0x165e60, extract((void(D::*)()){&D::rateLevelClosed}));

        if ((void($LevelInfoLayer::*)(LikeItemType, int, bool)){&$LevelInfoLayer::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            m->registerHook(base+0x165e90, extract((void(D::*)(LikeItemType, int, bool)){&D::likedItem}));

        if ((void($LevelInfoLayer::*)(FLAlertLayer*, bool)){&$LevelInfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x165f90, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelInfoLayer::*)(SetIDPopup*, int)){&$LevelInfoLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0x163e60, extract((void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $RateDemonLayer : public RateDemonLayer, public $CacBase {
public:
    dupable ~$RateDemonLayer() override {}

    dupable void keyBackClicked() {
        if ((void($RateDemonLayer::*)()){&$RateDemonLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12ec20))(this);
        else return RateDemonLayer::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x12e960))(this, p0, p1);
        else return RateDemonLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x12ea40))(this, p0, p1);
        else return RateDemonLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($RateDemonLayer::*)(UploadActionPopup*)){&$RateDemonLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x12eb40))(this, p0);
        else return RateDemonLayer::onClosePopup(p0);
    }

    dupable $RateDemonLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateDemonLayer::*)()){&$RateDemonLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12ec20, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x12e960, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x12ea40, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($RateDemonLayer::*)(UploadActionPopup*)){&$RateDemonLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x12eb40, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $RateLevelLayer : public RateLevelLayer, public $CacBase {
public:
    dupable ~$RateLevelLayer() override {}

    dupable void keyBackClicked() {
        if ((void($RateLevelLayer::*)()){&$RateLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e2250))(this);
        else return RateLevelLayer::keyBackClicked();
    }

    dupable $RateLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateLevelLayer::*)()){&$RateLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2e2250, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $RateStarsLayer : public RateStarsLayer, public $CacBase {
public:
    dupable ~$RateStarsLayer() override {}

    dupable void keyBackClicked() {
        if ((void($RateStarsLayer::*)()){&$RateStarsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x136ec0))(this);
        else return RateStarsLayer::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x136c10))(this, p0, p1);
        else return RateStarsLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x136cf0))(this, p0, p1);
        else return RateStarsLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($RateStarsLayer::*)(UploadActionPopup*)){&$RateStarsLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x136de0))(this, p0);
        else return RateStarsLayer::onClosePopup(p0);
    }

    dupable $RateStarsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateStarsLayer::*)()){&$RateStarsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x136ec0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x136c10, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x136cf0, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($RateStarsLayer::*)(UploadActionPopup*)){&$RateStarsLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x136de0, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $ScrollingLayer : public ScrollingLayer, public $CacBase {
public:
    dupable ~$ScrollingLayer() override {}

    dupable void draw() {
        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x41abc0))(this);
        else return ScrollingLayer::draw();
    }

    dupable void visit() {
        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x41acb0))(this);
        else return ScrollingLayer::visit();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41ae10))(this, p0, p1);
        else return ScrollingLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41afb0))(this, p0, p1);
        else return ScrollingLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41b0d0))(this, p0, p1);
        else return ScrollingLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41b110))(this, p0, p1);
        else return ScrollingLayer::ccTouchCancelled(p0, p1);
    }

    dupable $ScrollingLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x41abc0, extract((void(D::*)()){&D::draw}));

        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x41acb0, extract((void(D::*)()){&D::visit}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x41ae10, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x41afb0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x41b0d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x41b110, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $SelectArtLayer : public SelectArtLayer, public $CacBase {
public:
    dupable ~$SelectArtLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SelectArtLayer::*)()){&$SelectArtLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xad440))(this);
        else return SelectArtLayer::keyBackClicked();
    }

    dupable $SelectArtLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SelectArtLayer::*)()){&$SelectArtLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xad440, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetFolderPopup : public SetFolderPopup, public $CacBase {
public:
    dupable ~$SetFolderPopup() override {}

    dupable void valueChanged() {
        if ((void($SetFolderPopup::*)()){&$SetFolderPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x155d40))(this);
        else return SetFolderPopup::valueChanged();
    }

    dupable void setTextPopupClosed(SetTextPopup* p0, std::string p1) {
        if ((void($SetFolderPopup::*)(SetTextPopup*, std::string)){&$SetFolderPopup::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetTextPopup*, std::string)>(m->getOriginal(base+0x1561b0))(this, p0, p1);
        else return SetFolderPopup::setTextPopupClosed(p0, p1);
    }

    dupable $SetFolderPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetFolderPopup::*)()){&$SetFolderPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            m->registerHook(base+0x155d40, extract((void(D::*)()){&D::valueChanged}));

        if ((void($SetFolderPopup::*)(SetTextPopup*, std::string)){&$SetFolderPopup::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            m->registerHook(base+0x1561b0, extract((void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed}));
    }
};


template<class D>
class $SetItemIDLayer : public SetItemIDLayer, public $CacBase {
public:
    dupable ~$SetItemIDLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5bb90))(this);
        else return SetItemIDLayer::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5bb40))(this);
        else return SetItemIDLayer::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5b9e0))(this, p0);
        else return SetItemIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5ba20))(this, p0);
        else return SetItemIDLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*, float)){&$SetItemIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x5bca0))(this, p0, p1);
        else return SetItemIDLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5bd60))(this, p0);
        else return SetItemIDLayer::textInputReturn(p0);
    }

    dupable $SetItemIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x5bb90, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x5bb40, extract((void(D::*)()){&D::show}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x5b9e0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x5ba20, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*, float)){&$SetItemIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x5bca0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x5bd60, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SongInfoObject : public SongInfoObject, public $CacBase {
public:
    dupable ~$SongInfoObject() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) {
        if ((void($SongInfoObject::*)(DS_Dictionary*)){&$SongInfoObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x2f2c70))(this, p0);
        else return SongInfoObject::encodeWithCoder(p0);
    }

    dupable void canEncode() {
        if ((void($SongInfoObject::*)()){&$SongInfoObject::canEncode} != (void(D::*)()){&D::canEncode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2f2da0))(this);
        else return SongInfoObject::canEncode();
    }

    dupable $SongInfoObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongInfoObject::*)(DS_Dictionary*)){&$SongInfoObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x2f2c70, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($SongInfoObject::*)()){&$SongInfoObject::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(base+0x2f2da0, extract((void(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $StartPosObject : public StartPosObject, public $CacBase {
public:
    dupable ~$StartPosObject() override {}

    dupable bool init() {
        if ((bool($StartPosObject::*)()){&$StartPosObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xda8a0))(this);
        else return StartPosObject::init();
    }

    dupable void getSaveString() {
        if ((void($StartPosObject::*)()){&$StartPosObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xda960))(this);
        else return StartPosObject::getSaveString();
    }

    dupable $StartPosObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($StartPosObject::*)()){&$StartPosObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xda8a0, extract((bool(D::*)()){&D::init}));

        if ((void($StartPosObject::*)()){&$StartPosObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xda960, extract((void(D::*)()){&D::getSaveString}));
    }
};


template<class D>
class $WorldLevelPage : public WorldLevelPage, public $CacBase {
public:
    dupable ~$WorldLevelPage() override {}

    dupable void keyBackClicked() {
        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x204300))(this);
        else return WorldLevelPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2041c0))(this);
        else return WorldLevelPage::show();
    }

    dupable $WorldLevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x204300, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2041c0, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $AchievementCell : public AchievementCell, public $CacBase {
public:
    dupable ~$AchievementCell() override {}

    dupable bool init() {
        if ((bool($AchievementCell::*)()){&$AchievementCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x117730))(this);
        else return AchievementCell::init();
    }

    dupable void draw() {
        if ((void($AchievementCell::*)()){&$AchievementCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x117740))(this);
        else return AchievementCell::draw();
    }

    dupable $AchievementCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementCell::*)()){&$AchievementCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x117730, extract((bool(D::*)()){&D::init}));

        if ((void($AchievementCell::*)()){&$AchievementCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x117740, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $BoomScrollLayer : public BoomScrollLayer, public $CacBase {
public:
    dupable ~$BoomScrollLayer() override {}

    dupable void visit() {
        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1e2f80))(this);
        else return BoomScrollLayer::visit();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3c40))(this, p0, p1);
        else return BoomScrollLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3d90))(this, p0, p1);
        else return BoomScrollLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3ff0))(this, p0, p1);
        else return BoomScrollLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3b40))(this, p0, p1);
        else return BoomScrollLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1e3970))(this);
        else return BoomScrollLayer::registerWithTouchDispatcher();
    }

    dupable $BoomScrollLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x1e2f80, extract((void(D::*)()){&D::visit}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x1e3c40, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x1e3d90, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x1e3ff0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x1e3b40, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1e3970, extract((void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
public:
    dupable ~$CCNodeContainer() override {}

    dupable bool init() {
        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xba950))(this);
        else return CCNodeContainer::init();
    }

    dupable void visit() {
        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xba960))(this);
        else return CCNodeContainer::visit();
    }

    dupable $CCNodeContainer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xba950, extract((bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0xba960, extract((void(D::*)()){&D::visit}));
    }
};


template<class D>
class $CCSpriteWithHue : public CCSpriteWithHue, public $CacBase {
public:
    dupable ~$CCSpriteWithHue() override {}

    dupable void draw() {
        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35a400))(this);
        else return CCSpriteWithHue::draw();
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0) {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x359d10))(this, p0);
        else return CCSpriteWithHue::initWithTexture(p0);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(base+0x359d80))(this, p0, p1);
        else return CCSpriteWithHue::initWithTexture(p0, p1);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(base+0x359b80))(this, p0, p1, p2);
        else return CCSpriteWithHue::initWithTexture(p0, p1, p2);
    }

    dupable void initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCSpriteFrame*)){&$CCSpriteWithHue::initWithSpriteFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x359da0))(this, p0);
        else return CCSpriteWithHue::initWithSpriteFrame(p0);
    }

    dupable void updateColor() {
        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::updateColor} != (void(D::*)()){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x359f70))(this);
        else return CCSpriteWithHue::updateColor();
    }

    dupable $CCSpriteWithHue() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x35a400, extract((void(D::*)()){&D::draw}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x359d10, extract((void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture})
            m->registerHook(base+0x359d80, extract((void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture})
            m->registerHook(base+0x359b80, extract((void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCSpriteFrame*)){&$CCSpriteWithHue::initWithSpriteFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame})
            m->registerHook(base+0x359da0, extract((void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame}));

        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::updateColor} != (void(D::*)()){&D::updateColor})
            m->registerHook(base+0x359f70, extract((void(D::*)()){&D::updateColor}));
    }
};


template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
public:
    dupable ~$CCTextInputNode() override {}

    dupable void visit() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5d380))(this);
        else return CCTextInputNode::visit();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ec80))(this, p0, p1);
        else return CCTextInputNode::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5eea0))(this, p0, p1);
        else return CCTextInputNode::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee60))(this, p0, p1);
        else return CCTextInputNode::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee80))(this, p0, p1);
        else return CCTextInputNode::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5eec0))(this);
        else return CCTextInputNode::registerWithTouchDispatcher();
    }

    dupable void textChanged() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5dd70))(this);
        else return CCTextInputNode::textChanged();
    }

    dupable void onClickTrackNode(bool p0) {
        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x5dd40))(this, p0);
        else return CCTextInputNode::onClickTrackNode(p0);
    }

    dupable void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dad0))(this, p0);
        else return CCTextInputNode::keyboardWillShow(p0);
    }

    dupable void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dc20))(this, p0);
        else return CCTextInputNode::keyboardWillHide(p0);
    }

    dupable void onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (void(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTextFieldTTF*, char const*, int)>(m->getOriginal(base+0x5de50))(this, p0, p1, p2);
        else return CCTextInputNode::onTextFieldInsertText(p0, p1, p2);
    }

    dupable void onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e2c0))(this, p0);
        else return CCTextInputNode::onTextFieldAttachWithIME(p0);
    }

    dupable void onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) {
        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e610))(this, p0);
        else return CCTextInputNode::onTextFieldDetachWithIME(p0);
    }

    dupable $CCTextInputNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x5d380, extract((void(D::*)()){&D::visit}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x5ec80, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x5eea0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x5ee60, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x5ee80, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x5eec0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            m->registerHook(base+0x5dd70, extract((void(D::*)()){&D::textChanged}));

        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            m->registerHook(base+0x5dd40, extract((void(D::*)(bool)){&D::onClickTrackNode}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            m->registerHook(base+0x5dad0, extract((void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            m->registerHook(base+0x5dc20, extract((void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (void(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            m->registerHook(base+0x5de50, extract((void(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            m->registerHook(base+0x5e2c0, extract((void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            m->registerHook(base+0x5e610, extract((void(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME}));
    }
};


template<class D>
class $CustomSongLayer : public CustomSongLayer, public $CacBase {
public:
    dupable ~$CustomSongLayer() override {}

    dupable void keyBackClicked() {
        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf21c0))(this);
        else return CustomSongLayer::keyBackClicked();
    }

    dupable void show() {
        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf22a0))(this);
        else return CustomSongLayer::show();
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1fb0))(this, p0);
        else return CustomSongLayer::textChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1f10))(this, p0);
        else return CustomSongLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1e70))(this, p0);
        else return CustomSongLayer::textInputClosed(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($CustomSongLayer::*)(CCTextInputNode*, float)){&$CustomSongLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0xf1fd0))(this, p0, p1);
        else return CustomSongLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf2090))(this, p0);
        else return CustomSongLayer::textInputReturn(p0);
    }

    dupable void dropDownLayerWillClose(GJDropDownLayer* p0) {
        if ((void($CustomSongLayer::*)(GJDropDownLayer*)){&$CustomSongLayer::dropDownLayerWillClose} != (void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose})
            return reinterpret_cast<void(*)(decltype(this), GJDropDownLayer*)>(m->getOriginal(base+0xf2140))(this, p0);
        else return CustomSongLayer::dropDownLayerWillClose(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($CustomSongLayer::*)(FLAlertLayer*, bool)){&$CustomSongLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xf1be0))(this, p0, p1);
        else return CustomSongLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $CustomSongLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf21c0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0xf22a0, extract((void(D::*)()){&D::show}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xf1fb0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xf1f10, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xf1e70, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*, float)){&$CustomSongLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0xf1fd0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0xf2090, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($CustomSongLayer::*)(GJDropDownLayer*)){&$CustomSongLayer::dropDownLayerWillClose} != (void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose})
            m->registerHook(base+0xf2140, extract((void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose}));

        if ((void($CustomSongLayer::*)(FLAlertLayer*, bool)){&$CustomSongLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xf1be0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EndPortalObject : public EndPortalObject, public $CacBase {
public:
    dupable ~$EndPortalObject() override {}

    dupable bool init() {
        if ((bool($EndPortalObject::*)()){&$EndPortalObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1da980))(this);
        else return EndPortalObject::init();
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($EndPortalObject::*)(cocos2d::CCPoint const&)){&$EndPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x1dae70))(this, p0);
        else return EndPortalObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) {
        if ((void($EndPortalObject::*)(bool)){&$EndPortalObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1daf30))(this, p0);
        else return EndPortalObject::setVisible(p0);
    }

    dupable void triggerObject(GJBaseGameLayer* p0) {
        if ((void($EndPortalObject::*)(GJBaseGameLayer*)){&$EndPortalObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0x1dadc0))(this, p0);
        else return EndPortalObject::triggerObject(p0);
    }

    dupable void calculateSpawnXPos() {
        if ((void($EndPortalObject::*)()){&$EndPortalObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dae50))(this);
        else return EndPortalObject::calculateSpawnXPos();
    }

    dupable $EndPortalObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($EndPortalObject::*)()){&$EndPortalObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1da980, extract((bool(D::*)()){&D::init}));

        if ((void($EndPortalObject::*)(cocos2d::CCPoint const&)){&$EndPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x1dae70, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($EndPortalObject::*)(bool)){&$EndPortalObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x1daf30, extract((void(D::*)(bool)){&D::setVisible}));

        if ((void($EndPortalObject::*)(GJBaseGameLayer*)){&$EndPortalObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0x1dadc0, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($EndPortalObject::*)()){&$EndPortalObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(base+0x1dae50, extract((void(D::*)()){&D::calculateSpawnXPos}));
    }
};


template<class D>
class $FileSaveManager : public FileSaveManager, public $CacBase {
public:
    dupable ~$FileSaveManager() override {}

    dupable bool init() {
        if ((bool($FileSaveManager::*)()){&$FileSaveManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x6360))(this);
        else return FileSaveManager::init();
    }

    dupable void firstLoad() {
        if ((void($FileSaveManager::*)()){&$FileSaveManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6390))(this);
        else return FileSaveManager::firstLoad();
    }

    dupable $FileSaveManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($FileSaveManager::*)()){&$FileSaveManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x6360, extract((bool(D::*)()){&D::init}));

        if ((void($FileSaveManager::*)()){&$FileSaveManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x6390, extract((void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $GJBaseGameLayer : public GJBaseGameLayer, public $CacBase {
public:
    dupable ~$GJBaseGameLayer() override {}

    dupable bool init() {
        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xafc90))(this);
        else return GJBaseGameLayer::init();
    }

    dupable void objectsCollided(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xb6d90))(this, p0, p1);
        else return GJBaseGameLayer::objectsCollided(p0, p1);
    }

    dupable void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(base+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJBaseGameLayer::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return GJBaseGameLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0xba990))(this, p0, p1, p2);
        else return GJBaseGameLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
        else return GJBaseGameLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void toggleGroupTriggered(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0xb75a0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroupTriggered(p0, p1);
    }

    dupable void spawnGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb7050))(this, p0);
        else return GJBaseGameLayer::spawnGroup(p0);
    }

    dupable void addToSection(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb7b70))(this, p0);
        else return GJBaseGameLayer::addToSection(p0);
    }

    dupable void addToGroup(GameObject* p0, int p1, bool p2) {
        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(base+0xb77f0))(this, p0, p1, p2);
        else return GJBaseGameLayer::addToGroup(p0, p1, p2);
    }

    dupable void removeFromGroup(GameObject* p0, int p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(base+0xb7a60))(this, p0, p1);
        else return GJBaseGameLayer::removeFromGroup(p0, p1);
    }

    dupable $GJBaseGameLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xafc90, extract((bool(D::*)()){&D::init}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(base+0xb6d90, extract((void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(base+0xb73a0, extract((void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0xb7420, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0xba990, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0xba9a0, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            m->registerHook(base+0xb75a0, extract((void(D::*)(int, bool)){&D::toggleGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            m->registerHook(base+0xb7050, extract((void(D::*)(int)){&D::spawnGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            m->registerHook(base+0xb7b70, extract((void(D::*)(GameObject*)){&D::addToSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(base+0xb77f0, extract((void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(base+0xb7a60, extract((void(D::*)(GameObject*, int)){&D::removeFromGroup}));
    }
};


template<class D>
class $GJChallengeItem : public GJChallengeItem, public $CacBase {
public:
    dupable ~$GJChallengeItem() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) {
        if ((void($GJChallengeItem::*)(DS_Dictionary*)){&$GJChallengeItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4df60))(this, p0);
        else return GJChallengeItem::encodeWithCoder(p0);
    }

    dupable void canEncode() {
        if ((void($GJChallengeItem::*)()){&$GJChallengeItem::canEncode} != (void(D::*)()){&D::canEncode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4e020))(this);
        else return GJChallengeItem::canEncode();
    }

    dupable $GJChallengeItem() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJChallengeItem::*)(DS_Dictionary*)){&$GJChallengeItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4df60, extract((void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((void($GJChallengeItem::*)()){&$GJChallengeItem::canEncode} != (void(D::*)()){&D::canEncode})
            m->registerHook(base+0x4e020, extract((void(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GJDropDownLayer : public GJDropDownLayer, public $CacBase {
public:
    dupable ~$GJDropDownLayer() override {}

    dupable void draw() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352910))(this);
        else return GJDropDownLayer::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352940))(this, p0, p1);
        else return GJDropDownLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x3529a0))(this, p0, p1);
        else return GJDropDownLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352960))(this, p0, p1);
        else return GJDropDownLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352980))(this, p0, p1);
        else return GJDropDownLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525f0))(this);
        else return GJDropDownLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352630))(this);
        else return GJDropDownLayer::keyBackClicked();
    }

    dupable void customSetup() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352570))(this);
        else return GJDropDownLayer::customSetup();
    }

    dupable void enterLayer() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525c0))(this);
        else return GJDropDownLayer::enterLayer();
    }

    dupable void exitLayer(cocos2d::CCObject* p0) {
        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x352670))(this, p0);
        else return GJDropDownLayer::exitLayer(p0);
    }

    dupable void showLayer(bool p0) {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x3526c0))(this, p0);
        else return GJDropDownLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x3527b0))(this, p0);
        else return GJDropDownLayer::hideLayer(p0);
    }

    dupable void layerVisible() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528b0))(this);
        else return GJDropDownLayer::layerVisible();
    }

    dupable void layerHidden() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528d0))(this);
        else return GJDropDownLayer::layerHidden();
    }

    dupable void enterAnimFinished() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528a0))(this);
        else return GJDropDownLayer::enterAnimFinished();
    }

    dupable void disableUI() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352580))(this);
        else return GJDropDownLayer::disableUI();
    }

    dupable void enableUI() {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525a0))(this);
        else return GJDropDownLayer::enableUI();
    }

    dupable $GJDropDownLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x352910, extract((void(D::*)()){&D::draw}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x352940, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x3529a0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x352960, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x352980, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x3525f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x352630, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x352570, extract((void(D::*)()){&D::customSetup}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x3525c0, extract((void(D::*)()){&D::enterLayer}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(base+0x352670, extract((void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x3526c0, extract((void(D::*)(bool)){&D::showLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x3527b0, extract((void(D::*)(bool)){&D::hideLayer}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x3528b0, extract((void(D::*)()){&D::layerVisible}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x3528d0, extract((void(D::*)()){&D::layerHidden}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x3528a0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x352580, extract((void(D::*)()){&D::disableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x3525a0, extract((void(D::*)()){&D::enableUI}));
    }
};


template<class D>
class $GJEffectManager : public GJEffectManager, public $CacBase {
public:
    dupable ~$GJEffectManager() override {}

    dupable bool init() {
        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x180230))(this);
        else return GJEffectManager::init();
    }

    dupable $GJEffectManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x180230, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJFriendRequest : public GJFriendRequest, public $CacBase {
public:
    dupable ~$GJFriendRequest() override {}

    dupable bool init() {
        if ((bool($GJFriendRequest::*)()){&$GJFriendRequest::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2dea00))(this);
        else return GJFriendRequest::init();
    }

    dupable $GJFriendRequest() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJFriendRequest::*)()){&$GJFriendRequest::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2dea00, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJObjectDecoder : public GJObjectDecoder, public $CacBase {
public:
    dupable ~$GJObjectDecoder() override {}

    dupable bool init() {
        if ((bool($GJObjectDecoder::*)()){&$GJObjectDecoder::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x41e780))(this);
        else return GJObjectDecoder::init();
    }

    dupable void getDecodedObject(int p0, DS_Dictionary* p1) {
        if ((void($GJObjectDecoder::*)(int, DS_Dictionary*)){&$GJObjectDecoder::getDecodedObject} != (void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject})
            return reinterpret_cast<void(*)(decltype(this), int, DS_Dictionary*)>(m->getOriginal(base+0x41e790))(this, p0, p1);
        else return GJObjectDecoder::getDecodedObject(p0, p1);
    }

    dupable $GJObjectDecoder() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJObjectDecoder::*)()){&$GJObjectDecoder::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x41e780, extract((bool(D::*)()){&D::init}));

        if ((void($GJObjectDecoder::*)(int, DS_Dictionary*)){&$GJObjectDecoder::getDecodedObject} != (void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject})
            m->registerHook(base+0x41e790, extract((void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject}));
    }
};


template<class D>
class $InfoAlertButton : public InfoAlertButton, public $CacBase {
public:
    dupable ~$InfoAlertButton() override {}

    dupable void activate() {
        if ((void($InfoAlertButton::*)()){&$InfoAlertButton::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2ecd70))(this);
        else return InfoAlertButton::activate();
    }

    dupable $InfoAlertButton() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($InfoAlertButton::*)()){&$InfoAlertButton::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x2ecd70, extract((void(D::*)()){&D::activate}));
    }
};


template<class D>
class $LabelGameObject : public LabelGameObject, public $CacBase {
public:
    dupable ~$LabelGameObject() override {}

    dupable bool init() {
        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xdb990))(this);
        else return LabelGameObject::init();
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($LabelGameObject::*)(unsigned char)){&$LabelGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0xdba40))(this, p0);
        else return LabelGameObject::setOpacity(p0);
    }

    dupable void setupCustomSprites() {
        if ((void($LabelGameObject::*)()){&$LabelGameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdb9b0))(this);
        else return LabelGameObject::setupCustomSprites();
    }

    dupable void addMainSpriteToParent(bool p0) {
        if ((void($LabelGameObject::*)(bool)){&$LabelGameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdbce0))(this, p0);
        else return LabelGameObject::addMainSpriteToParent(p0);
    }

    dupable void getSaveString() {
        if ((void($LabelGameObject::*)()){&$LabelGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdbd50))(this);
        else return LabelGameObject::getSaveString();
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) {
        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xdbca0))(this, p0);
        else return LabelGameObject::setObjectColor(p0);
    }

    dupable $LabelGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xdb990, extract((bool(D::*)()){&D::init}));

        if ((void($LabelGameObject::*)(unsigned char)){&$LabelGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0xdba40, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($LabelGameObject::*)()){&$LabelGameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(base+0xdb9b0, extract((void(D::*)()){&D::setupCustomSprites}));

        if ((void($LabelGameObject::*)(bool)){&$LabelGameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(base+0xdbce0, extract((void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($LabelGameObject::*)()){&$LabelGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xdbd50, extract((void(D::*)()){&D::getSaveString}));

        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0xdbca0, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));
    }
};


template<class D>
class $MoreSearchLayer : public MoreSearchLayer, public $CacBase {
public:
    dupable ~$MoreSearchLayer() override {}

    dupable bool init() {
        if ((bool($MoreSearchLayer::*)()){&$MoreSearchLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3896b0))(this);
        else return MoreSearchLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($MoreSearchLayer::*)()){&$MoreSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38b820))(this);
        else return MoreSearchLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($MoreSearchLayer::*)(CCTextInputNode*, float)){&$MoreSearchLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x38b6b0))(this, p0, p1);
        else return MoreSearchLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($MoreSearchLayer::*)(CCTextInputNode*)){&$MoreSearchLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x38b770))(this, p0);
        else return MoreSearchLayer::textInputReturn(p0);
    }

    dupable $MoreSearchLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreSearchLayer::*)()){&$MoreSearchLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3896b0, extract((bool(D::*)()){&D::init}));

        if ((void($MoreSearchLayer::*)()){&$MoreSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x38b820, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MoreSearchLayer::*)(CCTextInputNode*, float)){&$MoreSearchLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x38b6b0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($MoreSearchLayer::*)(CCTextInputNode*)){&$MoreSearchLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x38b770, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $RetryLevelLayer : public RetryLevelLayer, public $CacBase {
public:
    dupable ~$RetryLevelLayer() override {}

    dupable void keyBackClicked() {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28ed10))(this);
        else return RetryLevelLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x28ec30))(this, p0);
        else return RetryLevelLayer::keyDown(p0);
    }

    dupable void customSetup() {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28de80))(this);
        else return RetryLevelLayer::customSetup();
    }

    dupable void showLayer(bool p0) {
        if ((void($RetryLevelLayer::*)(bool)){&$RetryLevelLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x28eaf0))(this, p0);
        else return RetryLevelLayer::showLayer(p0);
    }

    dupable void enterAnimFinished() {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28ebf0))(this);
        else return RetryLevelLayer::enterAnimFinished();
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) {
        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x28ecf0))(this, p0);
        else return RetryLevelLayer::keyUp(p0);
    }

    dupable $RetryLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x28ed10, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x28ec30, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x28de80, extract((void(D::*)()){&D::customSetup}));

        if ((void($RetryLevelLayer::*)(bool)){&$RetryLevelLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x28eaf0, extract((void(D::*)(bool)){&D::showLayer}));

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x28ebf0, extract((void(D::*)()){&D::enterAnimFinished}));

        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x28ecf0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $SelectFontLayer : public SelectFontLayer, public $CacBase {
public:
    dupable ~$SelectFontLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SelectFontLayer::*)()){&$SelectFontLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1445f0))(this);
        else return SelectFontLayer::keyBackClicked();
    }

    dupable $SelectFontLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SelectFontLayer::*)()){&$SelectFontLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1445f0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetGroupIDLayer : public SetGroupIDLayer, public $CacBase {
public:
    dupable ~$SetGroupIDLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x198050))(this);
        else return SetGroupIDLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x197ab0))(this, p0);
        else return SetGroupIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x197af0))(this, p0);
        else return SetGroupIDLayer::textChanged(p0);
    }

    dupable $SetGroupIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x198050, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x197ab0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x197af0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $SetupPulsePopup : public SetupPulsePopup, public $CacBase {
public:
    dupable ~$SetupPulsePopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1ec840))(this);
        else return SetupPulsePopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1ec870))(this);
        else return SetupPulsePopup::show();
    }

    dupable void colorValueChanged(cocos2d::_ccColor3B p0) {
        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x1ec680))(this, p0);
        else return SetupPulsePopup::colorValueChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec900))(this, p0);
        else return SetupPulsePopup::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec920))(this, p0);
        else return SetupPulsePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec960))(this, p0);
        else return SetupPulsePopup::textChanged(p0);
    }

    dupable void colorSelectClosed(GJSpecialColorSelect* p0, int p1) {
        if ((void($SetupPulsePopup::*)(GJSpecialColorSelect*, int)){&$SetupPulsePopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), GJSpecialColorSelect*, int)>(m->getOriginal(base+0x1ebf20))(this, p0, p1);
        else return SetupPulsePopup::colorSelectClosed(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*, float)){&$SetupPulsePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1ecf20))(this, p0, p1);
        else return SetupPulsePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ecfe0))(this, p0);
        else return SetupPulsePopup::textInputReturn(p0);
    }

    dupable $SetupPulsePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1ec840, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1ec870, extract((void(D::*)()){&D::show}));

        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(base+0x1ec680, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1ec900, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1ec920, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1ec960, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPulsePopup::*)(GJSpecialColorSelect*, int)){&$SetupPulsePopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            m->registerHook(base+0x1ebf20, extract((void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*, float)){&$SetupPulsePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1ecf20, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1ecfe0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupShakePopup : public SetupShakePopup, public $CacBase {
public:
    dupable ~$SetupShakePopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3b00d0))(this);
        else return SetupShakePopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3b0080))(this);
        else return SetupShakePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3afc80))(this, p0);
        else return SetupShakePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3afcc0))(this, p0);
        else return SetupShakePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupShakePopup::*)(CCTextInputNode*, float)){&$SetupShakePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x3b0260))(this, p0, p1);
        else return SetupShakePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3b0320))(this, p0);
        else return SetupShakePopup::textInputReturn(p0);
    }

    dupable $SetupShakePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3b00d0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x3b0080, extract((void(D::*)()){&D::show}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3afc80, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x3afcc0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*, float)){&$SetupShakePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x3b0260, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x3b0320, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupSpawnPopup : public SetupSpawnPopup, public $CacBase {
public:
    dupable ~$SetupSpawnPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13bc50))(this);
        else return SetupSpawnPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13bc00))(this);
        else return SetupSpawnPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13b950))(this, p0);
        else return SetupSpawnPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13b990))(this, p0);
        else return SetupSpawnPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*, float)){&$SetupSpawnPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x13bda0))(this, p0, p1);
        else return SetupSpawnPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13be60))(this, p0);
        else return SetupSpawnPopup::textInputReturn(p0);
    }

    dupable $SetupSpawnPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x13bc50, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x13bc00, extract((void(D::*)()){&D::show}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x13b950, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x13b990, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*, float)){&$SetupSpawnPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x13bda0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x13be60, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareLevelLayer : public ShareLevelLayer, public $CacBase {
public:
    dupable ~$ShareLevelLayer() override {}

    dupable void keyBackClicked() {
        if ((void($ShareLevelLayer::*)()){&$ShareLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12b830))(this);
        else return ShareLevelLayer::keyBackClicked();
    }

    dupable $ShareLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareLevelLayer::*)()){&$ShareLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12b830, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TopArtistsLayer : public TopArtistsLayer, public $CacBase {
public:
    dupable ~$TopArtistsLayer() override {}

    dupable bool init() {
        if ((bool($TopArtistsLayer::*)()){&$TopArtistsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x192c30))(this);
        else return TopArtistsLayer::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1935b0))(this);
        else return TopArtistsLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x193540))(this);
        else return TopArtistsLayer::keyBackClicked();
    }

    dupable void show() {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x193e40))(this);
        else return TopArtistsLayer::show();
    }

    dupable void loadListFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($TopArtistsLayer::*)(cocos2d::CCArray*, char const*)){&$TopArtistsLayer::loadListFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x193600))(this, p0, p1);
        else return TopArtistsLayer::loadListFinished(p0, p1);
    }

    dupable void loadListFailed(char const* p0) {
        if ((void($TopArtistsLayer::*)(char const*)){&$TopArtistsLayer::loadListFailed} != (void(D::*)(char const*)){&D::loadListFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1936f0))(this, p0);
        else return TopArtistsLayer::loadListFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($TopArtistsLayer::*)(std::string, char const*)){&$TopArtistsLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x193730))(this, p0, p1);
        else return TopArtistsLayer::setupPageInfo(p0, p1);
    }

    dupable $TopArtistsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($TopArtistsLayer::*)()){&$TopArtistsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x192c30, extract((bool(D::*)()){&D::init}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1935b0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x193540, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x193e40, extract((void(D::*)()){&D::show}));

        if ((void($TopArtistsLayer::*)(cocos2d::CCArray*, char const*)){&$TopArtistsLayer::loadListFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished})
            m->registerHook(base+0x193600, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished}));

        if ((void($TopArtistsLayer::*)(char const*)){&$TopArtistsLayer::loadListFailed} != (void(D::*)(char const*)){&D::loadListFailed})
            m->registerHook(base+0x1936f0, extract((void(D::*)(char const*)){&D::loadListFailed}));

        if ((void($TopArtistsLayer::*)(std::string, char const*)){&$TopArtistsLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x193730, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));
    }
};


template<class D>
class $AccountHelpLayer : public AccountHelpLayer, public $CacBase {
public:
    dupable ~$AccountHelpLayer() override {}

    dupable void customSetup() {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83e80))(this);
        else return AccountHelpLayer::customSetup();
    }

    dupable void layerHidden() {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x84b60))(this);
        else return AccountHelpLayer::layerHidden();
    }

    dupable void accountStatusChanged() {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x84a20))(this);
        else return AccountHelpLayer::accountStatusChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($AccountHelpLayer::*)(FLAlertLayer*, bool)){&$AccountHelpLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x84a50))(this, p0, p1);
        else return AccountHelpLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $AccountHelpLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x83e80, extract((void(D::*)()){&D::customSetup}));

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x84b60, extract((void(D::*)()){&D::layerHidden}));

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(base+0x84a20, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((void($AccountHelpLayer::*)(FLAlertLayer*, bool)){&$AccountHelpLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x84a50, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
public:
    dupable ~$CCAnimatedSprite() override {}

    dupable void setOpacity(unsigned char p0) {
        if ((void($CCAnimatedSprite::*)(unsigned char)){&$CCAnimatedSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1a6af0))(this, p0);
        else return CCAnimatedSprite::setOpacity(p0);
    }

    dupable void animationFinished(char const* p0) {
        if ((void($CCAnimatedSprite::*)(char const*)){&$CCAnimatedSprite::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1a6ad0))(this, p0);
        else return CCAnimatedSprite::animationFinished(p0);
    }

    dupable void animationFinishedO(cocos2d::CCObject* p0) {
        if ((void($CCAnimatedSprite::*)(cocos2d::CCObject*)){&$CCAnimatedSprite::animationFinishedO} != (void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1a6aa0))(this, p0);
        else return CCAnimatedSprite::animationFinishedO(p0);
    }

    dupable $CCAnimatedSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCAnimatedSprite::*)(unsigned char)){&$CCAnimatedSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1a6af0, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($CCAnimatedSprite::*)(char const*)){&$CCAnimatedSprite::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x1a6ad0, extract((void(D::*)(char const*)){&D::animationFinished}));

        if ((void($CCAnimatedSprite::*)(cocos2d::CCObject*)){&$CCAnimatedSprite::animationFinishedO} != (void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO})
            m->registerHook(base+0x1a6aa0, extract((void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO}));
    }
};


template<class D>
class $CCContentManager : public CCContentManager, public $CacBase {
public:
    dupable ~$CCContentManager() override {}

    dupable $CCContentManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CCPartAnimSprite : public CCPartAnimSprite, public $CacBase {
public:
    dupable ~$CCPartAnimSprite() override {}

    dupable void setScaleX(float p0) {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff50))(this, p0);
        else return CCPartAnimSprite::setScaleX(p0);
    }

    dupable void setScaleY(float p0) {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff70))(this, p0);
        else return CCPartAnimSprite::setScaleY(p0);
    }

    dupable void setScale(float p0) {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff30))(this, p0);
        else return CCPartAnimSprite::setScale(p0);
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($CCPartAnimSprite::*)(unsigned char)){&$CCPartAnimSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1c01d0))(this, p0);
        else return CCPartAnimSprite::setOpacity(p0);
    }

    dupable void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        if ((void($CCPartAnimSprite::*)(cocos2d::_ccBlendFunc)){&$CCPartAnimSprite::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(base+0x1bff90))(this, p0);
        else return CCPartAnimSprite::setBlendFunc(p0);
    }

    dupable void setDisplayFrame(cocos2d::CCSpriteFrame* p0) {
        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::setDisplayFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x1bfa40))(this, p0);
        else return CCPartAnimSprite::setDisplayFrame(p0);
    }

    dupable void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) {
        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::isFrameDisplayed} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x1bfc20))(this, p0);
        else return CCPartAnimSprite::isFrameDisplayed(p0);
    }

    dupable void displayFrame() {
        if ((void($CCPartAnimSprite::*)()){&$CCPartAnimSprite::displayFrame} != (void(D::*)()){&D::displayFrame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bfc40))(this);
        else return CCPartAnimSprite::displayFrame();
    }

    dupable $CCPartAnimSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x1bff50, extract((void(D::*)(float)){&D::setScaleX}));

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x1bff70, extract((void(D::*)(float)){&D::setScaleY}));

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x1bff30, extract((void(D::*)(float)){&D::setScale}));

        if ((void($CCPartAnimSprite::*)(unsigned char)){&$CCPartAnimSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1c01d0, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($CCPartAnimSprite::*)(cocos2d::_ccBlendFunc)){&$CCPartAnimSprite::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            m->registerHook(base+0x1bff90, extract((void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc}));

        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::setDisplayFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame})
            m->registerHook(base+0x1bfa40, extract((void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame}));

        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::isFrameDisplayed} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed})
            m->registerHook(base+0x1bfc20, extract((void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed}));

        if ((void($CCPartAnimSprite::*)()){&$CCPartAnimSprite::displayFrame} != (void(D::*)()){&D::displayFrame})
            m->registerHook(base+0x1bfc40, extract((void(D::*)()){&D::displayFrame}));
    }
};


template<class D>
class $CCScrollLayerExt : public CCScrollLayerExt, public $CacBase {
public:
    dupable ~$CCScrollLayerExt() override {}

    dupable void visit() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236550))(this);
        else return CCScrollLayerExt::visit();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x235ef0))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236300))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236020))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2362a0))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x235eb0))(this);
        else return CCScrollLayerExt::registerWithTouchDispatcher();
    }

    dupable void preVisitWithClippingRect(cocos2d::CCRect p0) {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0x2366a0))(this, p0);
        else return CCScrollLayerExt::preVisitWithClippingRect(p0);
    }

    dupable void postVisit() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236720))(this);
        else return CCScrollLayerExt::postVisit();
    }

    dupable $CCScrollLayerExt() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x236550, extract((void(D::*)()){&D::visit}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x235ef0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x236300, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x236020, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2362a0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x235eb0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            m->registerHook(base+0x2366a0, extract((void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            m->registerHook(base+0x236720, extract((void(D::*)()){&D::postVisit}));
    }
};


template<class D>
class $CheckpointObject : public CheckpointObject, public $CacBase {
public:
    dupable ~$CheckpointObject() override {}

    dupable bool init() {
        if ((bool($CheckpointObject::*)()){&$CheckpointObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x80920))(this);
        else return CheckpointObject::init();
    }

    dupable $CheckpointObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CheckpointObject::*)()){&$CheckpointObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x80920, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ColorSelectPopup : public ColorSelectPopup, public $CacBase {
public:
    dupable ~$ColorSelectPopup() override {}

    dupable void keyBackClicked() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x423540))(this);
        else return ColorSelectPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x423570))(this);
        else return ColorSelectPopup::show();
    }

    dupable void colorValueChanged(cocos2d::_ccColor3B p0) {
        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x423320))(this, p0);
        else return ColorSelectPopup::colorValueChanged(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x423820))(this, p0);
        else return ColorSelectPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x423860))(this, p0);
        else return ColorSelectPopup::textChanged(p0);
    }

    dupable void colorSelectClosed(GJSpecialColorSelect* p0, int p1) {
        if ((void($ColorSelectPopup::*)(GJSpecialColorSelect*, int)){&$ColorSelectPopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), GJSpecialColorSelect*, int)>(m->getOriginal(base+0x423c80))(this, p0, p1);
        else return ColorSelectPopup::colorSelectClosed(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*, float)){&$ColorSelectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x423fa0))(this, p0, p1);
        else return ColorSelectPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x424060))(this, p0);
        else return ColorSelectPopup::textInputReturn(p0);
    }

    dupable $ColorSelectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x423540, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x423570, extract((void(D::*)()){&D::show}));

        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(base+0x423320, extract((void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x423820, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x423860, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($ColorSelectPopup::*)(GJSpecialColorSelect*, int)){&$ColorSelectPopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            m->registerHook(base+0x423c80, extract((void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*, float)){&$ColorSelectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x423fa0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x424060, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $CustomSongWidget : public CustomSongWidget, public $CacBase {
public:
    dupable ~$CustomSongWidget() override {}

    dupable void loadSongInfoFinished(SongInfoObject* p0) {
        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x37e400))(this, p0);
        else return CustomSongWidget::loadSongInfoFinished(p0);
    }

    dupable void loadSongInfoFailed(int p0, GJSongError p1) {
        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x37e5a0))(this, p0, p1);
        else return CustomSongWidget::loadSongInfoFailed(p0, p1);
    }

    dupable void downloadSongFinished(SongInfoObject* p0) {
        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x37e7b0))(this, p0);
        else return CustomSongWidget::downloadSongFinished(p0);
    }

    dupable void downloadSongFailed(int p0, GJSongError p1) {
        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x37e8c0))(this, p0, p1);
        else return CustomSongWidget::downloadSongFailed(p0, p1);
    }

    dupable void songStateChanged() {
        if ((void($CustomSongWidget::*)()){&$CustomSongWidget::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37e390))(this);
        else return CustomSongWidget::songStateChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($CustomSongWidget::*)(FLAlertLayer*, bool)){&$CustomSongWidget::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x37ea00))(this, p0, p1);
        else return CustomSongWidget::FLAlert_Clicked(p0, p1);
    }

    dupable $CustomSongWidget() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            m->registerHook(base+0x37e400, extract((void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished}));

        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            m->registerHook(base+0x37e5a0, extract((void(D::*)(int, GJSongError)){&D::loadSongInfoFailed}));

        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            m->registerHook(base+0x37e7b0, extract((void(D::*)(SongInfoObject*)){&D::downloadSongFinished}));

        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            m->registerHook(base+0x37e8c0, extract((void(D::*)(int, GJSongError)){&D::downloadSongFailed}));

        if ((void($CustomSongWidget::*)()){&$CustomSongWidget::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            m->registerHook(base+0x37e390, extract((void(D::*)()){&D::songStateChanged}));

        if ((void($CustomSongWidget::*)(FLAlertLayer*, bool)){&$CustomSongWidget::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x37ea00, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EditorPauseLayer : public EditorPauseLayer, public $CacBase {
public:
    dupable ~$EditorPauseLayer() override {}

    dupable void keyBackClicked() {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13f320))(this);
        else return EditorPauseLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($EditorPauseLayer::*)(cocos2d::enumKeyCodes)){&$EditorPauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x13f3a0))(this, p0);
        else return EditorPauseLayer::keyDown(p0);
    }

    dupable void customSetup() {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13cc00))(this);
        else return EditorPauseLayer::customSetup();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($EditorPauseLayer::*)(FLAlertLayer*, bool)){&$EditorPauseLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x13f1b0))(this, p0, p1);
        else return EditorPauseLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $EditorPauseLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x13f320, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($EditorPauseLayer::*)(cocos2d::enumKeyCodes)){&$EditorPauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x13f3a0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x13cc00, extract((void(D::*)()){&D::customSetup}));

        if ((void($EditorPauseLayer::*)(FLAlertLayer*, bool)){&$EditorPauseLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x13f1b0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EffectGameObject : public EffectGameObject, public $CacBase {
public:
    dupable ~$EffectGameObject() override {}

    dupable void customSetup() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xca370))(this);
        else return EffectGameObject::customSetup();
    }

    dupable void triggerObject(GJBaseGameLayer* p0) {
        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0xc9870))(this, p0);
        else return EffectGameObject::triggerObject(p0);
    }

    dupable void getSaveString() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xcd7e0))(this);
        else return EffectGameObject::getSaveString();
    }

    dupable void triggerActivated(float p0) {
        if ((void($EffectGameObject::*)(float)){&$EffectGameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xca310))(this, p0);
        else return EffectGameObject::triggerActivated(p0);
    }

    dupable void spawnXPosition() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xca2d0))(this);
        else return EffectGameObject::spawnXPosition();
    }

    dupable $EffectGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0xca370, extract((void(D::*)()){&D::customSetup}));

        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0xc9870, extract((void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xcd7e0, extract((void(D::*)()){&D::getSaveString}));

        if ((void($EffectGameObject::*)(float)){&$EffectGameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0xca310, extract((void(D::*)(float)){&D::triggerActivated}));

        if ((void($EffectGameObject::*)()){&$EffectGameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(base+0xca2d0, extract((void(D::*)()){&D::spawnXPosition}));
    }
};


template<class D>
class $FollowRewardPage : public FollowRewardPage, public $CacBase {
public:
    dupable ~$FollowRewardPage() override {}

    dupable bool init() {
        if ((bool($FollowRewardPage::*)()){&$FollowRewardPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x22f4a0))(this);
        else return FollowRewardPage::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230eb0))(this);
        else return FollowRewardPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230e40))(this);
        else return FollowRewardPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230c10))(this);
        else return FollowRewardPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($FollowRewardPage::*)(FLAlertLayer*, bool)){&$FollowRewardPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x230da0))(this, p0, p1);
        else return FollowRewardPage::FLAlert_Clicked(p0, p1);
    }

    dupable void updateRate() {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::updateRate} != (void(D::*)()){&D::updateRate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230950))(this);
        else return FollowRewardPage::updateRate();
    }

    dupable $FollowRewardPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($FollowRewardPage::*)()){&$FollowRewardPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x22f4a0, extract((bool(D::*)()){&D::init}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x230eb0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x230e40, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x230c10, extract((void(D::*)()){&D::show}));

        if ((void($FollowRewardPage::*)(FLAlertLayer*, bool)){&$FollowRewardPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x230da0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::updateRate} != (void(D::*)()){&D::updateRate})
            m->registerHook(base+0x230950, extract((void(D::*)()){&D::updateRate}));
    }
};


template<class D>
class $GJAccountManager : public GJAccountManager, public $CacBase {
public:
    dupable ~$GJAccountManager() override {}

    dupable bool init() {
        if ((bool($GJAccountManager::*)()){&$GJAccountManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x879d0))(this);
        else return GJAccountManager::init();
    }

    dupable $GJAccountManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJAccountManager::*)()){&$GJAccountManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x879d0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJFlyGroundLayer : public GJFlyGroundLayer, public $CacBase {
public:
    dupable ~$GJFlyGroundLayer() override {}

    dupable bool init() {
        if ((bool($GJFlyGroundLayer::*)()){&$GJFlyGroundLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x356c00))(this);
        else return GJFlyGroundLayer::init();
    }

    dupable $GJFlyGroundLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJFlyGroundLayer::*)()){&$GJFlyGroundLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x356c00, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJLevelScoreCell : public GJLevelScoreCell, public $CacBase {
public:
    dupable ~$GJLevelScoreCell() override {}

    dupable bool init() {
        if ((bool($GJLevelScoreCell::*)()){&$GJLevelScoreCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11dbb0))(this);
        else return GJLevelScoreCell::init();
    }

    dupable void draw() {
        if ((void($GJLevelScoreCell::*)()){&$GJLevelScoreCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11dc00))(this);
        else return GJLevelScoreCell::draw();
    }

    dupable $GJLevelScoreCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJLevelScoreCell::*)()){&$GJLevelScoreCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11dbb0, extract((bool(D::*)()){&D::init}));

        if ((void($GJLevelScoreCell::*)()){&$GJLevelScoreCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11dc00, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $GJMoreGamesLayer : public GJMoreGamesLayer, public $CacBase {
public:
    dupable ~$GJMoreGamesLayer() override {}

    dupable void customSetup() {
        if ((void($GJMoreGamesLayer::*)()){&$GJMoreGamesLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43ae60))(this);
        else return GJMoreGamesLayer::customSetup();
    }

    dupable $GJMoreGamesLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMoreGamesLayer::*)()){&$GJMoreGamesLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x43ae60, extract((void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $GameLevelManager : public GameLevelManager, public $CacBase {
public:
    dupable ~$GameLevelManager() override {}

    dupable bool init() {
        if ((bool($GameLevelManager::*)()){&$GameLevelManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2b7ba0))(this);
        else return GameLevelManager::init();
    }

    dupable $GameLevelManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameLevelManager::*)()){&$GameLevelManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2b7ba0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameSoundManager : public GameSoundManager, public $CacBase {
public:
    dupable ~$GameSoundManager() override {}

    dupable bool init() {
        if ((bool($GameSoundManager::*)()){&$GameSoundManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3611d0))(this);
        else return GameSoundManager::init();
    }

    dupable $GameSoundManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameSoundManager::*)()){&$GameSoundManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3611d0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameStatsManager : public GameStatsManager, public $CacBase {
public:
    dupable ~$GameStatsManager() override {}

    dupable bool init() {
        if ((bool($GameStatsManager::*)()){&$GameStatsManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x39330))(this);
        else return GameStatsManager::init();
    }

    dupable $GameStatsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameStatsManager::*)()){&$GameStatsManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x39330, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GhostTrailEffect : public GhostTrailEffect, public $CacBase {
public:
    dupable ~$GhostTrailEffect() override {}

    dupable bool init() {
        if ((bool($GhostTrailEffect::*)()){&$GhostTrailEffect::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x360730))(this);
        else return GhostTrailEffect::init();
    }

    dupable void draw() {
        if ((void($GhostTrailEffect::*)()){&$GhostTrailEffect::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x360d20))(this);
        else return GhostTrailEffect::draw();
    }

    dupable $GhostTrailEffect() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GhostTrailEffect::*)()){&$GhostTrailEffect::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x360730, extract((bool(D::*)()){&D::init}));

        if ((void($GhostTrailEffect::*)()){&$GhostTrailEffect::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x360d20, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $KeybindingsLayer : public KeybindingsLayer, public $CacBase {
public:
    dupable ~$KeybindingsLayer() override {}

    dupable bool init() {
        if ((bool($KeybindingsLayer::*)()){&$KeybindingsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x375890))(this);
        else return KeybindingsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($KeybindingsLayer::*)()){&$KeybindingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x376f30))(this);
        else return KeybindingsLayer::keyBackClicked();
    }

    dupable $KeybindingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeybindingsLayer::*)()){&$KeybindingsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x375890, extract((bool(D::*)()){&D::init}));

        if ((void($KeybindingsLayer::*)()){&$KeybindingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x376f30, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LevelEditorLayer : public LevelEditorLayer, public $CacBase {
public:
    dupable ~$LevelEditorLayer() override {}

    dupable void update(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xa1b70))(this, p0);
        else return LevelEditorLayer::update(p0);
    }

    dupable void draw() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xa2a70))(this);
        else return LevelEditorLayer::draw();
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return LevelEditorLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0xa04e0))(this, p0, p1, p2);
        else return LevelEditorLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0x9c590))(this, p0, p1, p2, p3, p4, p5);
        else return LevelEditorLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void addToGroup(GameObject* p0, int p1, bool p2) {
        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(base+0x9dab0))(this, p0, p1, p2);
        else return LevelEditorLayer::addToGroup(p0, p1, p2);
    }

    dupable void removeFromGroup(GameObject* p0, int p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(base+0x9db60))(this, p0, p1);
        else return LevelEditorLayer::removeFromGroup(p0, p1);
    }

    dupable void timeForXPos(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x9c7d0))(this, p0);
        else return LevelEditorLayer::timeForXPos(p0);
    }

    dupable void xPosForTime(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x9c800))(this, p0);
        else return LevelEditorLayer::xPosForTime(p0);
    }

    dupable void levelSettingsUpdated() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x93f30))(this);
        else return LevelEditorLayer::levelSettingsUpdated();
    }

    dupable $LevelEditorLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0xa1b70, extract((void(D::*)(float)){&D::update}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xa2a70, extract((void(D::*)()){&D::draw}));

        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0x9c200, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0xa04e0, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0x9c590, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(base+0x9dab0, extract((void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(base+0x9db60, extract((void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(base+0x9c7d0, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(base+0x9c800, extract((void(D::*)(float)){&D::xPosForTime}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            m->registerHook(base+0x93f30, extract((void(D::*)()){&D::levelSettingsUpdated}));
    }
};


template<class D>
class $LevelLeaderboard : public LevelLeaderboard, public $CacBase {
public:
    dupable ~$LevelLeaderboard() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e7a0))(this);
        else return LevelLeaderboard::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e730))(this);
        else return LevelLeaderboard::keyBackClicked();
    }

    dupable void show() {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ec40))(this);
        else return LevelLeaderboard::show();
    }

    dupable void loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($LevelLeaderboard::*)(cocos2d::CCArray*, char const*)){&$LevelLeaderboard::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x20e980))(this, p0, p1);
        else return LevelLeaderboard::loadLeaderboardFinished(p0, p1);
    }

    dupable void loadLeaderboardFailed(char const* p0) {
        if ((void($LevelLeaderboard::*)(char const*)){&$LevelLeaderboard::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x20ead0))(this, p0);
        else return LevelLeaderboard::loadLeaderboardFailed(p0);
    }

    dupable void updateUserScoreFinished() {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e660))(this);
        else return LevelLeaderboard::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e690))(this);
        else return LevelLeaderboard::updateUserScoreFailed();
    }

    dupable $LevelLeaderboard() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x20e7a0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20e730, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x20ec40, extract((void(D::*)()){&D::show}));

        if ((void($LevelLeaderboard::*)(cocos2d::CCArray*, char const*)){&$LevelLeaderboard::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            m->registerHook(base+0x20e980, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished}));

        if ((void($LevelLeaderboard::*)(char const*)){&$LevelLeaderboard::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            m->registerHook(base+0x20ead0, extract((void(D::*)(char const*)){&D::loadLeaderboardFailed}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x20e660, extract((void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x20e690, extract((void(D::*)()){&D::updateUserScoreFailed}));
    }
};


template<class D>
class $LevelSearchLayer : public LevelSearchLayer, public $CacBase {
public:
    dupable ~$LevelSearchLayer() override {}

    dupable bool init() {
        if ((bool($LevelSearchLayer::*)()){&$LevelSearchLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x384770))(this);
        else return LevelSearchLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($LevelSearchLayer::*)()){&$LevelSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3891f0))(this);
        else return LevelSearchLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3885f0))(this, p0);
        else return LevelSearchLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3887f0))(this, p0);
        else return LevelSearchLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x388910))(this, p0);
        else return LevelSearchLayer::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($LevelSearchLayer::*)(FLAlertLayer*, bool)){&$LevelSearchLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x388580))(this, p0, p1);
        else return LevelSearchLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void demonFilterSelectClosed(int p0) {
        if ((void($LevelSearchLayer::*)(int)){&$LevelSearchLayer::demonFilterSelectClosed} != (void(D::*)(int)){&D::demonFilterSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x388040))(this, p0);
        else return LevelSearchLayer::demonFilterSelectClosed(p0);
    }

    dupable $LevelSearchLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelSearchLayer::*)()){&$LevelSearchLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x384770, extract((bool(D::*)()){&D::init}));

        if ((void($LevelSearchLayer::*)()){&$LevelSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3891f0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x3885f0, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3887f0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x388910, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($LevelSearchLayer::*)(FLAlertLayer*, bool)){&$LevelSearchLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x388580, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelSearchLayer::*)(int)){&$LevelSearchLayer::demonFilterSelectClosed} != (void(D::*)(int)){&D::demonFilterSelectClosed})
            m->registerHook(base+0x388040, extract((void(D::*)(int)){&D::demonFilterSelectClosed}));
    }
};


template<class D>
class $LevelSelectLayer : public LevelSelectLayer, public $CacBase {
public:
    dupable ~$LevelSelectLayer() override {}

    dupable void keyBackClicked() {
        if ((void($LevelSelectLayer::*)()){&$LevelSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x23a5e0))(this);
        else return LevelSelectLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($LevelSelectLayer::*)(cocos2d::enumKeyCodes)){&$LevelSelectLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x23a680))(this, p0);
        else return LevelSelectLayer::keyDown(p0);
    }

    dupable void updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) {
        if ((void($LevelSelectLayer::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&$LevelSelectLayer::updatePageWithObject} != (void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, cocos2d::CCObject*)>(m->getOriginal(base+0x2390a0))(this, p0, p1);
        else return LevelSelectLayer::updatePageWithObject(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) {
        if ((void($LevelSelectLayer::*)(cocos2d::CCPoint)){&$LevelSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x23a100))(this, p0);
        else return LevelSelectLayer::scrollLayerMoved(p0);
    }

    dupable $LevelSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelSelectLayer::*)()){&$LevelSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x23a5e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSelectLayer::*)(cocos2d::enumKeyCodes)){&$LevelSelectLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x23a680, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelSelectLayer::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&$LevelSelectLayer::updatePageWithObject} != (void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject})
            m->registerHook(base+0x2390a0, extract((void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject}));

        if ((void($LevelSelectLayer::*)(cocos2d::CCPoint)){&$LevelSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x23a100, extract((void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));
    }
};


template<class D>
class $MoreOptionsLayer : public MoreOptionsLayer, public $CacBase {
public:
    dupable ~$MoreOptionsLayer() override {}

    dupable bool init() {
        if ((bool($MoreOptionsLayer::*)()){&$MoreOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x43f470))(this);
        else return MoreOptionsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x441f50))(this);
        else return MoreOptionsLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($MoreOptionsLayer::*)(CCTextInputNode*, float)){&$MoreOptionsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x4420a0))(this, p0, p1);
        else return MoreOptionsLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($MoreOptionsLayer::*)(CCTextInputNode*)){&$MoreOptionsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x442160))(this, p0);
        else return MoreOptionsLayer::textInputReturn(p0);
    }

    dupable void googlePlaySignedIn() {
        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x442210))(this);
        else return MoreOptionsLayer::googlePlaySignedIn();
    }

    dupable $MoreOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreOptionsLayer::*)()){&$MoreOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x43f470, extract((bool(D::*)()){&D::init}));

        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x441f50, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MoreOptionsLayer::*)(CCTextInputNode*, float)){&$MoreOptionsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x4420a0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($MoreOptionsLayer::*)(CCTextInputNode*)){&$MoreOptionsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x442160, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            m->registerHook(base+0x442210, extract((void(D::*)()){&D::googlePlaySignedIn}));
    }
};


template<class D>
class $NumberInputLayer : public NumberInputLayer, public $CacBase {
public:
    dupable ~$NumberInputLayer() override {}

    dupable bool init() {
        if ((bool($NumberInputLayer::*)()){&$NumberInputLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x255ff0))(this);
        else return NumberInputLayer::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x256a70))(this);
        else return NumberInputLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2569c0))(this);
        else return NumberInputLayer::keyBackClicked();
    }

    dupable $NumberInputLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($NumberInputLayer::*)()){&$NumberInputLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x255ff0, extract((bool(D::*)()){&D::init}));

        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x256a70, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2569c0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $PlayerCheckpoint : public PlayerCheckpoint, public $CacBase {
public:
    dupable ~$PlayerCheckpoint() override {}

    dupable bool init() {
        if ((bool($PlayerCheckpoint::*)()){&$PlayerCheckpoint::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x807a0))(this);
        else return PlayerCheckpoint::init();
    }

    dupable $PlayerCheckpoint() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($PlayerCheckpoint::*)()){&$PlayerCheckpoint::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x807a0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $SetTargetIDLayer : public SetTargetIDLayer, public $CacBase {
public:
    dupable ~$SetTargetIDLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15b990))(this);
        else return SetTargetIDLayer::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15b940))(this);
        else return SetTargetIDLayer::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15b680))(this, p0);
        else return SetTargetIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15b6c0))(this, p0);
        else return SetTargetIDLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*, float)){&$SetTargetIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x15baa0))(this, p0, p1);
        else return SetTargetIDLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15bb60))(this, p0);
        else return SetTargetIDLayer::textInputReturn(p0);
    }

    dupable $SetTargetIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x15b990, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x15b940, extract((void(D::*)()){&D::show}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x15b680, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x15b6c0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*, float)){&$SetTargetIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x15baa0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x15bb60, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupRotatePopup : public SetupRotatePopup, public $CacBase {
public:
    dupable ~$SetupRotatePopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2f47c0))(this);
        else return SetupRotatePopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2f4770))(this);
        else return SetupRotatePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f45d0))(this, p0);
        else return SetupRotatePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f4610))(this, p0);
        else return SetupRotatePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*, float)){&$SetupRotatePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x2f48b0))(this, p0, p1);
        else return SetupRotatePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f4970))(this, p0);
        else return SetupRotatePopup::textInputReturn(p0);
    }

    dupable $SetupRotatePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2f47c0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2f4770, extract((void(D::*)()){&D::show}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x2f45d0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x2f4610, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*, float)){&$SetupRotatePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x2f48b0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x2f4970, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SliderTouchLogic : public SliderTouchLogic, public $CacBase {
public:
    dupable ~$SliderTouchLogic() override {}

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d630))(this, p0, p1);
        else return SliderTouchLogic::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d760))(this, p0, p1);
        else return SliderTouchLogic::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d730))(this, p0, p1);
        else return SliderTouchLogic::ccTouchEnded(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($SliderTouchLogic::*)()){&$SliderTouchLogic::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18da90))(this);
        else return SliderTouchLogic::registerWithTouchDispatcher();
    }

    dupable $SliderTouchLogic() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x18d630, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x18d760, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x18d730, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($SliderTouchLogic::*)()){&$SliderTouchLogic::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x18da90, extract((void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $SongOptionsLayer : public SongOptionsLayer, public $CacBase {
public:
    dupable ~$SongOptionsLayer() override {}

    dupable void keyBackClicked() {
        if ((void($SongOptionsLayer::*)()){&$SongOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf33c0))(this);
        else return SongOptionsLayer::keyBackClicked();
    }

    dupable $SongOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongOptionsLayer::*)()){&$SongOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf33c0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $WorldSelectLayer : public WorldSelectLayer, public $CacBase {
public:
    dupable ~$WorldSelectLayer() override {}

    dupable void onExit() {
        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x201320))(this);
        else return WorldSelectLayer::onExit();
    }

    dupable void keyBackClicked() {
        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x201250))(this);
        else return WorldSelectLayer::keyBackClicked();
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) {
        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x201140))(this, p0, p1);
        else return WorldSelectLayer::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) {
        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x201030))(this, p0, p1);
        else return WorldSelectLayer::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) {
        if ((void($WorldSelectLayer::*)(cocos2d::CCPoint)){&$WorldSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x201370))(this, p0);
        else return WorldSelectLayer::scrollLayerMoved(p0);
    }

    dupable $WorldSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x201320, extract((void(D::*)()){&D::onExit}));

        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x201250, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x201140, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));

        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x201030, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($WorldSelectLayer::*)(cocos2d::CCPoint)){&$WorldSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x201370, extract((void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));
    }
};


template<class D>
class $AccountLoginLayer : public AccountLoginLayer, public $CacBase {
public:
    dupable ~$AccountLoginLayer() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25d7e0))(this);
        else return AccountLoginLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25d6a0))(this);
        else return AccountLoginLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($AccountLoginLayer::*)(FLAlertLayer*, bool)){&$AccountLoginLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x25d4d0))(this, p0, p1);
        else return AccountLoginLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d9c0))(this, p0);
        else return AccountLoginLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d820))(this, p0);
        else return AccountLoginLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d9e0))(this, p0);
        else return AccountLoginLayer::textChanged(p0);
    }

    dupable void loginAccountFinished(int p0, int p1) {
        if ((void($AccountLoginLayer::*)(int, int)){&$AccountLoginLayer::loginAccountFinished} != (void(D::*)(int, int)){&D::loginAccountFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x25ce20))(this, p0, p1);
        else return AccountLoginLayer::loginAccountFinished(p0, p1);
    }

    dupable void loginAccountFailed(AccountError p0) {
        if ((void($AccountLoginLayer::*)(AccountError)){&$AccountLoginLayer::loginAccountFailed} != (void(D::*)(AccountError)){&D::loginAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), AccountError)>(m->getOriginal(base+0x25d190))(this, p0);
        else return AccountLoginLayer::loginAccountFailed(p0);
    }

    dupable $AccountLoginLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25d7e0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25d6a0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($AccountLoginLayer::*)(FLAlertLayer*, bool)){&$AccountLoginLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x25d4d0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x25d9c0, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x25d820, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x25d9e0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($AccountLoginLayer::*)(int, int)){&$AccountLoginLayer::loginAccountFinished} != (void(D::*)(int, int)){&D::loginAccountFinished})
            m->registerHook(base+0x25ce20, extract((void(D::*)(int, int)){&D::loginAccountFinished}));

        if ((void($AccountLoginLayer::*)(AccountError)){&$AccountLoginLayer::loginAccountFailed} != (void(D::*)(AccountError)){&D::loginAccountFailed})
            m->registerHook(base+0x25d190, extract((void(D::*)(AccountError)){&D::loginAccountFailed}));
    }
};


template<class D>
class $AchievementsLayer : public AchievementsLayer, public $CacBase {
public:
    dupable ~$AchievementsLayer() override {}

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($AchievementsLayer::*)(cocos2d::enumKeyCodes)){&$AchievementsLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x1be380))(this, p0);
        else return AchievementsLayer::keyDown(p0);
    }

    dupable void customSetup() {
        if ((void($AchievementsLayer::*)()){&$AchievementsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bdea0))(this);
        else return AchievementsLayer::customSetup();
    }

    dupable $AchievementsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AchievementsLayer::*)(cocos2d::enumKeyCodes)){&$AchievementsLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x1be380, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($AchievementsLayer::*)()){&$AchievementsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x1bdea0, extract((void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $AudioEffectsLayer : public AudioEffectsLayer, public $CacBase {
public:
    dupable ~$AudioEffectsLayer() override {}

    dupable void draw() {
        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2722a0))(this);
        else return AudioEffectsLayer::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) {
        if ((void($AudioEffectsLayer::*)(float, char const*)){&$AudioEffectsLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x272170))(this, p0, p1);
        else return AudioEffectsLayer::updateTweenAction(p0, p1);
    }

    dupable $AudioEffectsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2722a0, extract((void(D::*)()){&D::draw}));

        if ((void($AudioEffectsLayer::*)(float, char const*)){&$AudioEffectsLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x272170, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
public:
    dupable ~$CCMenuItemToggler() override {}

    dupable void activate() {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38bc0))(this);
        else return CCMenuItemToggler::activate();
    }

    dupable void selected() {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::selected} != (void(D::*)()){&D::selected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38b80))(this);
        else return CCMenuItemToggler::selected();
    }

    dupable void unselected() {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::unselected} != (void(D::*)()){&D::unselected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38c00))(this);
        else return CCMenuItemToggler::unselected();
    }

    dupable void setEnabled(bool p0) {
        if ((void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::setEnabled} != (void(D::*)(bool)){&D::setEnabled})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x38c40))(this, p0);
        else return CCMenuItemToggler::setEnabled(p0);
    }

    dupable $CCMenuItemToggler() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x38bc0, extract((void(D::*)()){&D::activate}));

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::selected} != (void(D::*)()){&D::selected})
            m->registerHook(base+0x38b80, extract((void(D::*)()){&D::selected}));

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::unselected} != (void(D::*)()){&D::unselected})
            m->registerHook(base+0x38c00, extract((void(D::*)()){&D::unselected}));

        if ((void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::setEnabled} != (void(D::*)(bool)){&D::setEnabled})
            m->registerHook(base+0x38c40, extract((void(D::*)(bool)){&D::setEnabled}));
    }
};


template<class D>
class $ColorActionSprite : public ColorActionSprite, public $CacBase {
public:
    dupable ~$ColorActionSprite() override {}

    dupable bool init() {
        if ((bool($ColorActionSprite::*)()){&$ColorActionSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x175370))(this);
        else return ColorActionSprite::init();
    }

    dupable $ColorActionSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ColorActionSprite::*)()){&$ColorActionSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x175370, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $DungeonBarsSprite : public DungeonBarsSprite, public $CacBase {
public:
    dupable ~$DungeonBarsSprite() override {}

    dupable bool init() {
        if ((bool($DungeonBarsSprite::*)()){&$DungeonBarsSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x26c2b0))(this);
        else return DungeonBarsSprite::init();
    }

    dupable void visit() {
        if ((void($DungeonBarsSprite::*)()){&$DungeonBarsSprite::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c330))(this);
        else return DungeonBarsSprite::visit();
    }

    dupable $DungeonBarsSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($DungeonBarsSprite::*)()){&$DungeonBarsSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x26c2b0, extract((bool(D::*)()){&D::init}));

        if ((void($DungeonBarsSprite::*)()){&$DungeonBarsSprite::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x26c330, extract((void(D::*)()){&D::visit}));
    }
};


template<class D>
class $EditTriggersPopup : public EditTriggersPopup, public $CacBase {
public:
    dupable ~$EditTriggersPopup() override {}

    dupable void keyBackClicked() {
        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1458a0))(this);
        else return EditTriggersPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x145850))(this);
        else return EditTriggersPopup::show();
    }

    dupable $EditTriggersPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1458a0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x145850, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $GJColorSetupLayer : public GJColorSetupLayer, public $CacBase {
public:
    dupable ~$GJColorSetupLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf0210))(this);
        else return GJColorSetupLayer::keyBackClicked();
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) {
        if ((void($GJColorSetupLayer::*)(cocos2d::CCNode*)){&$GJColorSetupLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xf01e0))(this, p0);
        else return GJColorSetupLayer::colorSelectClosed(p0);
    }

    dupable $GJColorSetupLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf0210, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJColorSetupLayer::*)(cocos2d::CCNode*)){&$GJColorSetupLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xf01e0, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));
    }
};


template<class D>
class $GJRotationControl : public GJRotationControl, public $CacBase {
public:
    dupable ~$GJRotationControl() override {}

    dupable bool init() {
        if ((bool($GJRotationControl::*)()){&$GJRotationControl::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x31510))(this);
        else return GJRotationControl::init();
    }

    dupable void draw() {
        if ((void($GJRotationControl::*)()){&$GJRotationControl::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x31ac0))(this);
        else return GJRotationControl::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31790))(this, p0, p1);
        else return GJRotationControl::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x318b0))(this, p0, p1);
        else return GJRotationControl::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31990))(this, p0, p1);
        else return GJRotationControl::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31a80))(this, p0, p1);
        else return GJRotationControl::ccTouchCancelled(p0, p1);
    }

    dupable $GJRotationControl() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRotationControl::*)()){&$GJRotationControl::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x31510, extract((bool(D::*)()){&D::init}));

        if ((void($GJRotationControl::*)()){&$GJRotationControl::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x31ac0, extract((void(D::*)()){&D::draw}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x31790, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x318b0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x31990, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x31a80, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $GooglePlayManager : public GooglePlayManager, public $CacBase {
public:
    dupable ~$GooglePlayManager() override {}

    dupable bool init() {
        if ((bool($GooglePlayManager::*)()){&$GooglePlayManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x246130))(this);
        else return GooglePlayManager::init();
    }

    dupable $GooglePlayManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GooglePlayManager::*)()){&$GooglePlayManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x246130, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $LeaderboardsLayer : public LeaderboardsLayer, public $CacBase {
public:
    dupable ~$LeaderboardsLayer() override {}

    dupable void keyBackClicked() {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a11c0))(this);
        else return LeaderboardsLayer::keyBackClicked();
    }

    dupable void updateUserScoreFinished() {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a07c0))(this);
        else return LeaderboardsLayer::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a0820))(this);
        else return LeaderboardsLayer::updateUserScoreFailed();
    }

    dupable void loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($LeaderboardsLayer::*)(cocos2d::CCArray*, char const*)){&$LeaderboardsLayer::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x2a08c0))(this, p0, p1);
        else return LeaderboardsLayer::loadLeaderboardFinished(p0, p1);
    }

    dupable void loadLeaderboardFailed(char const* p0) {
        if ((void($LeaderboardsLayer::*)(char const*)){&$LeaderboardsLayer::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2a0fa0))(this, p0);
        else return LeaderboardsLayer::loadLeaderboardFailed(p0);
    }

    dupable $LeaderboardsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2a11c0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x2a07c0, extract((void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x2a0820, extract((void(D::*)()){&D::updateUserScoreFailed}));

        if ((void($LeaderboardsLayer::*)(cocos2d::CCArray*, char const*)){&$LeaderboardsLayer::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            m->registerHook(base+0x2a08c0, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished}));

        if ((void($LeaderboardsLayer::*)(char const*)){&$LeaderboardsLayer::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            m->registerHook(base+0x2a0fa0, extract((void(D::*)(char const*)){&D::loadLeaderboardFailed}));
    }
};


template<class D>
class $LevelBrowserLayer : public LevelBrowserLayer, public $CacBase {
public:
    dupable ~$LevelBrowserLayer() override {}

    dupable void onEnter() {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255b70))(this);
        else return LevelBrowserLayer::onEnter();
    }

    dupable void onEnterTransitionDidFinish() {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255be0))(this);
        else return LevelBrowserLayer::onEnterTransitionDidFinish();
    }

    dupable void keyBackClicked() {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255630))(this);
        else return LevelBrowserLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($LevelBrowserLayer::*)(cocos2d::enumKeyCodes)){&$LevelBrowserLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x255680))(this, p0);
        else return LevelBrowserLayer::keyDown(p0);
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($LevelBrowserLayer::*)(cocos2d::CCArray*, char const*)){&$LevelBrowserLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x254e10))(this, p0, p1);
        else return LevelBrowserLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) {
        if ((void($LevelBrowserLayer::*)(char const*)){&$LevelBrowserLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x254f60))(this, p0);
        else return LevelBrowserLayer::loadLevelsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($LevelBrowserLayer::*)(std::string, char const*)){&$LevelBrowserLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x255050))(this, p0, p1);
        else return LevelBrowserLayer::setupPageInfo(p0, p1);
    }

    dupable void setTextPopupClosed(SetTextPopup* p0, std::string p1) {
        if ((void($LevelBrowserLayer::*)(SetTextPopup*, std::string)){&$LevelBrowserLayer::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetTextPopup*, std::string)>(m->getOriginal(base+0x255760))(this, p0, p1);
        else return LevelBrowserLayer::setTextPopupClosed(p0, p1);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($LevelBrowserLayer::*)(FLAlertLayer*, bool)){&$LevelBrowserLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x255840))(this, p0, p1);
        else return LevelBrowserLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) {
        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0x2554f0))(this, p0, p1);
        else return LevelBrowserLayer::setIDPopupClosed(p0, p1);
    }

    dupable $LevelBrowserLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x255b70, extract((void(D::*)()){&D::onEnter}));

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(base+0x255be0, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x255630, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelBrowserLayer::*)(cocos2d::enumKeyCodes)){&$LevelBrowserLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x255680, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelBrowserLayer::*)(cocos2d::CCArray*, char const*)){&$LevelBrowserLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x254e10, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($LevelBrowserLayer::*)(char const*)){&$LevelBrowserLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x254f60, extract((void(D::*)(char const*)){&D::loadLevelsFailed}));

        if ((void($LevelBrowserLayer::*)(std::string, char const*)){&$LevelBrowserLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x255050, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($LevelBrowserLayer::*)(SetTextPopup*, std::string)){&$LevelBrowserLayer::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            m->registerHook(base+0x255760, extract((void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed}));

        if ((void($LevelBrowserLayer::*)(FLAlertLayer*, bool)){&$LevelBrowserLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x255840, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0x2554f0, extract((void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $LevelFeatureLayer : public LevelFeatureLayer, public $CacBase {
public:
    dupable ~$LevelFeatureLayer() override {}

    dupable void keyBackClicked() {
        if ((void($LevelFeatureLayer::*)()){&$LevelFeatureLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x297a00))(this);
        else return LevelFeatureLayer::keyBackClicked();
    }

    dupable $LevelFeatureLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelFeatureLayer::*)()){&$LevelFeatureLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x297a00, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LocalLevelManager : public LocalLevelManager, public $CacBase {
public:
    dupable ~$LocalLevelManager() override {}

    dupable bool init() {
        if ((bool($LocalLevelManager::*)()){&$LocalLevelManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x35dfc0))(this);
        else return LocalLevelManager::init();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) {
        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x35ed60))(this, p0);
        else return LocalLevelManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) {
        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x35eda0))(this, p0);
        else return LocalLevelManager::dataLoaded(p0);
    }

    dupable void firstLoad() {
        if ((void($LocalLevelManager::*)()){&$LocalLevelManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35ed10))(this);
        else return LocalLevelManager::firstLoad();
    }

    dupable $LocalLevelManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LocalLevelManager::*)()){&$LocalLevelManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x35dfc0, extract((bool(D::*)()){&D::init}));

        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x35ed60, extract((void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x35eda0, extract((void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($LocalLevelManager::*)()){&$LocalLevelManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x35ed10, extract((void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $PromoInterstitial : public PromoInterstitial, public $CacBase {
public:
    dupable ~$PromoInterstitial() override {}

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x169e80))(this, p0, p1);
        else return PromoInterstitial::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x16a0c0))(this, p0, p1);
        else return PromoInterstitial::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x169fa0))(this, p0, p1);
        else return PromoInterstitial::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x16a040))(this, p0, p1);
        else return PromoInterstitial::ccTouchCancelled(p0, p1);
    }

    dupable void keyBackClicked() {
        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169cf0))(this);
        else return PromoInterstitial::keyBackClicked();
    }

    dupable void show() {
        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169cc0))(this);
        else return PromoInterstitial::show();
    }

    dupable $PromoInterstitial() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x169e80, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x16a0c0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x169fa0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x16a040, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x169cf0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x169cc0, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $PurchaseItemPopup : public PurchaseItemPopup, public $CacBase {
public:
    dupable ~$PurchaseItemPopup() override {}

    dupable void keyBackClicked() {
        if ((void($PurchaseItemPopup::*)()){&$PurchaseItemPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1a2fc0))(this);
        else return PurchaseItemPopup::keyBackClicked();
    }

    dupable $PurchaseItemPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PurchaseItemPopup::*)()){&$PurchaseItemPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1a2fc0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $RewardUnlockLayer : public RewardUnlockLayer, public $CacBase {
public:
    dupable ~$RewardUnlockLayer() override {}

    dupable void keyBackClicked() {
        if ((void($RewardUnlockLayer::*)()){&$RewardUnlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf81b0))(this);
        else return RewardUnlockLayer::keyBackClicked();
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) {
        if ((void($RewardUnlockLayer::*)(CurrencyRewardLayer*)){&$RewardUnlockLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0xf8170))(this, p0);
        else return RewardUnlockLayer::currencyWillExit(p0);
    }

    dupable $RewardUnlockLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RewardUnlockLayer::*)()){&$RewardUnlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf81b0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($RewardUnlockLayer::*)(CurrencyRewardLayer*)){&$RewardUnlockLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0xf8170, extract((void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));
    }
};


template<class D>
class $SecretNumberLayer : public SecretNumberLayer, public $CacBase {
public:
    dupable ~$SecretNumberLayer() override {}

    dupable bool init() {
        if ((bool($SecretNumberLayer::*)()){&$SecretNumberLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x266c30))(this);
        else return SecretNumberLayer::init();
    }

    dupable $SecretNumberLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretNumberLayer::*)()){&$SecretNumberLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x266c30, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $SetupOpacityPopup : public SetupOpacityPopup, public $CacBase {
public:
    dupable ~$SetupOpacityPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34bf0))(this);
        else return SetupOpacityPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34ba0))(this);
        else return SetupOpacityPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34a20))(this, p0);
        else return SetupOpacityPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34a60))(this, p0);
        else return SetupOpacityPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*, float)){&$SetupOpacityPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x34e50))(this, p0, p1);
        else return SetupOpacityPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34f10))(this, p0);
        else return SetupOpacityPopup::textInputReturn(p0);
    }

    dupable $SetupOpacityPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x34bf0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x34ba0, extract((void(D::*)()){&D::show}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x34a20, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x34a60, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*, float)){&$SetupOpacityPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x34e50, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x34f10, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareCommentLayer : public ShareCommentLayer, public $CacBase {
public:
    dupable ~$ShareCommentLayer() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x350590))(this);
        else return ShareCommentLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3504e0))(this);
        else return ShareCommentLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x350690))(this, p0);
        else return ShareCommentLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3505d0))(this, p0);
        else return ShareCommentLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3507b0))(this, p0);
        else return ShareCommentLayer::textChanged(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3509f0))(this, p0, p1);
        else return ShareCommentLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x350ad0))(this, p0, p1);
        else return ShareCommentLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($ShareCommentLayer::*)(UploadActionPopup*)){&$ShareCommentLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x350ba0))(this, p0);
        else return ShareCommentLayer::onClosePopup(p0);
    }

    dupable $ShareCommentLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x350590, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3504e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x350690, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3505d0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x3507b0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x3509f0, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x350ad0, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($ShareCommentLayer::*)(UploadActionPopup*)){&$ShareCommentLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x350ba0, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $SpriteDescription : public SpriteDescription, public $CacBase {
public:
    dupable ~$SpriteDescription() override {}

    dupable $SpriteDescription() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TableViewDelegate : public TableViewDelegate, public $CacBase {
public:
    dupable ~$TableViewDelegate() override {}

    dupable void willTweenToIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($TableViewDelegate::*)(CCIndexPath&, TableViewCell*, TableView*)){&$TableViewDelegate::willTweenToIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::willTweenToIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x120460))(this, p0, p1, p2);
        else return TableViewDelegate::willTweenToIndexPath(p0, p1, p2);
    }

    dupable void didEndTweenToIndexPath(CCIndexPath& p0, TableView* p1) {
        if ((void($TableViewDelegate::*)(CCIndexPath&, TableView*)){&$TableViewDelegate::didEndTweenToIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didEndTweenToIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x120470))(this, p0, p1);
        else return TableViewDelegate::didEndTweenToIndexPath(p0, p1);
    }

    dupable void TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {
        if ((void($TableViewDelegate::*)(CCIndexPath&, TableViewCell*, TableView*)){&$TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewDidDisplayCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x120480))(this, p0, p1, p2);
        else return TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath(p0, p1, p2);
    }

    dupable $TableViewDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TableViewDelegate::*)(CCIndexPath&, TableViewCell*, TableView*)){&$TableViewDelegate::willTweenToIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::willTweenToIndexPath})
            m->registerHook(base+0x120460, extract((void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::willTweenToIndexPath}));

        if ((void($TableViewDelegate::*)(CCIndexPath&, TableView*)){&$TableViewDelegate::didEndTweenToIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didEndTweenToIndexPath})
            m->registerHook(base+0x120470, extract((void(D::*)(CCIndexPath&, TableView*)){&D::didEndTweenToIndexPath}));

        if ((void($TableViewDelegate::*)(CCIndexPath&, TableViewCell*, TableView*)){&$TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewDidDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x120480, extract((void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewDidDisplayCellForRowAtIndexPath}));
    }
};


template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
public:
    dupable ~$TextInputDelegate() override {}

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1573f0))(this, p0);
        else return TextInputDelegate::textChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x6200))(this, p0);
        else return TextInputDelegate::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x157400))(this, p0);
        else return TextInputDelegate::textInputClosed(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*, float)){&$TextInputDelegate::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0xe1810))(this, p0, p1);
        else return TextInputDelegate::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1820))(this, p0);
        else return TextInputDelegate::textInputReturn(p0);
    }

    dupable void allowTextInput(CCTextInputNode* p0) {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x6210))(this, p0);
        else return TextInputDelegate::allowTextInput(p0);
    }

    dupable $TextInputDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1573f0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x6200, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x157400, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*, float)){&$TextInputDelegate::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0xe1810, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0xe1820, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            m->registerHook(base+0x6210, extract((void(D::*)(CCTextInputNode*)){&D::allowTextInput}));
    }
};


template<class D>
class $UploadActionPopup : public UploadActionPopup, public $CacBase {
public:
    dupable ~$UploadActionPopup() override {}

    dupable void keyBackClicked() {
        if ((void($UploadActionPopup::*)()){&$UploadActionPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14ca10))(this);
        else return UploadActionPopup::keyBackClicked();
    }

    dupable $UploadActionPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadActionPopup::*)()){&$UploadActionPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14ca10, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $VideoOptionsLayer : public VideoOptionsLayer, public $CacBase {
public:
    dupable ~$VideoOptionsLayer() override {}

    dupable bool init() {
        if ((bool($VideoOptionsLayer::*)()){&$VideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x442460))(this);
        else return VideoOptionsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($VideoOptionsLayer::*)()){&$VideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x443f50))(this);
        else return VideoOptionsLayer::keyBackClicked();
    }

    dupable $VideoOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($VideoOptionsLayer::*)()){&$VideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x442460, extract((bool(D::*)()){&D::init}));

        if ((void($VideoOptionsLayer::*)()){&$VideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x443f50, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $AchievementManager : public AchievementManager, public $CacBase {
public:
    dupable ~$AchievementManager() override {}

    dupable bool init() {
        if ((bool($AchievementManager::*)()){&$AchievementManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x4244c0))(this);
        else return AchievementManager::init();
    }

    dupable $AchievementManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementManager::*)()){&$AchievementManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x4244c0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $AnimatedGameObject : public AnimatedGameObject, public $CacBase {
public:
    dupable ~$AnimatedGameObject() override {}

    dupable void setOpacity(unsigned char p0) {
        if ((void($AnimatedGameObject::*)(unsigned char)){&$AnimatedGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0xc8640))(this, p0);
        else return AnimatedGameObject::setOpacity(p0);
    }

    dupable void resetObject() {
        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc9720))(this);
        else return AnimatedGameObject::resetObject();
    }

    dupable void activateObject() {
        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc84d0))(this);
        else return AnimatedGameObject::activateObject();
    }

    dupable void deactivateObject(bool p0) {
        if ((void($AnimatedGameObject::*)(bool)){&$AnimatedGameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xc85e0))(this, p0);
        else return AnimatedGameObject::deactivateObject(p0);
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) {
        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B const&)){&$AnimatedGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xc8720))(this, p0);
        else return AnimatedGameObject::setObjectColor(p0);
    }

    dupable void animationFinished(char const* p0) {
        if ((void($AnimatedGameObject::*)(char const*)){&$AnimatedGameObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0xc8750))(this, p0);
        else return AnimatedGameObject::animationFinished(p0);
    }

    dupable void displayFrameChanged(cocos2d::CCObject* p0, std::string p1) {
        if ((void($AnimatedGameObject::*)(cocos2d::CCObject*, std::string)){&$AnimatedGameObject::displayFrameChanged} != (void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string)>(m->getOriginal(base+0xc9160))(this, p0, p1);
        else return AnimatedGameObject::displayFrameChanged(p0, p1);
    }

    dupable $AnimatedGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AnimatedGameObject::*)(unsigned char)){&$AnimatedGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0xc8640, extract((void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0xc9720, extract((void(D::*)()){&D::resetObject}));

        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(base+0xc84d0, extract((void(D::*)()){&D::activateObject}));

        if ((void($AnimatedGameObject::*)(bool)){&$AnimatedGameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(base+0xc85e0, extract((void(D::*)(bool)){&D::deactivateObject}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B const&)){&$AnimatedGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0xc8720, extract((void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($AnimatedGameObject::*)(char const*)){&$AnimatedGameObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0xc8750, extract((void(D::*)(char const*)){&D::animationFinished}));

        if ((void($AnimatedGameObject::*)(cocos2d::CCObject*, std::string)){&$AnimatedGameObject::displayFrameChanged} != (void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged})
            m->registerHook(base+0xc9160, extract((void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged}));
    }
};


template<class D>
class $AnimatedShopKeeper : public AnimatedShopKeeper, public $CacBase {
public:
    dupable ~$AnimatedShopKeeper() override {}

    dupable void animationFinished(char const* p0) {
        if ((void($AnimatedShopKeeper::*)(char const*)){&$AnimatedShopKeeper::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1a3130))(this, p0);
        else return AnimatedShopKeeper::animationFinished(p0);
    }

    dupable $AnimatedShopKeeper() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AnimatedShopKeeper::*)(char const*)){&$AnimatedShopKeeper::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x1a3130, extract((void(D::*)(char const*)){&D::animationFinished}));
    }
};


template<class D>
class $ColorChannelSprite : public ColorChannelSprite, public $CacBase {
public:
    dupable ~$ColorChannelSprite() override {}

    dupable bool init() {
        if ((bool($ColorChannelSprite::*)()){&$ColorChannelSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x16deb0))(this);
        else return ColorChannelSprite::init();
    }

    dupable $ColorChannelSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ColorChannelSprite::*)()){&$ColorChannelSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x16deb0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ConfigureHSVWidget : public ConfigureHSVWidget, public $CacBase {
public:
    dupable ~$ConfigureHSVWidget() override {}

    dupable $ConfigureHSVWidget() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $EditorOptionsLayer : public EditorOptionsLayer, public $CacBase {
public:
    dupable ~$EditorOptionsLayer() override {}

    dupable bool init() {
        if ((bool($EditorOptionsLayer::*)()){&$EditorOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x147420))(this);
        else return EditorOptionsLayer::init();
    }

    dupable void setupOptions() {
        if ((void($EditorOptionsLayer::*)()){&$EditorOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x147440))(this);
        else return EditorOptionsLayer::setupOptions();
    }

    dupable void onClose(cocos2d::CCObject* p0) {
        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x147c30))(this, p0);
        else return EditorOptionsLayer::onClose(p0);
    }

    dupable $EditorOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($EditorOptionsLayer::*)()){&$EditorOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x147420, extract((bool(D::*)()){&D::init}));

        if ((void($EditorOptionsLayer::*)()){&$EditorOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            m->registerHook(base+0x147440, extract((void(D::*)()){&D::setupOptions}));

        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            m->registerHook(base+0x147c30, extract((void(D::*)(cocos2d::CCObject*)){&D::onClose}));
    }
};


template<class D>
class $FriendRequestPopup : public FriendRequestPopup, public $CacBase {
public:
    dupable ~$FriendRequestPopup() override {}

    dupable void keyBackClicked() {
        if ((void($FriendRequestPopup::*)()){&$FriendRequestPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14e2a0))(this);
        else return FriendRequestPopup::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x14e390))(this, p0, p1);
        else return FriendRequestPopup::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x14e560))(this, p0, p1);
        else return FriendRequestPopup::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($FriendRequestPopup::*)(UploadActionPopup*)){&$FriendRequestPopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x14e640))(this, p0);
        else return FriendRequestPopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($FriendRequestPopup::*)(FLAlertLayer*, bool)){&$FriendRequestPopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x14e7c0))(this, p0, p1);
        else return FriendRequestPopup::FLAlert_Clicked(p0, p1);
    }

    dupable $FriendRequestPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FriendRequestPopup::*)()){&$FriendRequestPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14e2a0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x14e390, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x14e560, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($FriendRequestPopup::*)(UploadActionPopup*)){&$FriendRequestPopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x14e640, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($FriendRequestPopup::*)(FLAlertLayer*, bool)){&$FriendRequestPopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x14e7c0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $FriendsProfilePage : public FriendsProfilePage, public $CacBase {
public:
    dupable ~$FriendsProfilePage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa6e0))(this);
        else return FriendsProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa5e0))(this);
        else return FriendsProfilePage::keyBackClicked();
    }

    dupable void getUserListFinished(cocos2d::CCArray* p0, UserListType p1) {
        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::getUserListFinished} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, UserListType)>(m->getOriginal(base+0x3aa240))(this, p0, p1);
        else return FriendsProfilePage::getUserListFinished(p0, p1);
    }

    dupable void getUserListFailed(UserListType p0, GJErrorCode p1) {
        if ((void($FriendsProfilePage::*)(UserListType, GJErrorCode)){&$FriendsProfilePage::getUserListFailed} != (void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed})
            return reinterpret_cast<void(*)(decltype(this), UserListType, GJErrorCode)>(m->getOriginal(base+0x3aa390))(this, p0, p1);
        else return FriendsProfilePage::getUserListFailed(p0, p1);
    }

    dupable void userListChanged(cocos2d::CCArray* p0, UserListType p1) {
        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::userListChanged} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, UserListType)>(m->getOriginal(base+0x3aa4a0))(this, p0, p1);
        else return FriendsProfilePage::userListChanged(p0, p1);
    }

    dupable void forceReloadList(UserListType p0) {
        if ((void($FriendsProfilePage::*)(UserListType)){&$FriendsProfilePage::forceReloadList} != (void(D::*)(UserListType)){&D::forceReloadList})
            return reinterpret_cast<void(*)(decltype(this), UserListType)>(m->getOriginal(base+0x3aa4e0))(this, p0);
        else return FriendsProfilePage::forceReloadList(p0);
    }

    dupable $FriendsProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x3aa6e0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3aa5e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::getUserListFinished} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished})
            m->registerHook(base+0x3aa240, extract((void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished}));

        if ((void($FriendsProfilePage::*)(UserListType, GJErrorCode)){&$FriendsProfilePage::getUserListFailed} != (void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed})
            m->registerHook(base+0x3aa390, extract((void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed}));

        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::userListChanged} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged})
            m->registerHook(base+0x3aa4a0, extract((void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged}));

        if ((void($FriendsProfilePage::*)(UserListType)){&$FriendsProfilePage::forceReloadList} != (void(D::*)(UserListType)){&D::forceReloadList})
            m->registerHook(base+0x3aa4e0, extract((void(D::*)(UserListType)){&D::forceReloadList}));
    }
};


template<class D>
class $GJCommentListLayer : public GJCommentListLayer, public $CacBase {
public:
    dupable ~$GJCommentListLayer() override {}

    dupable $GJCommentListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJMoveCommandLayer : public GJMoveCommandLayer, public $CacBase {
public:
    dupable ~$GJMoveCommandLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x374970))(this);
        else return GJMoveCommandLayer::keyBackClicked();
    }

    dupable void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(base+0x373c20))(this, p0, p1);
        else return GJMoveCommandLayer::valuePopupClosed(p0, p1);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374430))(this, p0);
        else return GJMoveCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374470))(this, p0);
        else return GJMoveCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x374b50))(this, p0, p1);
        else return GJMoveCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374c10))(this, p0);
        else return GJMoveCommandLayer::textInputReturn(p0);
    }

    dupable $GJMoveCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x374970, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(base+0x373c20, extract((void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x374430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x374470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x374b50, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x374c10, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GameEffectsManager : public GameEffectsManager, public $CacBase {
public:
    dupable ~$GameEffectsManager() override {}

    dupable $GameEffectsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GroupCommandObject : public GroupCommandObject, public $CacBase {
public:
    dupable ~$GroupCommandObject() override {}

    dupable bool init() {
        if ((bool($GroupCommandObject::*)()){&$GroupCommandObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x16e590))(this);
        else return GroupCommandObject::init();
    }

    dupable void updateTweenAction(float p0, char const* p1) {
        if ((void($GroupCommandObject::*)(float, char const*)){&$GroupCommandObject::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x16ead0))(this, p0, p1);
        else return GroupCommandObject::updateTweenAction(p0, p1);
    }

    dupable $GroupCommandObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GroupCommandObject::*)()){&$GroupCommandObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x16e590, extract((bool(D::*)()){&D::init}));

        if ((void($GroupCommandObject::*)(float, char const*)){&$GroupCommandObject::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x16ead0, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $KeybindingsManager : public KeybindingsManager, public $CacBase {
public:
    dupable ~$KeybindingsManager() override {}

    dupable bool init() {
        if ((bool($KeybindingsManager::*)()){&$KeybindingsManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x289a00))(this);
        else return KeybindingsManager::init();
    }

    dupable $KeybindingsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeybindingsManager::*)()){&$KeybindingsManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x289a00, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $LevelSettingsLayer : public LevelSettingsLayer, public $CacBase {
public:
    dupable ~$LevelSettingsLayer() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac070))(this);
        else return LevelSettingsLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac7b0))(this);
        else return LevelSettingsLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($LevelSettingsLayer::*)(FLAlertLayer*, bool)){&$LevelSettingsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xac260))(this, p0, p1);
        else return LevelSettingsLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) {
        if ((void($LevelSettingsLayer::*)(cocos2d::CCNode*)){&$LevelSettingsLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xac100))(this, p0);
        else return LevelSettingsLayer::colorSelectClosed(p0);
    }

    dupable void customSongLayerClosed() {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::customSongLayerClosed} != (void(D::*)()){&D::customSongLayerClosed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac340))(this);
        else return LevelSettingsLayer::customSongLayerClosed();
    }

    dupable void selectArtClosed(SelectArtLayer* p0) {
        if ((void($LevelSettingsLayer::*)(SelectArtLayer*)){&$LevelSettingsLayer::selectArtClosed} != (void(D::*)(SelectArtLayer*)){&D::selectArtClosed})
            return reinterpret_cast<void(*)(decltype(this), SelectArtLayer*)>(m->getOriginal(base+0xac5e0))(this, p0);
        else return LevelSettingsLayer::selectArtClosed(p0);
    }

    dupable $LevelSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0xac070, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xac7b0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSettingsLayer::*)(FLAlertLayer*, bool)){&$LevelSettingsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xac260, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelSettingsLayer::*)(cocos2d::CCNode*)){&$LevelSettingsLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xac100, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::customSongLayerClosed} != (void(D::*)()){&D::customSongLayerClosed})
            m->registerHook(base+0xac340, extract((void(D::*)()){&D::customSongLayerClosed}));

        if ((void($LevelSettingsLayer::*)(SelectArtLayer*)){&$LevelSettingsLayer::selectArtClosed} != (void(D::*)(SelectArtLayer*)){&D::selectArtClosed})
            m->registerHook(base+0xac5e0, extract((void(D::*)(SelectArtLayer*)){&D::selectArtClosed}));
    }
};


template<class D>
class $AchievementNotifier : public AchievementNotifier, public $CacBase {
public:
    dupable ~$AchievementNotifier() override {}

    dupable bool init() {
        if ((bool($AchievementNotifier::*)()){&$AchievementNotifier::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x464e90))(this);
        else return AchievementNotifier::init();
    }

    dupable $AchievementNotifier() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementNotifier::*)()){&$AchievementNotifier::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x464e90, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CCAnimateFrameCache : public CCAnimateFrameCache, public $CacBase {
public:
    dupable ~$CCAnimateFrameCache() override {}

    dupable $CCAnimateFrameCache() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CollisionBlockPopup : public CollisionBlockPopup, public $CacBase {
public:
    dupable ~$CollisionBlockPopup() override {}

    dupable void keyBackClicked() {
        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1317e0))(this);
        else return CollisionBlockPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x131790))(this);
        else return CollisionBlockPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x131630))(this, p0);
        else return CollisionBlockPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x131670))(this, p0);
        else return CollisionBlockPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*, float)){&$CollisionBlockPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1318f0))(this, p0, p1);
        else return CollisionBlockPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1319b0))(this, p0);
        else return CollisionBlockPopup::textInputReturn(p0);
    }

    dupable $CollisionBlockPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1317e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x131790, extract((void(D::*)()){&D::show}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x131630, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x131670, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*, float)){&$CollisionBlockPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1318f0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1319b0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $CommunityCreditNode : public CommunityCreditNode, public $CacBase {
public:
    dupable ~$CommunityCreditNode() override {}

    dupable $CommunityCreditNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $ConfigureValuePopup : public ConfigureValuePopup, public $CacBase {
public:
    dupable ~$ConfigureValuePopup() override {}

    dupable void keyBackClicked() {
        if ((void($ConfigureValuePopup::*)()){&$ConfigureValuePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x382c00))(this);
        else return ConfigureValuePopup::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x382a90))(this, p0);
        else return ConfigureValuePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x382ad0))(this, p0);
        else return ConfigureValuePopup::textChanged(p0);
    }

    dupable $ConfigureValuePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ConfigureValuePopup::*)()){&$ConfigureValuePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x382c00, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x382a90, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x382ad0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $CurrencyRewardLayer : public CurrencyRewardLayer, public $CacBase {
public:
    dupable ~$CurrencyRewardLayer() override {}

    dupable void update(float p0) {
        if ((void($CurrencyRewardLayer::*)(float)){&$CurrencyRewardLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x44a5c0))(this, p0);
        else return CurrencyRewardLayer::update(p0);
    }

    dupable $CurrencyRewardLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CurrencyRewardLayer::*)(float)){&$CurrencyRewardLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x44a5c0, extract((void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $EditGameObjectPopup : public EditGameObjectPopup, public $CacBase {
public:
    dupable ~$EditGameObjectPopup() override {}

    dupable void keyBackClicked() {
        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x154070))(this);
        else return EditGameObjectPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x154020))(this);
        else return EditGameObjectPopup::show();
    }

    dupable $EditGameObjectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x154070, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x154020, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $FRequestProfilePage : public FRequestProfilePage, public $CacBase {
public:
    dupable ~$FRequestProfilePage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x437300))(this);
        else return FRequestProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4372d0))(this);
        else return FRequestProfilePage::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($FRequestProfilePage::*)(FLAlertLayer*, bool)){&$FRequestProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x437200))(this, p0, p1);
        else return FRequestProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($FRequestProfilePage::*)(UploadActionPopup*)){&$FRequestProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x437340))(this, p0);
        else return FRequestProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x4373a0))(this, p0, p1);
        else return FRequestProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x437500))(this, p0, p1);
        else return FRequestProfilePage::uploadActionFailed(p0, p1);
    }

    dupable void loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($FRequestProfilePage::*)(cocos2d::CCArray*, char const*)){&$FRequestProfilePage::loadFRequestsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x437840))(this, p0, p1);
        else return FRequestProfilePage::loadFRequestsFinished(p0, p1);
    }

    dupable void loadFRequestsFailed(char const* p0, GJErrorCode p1) {
        if ((void($FRequestProfilePage::*)(char const*, GJErrorCode)){&$FRequestProfilePage::loadFRequestsFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*, GJErrorCode)>(m->getOriginal(base+0x437930))(this, p0, p1);
        else return FRequestProfilePage::loadFRequestsFailed(p0, p1);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($FRequestProfilePage::*)(std::string, char const*)){&$FRequestProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x437ab0))(this, p0, p1);
        else return FRequestProfilePage::setupPageInfo(p0, p1);
    }

    dupable void forceReloadRequests(bool p0) {
        if ((void($FRequestProfilePage::*)(bool)){&$FRequestProfilePage::forceReloadRequests} != (void(D::*)(bool)){&D::forceReloadRequests})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x437a60))(this, p0);
        else return FRequestProfilePage::forceReloadRequests(p0);
    }

    dupable $FRequestProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x437300, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4372d0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($FRequestProfilePage::*)(FLAlertLayer*, bool)){&$FRequestProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x437200, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($FRequestProfilePage::*)(UploadActionPopup*)){&$FRequestProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x437340, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x4373a0, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x437500, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($FRequestProfilePage::*)(cocos2d::CCArray*, char const*)){&$FRequestProfilePage::loadFRequestsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished})
            m->registerHook(base+0x437840, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished}));

        if ((void($FRequestProfilePage::*)(char const*, GJErrorCode)){&$FRequestProfilePage::loadFRequestsFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed})
            m->registerHook(base+0x437930, extract((void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed}));

        if ((void($FRequestProfilePage::*)(std::string, char const*)){&$FRequestProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x437ab0, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($FRequestProfilePage::*)(bool)){&$FRequestProfilePage::forceReloadRequests} != (void(D::*)(bool)){&D::forceReloadRequests})
            m->registerHook(base+0x437a60, extract((void(D::*)(bool)){&D::forceReloadRequests}));
    }
};


template<class D>
class $GJWriteMessagePopup : public GJWriteMessagePopup, public $CacBase {
public:
    dupable ~$GJWriteMessagePopup() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1527b0))(this);
        else return GJWriteMessagePopup::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x152780))(this);
        else return GJWriteMessagePopup::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x152830))(this, p0);
        else return GJWriteMessagePopup::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1527f0))(this, p0);
        else return GJWriteMessagePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x152990))(this, p0);
        else return GJWriteMessagePopup::textChanged(p0);
    }

    dupable void uploadMessageFinished(int p0) {
        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFinished} != (void(D::*)(int)){&D::uploadMessageFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x152fc0))(this, p0);
        else return GJWriteMessagePopup::uploadMessageFinished(p0);
    }

    dupable void uploadMessageFailed(int p0) {
        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFailed} != (void(D::*)(int)){&D::uploadMessageFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1530a0))(this, p0);
        else return GJWriteMessagePopup::uploadMessageFailed(p0);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($GJWriteMessagePopup::*)(UploadActionPopup*)){&$GJWriteMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x153170))(this, p0);
        else return GJWriteMessagePopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($GJWriteMessagePopup::*)(FLAlertLayer*, bool)){&$GJWriteMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1532b0))(this, p0, p1);
        else return GJWriteMessagePopup::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*, float)){&$GJWriteMessagePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x153390))(this, p0, p1);
        else return GJWriteMessagePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x153450))(this, p0);
        else return GJWriteMessagePopup::textInputReturn(p0);
    }

    dupable $GJWriteMessagePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1527b0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x152780, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x152830, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1527f0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x152990, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFinished} != (void(D::*)(int)){&D::uploadMessageFinished})
            m->registerHook(base+0x152fc0, extract((void(D::*)(int)){&D::uploadMessageFinished}));

        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFailed} != (void(D::*)(int)){&D::uploadMessageFailed})
            m->registerHook(base+0x1530a0, extract((void(D::*)(int)){&D::uploadMessageFailed}));

        if ((void($GJWriteMessagePopup::*)(UploadActionPopup*)){&$GJWriteMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x153170, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($GJWriteMessagePopup::*)(FLAlertLayer*, bool)){&$GJWriteMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1532b0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*, float)){&$GJWriteMessagePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x153390, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x153450, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GauntletSelectLayer : public GauntletSelectLayer, public $CacBase {
public:
    dupable ~$GauntletSelectLayer() override {}

    dupable void onExit() {
        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2eb490))(this);
        else return GauntletSelectLayer::onExit();
    }

    dupable void keyBackClicked() {
        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2eb370))(this);
        else return GauntletSelectLayer::keyBackClicked();
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) {
        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x2eb260))(this, p0, p1);
        else return GauntletSelectLayer::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) {
        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x2eb150))(this, p0, p1);
        else return GauntletSelectLayer::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($GauntletSelectLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletSelectLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x2ea630))(this, p0, p1);
        else return GauntletSelectLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) {
        if ((void($GauntletSelectLayer::*)(char const*)){&$GauntletSelectLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2ea820))(this, p0);
        else return GauntletSelectLayer::loadLevelsFailed(p0);
    }

    dupable $GauntletSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x2eb490, extract((void(D::*)()){&D::onExit}));

        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2eb370, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x2eb260, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));

        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x2eb150, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($GauntletSelectLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletSelectLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x2ea630, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($GauntletSelectLayer::*)(char const*)){&$GauntletSelectLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x2ea820, extract((void(D::*)(char const*)){&D::loadLevelsFailed}));
    }
};


template<class D>
class $GravityEffectSprite : public GravityEffectSprite, public $CacBase {
public:
    dupable ~$GravityEffectSprite() override {}

    dupable bool init() {
        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x80b20))(this);
        else return GravityEffectSprite::init();
    }

    dupable void draw() {
        if ((void($GravityEffectSprite::*)()){&$GravityEffectSprite::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80d80))(this);
        else return GravityEffectSprite::draw();
    }

    dupable $GravityEffectSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x80b20, extract((bool(D::*)()){&D::init}));

        if ((void($GravityEffectSprite::*)()){&$GravityEffectSprite::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x80d80, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $LevelSettingsObject : public LevelSettingsObject, public $CacBase {
public:
    dupable ~$LevelSettingsObject() override {}

    dupable bool init() {
        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xa5690))(this);
        else return LevelSettingsObject::init();
    }

    dupable $LevelSettingsObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xa5690, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $MessagesProfilePage : public MessagesProfilePage, public $CacBase {
public:
    dupable ~$MessagesProfilePage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x107eb0))(this);
        else return MessagesProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x107e80))(this);
        else return MessagesProfilePage::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($MessagesProfilePage::*)(FLAlertLayer*, bool)){&$MessagesProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x107b20))(this, p0, p1);
        else return MessagesProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) {
        if ((void($MessagesProfilePage::*)(UploadActionPopup*)){&$MessagesProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x107b90))(this, p0);
        else return MessagesProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x107bf0))(this, p0, p1);
        else return MessagesProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x107d50))(this, p0, p1);
        else return MessagesProfilePage::uploadActionFailed(p0, p1);
    }

    dupable void loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($MessagesProfilePage::*)(cocos2d::CCArray*, char const*)){&$MessagesProfilePage::loadMessagesFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x108150))(this, p0, p1);
        else return MessagesProfilePage::loadMessagesFinished(p0, p1);
    }

    dupable void loadMessagesFailed(char const* p0, GJErrorCode p1) {
        if ((void($MessagesProfilePage::*)(char const*, GJErrorCode)){&$MessagesProfilePage::loadMessagesFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*, GJErrorCode)>(m->getOriginal(base+0x108280))(this, p0, p1);
        else return MessagesProfilePage::loadMessagesFailed(p0, p1);
    }

    dupable void forceReloadMessages(bool p0) {
        if ((void($MessagesProfilePage::*)(bool)){&$MessagesProfilePage::forceReloadMessages} != (void(D::*)(bool)){&D::forceReloadMessages})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1083b0))(this, p0);
        else return MessagesProfilePage::forceReloadMessages(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($MessagesProfilePage::*)(std::string, char const*)){&$MessagesProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x108400))(this, p0, p1);
        else return MessagesProfilePage::setupPageInfo(p0, p1);
    }

    dupable $MessagesProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x107eb0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x107e80, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MessagesProfilePage::*)(FLAlertLayer*, bool)){&$MessagesProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x107b20, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($MessagesProfilePage::*)(UploadActionPopup*)){&$MessagesProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x107b90, extract((void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x107bf0, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x107d50, extract((void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($MessagesProfilePage::*)(cocos2d::CCArray*, char const*)){&$MessagesProfilePage::loadMessagesFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished})
            m->registerHook(base+0x108150, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished}));

        if ((void($MessagesProfilePage::*)(char const*, GJErrorCode)){&$MessagesProfilePage::loadMessagesFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed})
            m->registerHook(base+0x108280, extract((void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed}));

        if ((void($MessagesProfilePage::*)(bool)){&$MessagesProfilePage::forceReloadMessages} != (void(D::*)(bool)){&D::forceReloadMessages})
            m->registerHook(base+0x1083b0, extract((void(D::*)(bool)){&D::forceReloadMessages}));

        if ((void($MessagesProfilePage::*)(std::string, char const*)){&$MessagesProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x108400, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));
    }
};


template<class D>
class $SetupAnimationPopup : public SetupAnimationPopup, public $CacBase {
public:
    dupable ~$SetupAnimationPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ade0))(this);
        else return SetupAnimationPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ad90))(this);
        else return SetupAnimationPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20aaf0))(this, p0);
        else return SetupAnimationPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20ab30))(this, p0);
        else return SetupAnimationPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*, float)){&$SetupAnimationPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x20af30))(this, p0, p1);
        else return SetupAnimationPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20aff0))(this, p0);
        else return SetupAnimationPopup::textInputReturn(p0);
    }

    dupable $SetupAnimationPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20ade0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x20ad90, extract((void(D::*)()){&D::show}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x20aaf0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x20ab30, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*, float)){&$SetupAnimationPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x20af30, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x20aff0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $AccountRegisterLayer : public AccountRegisterLayer, public $CacBase {
public:
    dupable ~$AccountRegisterLayer() override {}

    dupable bool init() {
        if ((bool($AccountRegisterLayer::*)()){&$AccountRegisterLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2575d0))(this);
        else return AccountRegisterLayer::init();
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25a910))(this);
        else return AccountRegisterLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25a730))(this);
        else return AccountRegisterLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($AccountRegisterLayer::*)(FLAlertLayer*, bool)){&$AccountRegisterLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x25a380))(this, p0, p1);
        else return AccountRegisterLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b420))(this, p0);
        else return AccountRegisterLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25a950))(this, p0);
        else return AccountRegisterLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b440))(this, p0);
        else return AccountRegisterLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*, float)){&$AccountRegisterLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x25b460))(this, p0, p1);
        else return AccountRegisterLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b520))(this, p0);
        else return AccountRegisterLayer::textInputReturn(p0);
    }

    dupable void allowTextInput(CCTextInputNode* p0) {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b5d0))(this, p0);
        else return AccountRegisterLayer::allowTextInput(p0);
    }

    dupable void registerAccountFinished() {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerAccountFinished} != (void(D::*)()){&D::registerAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x259bf0))(this);
        else return AccountRegisterLayer::registerAccountFinished();
    }

    dupable void registerAccountFailed(AccountError p0) {
        if ((void($AccountRegisterLayer::*)(AccountError)){&$AccountRegisterLayer::registerAccountFailed} != (void(D::*)(AccountError)){&D::registerAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), AccountError)>(m->getOriginal(base+0x259d70))(this, p0);
        else return AccountRegisterLayer::registerAccountFailed(p0);
    }

    dupable $AccountRegisterLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AccountRegisterLayer::*)()){&$AccountRegisterLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2575d0, extract((bool(D::*)()){&D::init}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25a910, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25a730, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($AccountRegisterLayer::*)(FLAlertLayer*, bool)){&$AccountRegisterLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x25a380, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x25b420, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x25a950, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x25b440, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*, float)){&$AccountRegisterLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x25b460, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x25b520, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            m->registerHook(base+0x25b5d0, extract((void(D::*)(CCTextInputNode*)){&D::allowTextInput}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerAccountFinished} != (void(D::*)()){&D::registerAccountFinished})
            m->registerHook(base+0x259bf0, extract((void(D::*)()){&D::registerAccountFinished}));

        if ((void($AccountRegisterLayer::*)(AccountError)){&$AccountRegisterLayer::registerAccountFailed} != (void(D::*)(AccountError)){&D::registerAccountFailed})
            m->registerHook(base+0x259d70, extract((void(D::*)(AccountError)){&D::registerAccountFailed}));
    }
};


template<class D>
class $CommunityCreditsPage : public CommunityCreditsPage, public $CacBase {
public:
    dupable ~$CommunityCreditsPage() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e9f0))(this);
        else return CommunityCreditsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e980))(this);
        else return CommunityCreditsPage::keyBackClicked();
    }

    dupable void show() {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e7e0))(this);
        else return CommunityCreditsPage::show();
    }

    dupable $CommunityCreditsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x19e9f0, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x19e980, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x19e7e0, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $CustomizeObjectLayer : public CustomizeObjectLayer, public $CacBase {
public:
    dupable ~$CustomizeObjectLayer() override {}

    dupable void keyBackClicked() {
        if ((void($CustomizeObjectLayer::*)()){&$CustomizeObjectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xe16c0))(this);
        else return CustomizeObjectLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1280))(this, p0);
        else return CustomizeObjectLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1430))(this, p0);
        else return CustomizeObjectLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1470))(this, p0);
        else return CustomizeObjectLayer::textChanged(p0);
    }

    dupable void hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) {
        if ((void($CustomizeObjectLayer::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&$CustomizeObjectLayer::hsvPopupClosed} != (void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), HSVWidgetPopup*, cocos2d::_ccHSVValue)>(m->getOriginal(base+0xe1050))(this, p0, p1);
        else return CustomizeObjectLayer::hsvPopupClosed(p0, p1);
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) {
        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xe0c60))(this, p0);
        else return CustomizeObjectLayer::colorSelectClosed(p0);
    }

    dupable void colorSetupClosed(int p0) {
        if ((void($CustomizeObjectLayer::*)(int)){&$CustomizeObjectLayer::colorSetupClosed} != (void(D::*)(int)){&D::colorSetupClosed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xe0850))(this, p0);
        else return CustomizeObjectLayer::colorSetupClosed(p0);
    }

    dupable $CustomizeObjectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomizeObjectLayer::*)()){&$CustomizeObjectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xe16c0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xe1280, extract((void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xe1430, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xe1470, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomizeObjectLayer::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&$CustomizeObjectLayer::hsvPopupClosed} != (void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed})
            m->registerHook(base+0xe1050, extract((void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed}));

        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xe0c60, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($CustomizeObjectLayer::*)(int)){&$CustomizeObjectLayer::colorSetupClosed} != (void(D::*)(int)){&D::colorSetupClosed})
            m->registerHook(base+0xe0850, extract((void(D::*)(int)){&D::colorSetupClosed}));
    }
};


template<class D>
class $GJFollowCommandLayer : public GJFollowCommandLayer, public $CacBase {
public:
    dupable ~$GJFollowCommandLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x16da20))(this);
        else return GJFollowCommandLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16d440))(this, p0);
        else return GJFollowCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16d480))(this, p0);
        else return GJFollowCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x16dc00))(this, p0, p1);
        else return GJFollowCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16dcc0))(this, p0);
        else return GJFollowCommandLayer::textInputReturn(p0);
    }

    dupable $GJFollowCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x16da20, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x16d440, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x16d480, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x16dc00, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x16dcc0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GJRotateCommandLayer : public GJRotateCommandLayer, public $CacBase {
public:
    dupable ~$GJRotateCommandLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5e30))(this);
        else return GJRotateCommandLayer::keyBackClicked();
    }

    dupable void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        if ((void($GJRotateCommandLayer::*)(ConfigureValuePopup*, float)){&$GJRotateCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(base+0x5160))(this, p0, p1);
        else return GJRotateCommandLayer::valuePopupClosed(p0, p1);
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5890))(this, p0);
        else return GJRotateCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x58d0))(this, p0);
        else return GJRotateCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*, float)){&$GJRotateCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x6010))(this, p0, p1);
        else return GJRotateCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x60d0))(this, p0);
        else return GJRotateCommandLayer::textInputReturn(p0);
    }

    dupable $GJRotateCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x5e30, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJRotateCommandLayer::*)(ConfigureValuePopup*, float)){&$GJRotateCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(base+0x5160, extract((void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x5890, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x58d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*, float)){&$GJRotateCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x6010, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x60d0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GJSpecialColorSelect : public GJSpecialColorSelect, public $CacBase {
public:
    dupable ~$GJSpecialColorSelect() override {}

    dupable void keyBackClicked() {
        if ((void($GJSpecialColorSelect::*)()){&$GJSpecialColorSelect::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x383ca0))(this);
        else return GJSpecialColorSelect::keyBackClicked();
    }

    dupable $GJSpecialColorSelect() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJSpecialColorSelect::*)()){&$GJSpecialColorSelect::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x383ca0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $MusicDelegateHandler : public MusicDelegateHandler, public $CacBase {
public:
    dupable ~$MusicDelegateHandler() override {}

    dupable $MusicDelegateHandler() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $MusicDownloadManager : public MusicDownloadManager, public $CacBase {
public:
    dupable ~$MusicDownloadManager() override {}

    dupable bool init() {
        if ((bool($MusicDownloadManager::*)()){&$MusicDownloadManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2ef100))(this);
        else return MusicDownloadManager::init();
    }

    dupable $MusicDownloadManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MusicDownloadManager::*)()){&$MusicDownloadManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2ef100, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ParentalOptionsLayer : public ParentalOptionsLayer, public $CacBase {
public:
    dupable ~$ParentalOptionsLayer() override {}

    dupable bool init() {
        if ((bool($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x445da0))(this);
        else return ParentalOptionsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4472d0))(this);
        else return ParentalOptionsLayer::keyBackClicked();
    }

    dupable $ParentalOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x445da0, extract((bool(D::*)()){&D::init}));

        if ((void($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4472d0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TeleportPortalObject : public TeleportPortalObject, public $CacBase {
public:
    dupable ~$TeleportPortalObject() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) {
        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint const&)){&$TeleportPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0xdad00))(this, p0);
        else return TeleportPortalObject::setPosition(p0);
    }

    dupable void setRotation(float p0) {
        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xdadb0))(this, p0);
        else return TeleportPortalObject::setRotation(p0);
    }

    dupable void setStartPos(cocos2d::CCPoint p0) {
        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint)){&$TeleportPortalObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0xdab50))(this, p0);
        else return TeleportPortalObject::setStartPos(p0);
    }

    dupable void getSaveString() {
        if ((void($TeleportPortalObject::*)()){&$TeleportPortalObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdaf00))(this);
        else return TeleportPortalObject::getSaveString();
    }

    dupable void addToGroup(int p0) {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae40))(this, p0);
        else return TeleportPortalObject::addToGroup(p0);
    }

    dupable void removeFromGroup(int p0) {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdaea0))(this, p0);
        else return TeleportPortalObject::removeFromGroup(p0);
    }

    dupable void setRotation2(float p0) {
        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation2} != (void(D::*)(float)){&D::setRotation2})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xdae10))(this, p0);
        else return TeleportPortalObject::setRotation2(p0);
    }

    dupable void addToGroup2(int p0) {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup2} != (void(D::*)(int)){&D::addToGroup2})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae20))(this, p0);
        else return TeleportPortalObject::addToGroup2(p0);
    }

    dupable void removeFromGroup2(int p0) {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup2} != (void(D::*)(int)){&D::removeFromGroup2})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae30))(this, p0);
        else return TeleportPortalObject::removeFromGroup2(p0);
    }

    dupable $TeleportPortalObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint const&)){&$TeleportPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0xdad00, extract((void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0xdadb0, extract((void(D::*)(float)){&D::setRotation}));

        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint)){&$TeleportPortalObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(base+0xdab50, extract((void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($TeleportPortalObject::*)()){&$TeleportPortalObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xdaf00, extract((void(D::*)()){&D::getSaveString}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(base+0xdae40, extract((void(D::*)(int)){&D::addToGroup}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(base+0xdaea0, extract((void(D::*)(int)){&D::removeFromGroup}));

        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation2} != (void(D::*)(float)){&D::setRotation2})
            m->registerHook(base+0xdae10, extract((void(D::*)(float)){&D::setRotation2}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup2} != (void(D::*)(int)){&D::addToGroup2})
            m->registerHook(base+0xdae20, extract((void(D::*)(int)){&D::addToGroup2}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup2} != (void(D::*)(int)){&D::removeFromGroup2})
            m->registerHook(base+0xdae30, extract((void(D::*)(int)){&D::removeFromGroup2}));
    }
};


template<class D>
class $UploadActionDelegate : public UploadActionDelegate, public $CacBase {
public:
    dupable ~$UploadActionDelegate() override {}

    dupable void uploadActionFinished(int p0, int p1) {
        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3aa720))(this, p0, p1);
        else return UploadActionDelegate::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) {
        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3aa730))(this, p0, p1);
        else return UploadActionDelegate::uploadActionFailed(p0, p1);
    }

    dupable $UploadActionDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x3aa720, extract((void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x3aa730, extract((void(D::*)(int, int)){&D::uploadActionFailed}));
    }
};


template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
public:
    dupable ~$CCMenuItemSpriteExtra() override {}

    dupable void activate() {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125730))(this);
        else return CCMenuItemSpriteExtra::activate();
    }

    dupable void selected() {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::selected} != (void(D::*)()){&D::selected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125840))(this);
        else return CCMenuItemSpriteExtra::selected();
    }

    dupable void unselected() {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::unselected} != (void(D::*)()){&D::unselected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125a70))(this);
        else return CCMenuItemSpriteExtra::unselected();
    }

    dupable $CCMenuItemSpriteExtra() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x125730, extract((void(D::*)()){&D::activate}));

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::selected} != (void(D::*)()){&D::selected})
            m->registerHook(base+0x125840, extract((void(D::*)()){&D::selected}));

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::unselected} != (void(D::*)()){&D::unselected})
            m->registerHook(base+0x125a70, extract((void(D::*)()){&D::unselected}));
    }
};


template<class D>
class $CreateGuidelinesLayer : public CreateGuidelinesLayer, public $CacBase {
public:
    dupable ~$CreateGuidelinesLayer() override {}

    dupable void update(float p0) {
        if ((void($CreateGuidelinesLayer::*)(float)){&$CreateGuidelinesLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x299c50))(this, p0);
        else return CreateGuidelinesLayer::update(p0);
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299dd0))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299f50))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299f70))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x29a030))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29a070))(this);
        else return CreateGuidelinesLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x299ce0))(this);
        else return CreateGuidelinesLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x29a0b0))(this, p0);
        else return CreateGuidelinesLayer::keyDown(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($CreateGuidelinesLayer::*)(FLAlertLayer*, bool)){&$CreateGuidelinesLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x299c70))(this, p0, p1);
        else return CreateGuidelinesLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x29a180))(this, p0);
        else return CreateGuidelinesLayer::keyUp(p0);
    }

    dupable $CreateGuidelinesLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CreateGuidelinesLayer::*)(float)){&$CreateGuidelinesLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x299c50, extract((void(D::*)(float)){&D::update}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x299dd0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x299f50, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x299f70, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x29a030, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x29a070, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x299ce0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x29a0b0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($CreateGuidelinesLayer::*)(FLAlertLayer*, bool)){&$CreateGuidelinesLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x299c70, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x29a180, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $GJPFollowCommandLayer : public GJPFollowCommandLayer, public $CacBase {
public:
    dupable ~$GJPFollowCommandLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1b2590))(this);
        else return GJPFollowCommandLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b1d80))(this, p0);
        else return GJPFollowCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b1dc0))(this, p0);
        else return GJPFollowCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJPFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1b27a0))(this, p0, p1);
        else return GJPFollowCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b2860))(this, p0);
        else return GJPFollowCommandLayer::textInputReturn(p0);
    }

    dupable $GJPFollowCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1b2590, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1b1d80, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1b1dc0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJPFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1b27a0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1b2860, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $MoreVideoOptionsLayer : public MoreVideoOptionsLayer, public $CacBase {
public:
    dupable ~$MoreVideoOptionsLayer() override {}

    dupable bool init() {
        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x444150))(this);
        else return MoreVideoOptionsLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x445ba0))(this);
        else return MoreVideoOptionsLayer::keyBackClicked();
    }

    dupable $MoreVideoOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x444150, extract((bool(D::*)()){&D::init}));

        if ((void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x445ba0, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $MusicDownloadDelegate : public MusicDownloadDelegate, public $CacBase {
public:
    dupable ~$MusicDownloadDelegate() override {}

    dupable void loadSongInfoFinished(SongInfoObject* p0) {
        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x320a0))(this, p0);
        else return MusicDownloadDelegate::loadSongInfoFinished(p0);
    }

    dupable void loadSongInfoFailed(int p0, GJSongError p1) {
        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x320b0))(this, p0, p1);
        else return MusicDownloadDelegate::loadSongInfoFailed(p0, p1);
    }

    dupable void downloadSongFinished(SongInfoObject* p0) {
        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x320c0))(this, p0);
        else return MusicDownloadDelegate::downloadSongFinished(p0);
    }

    dupable void downloadSongFailed(int p0, GJSongError p1) {
        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x320d0))(this, p0, p1);
        else return MusicDownloadDelegate::downloadSongFailed(p0, p1);
    }

    dupable $MusicDownloadDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            m->registerHook(base+0x320a0, extract((void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished}));

        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            m->registerHook(base+0x320b0, extract((void(D::*)(int, GJSongError)){&D::loadSongInfoFailed}));

        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            m->registerHook(base+0x320c0, extract((void(D::*)(SongInfoObject*)){&D::downloadSongFinished}));

        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            m->registerHook(base+0x320d0, extract((void(D::*)(int, GJSongError)){&D::downloadSongFailed}));
    }
};


template<class D>
class $SetupTouchTogglePopup : public SetupTouchTogglePopup, public $CacBase {
public:
    dupable ~$SetupTouchTogglePopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x159850))(this);
        else return SetupTouchTogglePopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x159800))(this);
        else return SetupTouchTogglePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x159660))(this, p0);
        else return SetupTouchTogglePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1596a0))(this, p0);
        else return SetupTouchTogglePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*, float)){&$SetupTouchTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x159960))(this, p0, p1);
        else return SetupTouchTogglePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x159a20))(this, p0);
        else return SetupTouchTogglePopup::textInputReturn(p0);
    }

    dupable $SetupTouchTogglePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x159850, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x159800, extract((void(D::*)()){&D::show}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x159660, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1596a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*, float)){&$SetupTouchTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x159960, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x159a20, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ColorSelectLiveOverlay : public ColorSelectLiveOverlay, public $CacBase {
public:
    dupable ~$ColorSelectLiveOverlay() override {}

    dupable void keyBackClicked() {
        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e4550))(this);
        else return ColorSelectLiveOverlay::keyBackClicked();
    }

    dupable void show() {
        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e4620))(this);
        else return ColorSelectLiveOverlay::show();
    }

    dupable $ColorSelectLiveOverlay() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2e4550, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2e4620, extract((void(D::*)()){&D::show}));
    }
};


template<class D>
class $DemonFilterSelectLayer : public DemonFilterSelectLayer, public $CacBase {
public:
    dupable ~$DemonFilterSelectLayer() override {}

    dupable bool init() {
        if ((bool($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x38b9d0))(this);
        else return DemonFilterSelectLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38c060))(this);
        else return DemonFilterSelectLayer::keyBackClicked();
    }

    dupable $DemonFilterSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x38b9d0, extract((bool(D::*)()){&D::init}));

        if ((void($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x38c060, extract((void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $GJAccountSettingsLayer : public GJAccountSettingsLayer, public $CacBase {
public:
    dupable ~$GJAccountSettingsLayer() override {}

    dupable void keyBackClicked() {
        if ((void($GJAccountSettingsLayer::*)()){&$GJAccountSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14b200))(this);
        else return GJAccountSettingsLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*, float)){&$GJAccountSettingsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x14abe0))(this, p0, p1);
        else return GJAccountSettingsLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*)){&$GJAccountSettingsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x14aca0))(this, p0);
        else return GJAccountSettingsLayer::textInputReturn(p0);
    }

    dupable $GJAccountSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJAccountSettingsLayer::*)()){&$GJAccountSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14b200, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*, float)){&$GJAccountSettingsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x14abe0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*)){&$GJAccountSettingsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x14aca0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupAnimSettingsPopup : public SetupAnimSettingsPopup, public $CacBase {
public:
    dupable ~$SetupAnimSettingsPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x599f0))(this);
        else return SetupAnimSettingsPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x599a0))(this);
        else return SetupAnimSettingsPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x597b0))(this, p0);
        else return SetupAnimSettingsPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x597f0))(this, p0);
        else return SetupAnimSettingsPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*, float)){&$SetupAnimSettingsPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x59ae0))(this, p0, p1);
        else return SetupAnimSettingsPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x59ba0))(this, p0);
        else return SetupAnimSettingsPopup::textInputReturn(p0);
    }

    dupable $SetupAnimSettingsPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x599f0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x599a0, extract((void(D::*)()){&D::show}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x597b0, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x597f0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*, float)){&$SetupAnimSettingsPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x59ae0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x59ba0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupCountTriggerPopup : public SetupCountTriggerPopup, public $CacBase {
public:
    dupable ~$SetupCountTriggerPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15ec70))(this);
        else return SetupCountTriggerPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15ec20))(this);
        else return SetupCountTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15e960))(this, p0);
        else return SetupCountTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15e9a0))(this, p0);
        else return SetupCountTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCountTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x15ede0))(this, p0, p1);
        else return SetupCountTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15eea0))(this, p0);
        else return SetupCountTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupCountTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x15ec70, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x15ec20, extract((void(D::*)()){&D::show}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x15e960, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x15e9a0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCountTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x15ede0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x15eea0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupInstantCountPopup : public SetupInstantCountPopup, public $CacBase {
public:
    dupable ~$SetupInstantCountPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x355600))(this);
        else return SetupInstantCountPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3555b0))(this);
        else return SetupInstantCountPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355230))(this, p0);
        else return SetupInstantCountPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355270))(this, p0);
        else return SetupInstantCountPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*, float)){&$SetupInstantCountPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x355770))(this, p0, p1);
        else return SetupInstantCountPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355830))(this, p0);
        else return SetupInstantCountPopup::textInputReturn(p0);
    }

    dupable $SetupInstantCountPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x355600, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x3555b0, extract((void(D::*)()){&D::show}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x355230, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x355270, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*, float)){&$SetupInstantCountPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x355770, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x355830, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupObjectTogglePopup : public SetupObjectTogglePopup, public $CacBase {
public:
    dupable ~$SetupObjectTogglePopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1c27f0))(this);
        else return SetupObjectTogglePopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1c27a0))(this);
        else return SetupObjectTogglePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c2620))(this, p0);
        else return SetupObjectTogglePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c2660))(this, p0);
        else return SetupObjectTogglePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*, float)){&$SetupObjectTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1c2900))(this, p0, p1);
        else return SetupObjectTogglePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c29c0))(this, p0);
        else return SetupObjectTogglePopup::textInputReturn(p0);
    }

    dupable $SetupObjectTogglePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1c27f0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1c27a0, extract((void(D::*)()){&D::show}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1c2620, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1c2660, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*, float)){&$SetupObjectTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1c2900, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1c29c0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SpriteAnimationManager : public SpriteAnimationManager, public $CacBase {
public:
    dupable ~$SpriteAnimationManager() override {}

    dupable $SpriteAnimationManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $BoomScrollLayerDelegate : public BoomScrollLayerDelegate, public $CacBase {
public:
    dupable ~$BoomScrollLayerDelegate() override {}

    dupable void scrollLayerScrollingStarted(BoomScrollLayer* p0) {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*)){&$BoomScrollLayerDelegate::scrollLayerScrollingStarted} != (void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*)>(m->getOriginal(base+0x204370))(this, p0);
        else return BoomScrollLayerDelegate::scrollLayerScrollingStarted(p0);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x23cf70))(this, p0, p1);
        else return BoomScrollLayerDelegate::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) {
        if ((void($BoomScrollLayerDelegate::*)(cocos2d::CCPoint)){&$BoomScrollLayerDelegate::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x2eca30))(this, p0);
        else return BoomScrollLayerDelegate::scrollLayerMoved(p0);
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x23cf80))(this, p0, p1);
        else return BoomScrollLayerDelegate::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable $BoomScrollLayerDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*)){&$BoomScrollLayerDelegate::scrollLayerScrollingStarted} != (void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted})
            m->registerHook(base+0x204370, extract((void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted}));

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x23cf70, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($BoomScrollLayerDelegate::*)(cocos2d::CCPoint)){&$BoomScrollLayerDelegate::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x2eca30, extract((void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x23cf80, extract((void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));
    }
};


template<class D>
class $SetupPickupTriggerPopup : public SetupPickupTriggerPopup, public $CacBase {
public:
    dupable ~$SetupPickupTriggerPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37f00))(this);
        else return SetupPickupTriggerPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37eb0))(this);
        else return SetupPickupTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x37c60))(this, p0);
        else return SetupPickupTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x37ca0))(this, p0);
        else return SetupPickupTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*, float)){&$SetupPickupTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x38050))(this, p0, p1);
        else return SetupPickupTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x38110))(this, p0);
        else return SetupPickupTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupPickupTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x37f00, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x37eb0, extract((void(D::*)()){&D::show}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x37c60, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x37ca0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*, float)){&$SetupPickupTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x38050, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x38110, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareLevelSettingsLayer : public ShareLevelSettingsLayer, public $CacBase {
public:
    dupable ~$ShareLevelSettingsLayer() override {}

    dupable void keyBackClicked() {
        if ((void($ShareLevelSettingsLayer::*)()){&$ShareLevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12db50))(this);
        else return ShareLevelSettingsLayer::keyBackClicked();
    }

    dupable void numberInputClosed(NumberInputLayer* p0) {
        if ((void($ShareLevelSettingsLayer::*)(NumberInputLayer*)){&$ShareLevelSettingsLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            return reinterpret_cast<void(*)(decltype(this), NumberInputLayer*)>(m->getOriginal(base+0x12da50))(this, p0);
        else return ShareLevelSettingsLayer::numberInputClosed(p0);
    }

    dupable $ShareLevelSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareLevelSettingsLayer::*)()){&$ShareLevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12db50, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($ShareLevelSettingsLayer::*)(NumberInputLayer*)){&$ShareLevelSettingsLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            m->registerHook(base+0x12da50, extract((void(D::*)(NumberInputLayer*)){&D::numberInputClosed}));
    }
};


template<class D>
class $PlatformDownloadDelegate : public PlatformDownloadDelegate, public $CacBase {
public:
    dupable ~$PlatformDownloadDelegate() override {}

    dupable void downloadFinished(char const* p0) {
        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFinished} != (void(D::*)(char const*)){&D::downloadFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2f2db0))(this, p0);
        else return PlatformDownloadDelegate::downloadFinished(p0);
    }

    dupable void downloadFailed(char const* p0) {
        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFailed} != (void(D::*)(char const*)){&D::downloadFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2f2dc0))(this, p0);
        else return PlatformDownloadDelegate::downloadFailed(p0);
    }

    dupable $PlatformDownloadDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFinished} != (void(D::*)(char const*)){&D::downloadFinished})
            m->registerHook(base+0x2f2db0, extract((void(D::*)(char const*)){&D::downloadFinished}));

        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFailed} != (void(D::*)(char const*)){&D::downloadFailed})
            m->registerHook(base+0x2f2dc0, extract((void(D::*)(char const*)){&D::downloadFailed}));
    }
};


template<class D>
class $SetupInteractObjectPopup : public SetupInteractObjectPopup, public $CacBase {
public:
    dupable ~$SetupInteractObjectPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29c550))(this);
        else return SetupInteractObjectPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29c500))(this);
        else return SetupInteractObjectPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c270))(this, p0);
        else return SetupInteractObjectPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c2b0))(this, p0);
        else return SetupInteractObjectPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*, float)){&$SetupInteractObjectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x29c6a0))(this, p0, p1);
        else return SetupInteractObjectPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c760))(this, p0);
        else return SetupInteractObjectPopup::textInputReturn(p0);
    }

    dupable $SetupInteractObjectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x29c550, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x29c500, extract((void(D::*)()){&D::show}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x29c270, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x29c2b0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*, float)){&$SetupInteractObjectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x29c6a0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x29c760, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupCollisionTriggerPopup : public SetupCollisionTriggerPopup, public $CacBase {
public:
    dupable ~$SetupCollisionTriggerPopup() override {}

    dupable void keyBackClicked() {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d8880))(this);
        else return SetupCollisionTriggerPopup::keyBackClicked();
    }

    dupable void show() {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d8830))(this);
        else return SetupCollisionTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d8490))(this, p0);
        else return SetupCollisionTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d84d0))(this, p0);
        else return SetupCollisionTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCollisionTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1d89f0))(this, p0, p1);
        else return SetupCollisionTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d8ab0))(this, p0);
        else return SetupCollisionTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupCollisionTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d8880, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1d8830, extract((void(D::*)()){&D::show}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1d8490, extract((void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1d84d0, extract((void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCollisionTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1d89f0, extract((void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1d8ab0, extract((void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $UpdateAccountSettingsPopup : public UpdateAccountSettingsPopup, public $CacBase {
public:
    dupable ~$UpdateAccountSettingsPopup() override {}

    dupable void keyBackClicked() {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14bcb0))(this);
        else return UpdateAccountSettingsPopup::keyBackClicked();
    }

    dupable void updateSettingsFinished() {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFinished} != (void(D::*)()){&D::updateSettingsFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14ba40))(this);
        else return UpdateAccountSettingsPopup::updateSettingsFinished();
    }

    dupable void updateSettingsFailed() {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFailed} != (void(D::*)()){&D::updateSettingsFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14bb80))(this);
        else return UpdateAccountSettingsPopup::updateSettingsFailed();
    }

    dupable $UpdateAccountSettingsPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14bcb0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFinished} != (void(D::*)()){&D::updateSettingsFinished})
            m->registerHook(base+0x14ba40, extract((void(D::*)()){&D::updateSettingsFinished}));

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFailed} != (void(D::*)()){&D::updateSettingsFailed})
            m->registerHook(base+0x14bb80, extract((void(D::*)()){&D::updateSettingsFailed}));
    }
};


template<class D>
class $Slider : public Slider, public $CacBase {
public:
    dupable ~$Slider() override {}

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e2e0))(this, p0, p1);
        else return Slider::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e360))(this, p0, p1);
        else return Slider::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e320))(this, p0, p1);
        else return Slider::ccTouchEnded(p0, p1);
    }

    dupable $Slider() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x18e2e0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x18e360, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x18e320, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));
    }
};


template<class D>
class $UILayer : public UILayer, public $CacBase {
public:
    dupable ~$UILayer() override {}

    dupable bool init() {
        if ((bool($UILayer::*)()){&$UILayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x27fe40))(this);
        else return UILayer::init();
    }

    dupable void draw() {
        if ((void($UILayer::*)()){&$UILayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x280980))(this);
        else return UILayer::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280990))(this, p0, p1);
        else return UILayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280ad0))(this, p0, p1);
        else return UILayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280af0))(this, p0, p1);
        else return UILayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280bd0))(this, p0, p1);
        else return UILayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($UILayer::*)()){&$UILayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x280c10))(this);
        else return UILayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($UILayer::*)()){&$UILayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2808e0))(this);
        else return UILayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x280470))(this, p0);
        else return UILayer::keyDown(p0);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) {
        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x280600))(this, p0);
        else return UILayer::keyUp(p0);
    }

    dupable $UILayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($UILayer::*)()){&$UILayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x27fe40, extract((bool(D::*)()){&D::init}));

        if ((void($UILayer::*)()){&$UILayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x280980, extract((void(D::*)()){&D::draw}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x280990, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x280ad0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x280af0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x280bd0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($UILayer::*)()){&$UILayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x280c10, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($UILayer::*)()){&$UILayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2808e0, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x280470, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x280600, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $EditorUI : public EditorUI, public $CacBase {
public:
    dupable ~$EditorUI() override {}

    dupable void draw() {
        if ((void($EditorUI::*)()){&$EditorUI::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e170))(this);
        else return EditorUI::draw();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2ed60))(this, p0, p1);
        else return EditorUI::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2f3d0))(this, p0, p1);
        else return EditorUI::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2fb00))(this, p0, p1);
        else return EditorUI::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x30710))(this, p0, p1);
        else return EditorUI::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($EditorUI::*)()){&$EditorUI::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x30750))(this);
        else return EditorUI::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($EditorUI::*)()){&$EditorUI::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x24c50))(this);
        else return EditorUI::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x30790))(this, p0);
        else return EditorUI::keyDown(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($EditorUI::*)(FLAlertLayer*, bool)){&$EditorUI::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1f590))(this, p0, p1);
        else return EditorUI::FLAlert_Clicked(p0, p1);
    }

    dupable void songStateChanged() {
        if ((void($EditorUI::*)()){&$EditorUI::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x24760))(this);
        else return EditorUI::songStateChanged();
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) {
        if ((void($EditorUI::*)(cocos2d::CCNode*)){&$EditorUI::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0x29940))(this, p0);
        else return EditorUI::colorSelectClosed(p0);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) {
        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x312b0))(this, p0);
        else return EditorUI::keyUp(p0);
    }

    dupable void scrollWheel(float p0, float p1) {
        if ((void($EditorUI::*)(float, float)){&$EditorUI::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x31370))(this, p0, p1);
        else return EditorUI::scrollWheel(p0, p1);
    }

    dupable void angleChangeBegin() {
        if ((void($EditorUI::*)()){&$EditorUI::angleChangeBegin} != (void(D::*)()){&D::angleChangeBegin})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e260))(this);
        else return EditorUI::angleChangeBegin();
    }

    dupable void angleChangeEnded() {
        if ((void($EditorUI::*)()){&$EditorUI::angleChangeEnded} != (void(D::*)()){&D::angleChangeEnded})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e320))(this);
        else return EditorUI::angleChangeEnded();
    }

    dupable void angleChanged(float p0) {
        if ((void($EditorUI::*)(float)){&$EditorUI::angleChanged} != (void(D::*)(float)){&D::angleChanged})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2e3a0))(this, p0);
        else return EditorUI::angleChanged(p0);
    }

    dupable void scaleChangeBegin() {
        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeBegin} != (void(D::*)()){&D::scaleChangeBegin})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25120))(this);
        else return EditorUI::scaleChangeBegin();
    }

    dupable void scaleChangeEnded() {
        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeEnded} != (void(D::*)()){&D::scaleChangeEnded})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x251e0))(this);
        else return EditorUI::scaleChangeEnded();
    }

    dupable void scaleChanged(float p0) {
        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x25260))(this, p0);
        else return EditorUI::scaleChanged(p0);
    }

    dupable $EditorUI() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditorUI::*)()){&$EditorUI::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2e170, extract((void(D::*)()){&D::draw}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2ed60, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2f3d0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2fb00, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x30710, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($EditorUI::*)()){&$EditorUI::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x30750, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($EditorUI::*)()){&$EditorUI::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x24c50, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x30790, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorUI::*)(FLAlertLayer*, bool)){&$EditorUI::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1f590, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($EditorUI::*)()){&$EditorUI::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            m->registerHook(base+0x24760, extract((void(D::*)()){&D::songStateChanged}));

        if ((void($EditorUI::*)(cocos2d::CCNode*)){&$EditorUI::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0x29940, extract((void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x312b0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));

        if ((void($EditorUI::*)(float, float)){&$EditorUI::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            m->registerHook(base+0x31370, extract((void(D::*)(float, float)){&D::scrollWheel}));

        if ((void($EditorUI::*)()){&$EditorUI::angleChangeBegin} != (void(D::*)()){&D::angleChangeBegin})
            m->registerHook(base+0x2e260, extract((void(D::*)()){&D::angleChangeBegin}));

        if ((void($EditorUI::*)()){&$EditorUI::angleChangeEnded} != (void(D::*)()){&D::angleChangeEnded})
            m->registerHook(base+0x2e320, extract((void(D::*)()){&D::angleChangeEnded}));

        if ((void($EditorUI::*)(float)){&$EditorUI::angleChanged} != (void(D::*)(float)){&D::angleChanged})
            m->registerHook(base+0x2e3a0, extract((void(D::*)(float)){&D::angleChanged}));

        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeBegin} != (void(D::*)()){&D::scaleChangeBegin})
            m->registerHook(base+0x25120, extract((void(D::*)()){&D::scaleChangeBegin}));

        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeEnded} != (void(D::*)()){&D::scaleChangeEnded})
            m->registerHook(base+0x251e0, extract((void(D::*)()){&D::scaleChangeEnded}));

        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            m->registerHook(base+0x25260, extract((void(D::*)(float)){&D::scaleChanged}));
    }
};


template<class D>
class $GManager : public GManager, public $CacBase {
public:
    dupable ~$GManager() override {}

    dupable bool init() {
        if ((bool($GManager::*)()){&$GManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x26ee00))(this);
        else return GManager::init();
    }

    dupable void setup() {
        if ((void($GManager::*)()){&$GManager::setup} != (void(D::*)()){&D::setup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26ee20))(this);
        else return GManager::setup();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) {
        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x26f5b0))(this, p0);
        else return GManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) {
        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x26fb70))(this, p0);
        else return GManager::dataLoaded(p0);
    }

    dupable void firstLoad() {
        if ((void($GManager::*)()){&$GManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26fb80))(this);
        else return GManager::firstLoad();
    }

    dupable $GManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GManager::*)()){&$GManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x26ee00, extract((bool(D::*)()){&D::init}));

        if ((void($GManager::*)()){&$GManager::setup} != (void(D::*)()){&D::setup})
            m->registerHook(base+0x26ee20, extract((void(D::*)()){&D::setup}));

        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x26f5b0, extract((void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x26fb70, extract((void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($GManager::*)()){&$GManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x26fb80, extract((void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $GameCell : public GameCell, public $CacBase {
public:
    dupable ~$GameCell() override {}

    dupable bool init() {
        if ((bool($GameCell::*)()){&$GameCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18f980))(this);
        else return GameCell::init();
    }

    dupable void draw() {
        if ((void($GameCell::*)()){&$GameCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18fa40))(this);
        else return GameCell::draw();
    }

    dupable $GameCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameCell::*)()){&$GameCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18f980, extract((bool(D::*)()){&D::init}));

        if ((void($GameCell::*)()){&$GameCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18fa40, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ListCell : public ListCell, public $CacBase {
public:
    dupable ~$ListCell() override {}

    dupable bool init() {
        if ((bool($ListCell::*)()){&$ListCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18f7a0))(this);
        else return ListCell::init();
    }

    dupable void draw() {
        if ((void($ListCell::*)()){&$ListCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18f840))(this);
        else return ListCell::draw();
    }

    dupable $ListCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ListCell::*)()){&$ListCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18f7a0, extract((bool(D::*)()){&D::init}));

        if ((void($ListCell::*)()){&$ListCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18f840, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $SongCell : public SongCell, public $CacBase {
public:
    dupable ~$SongCell() override {}

    dupable bool init() {
        if ((bool($SongCell::*)()){&$SongCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c200))(this);
        else return SongCell::init();
    }

    dupable void draw() {
        if ((void($SongCell::*)()){&$SongCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c240))(this);
        else return SongCell::draw();
    }

    dupable $SongCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SongCell::*)()){&$SongCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c200, extract((bool(D::*)()){&D::init}));

        if ((void($SongCell::*)()){&$SongCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c240, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $TextArea : public TextArea, public $CacBase {
public:
    dupable ~$TextArea() override {}

    dupable void draw() {
        if ((void($TextArea::*)()){&$TextArea::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19f890))(this);
        else return TextArea::draw();
    }

    dupable void setOpacity(unsigned char p0) {
        if ((void($TextArea::*)(unsigned char)){&$TextArea::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x19f760))(this, p0);
        else return TextArea::setOpacity(p0);
    }

    dupable $TextArea() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TextArea::*)()){&$TextArea::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x19f890, extract((void(D::*)()){&D::draw}));

        if ((void($TextArea::*)(unsigned char)){&$TextArea::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x19f760, extract((void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $GJComment : public GJComment, public $CacBase {
public:
    dupable ~$GJComment() override {}

    dupable bool init() {
        if ((bool($GJComment::*)()){&$GJComment::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2dfec0))(this);
        else return GJComment::init();
    }

    dupable $GJComment() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJComment::*)()){&$GJComment::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2dfec0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJMapPack : public GJMapPack, public $CacBase {
public:
    dupable ~$GJMapPack() override {}

    dupable bool init() {
        if ((bool($GJMapPack::*)()){&$GJMapPack::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2de0e0))(this);
        else return GJMapPack::init();
    }

    dupable $GJMapPack() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJMapPack::*)()){&$GJMapPack::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2de0e0, extract((bool(D::*)()){&D::init}));
    }
};


template<class D>
class $InfoLayer : public InfoLayer, public $CacBase {
public:
    dupable ~$InfoLayer() override {}

    dupable void registerWithTouchDispatcher() {
        if ((void($InfoLayer::*)()){&$InfoLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a070))(this);
        else return InfoLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() {
        if ((void($InfoLayer::*)()){&$InfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a000))(this);
        else return InfoLayer::keyBackClicked();
    }

    dupable void show() {
        if ((void($InfoLayer::*)()){&$InfoLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45ab80))(this);
        else return InfoLayer::show();
    }

    dupable void loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) {
        if ((void($InfoLayer::*)(cocos2d::CCArray*, char const*)){&$InfoLayer::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x45a1b0))(this, p0, p1);
        else return InfoLayer::loadCommentsFinished(p0, p1);
    }

    dupable void loadCommentsFailed(char const* p0) {
        if ((void($InfoLayer::*)(char const*)){&$InfoLayer::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x45a270))(this, p0);
        else return InfoLayer::loadCommentsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) {
        if ((void($InfoLayer::*)(std::string, char const*)){&$InfoLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x45a320))(this, p0, p1);
        else return InfoLayer::setupPageInfo(p0, p1);
    }

    dupable void commentUploadFinished(int p0) {
        if ((void($InfoLayer::*)(int)){&$InfoLayer::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x45a890))(this, p0);
        else return InfoLayer::commentUploadFinished(p0);
    }

    dupable void commentUploadFailed(int p0, CommentError p1) {
        if ((void($InfoLayer::*)(int, CommentError)){&$InfoLayer::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), int, CommentError)>(m->getOriginal(base+0x45a960))(this, p0, p1);
        else return InfoLayer::commentUploadFailed(p0, p1);
    }

    dupable void updateUserScoreFinished() {
        if ((void($InfoLayer::*)()){&$InfoLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a720))(this);
        else return InfoLayer::updateUserScoreFinished();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($InfoLayer::*)(FLAlertLayer*, bool)){&$InfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x459d50))(this, p0, p1);
        else return InfoLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $InfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($InfoLayer::*)()){&$InfoLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x45a070, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($InfoLayer::*)()){&$InfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x45a000, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($InfoLayer::*)()){&$InfoLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x45ab80, extract((void(D::*)()){&D::show}));

        if ((void($InfoLayer::*)(cocos2d::CCArray*, char const*)){&$InfoLayer::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            m->registerHook(base+0x45a1b0, extract((void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished}));

        if ((void($InfoLayer::*)(char const*)){&$InfoLayer::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            m->registerHook(base+0x45a270, extract((void(D::*)(char const*)){&D::loadCommentsFailed}));

        if ((void($InfoLayer::*)(std::string, char const*)){&$InfoLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x45a320, extract((void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($InfoLayer::*)(int)){&$InfoLayer::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            m->registerHook(base+0x45a890, extract((void(D::*)(int)){&D::commentUploadFinished}));

        if ((void($InfoLayer::*)(int, CommentError)){&$InfoLayer::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            m->registerHook(base+0x45a960, extract((void(D::*)(int, CommentError)){&D::commentUploadFailed}));

        if ((void($InfoLayer::*)()){&$InfoLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x45a720, extract((void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($InfoLayer::*)(FLAlertLayer*, bool)){&$InfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x459d50, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $KeysLayer : public KeysLayer, public $CacBase {
public:
    dupable ~$KeysLayer() override {}

    dupable bool init() {
        if ((bool($KeysLayer::*)()){&$KeysLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x44d340))(this);
        else return KeysLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($KeysLayer::*)()){&$KeysLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x453210))(this);
        else return KeysLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($KeysLayer::*)(FLAlertLayer*, bool)){&$KeysLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x4532e0))(this, p0, p1);
        else return KeysLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($KeysLayer::*)(DialogLayer*)){&$KeysLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x453090))(this, p0);
        else return KeysLayer::dialogClosed(p0);
    }

    dupable $KeysLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeysLayer::*)()){&$KeysLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x44d340, extract((bool(D::*)()){&D::init}));

        if ((void($KeysLayer::*)()){&$KeysLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x453210, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($KeysLayer::*)(FLAlertLayer*, bool)){&$KeysLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x4532e0, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($KeysLayer::*)(DialogLayer*)){&$KeysLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x453090, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $LevelCell : public LevelCell, public $CacBase {
public:
    dupable ~$LevelCell() override {}

    dupable bool init() {
        if ((bool($LevelCell::*)()){&$LevelCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x117a40))(this);
        else return LevelCell::init();
    }

    dupable void draw() {
        if ((void($LevelCell::*)()){&$LevelCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11a4d0))(this);
        else return LevelCell::draw();
    }

    dupable $LevelCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelCell::*)()){&$LevelCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x117a40, extract((bool(D::*)()){&D::init}));

        if ((void($LevelCell::*)()){&$LevelCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11a4d0, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $LevelPage : public LevelPage, public $CacBase {
public:
    dupable ~$LevelPage() override {}

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23cd90))(this, p0, p1);
        else return LevelPage::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23ceb0))(this, p0, p1);
        else return LevelPage::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23ced0))(this, p0, p1);
        else return LevelPage::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23cef0))(this, p0, p1);
        else return LevelPage::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($LevelPage::*)()){&$LevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x23cf30))(this);
        else return LevelPage::registerWithTouchDispatcher();
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($LevelPage::*)(DialogLayer*)){&$LevelPage::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x23cad0))(this, p0);
        else return LevelPage::dialogClosed(p0);
    }

    dupable $LevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x23cd90, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x23ceb0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x23ced0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x23cef0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($LevelPage::*)()){&$LevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x23cf30, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelPage::*)(DialogLayer*)){&$LevelPage::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x23cad0, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
public:
    dupable ~$MenuLayer() override {}

    dupable bool init() {
        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1d14b0))(this);
        else return MenuLayer::init();
    }

    dupable void keyBackClicked() {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d3160))(this);
        else return MenuLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) {
        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x1d33d0))(this, p0);
        else return MenuLayer::keyDown(p0);
    }

    dupable void googlePlaySignedIn() {
        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d2f30))(this);
        else return MenuLayer::googlePlaySignedIn();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) {
        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1d3190))(this, p0, p1);
        else return MenuLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $MenuLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1d14b0, extract((bool(D::*)()){&D::init}));

        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d3160, extract((void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x1d33d0, extract((void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            m->registerHook(base+0x1d2f30, extract((void(D::*)()){&D::googlePlaySignedIn}));

        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1d3190, extract((void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $PlayLayer : public PlayLayer, public $CacBase {
public:
    dupable ~$PlayLayer() override {}

    dupable void update(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x77900))(this, p0);
        else return PlayLayer::update(p0);
    }

    dupable void onEnterTransitionDidFinish() {
        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x806e0))(this);
        else return PlayLayer::onEnterTransitionDidFinish();
    }

    dupable void onExit() {
        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80710))(this);
        else return PlayLayer::onExit();
    }

    dupable void draw() {
        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7d160))(this);
        else return PlayLayer::draw();
    }

    dupable void visit() {
        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x75ef0))(this);
        else return PlayLayer::visit();
    }

    dupable void updateTweenAction(float p0, char const* p1) {
        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x7ffb0))(this, p0, p1);
        else return PlayLayer::updateTweenAction(p0, p1);
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return PlayLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0x7cd10))(this, p0, p1, p2);
        else return PlayLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void timeForXPos(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x7d120))(this, p0);
        else return PlayLayer::timeForXPos(p0);
    }

    dupable void xPosForTime(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x7d140))(this, p0);
        else return PlayLayer::xPosForTime(p0);
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) {
        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0x7e070))(this, p0);
        else return PlayLayer::currencyWillExit(p0);
    }

    dupable void circleWaveWillBeRemoved(CCCircleWave* p0) {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(base+0x7e110))(this, p0);
        else return PlayLayer::circleWaveWillBeRemoved(p0);
    }

    dupable void dialogClosed(DialogLayer* p0) {
        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x7e0b0))(this, p0);
        else return PlayLayer::dialogClosed(p0);
    }

    dupable $PlayLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x77900, extract((void(D::*)(float)){&D::update}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(base+0x806e0, extract((void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x80710, extract((void(D::*)()){&D::onExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x7d160, extract((void(D::*)()){&D::draw}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x75ef0, extract((void(D::*)()){&D::visit}));

        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x7ffb0, extract((void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0x7c7f0, extract((void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0x7cd10, extract((void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0x7aa10, extract((void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(base+0x7d120, extract((void(D::*)(float)){&D::timeForXPos}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(base+0x7d140, extract((void(D::*)(float)){&D::xPosForTime}));

        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0x7e070, extract((void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            m->registerHook(base+0x7e110, extract((void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved}));

        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x7e0b0, extract((void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $StatsCell : public StatsCell, public $CacBase {
public:
    dupable ~$StatsCell() override {}

    dupable bool init() {
        if ((bool($StatsCell::*)()){&$StatsCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11b100))(this);
        else return StatsCell::init();
    }

    dupable void draw() {
        if ((void($StatsCell::*)()){&$StatsCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11bf80))(this);
        else return StatsCell::draw();
    }

    dupable $StatsCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($StatsCell::*)()){&$StatsCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11b100, extract((bool(D::*)()){&D::init}));

        if ((void($StatsCell::*)()){&$StatsCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11bf80, extract((void(D::*)()){&D::draw}));
    }
};


template<class D>
class $TableView : public TableView, public $CacBase {
public:
    dupable ~$TableView() override {}

    dupable void onEnter() {
        if ((void($TableView::*)()){&$TableView::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff30))(this);
        else return TableView::onEnter();
    }

    dupable void onExit() {
        if ((void($TableView::*)()){&$TableView::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff40))(this);
        else return TableView::onExit();
    }

    dupable void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380120))(this, p0, p1);
        else return TableView::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380be0))(this, p0, p1);
        else return TableView::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x3809a0))(this, p0, p1);
        else return TableView::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380b20))(this, p0, p1);
        else return TableView::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() {
        if ((void($TableView::*)()){&$TableView::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff50))(this);
        else return TableView::registerWithTouchDispatcher();
    }

    dupable void scrollWheel(float p0, float p1) {
        if ((void($TableView::*)(float, float)){&$TableView::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x380cd0))(this, p0, p1);
        else return TableView::scrollWheel(p0, p1);
    }

    dupable void scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrllViewWillBeginDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818a0))(this, p0);
        else return TableView::scrllViewWillBeginDecelerating(p0);
    }

    dupable void scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818c0))(this, p0);
        else return TableView::scrollViewDidEndDecelerating(p0);
    }

    dupable void scrollViewTouchMoving(CCScrollLayerExt* p0) {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewTouchMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818e0))(this, p0);
        else return TableView::scrollViewTouchMoving(p0);
    }

    dupable void scrollViewDidEndMoving(CCScrollLayerExt* p0) {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x381900))(this, p0);
        else return TableView::scrollViewDidEndMoving(p0);
    }

    dupable $TableView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TableView::*)()){&$TableView::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x37ff30, extract((void(D::*)()){&D::onEnter}));

        if ((void($TableView::*)()){&$TableView::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x37ff40, extract((void(D::*)()){&D::onExit}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x380120, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x380be0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x3809a0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x380b20, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($TableView::*)()){&$TableView::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x37ff50, extract((void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($TableView::*)(float, float)){&$TableView::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            m->registerHook(base+0x380cd0, extract((void(D::*)(float, float)){&D::scrollWheel}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrllViewWillBeginDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating})
            m->registerHook(base+0x3818a0, extract((void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating})
            m->registerHook(base+0x3818c0, extract((void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewTouchMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving})
            m->registerHook(base+0x3818e0, extract((void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving})
            m->registerHook(base+0x381900, extract((void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving}));
    }
};
