//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

void __apply_hooks();
#define APPLY_HOOKS() static int const __cachook = (__apply_hooks(), 0)

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};


class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}

void __apply_hooks() {
    for(auto& i : __cackit::glob) i->apply_hooks();
    m->enable();
}


class $AnimatedGameObject : public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $AnimatedGameObject(bool dont_push) {}
    typedef AnimatedGameObject* __thistype;

    virtual void playAnimation(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
    }

    virtual void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0xc8450))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $AnimatedGameObject(true);
        if (extract_virtual(&orig, (void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation}) != extract_virtual(this, (void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation}))
            m->registerHook(getBase()+0xc93d0, extract_virtual(this, (void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation}));

        if (extract_virtual(&orig, (void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor}) != extract_virtual(this, (void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor}))
            m->registerHook(getBase()+0xc8450, extract_virtual(this, (void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor}));
    }
};


class $AppDelegate : public $CacBase {
 public:
    $AppDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $AppDelegate(bool dont_push) {}
    typedef AppDelegate* __thistype;

    virtual void bgScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aaab0))(this);
    }

    virtual void get() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3aab10))(this);
    }

    void apply_hooks() override {
        auto orig = $AppDelegate(true);
        if (extract_virtual(&orig, (void($AppDelegate::*)()){&$AppDelegate::bgScale}) != extract_virtual(this, (void($AppDelegate::*)()){&$AppDelegate::bgScale}))
            m->registerHook(getBase()+0x3aaab0, extract_virtual(this, (void($AppDelegate::*)()){&$AppDelegate::bgScale}));

        if (extract_virtual(&orig, (void($AppDelegate::*)()){&$AppDelegate::get}) != extract_virtual(this, (void($AppDelegate::*)()){&$AppDelegate::get}))
            m->registerHook(getBase()+0x3aab10, extract_virtual(this, (void($AppDelegate::*)()){&$AppDelegate::get}));
    }
};


class $AudioEffectsLayer : public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $AudioEffectsLayer(bool dont_push) {}
    typedef AudioEffectsLayer* __thistype;

    virtual void audioStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x271f40))(this, p0);
    }

    virtual void create(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x271a00))(this, p0);
    }

    virtual void resetAudioVars() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x271ee0))(this);
    }

    void apply_hooks() override {
        auto orig = $AudioEffectsLayer(true);
        if (extract_virtual(&orig, (void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep}) != extract_virtual(this, (void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep}))
            m->registerHook(getBase()+0x271f40, extract_virtual(this, (void($AudioEffectsLayer::*)(float)){&$AudioEffectsLayer::audioStep}));

        if (extract_virtual(&orig, (void($AudioEffectsLayer::*)(std::string)){&$AudioEffectsLayer::create}) != extract_virtual(this, (void($AudioEffectsLayer::*)(std::string)){&$AudioEffectsLayer::create}))
            m->registerHook(getBase()+0x271a00, extract_virtual(this, (void($AudioEffectsLayer::*)(std::string)){&$AudioEffectsLayer::create}));

        if (extract_virtual(&orig, (void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars}) != extract_virtual(this, (void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars}))
            m->registerHook(getBase()+0x271ee0, extract_virtual(this, (void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::resetAudioVars}));
    }
};


class $ButtonSprite : public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ButtonSprite(bool dont_push) {}
    typedef ButtonSprite* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x4fa10))(this, p0);
    }

    virtual void create(char const* p0, int p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, int, float, bool)>(m->getOriginal(getBase()+0x4fa40))(this, p0, p1, p2, p3, p4);
    }

    virtual void updateBGImage(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x502d0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $ButtonSprite(true);
        if (extract_virtual(&orig, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::create}) != extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::create}))
            m->registerHook(getBase()+0x4fa10, extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::create}));

        if (extract_virtual(&orig, (void($ButtonSprite::*)(char const*, int, int, float, bool)){&$ButtonSprite::create}) != extract_virtual(this, (void($ButtonSprite::*)(char const*, int, int, float, bool)){&$ButtonSprite::create}))
            m->registerHook(getBase()+0x4fa40, extract_virtual(this, (void($ButtonSprite::*)(char const*, int, int, float, bool)){&$ButtonSprite::create}));

        if (extract_virtual(&orig, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage}) != extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage}))
            m->registerHook(getBase()+0x502d0, extract_virtual(this, (void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage}));
    }
};


class $CCAnimatedSprite : public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCAnimatedSprite(bool dont_push) {}
    typedef CCAnimatedSprite* __thistype;

    virtual void runAnimation(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
    }

    virtual void tweenToAnimation(std::string p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCAnimatedSprite(true);
        if (extract_virtual(&orig, (void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation}) != extract_virtual(this, (void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation}))
            m->registerHook(getBase()+0x1a6430, extract_virtual(this, (void($CCAnimatedSprite::*)(std::string)){&$CCAnimatedSprite::runAnimation}));

        if (extract_virtual(&orig, (void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation}) != extract_virtual(this, (void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation}))
            m->registerHook(getBase()+0x1a65b0, extract_virtual(this, (void($CCAnimatedSprite::*)(std::string, float)){&$CCAnimatedSprite::tweenToAnimation}));
    }
};


class $CCCircleWave : public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCCircleWave(bool dont_push) {}
    typedef CCCircleWave* __thistype;

    virtual void create(float p0, float p1, float p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool)>(m->getOriginal(getBase()+0xbd270))(this, p0, p1, p2, p3);
    }

    virtual void create(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool, bool)>(m->getOriginal(getBase()+0xbd290))(this, p0, p1, p2, p3, p4);
    }

    virtual void followObject(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
    }

    virtual void updatePosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xbd630))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCCircleWave(true);
        if (extract_virtual(&orig, (void($CCCircleWave::*)(float, float, float, bool)){&$CCCircleWave::create}) != extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool)){&$CCCircleWave::create}))
            m->registerHook(getBase()+0xbd270, extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool)){&$CCCircleWave::create}));

        if (extract_virtual(&orig, (void($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::create}) != extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::create}))
            m->registerHook(getBase()+0xbd290, extract_virtual(this, (void($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::create}));

        if (extract_virtual(&orig, (void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject}) != extract_virtual(this, (void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject}))
            m->registerHook(getBase()+0xbd670, extract_virtual(this, (void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject}));

        if (extract_virtual(&orig, (void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition}) != extract_virtual(this, (void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition}))
            m->registerHook(getBase()+0xbd630, extract_virtual(this, (void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition}));
    }
};


class $CCLightFlash : public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCLightFlash(bool dont_push) {}
    typedef CCLightFlash* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x295870))(this);
    }

    virtual void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

    void apply_hooks() override {
        auto orig = $CCLightFlash(true);
        if (extract_virtual(&orig, (void($CCLightFlash::*)()){&$CCLightFlash::create}) != extract_virtual(this, (void($CCLightFlash::*)()){&$CCLightFlash::create}))
            m->registerHook(getBase()+0x295870, extract_virtual(this, (void($CCLightFlash::*)()){&$CCLightFlash::create}));

        if (extract_virtual(&orig, (void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect}) != extract_virtual(this, (void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect}))
            m->registerHook(getBase()+0x295900, extract_virtual(this, (void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)){&$CCLightFlash::playEffect}));
    }
};


class $CCMenuItemSpriteExtra : public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMenuItemSpriteExtra(bool dont_push) {}
    typedef CCMenuItemSpriteExtra* __thistype;

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1253c0))(this, p0, p1, p2, p3);
    }

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCMenuItemSpriteExtra(true);
        if (extract_virtual(&orig, (void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create}) != extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create}))
            m->registerHook(getBase()+0x1253c0, extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemSpriteExtra::create}));

        if (extract_virtual(&orig, (void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult}) != extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult}))
            m->registerHook(getBase()+0x1255e0, extract_virtual(this, (void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult}));
    }
};


class $CCMenuItemToggler : public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMenuItemToggler(bool dont_push) {}
    typedef CCMenuItemToggler* __thistype;

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x38400))(this, p0, p1, p2, p3);
    }

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x38a40))(this, p0);
    }

    virtual void toggle(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x38950))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCMenuItemToggler(true);
        if (extract_virtual(&orig, (void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create}) != extract_virtual(this, (void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create}))
            m->registerHook(getBase()+0x38400, extract_virtual(this, (void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CCMenuItemToggler::create}));

        if (extract_virtual(&orig, (void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult}) != extract_virtual(this, (void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult}))
            m->registerHook(getBase()+0x38a40, extract_virtual(this, (void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult}));

        if (extract_virtual(&orig, (void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle}) != extract_virtual(this, (void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle}))
            m->registerHook(getBase()+0x38950, extract_virtual(this, (void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::toggle}));
    }
};


class $CCMoveCNode : public $CacBase {
 public:
    $CCMoveCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMoveCNode(bool dont_push) {}
    typedef CCMoveCNode* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1842a0))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18b3d0))(this);
    }

    void apply_hooks() override {
        auto orig = $CCMoveCNode(true);
        if (extract_virtual(&orig, (void($CCMoveCNode::*)()){&$CCMoveCNode::create}) != extract_virtual(this, (void($CCMoveCNode::*)()){&$CCMoveCNode::create}))
            m->registerHook(getBase()+0x1842a0, extract_virtual(this, (void($CCMoveCNode::*)()){&$CCMoveCNode::create}));

        if (extract_virtual(&orig, (void($CCMoveCNode::*)()){&$CCMoveCNode::init}) != extract_virtual(this, (void($CCMoveCNode::*)()){&$CCMoveCNode::init}))
            m->registerHook(getBase()+0x18b3d0, extract_virtual(this, (void($CCMoveCNode::*)()){&$CCMoveCNode::init}));
    }
};


class $CCNodeContainer : public $CacBase {
 public:
    $CCNodeContainer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCNodeContainer(bool dont_push) {}
    typedef CCNodeContainer* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb1090))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xba950))(this);
    }

    virtual void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xba960))(this);
    }

    void apply_hooks() override {
        auto orig = $CCNodeContainer(true);
        if (extract_virtual(&orig, (void($CCNodeContainer::*)()){&$CCNodeContainer::create}) != extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::create}))
            m->registerHook(getBase()+0xb1090, extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::create}));

        if (extract_virtual(&orig, (void($CCNodeContainer::*)()){&$CCNodeContainer::init}) != extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::init}))
            m->registerHook(getBase()+0xba950, extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::init}));

        if (extract_virtual(&orig, (void($CCNodeContainer::*)()){&$CCNodeContainer::visit}) != extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::visit}))
            m->registerHook(getBase()+0xba960, extract_virtual(this, (void($CCNodeContainer::*)()){&$CCNodeContainer::visit}));
    }
};


class $CCSpritePlus : public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCSpritePlus(bool dont_push) {}
    typedef CCSpritePlus* __thistype;

    virtual void initWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x248670))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCSpritePlus(true);
        if (extract_virtual(&orig, (void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName}) != extract_virtual(this, (void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName}))
            m->registerHook(getBase()+0x248670, extract_virtual(this, (void($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName}));
    }
};


class $CCTextInputNode : public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTextInputNode(bool dont_push) {}
    typedef CCTextInputNode* __thistype;

    virtual void create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<void(*)(decltype(this), float, float, char const*, char const*, int, char const*)>(m->getOriginal(getBase()+0x5cfb0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void getString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
    }

    virtual void refreshLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5d730))(this);
    }

    virtual void setAllowedChars(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d360))(this, p0);
    }

    virtual void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x5da90))(this, p0);
    }

    virtual void setLabelPlaceholderScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da70))(this, p0);
    }

    virtual void setMaxLabelScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da30))(this, p0);
    }

    virtual void setMaxLabelWidth(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da50))(this, p0);
    }

    virtual void setString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
    }

    virtual void updateLabel(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d4a0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCTextInputNode(true);
        if (extract_virtual(&orig, (void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create}) != extract_virtual(this, (void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create}))
            m->registerHook(getBase()+0x5cfb0, extract_virtual(this, (void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)()){&$CCTextInputNode::getString}) != extract_virtual(this, (void($CCTextInputNode::*)()){&$CCTextInputNode::getString}))
            m->registerHook(getBase()+0x5d6f0, extract_virtual(this, (void($CCTextInputNode::*)()){&$CCTextInputNode::getString}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel}) != extract_virtual(this, (void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel}))
            m->registerHook(getBase()+0x5d730, extract_virtual(this, (void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars}) != extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars}))
            m->registerHook(getBase()+0x5d360, extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor}) != extract_virtual(this, (void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor}))
            m->registerHook(getBase()+0x5da90, extract_virtual(this, (void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale}) != extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale}))
            m->registerHook(getBase()+0x5da70, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale}) != extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale}))
            m->registerHook(getBase()+0x5da30, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth}) != extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth}))
            m->registerHook(getBase()+0x5da50, extract_virtual(this, (void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString}) != extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString}))
            m->registerHook(getBase()+0x5d3e0, extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString}));

        if (extract_virtual(&orig, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel}) != extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel}))
            m->registerHook(getBase()+0x5d4a0, extract_virtual(this, (void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel}));
    }
};


class $CheckpointObject : public $CacBase {
 public:
    $CheckpointObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CheckpointObject(bool dont_push) {}
    typedef CheckpointObject* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e7d0))(this);
    }

    virtual void getObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef50))(this);
    }

    void apply_hooks() override {
        auto orig = $CheckpointObject(true);
        if (extract_virtual(&orig, (void($CheckpointObject::*)()){&$CheckpointObject::create}) != extract_virtual(this, (void($CheckpointObject::*)()){&$CheckpointObject::create}))
            m->registerHook(getBase()+0x7e7d0, extract_virtual(this, (void($CheckpointObject::*)()){&$CheckpointObject::create}));

        if (extract_virtual(&orig, (void($CheckpointObject::*)()){&$CheckpointObject::getObject}) != extract_virtual(this, (void($CheckpointObject::*)()){&$CheckpointObject::getObject}))
            m->registerHook(getBase()+0x7ef50, extract_virtual(this, (void($CheckpointObject::*)()){&$CheckpointObject::getObject}));
    }
};


class $CollisionBlockPopup : public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CollisionBlockPopup(bool dont_push) {}
    typedef CollisionBlockPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x130010))(this, p0, p1);
    }

    virtual void onNextItemID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x130e60))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CollisionBlockPopup(true);
        if (extract_virtual(&orig, (void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create}) != extract_virtual(this, (void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create}))
            m->registerHook(getBase()+0x130010, extract_virtual(this, (void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$CollisionBlockPopup::create}));

        if (extract_virtual(&orig, (void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID}) != extract_virtual(this, (void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID}))
            m->registerHook(getBase()+0x130e60, extract_virtual(this, (void($CollisionBlockPopup::*)(cocos2d::CCObject*)){&$CollisionBlockPopup::onNextItemID}));
    }
};


class $CollisionTriggerAction : public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CollisionTriggerAction(bool dont_push) {}
    typedef CollisionTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x176ee0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CollisionTriggerAction(true);
        if (extract_virtual(&orig, (void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString}) != extract_virtual(this, (void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString}))
            m->registerHook(getBase()+0x176ee0, extract_virtual(this, (void($CollisionTriggerAction::*)(std::string)){&$CollisionTriggerAction::createFromString}));
    }
};


class $ColorAction : public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ColorAction(bool dont_push) {}
    typedef ColorAction* __thistype;

    virtual void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17d080))(this);
    }

    virtual void setupFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0x17f310))(this, p0);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17f270))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $ColorAction(true);
        if (extract_virtual(&orig, (void($ColorAction::*)()){&$ColorAction::getSaveString}) != extract_virtual(this, (void($ColorAction::*)()){&$ColorAction::getSaveString}))
            m->registerHook(getBase()+0x17d080, extract_virtual(this, (void($ColorAction::*)()){&$ColorAction::getSaveString}));

        if (extract_virtual(&orig, (void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict}) != extract_virtual(this, (void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict}))
            m->registerHook(getBase()+0x17f310, extract_virtual(this, (void($ColorAction::*)(cocos2d::CCDictionary*)){&$ColorAction::setupFromDict}));

        if (extract_virtual(&orig, (void($ColorAction::*)(std::string)){&$ColorAction::setupFromString}) != extract_virtual(this, (void($ColorAction::*)(std::string)){&$ColorAction::setupFromString}))
            m->registerHook(getBase()+0x17f270, extract_virtual(this, (void($ColorAction::*)(std::string)){&$ColorAction::setupFromString}));
    }
};


class $ColorChannelSprite : public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ColorChannelSprite(bool dont_push) {}
    typedef ColorChannelSprite* __thistype;

    virtual void updateBlending(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x16e1d0))(this, p0);
    }

    virtual void updateCopyLabel(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x16ded0))(this, p0, p1);
    }

    virtual void updateOpacity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x16e080))(this, p0);
    }

    virtual void updateValues(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $ColorChannelSprite(true);
        if (extract_virtual(&orig, (void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending}) != extract_virtual(this, (void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending}))
            m->registerHook(getBase()+0x16e1d0, extract_virtual(this, (void($ColorChannelSprite::*)(bool)){&$ColorChannelSprite::updateBlending}));

        if (extract_virtual(&orig, (void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel}) != extract_virtual(this, (void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel}))
            m->registerHook(getBase()+0x16ded0, extract_virtual(this, (void($ColorChannelSprite::*)(int, bool)){&$ColorChannelSprite::updateCopyLabel}));

        if (extract_virtual(&orig, (void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity}) != extract_virtual(this, (void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity}))
            m->registerHook(getBase()+0x16e080, extract_virtual(this, (void($ColorChannelSprite::*)(float)){&$ColorChannelSprite::updateOpacity}));

        if (extract_virtual(&orig, (void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues}) != extract_virtual(this, (void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues}))
            m->registerHook(getBase()+0x16e2e0, extract_virtual(this, (void($ColorChannelSprite::*)(ColorAction*)){&$ColorChannelSprite::updateValues}));
    }
};


class $ColorSelectPopup : public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ColorSelectPopup(bool dont_push) {}
    typedef ColorSelectPopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x423320))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41eb70))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
    }

    virtual void onDefault(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
    }

    virtual void onMultiTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422680))(this, p0);
    }

    virtual void onPlayerColor1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422500))(this, p0);
    }

    virtual void onPlayerColor2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
    }

    virtual void onSpawnedByTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
    }

    virtual void onToggleHSVMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
    }

    virtual void onTouchTriggered(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
    }

    virtual void show() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423570))(this);
    }

    virtual void sliderChanged(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
    }

    virtual void updateCopyColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423b70))(this);
    }

    virtual void updateCopyColorTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422ed0))(this);
    }

    virtual void updateDurLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x421eb0))(this);
    }

    virtual void updateHSVMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422e00))(this);
    }

    virtual void updateOpacityLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x422000))(this);
    }

    virtual void updateTouchTriggered() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423020))(this);
    }

    void apply_hooks() override {
        auto orig = $ColorSelectPopup(true);
        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged}))
            m->registerHook(getBase()+0x423320, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create}) != extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create}))
            m->registerHook(getBase()+0x41eb70, extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$ColorSelectPopup::create}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init}) != extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init}))
            m->registerHook(getBase()+0x41ee70, extract_virtual(this, (void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*)){&$ColorSelectPopup::init}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault}))
            m->registerHook(getBase()+0x4220e0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onDefault}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger}))
            m->registerHook(getBase()+0x422680, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onMultiTrigger}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1}))
            m->registerHook(getBase()+0x422500, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor1}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2}))
            m->registerHook(getBase()+0x4225c0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onPlayerColor2}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger}))
            m->registerHook(getBase()+0x4227f0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onSpawnedByTrigger}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode}))
            m->registerHook(getBase()+0x4227b0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onToggleHSVMode}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered}))
            m->registerHook(getBase()+0x4228b0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::onTouchTriggered}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::show}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::show}))
            m->registerHook(getBase()+0x423570, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::show}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged}) != extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged}))
            m->registerHook(getBase()+0x421ca0, extract_virtual(this, (void($ColorSelectPopup::*)(cocos2d::CCObject*)){&$ColorSelectPopup::sliderChanged}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor}))
            m->registerHook(getBase()+0x423b70, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColor}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel}))
            m->registerHook(getBase()+0x422ed0, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateCopyColorTextInputLabel}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel}))
            m->registerHook(getBase()+0x421eb0, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateDurLabel}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode}))
            m->registerHook(getBase()+0x422e00, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateHSVMode}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel}))
            m->registerHook(getBase()+0x422000, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateOpacityLabel}));

        if (extract_virtual(&orig, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered}) != extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered}))
            m->registerHook(getBase()+0x423020, extract_virtual(this, (void($ColorSelectPopup::*)()){&$ColorSelectPopup::updateTouchTriggered}));
    }
};


class $CountTriggerAction : public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CountTriggerAction(bool dont_push) {}
    typedef CountTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1754f0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CountTriggerAction(true);
        if (extract_virtual(&orig, (void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString}) != extract_virtual(this, (void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString}))
            m->registerHook(getBase()+0x1754f0, extract_virtual(this, (void($CountTriggerAction::*)(std::string)){&$CountTriggerAction::createFromString}));
    }
};


class $CreateMenuItem : public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CreateMenuItem(bool dont_push) {}
    typedef CreateMenuItem* __thistype;

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1c580))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        auto orig = $CreateMenuItem(true);
        if (extract_virtual(&orig, (void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create}) != extract_virtual(this, (void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create}))
            m->registerHook(getBase()+0x1c580, extract_virtual(this, (void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)){&$CreateMenuItem::create}));
    }
};


class $CreatorLayer : public $CacBase {
 public:
    $CreatorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CreatorLayer(bool dont_push) {}
    typedef CreatorLayer* __thistype;

    virtual void onMyLevels(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142b70))(this, p0);
    }

    virtual void onSavedLevels(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x142860))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CreatorLayer(true);
        if (extract_virtual(&orig, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels}) != extract_virtual(this, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels}))
            m->registerHook(getBase()+0x142b70, extract_virtual(this, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onMyLevels}));

        if (extract_virtual(&orig, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels}) != extract_virtual(this, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels}))
            m->registerHook(getBase()+0x142860, extract_virtual(this, (void($CreatorLayer::*)(cocos2d::CCObject*)){&$CreatorLayer::onSavedLevels}));
    }
};


class $CustomizeObjectLayer : public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CustomizeObjectLayer(bool dont_push) {}
    typedef CustomizeObjectLayer* __thistype;

    virtual void colorSelectClosed(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xe1050))(this, p0);
    }

    virtual void create(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd340))(this, p0, p1);
    }

    virtual void init(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1430))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CustomizeObjectLayer(true);
        if (extract_virtual(&orig, (void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed}) != extract_virtual(this, (void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed}))
            m->registerHook(getBase()+0xe1050, extract_virtual(this, (void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed}));

        if (extract_virtual(&orig, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create}) != extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create}))
            m->registerHook(getBase()+0xdd340, extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::create}));

        if (extract_virtual(&orig, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init}) != extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init}))
            m->registerHook(getBase()+0xdd560, extract_virtual(this, (void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*)){&$CustomizeObjectLayer::init}));

        if (extract_virtual(&orig, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged}) != extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged}))
            m->registerHook(getBase()+0xe1470, extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged}));

        if (extract_virtual(&orig, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed}) != extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed}))
            m->registerHook(getBase()+0xe1430, extract_virtual(this, (void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed}));
    }
};


class $DelayedSpawnNode : public $CacBase {
 public:
    $DelayedSpawnNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $DelayedSpawnNode(bool dont_push) {}
    typedef DelayedSpawnNode* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9b360))(this);
    }

    void apply_hooks() override {
        auto orig = $DelayedSpawnNode(true);
        if (extract_virtual(&orig, (void($DelayedSpawnNode::*)()){&$DelayedSpawnNode::create}) != extract_virtual(this, (void($DelayedSpawnNode::*)()){&$DelayedSpawnNode::create}))
            m->registerHook(getBase()+0x9b360, extract_virtual(this, (void($DelayedSpawnNode::*)()){&$DelayedSpawnNode::create}));
    }
};


class $DialogLayer : public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $DialogLayer(bool dont_push) {}
    typedef DialogLayer* __thistype;

    virtual void create(DialogObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), DialogObject*, int)>(m->getOriginal(getBase()+0x2047c0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $DialogLayer(true);
        if (extract_virtual(&orig, (void($DialogLayer::*)(DialogObject*, int)){&$DialogLayer::create}) != extract_virtual(this, (void($DialogLayer::*)(DialogObject*, int)){&$DialogLayer::create}))
            m->registerHook(getBase()+0x2047c0, extract_virtual(this, (void($DialogLayer::*)(DialogObject*, int)){&$DialogLayer::create}));
    }
};


class $DialogObject : public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $DialogObject(bool dont_push) {}
    typedef DialogObject* __thistype;

    virtual void create(std::string p0, std::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, std::string, int, float, bool, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x204410))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        auto orig = $DialogObject(true);
        if (extract_virtual(&orig, (void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create}) != extract_virtual(this, (void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create}))
            m->registerHook(getBase()+0x204410, extract_virtual(this, (void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B)){&$DialogObject::create}));
    }
};


class $DrawGridLayer : public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $DrawGridLayer(bool dont_push) {}
    typedef DrawGridLayer* __thistype;

    virtual void addPlayer2Point(cocos2d::CCPoint p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
    }

    virtual void addPlayerPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
    }

    virtual void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x99900))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0x920c0))(this, p0, p1);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa3c40))(this);
    }

    virtual void init(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa36e0))(this, p0, p1);
    }

    virtual void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9b330))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa3b30))(this, p0);
    }

    virtual void updateTimeMarkers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92950))(this);
    }

    virtual void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c830))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $DrawGridLayer(true);
        if (extract_virtual(&orig, (void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point}) != extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point}))
            m->registerHook(getBase()+0xa25b0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint, bool)){&$DrawGridLayer::addPlayer2Point}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint}) != extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint}))
            m->registerHook(getBase()+0xa39c0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCPoint)){&$DrawGridLayer::addPlayerPoint}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects}) != extract_virtual(this, (void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects}))
            m->registerHook(getBase()+0x99900, extract_virtual(this, (void($DrawGridLayer::*)(GameObject*)){&$DrawGridLayer::addToSpeedObjects}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create}) != extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create}))
            m->registerHook(getBase()+0x920c0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::create}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)()){&$DrawGridLayer::draw}) != extract_virtual(this, (void($DrawGridLayer::*)()){&$DrawGridLayer::draw}))
            m->registerHook(getBase()+0xa3c40, extract_virtual(this, (void($DrawGridLayer::*)()){&$DrawGridLayer::draw}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init}) != extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init}))
            m->registerHook(getBase()+0xa36e0, extract_virtual(this, (void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*)){&$DrawGridLayer::init}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos}) != extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos}))
            m->registerHook(getBase()+0x9b330, extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::timeForXPos}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::update}) != extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::update}))
            m->registerHook(getBase()+0xa3b30, extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::update}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers}) != extract_virtual(this, (void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers}))
            m->registerHook(getBase()+0x92950, extract_virtual(this, (void($DrawGridLayer::*)()){&$DrawGridLayer::updateTimeMarkers}));

        if (extract_virtual(&orig, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime}) != extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime}))
            m->registerHook(getBase()+0x9c830, extract_virtual(this, (void($DrawGridLayer::*)(float)){&$DrawGridLayer::xPosForTime}));
    }
};


class $EditButtonBar : public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EditButtonBar(bool dont_push) {}
    typedef EditButtonBar* __thistype;

    virtual void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        auto orig = $EditButtonBar(true);
        if (extract_virtual(&orig, (void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems}) != extract_virtual(this, (void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems}))
            m->registerHook(getBase()+0x351010, extract_virtual(this, (void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems}));
    }
};


class $EditorOptionsLayer : public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EditorOptionsLayer(bool dont_push) {}
    typedef EditorOptionsLayer* __thistype;

    virtual void onButtonsPerRow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x147b30))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $EditorOptionsLayer(true);
        if (extract_virtual(&orig, (void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow}) != extract_virtual(this, (void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow}))
            m->registerHook(getBase()+0x147b30, extract_virtual(this, (void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onButtonsPerRow}));
    }
};


class $EditorPauseLayer : public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EditorPauseLayer(bool dont_push) {}
    typedef EditorPauseLayer* __thistype;

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x13c680))(this, p0);
    }

    virtual void saveLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
    }

    void apply_hooks() override {
        auto orig = $EditorPauseLayer(true);
        if (extract_virtual(&orig, (void($EditorPauseLayer::*)(LevelEditorLayer*)){&$EditorPauseLayer::create}) != extract_virtual(this, (void($EditorPauseLayer::*)(LevelEditorLayer*)){&$EditorPauseLayer::create}))
            m->registerHook(getBase()+0x13c680, extract_virtual(this, (void($EditorPauseLayer::*)(LevelEditorLayer*)){&$EditorPauseLayer::create}));

        if (extract_virtual(&orig, (void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel}) != extract_virtual(this, (void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel}))
            m->registerHook(getBase()+0x13ebd0, extract_virtual(this, (void($EditorPauseLayer::*)()){&$EditorPauseLayer::saveLevel}));
    }
};


class $EditorUI : public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EditorUI(bool dont_push) {}
    typedef EditorUI* __thistype;

    virtual void constrainGameLayerPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c6d0))(this);
    }

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8a80))(this, p0);
    }

    virtual void deselectAll() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
    }

    virtual void disableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
    }

    virtual void editButtonUsable() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28f30))(this);
    }

    virtual void editObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x195a0))(this, p0);
    }

    virtual void enableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
    }

    virtual CreateMenuItem* getCreateBtn(int p0, int p1) {
        return reinterpret_cast<CreateMenuItem*(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
    }

    virtual void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
    }

    virtual void getSelectedObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
    }

    virtual void init(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8ae0))(this, p0);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x30790))(this, p0);
    }

    virtual void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
    }

    virtual void onDuplicate(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
    }

    virtual void pasteObjects(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x232d0))(this, p0);
    }

    virtual void playtestStopped() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24790))(this);
    }

    virtual void redoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
    }

    virtual void replaceGroupID(GameObject* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, int)>(m->getOriginal(getBase()+0x27470))(this, p0, p1, p2);
    }

    virtual void scaleChanged(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x25490))(this, p0);
    }

    virtual void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
    }

    virtual void selectObjects(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
    }

    virtual void setupCreateMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xcb50))(this);
    }

    virtual void undoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb830))(this, p0);
    }

    virtual void updateButtons() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
    }

    virtual void updateObjectInfoLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cb10))(this);
    }

    virtual void updateSlider() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18a90))(this);
    }

    virtual void updateZoom(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x248c0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $EditorUI(true);
        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition}))
            m->registerHook(getBase()+0x1c6d0, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition}));

        if (extract_virtual(&orig, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create}) != extract_virtual(this, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create}))
            m->registerHook(getBase()+0x8a80, extract_virtual(this, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::deselectAll}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::deselectAll}))
            m->registerHook(getBase()+0x1f300, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::deselectAll}));

        if (extract_virtual(&orig, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton}) != extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton}))
            m->registerHook(getBase()+0x1c0f0, extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::editButtonUsable}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::editButtonUsable}))
            m->registerHook(getBase()+0x28f30, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::editButtonUsable}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject}))
            m->registerHook(getBase()+0x195a0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject}));

        if (extract_virtual(&orig, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton}) != extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton}))
            m->registerHook(getBase()+0x1bff0, extract_virtual(this, (void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton}));

        if (extract_virtual(&orig, (CreateMenuItem*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn}) != extract_virtual(this, (CreateMenuItem*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn}))
            m->registerHook(getBase()+0x1f6c0, extract_virtual(this, (CreateMenuItem*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter}))
            m->registerHook(getBase()+0x23470, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::getSelectedObjects}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::getSelectedObjects}))
            m->registerHook(getBase()+0x23f30, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::getSelectedObjects}));

        if (extract_virtual(&orig, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init}) != extract_virtual(this, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init}))
            m->registerHook(getBase()+0x8ae0, extract_virtual(this, (void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown}))
            m->registerHook(getBase()+0x30790, extract_virtual(this, (void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown}));

        if (extract_virtual(&orig, (void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject}) != extract_virtual(this, (void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject}))
            m->registerHook(getBase()+0x24b10, extract_virtual(this, (void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate}))
            m->registerHook(getBase()+0x18ba0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate}));

        if (extract_virtual(&orig, (void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects}) != extract_virtual(this, (void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects}))
            m->registerHook(getBase()+0x232d0, extract_virtual(this, (void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::playtestStopped}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::playtestStopped}))
            m->registerHook(getBase()+0x24790, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::playtestStopped}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction}))
            m->registerHook(getBase()+0xb8e0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction}));

        if (extract_virtual(&orig, (void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID}) != extract_virtual(this, (void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID}))
            m->registerHook(getBase()+0x27470, extract_virtual(this, (void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID}));

        if (extract_virtual(&orig, (void($EditorUI::*)(float)){&$EditorUI::scaleChanged}) != extract_virtual(this, (void($EditorUI::*)(float)){&$EditorUI::scaleChanged}))
            m->registerHook(getBase()+0x25490, extract_virtual(this, (void($EditorUI::*)(float)){&$EditorUI::scaleChanged}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects}))
            m->registerHook(getBase()+0x252e0, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects}))
            m->registerHook(getBase()+0x23940, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::setupCreateMenu}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::setupCreateMenu}))
            m->registerHook(getBase()+0xcb50, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::setupCreateMenu}));

        if (extract_virtual(&orig, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction}) != extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction}))
            m->registerHook(getBase()+0xb830, extract_virtual(this, (void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::updateButtons}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateButtons}))
            m->registerHook(getBase()+0x1a300, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateButtons}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel}))
            m->registerHook(getBase()+0x1cb10, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel}));

        if (extract_virtual(&orig, (void($EditorUI::*)()){&$EditorUI::updateSlider}) != extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateSlider}))
            m->registerHook(getBase()+0x18a90, extract_virtual(this, (void($EditorUI::*)()){&$EditorUI::updateSlider}));

        if (extract_virtual(&orig, (void($EditorUI::*)(float)){&$EditorUI::updateZoom}) != extract_virtual(this, (void($EditorUI::*)(float)){&$EditorUI::updateZoom}))
            m->registerHook(getBase()+0x248c0, extract_virtual(this, (void($EditorUI::*)(float)){&$EditorUI::updateZoom}));
    }
};


class $EffectGameObject : public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EffectGameObject(bool dont_push) {}
    typedef EffectGameObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xc9790))(this, p0);
    }

    virtual void getTargetColorIndex() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xca1f0))(this);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $EffectGameObject(true);
        if (extract_virtual(&orig, (void($EffectGameObject::*)(char const*)){&$EffectGameObject::create}) != extract_virtual(this, (void($EffectGameObject::*)(char const*)){&$EffectGameObject::create}))
            m->registerHook(getBase()+0xc9790, extract_virtual(this, (void($EffectGameObject::*)(char const*)){&$EffectGameObject::create}));

        if (extract_virtual(&orig, (void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex}) != extract_virtual(this, (void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex}))
            m->registerHook(getBase()+0xca1f0, extract_virtual(this, (void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex}));

        if (extract_virtual(&orig, (void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject}) != extract_virtual(this, (void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject}))
            m->registerHook(getBase()+0xc9870, extract_virtual(this, (void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject}));
    }
};


class $EndLevelLayer : public $CacBase {
 public:
    $EndLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EndLevelLayer(bool dont_push) {}
    typedef EndLevelLayer* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2787d0))(this);
    }

    void apply_hooks() override {
        auto orig = $EndLevelLayer(true);
        if (extract_virtual(&orig, (void($EndLevelLayer::*)()){&$EndLevelLayer::create}) != extract_virtual(this, (void($EndLevelLayer::*)()){&$EndLevelLayer::create}))
            m->registerHook(getBase()+0x2787d0, extract_virtual(this, (void($EndLevelLayer::*)()){&$EndLevelLayer::create}));
    }
};


class $EndPortalObject : public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $EndPortalObject(bool dont_push) {}
    typedef EndPortalObject* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1da8f0))(this);
    }

    virtual void updateColors(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $EndPortalObject(true);
        if (extract_virtual(&orig, (void($EndPortalObject::*)()){&$EndPortalObject::create}) != extract_virtual(this, (void($EndPortalObject::*)()){&$EndPortalObject::create}))
            m->registerHook(getBase()+0x1da8f0, extract_virtual(this, (void($EndPortalObject::*)()){&$EndPortalObject::create}));

        if (extract_virtual(&orig, (void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors}) != extract_virtual(this, (void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors}))
            m->registerHook(getBase()+0x1dacb0, extract_virtual(this, (void($EndPortalObject::*)(cocos2d::_ccColor3B)){&$EndPortalObject::updateColors}));
    }
};


class $FLAlertLayer : public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $FLAlertLayer(bool dont_push) {}
    typedef FLAlertLayer* __thistype;

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(getBase()+0x25e0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25dec0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25ed90))(this);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
    }

    virtual void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f350))(this);
    }

    virtual void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f2e0))(this);
    }

    virtual void show() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x25f120))(this);
    }

    void apply_hooks() override {
        auto orig = $FLAlertLayer(true);
        if (extract_virtual(&orig, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan}) != extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan}))
            m->registerHook(getBase()+0x25ee40, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled}) != extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled}))
            m->registerHook(getBase()+0x25f020, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded}) != extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded}))
            m->registerHook(getBase()+0x25ef60, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved}) != extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved}))
            m->registerHook(getBase()+0x25f0a0, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create}) != extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create}))
            m->registerHook(getBase()+0x25e0e0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create}) != extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create}))
            m->registerHook(getBase()+0x25dec0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init}) != extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init}))
            m->registerHook(getBase()+0x25e1b0, extract_virtual(this, (void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked}) != extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked}))
            m->registerHook(getBase()+0x25ed90, extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown}) != extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown}))
            m->registerHook(getBase()+0x25ece0, extract_virtual(this, (void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter}) != extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter}))
            m->registerHook(getBase()+0x25f350, extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher}) != extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher}))
            m->registerHook(getBase()+0x25f2e0, extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher}));

        if (extract_virtual(&orig, (void($FLAlertLayer::*)()){&$FLAlertLayer::show}) != extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::show}))
            m->registerHook(getBase()+0x25f120, extract_virtual(this, (void($FLAlertLayer::*)()){&$FLAlertLayer::show}));
    }
};


class $FMODAudioEngine : public $CacBase {
 public:
    $FMODAudioEngine() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $FMODAudioEngine(bool dont_push) {}
    typedef FMODAudioEngine* __thistype;

    virtual void fadeBackgroundMusic(bool p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, float)>(m->getOriginal(getBase()+0x20fd50))(this, p0, p1);
    }

    virtual void getBackgroundMusicVolume() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2104a0))(this);
    }

    virtual void isBackgroundMusicPlaying() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20feb0))(this);
    }

    virtual void pauseAllEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x210420))(this);
    }

    virtual void pauseBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20fdd0))(this);
    }

    virtual void resumeAllEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x210440))(this);
    }

    virtual void resumeBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20fdf0))(this);
    }

    virtual void setBackgroundMusicTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x20fe10))(this, p0);
    }

    virtual void sharedEngine() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20ef80))(this);
    }

    void apply_hooks() override {
        auto orig = $FMODAudioEngine(true);
        if (extract_virtual(&orig, (void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic}) != extract_virtual(this, (void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic}))
            m->registerHook(getBase()+0x20fd50, extract_virtual(this, (void($FMODAudioEngine::*)(bool, float)){&$FMODAudioEngine::fadeBackgroundMusic}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::getBackgroundMusicVolume}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::getBackgroundMusicVolume}))
            m->registerHook(getBase()+0x2104a0, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::getBackgroundMusicVolume}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::isBackgroundMusicPlaying}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::isBackgroundMusicPlaying}))
            m->registerHook(getBase()+0x20feb0, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::isBackgroundMusicPlaying}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseAllEffects}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseAllEffects}))
            m->registerHook(getBase()+0x210420, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseAllEffects}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseBackgroundMusic}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseBackgroundMusic}))
            m->registerHook(getBase()+0x20fdd0, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::pauseBackgroundMusic}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeAllEffects}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeAllEffects}))
            m->registerHook(getBase()+0x210440, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeAllEffects}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeBackgroundMusic}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeBackgroundMusic}))
            m->registerHook(getBase()+0x20fdf0, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::resumeBackgroundMusic}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime}) != extract_virtual(this, (void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime}))
            m->registerHook(getBase()+0x20fe10, extract_virtual(this, (void($FMODAudioEngine::*)(float)){&$FMODAudioEngine::setBackgroundMusicTime}));

        if (extract_virtual(&orig, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::sharedEngine}) != extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::sharedEngine}))
            m->registerHook(getBase()+0x20ef80, extract_virtual(this, (void($FMODAudioEngine::*)()){&$FMODAudioEngine::sharedEngine}));
    }
};


class $FollowRewardPage : public $CacBase {
 public:
    $FollowRewardPage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $FollowRewardPage(bool dont_push) {}
    typedef FollowRewardPage* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22f140))(this);
    }

    void apply_hooks() override {
        auto orig = $FollowRewardPage(true);
        if (extract_virtual(&orig, (void($FollowRewardPage::*)()){&$FollowRewardPage::create}) != extract_virtual(this, (void($FollowRewardPage::*)()){&$FollowRewardPage::create}))
            m->registerHook(getBase()+0x22f140, extract_virtual(this, (void($FollowRewardPage::*)()){&$FollowRewardPage::create}));
    }
};


class $GJAccountManager : public $CacBase {
 public:
    $GJAccountManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJAccountManager(bool dont_push) {}
    typedef GJAccountManager* __thistype;

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x85070))(this);
    }

    void apply_hooks() override {
        auto orig = $GJAccountManager(true);
        if (extract_virtual(&orig, (void($GJAccountManager::*)()){&$GJAccountManager::sharedState}) != extract_virtual(this, (void($GJAccountManager::*)()){&$GJAccountManager::sharedState}))
            m->registerHook(getBase()+0x85070, extract_virtual(this, (void($GJAccountManager::*)()){&$GJAccountManager::sharedState}));
    }
};


class $GJBaseGameLayer : public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJBaseGameLayer(bool dont_push) {}
    typedef GJBaseGameLayer* __thistype;

    virtual void addObjectCounter(LabelGameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
    }

    virtual void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
    }

    virtual void addToGroups(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
    }

    virtual void addToSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
    }

    virtual void atlasValue(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
    }

    virtual void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
    }

    virtual void checkSpawnObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6f90))(this);
    }

    virtual void collectItem(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
    }

    virtual void collectedObject(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void createTextLayers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb5260))(this);
    }

    virtual void damagingObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb6140))(this, p0);
    }

    virtual void enableHighCapacityMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb11e0))(this);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
    }

    virtual void getCapacityString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb2210))(this);
    }

    virtual void getGroundHeightForMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6630))(this, p0);
    }

    virtual void getGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
    }

    virtual void getMoveDeltaForObjects(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
    }

    virtual void getOptimizedGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7940))(this, p0);
    }

    virtual void getStaticGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xafc90))(this);
    }

    virtual void isGroupDisabledForObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
    }

    virtual void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
    }

    virtual void loadUpToPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xba680))(this, p0);
    }

    virtual void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
    }

    virtual void objectTriggered(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
    }

    virtual void optimizeMoveGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb96c0))(this);
    }

    virtual void parentForZLayer(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
    }

    virtual void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
    }

    virtual void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
    }

    virtual void processFollowActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8fd0))(this);
    }

    virtual void processMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb86c0))(this);
    }

    virtual void processMoveActionsStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
    }

    virtual void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
    }

    virtual void processPlayerFollowActions(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
    }

    virtual void processRotationActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb7fd0))(this);
    }

    virtual void pushButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
    }

    virtual void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
    }

    virtual void refreshCounterLabels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9fc0))(this);
    }

    virtual void releaseButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
    }

    virtual void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
    }

    virtual void removeFromGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
    }

    virtual void removeObjectFromSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
    }

    virtual void reorderObjectSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
    }

    virtual void resetGroupCounters(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba300))(this, p0);
    }

    virtual void resetMoveOptimizedValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9670))(this);
    }

    virtual void sectionForPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb6120))(this, p0);
    }

    virtual void setupLayers() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xaffe0))(this);
    }

    virtual void shouldExitHackedLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb1100))(this);
    }

    virtual void spawnGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7050))(this, p0);
    }

    virtual void spawnGroupTriggered(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
    }

    virtual void staticObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
    }

    virtual void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
    }

    virtual void toggleGroupTriggered(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
    }

    virtual void togglePlayerVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba910))(this, p0);
    }

    virtual void triggerMoveCommand(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
    }

    virtual void updateCollisionBlocks() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb6a30))(this);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateCounters(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
    }

    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
    }

    virtual void updateLayerCapacity(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0xb1680))(this, p0);
    }

    virtual void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
    }

    virtual void updateOBB2(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
    }

    virtual void updateQueuedLabels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb9f30))(this);
    }

    void apply_hooks() override {
        auto orig = $GJBaseGameLayer(true);
        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter}) != extract_virtual(this, (void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter}))
            m->registerHook(getBase()+0xb9eb0, extract_virtual(this, (void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup}))
            m->registerHook(getBase()+0xb77f0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups}))
            m->registerHook(getBase()+0xb7780, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection}))
            m->registerHook(getBase()+0xb7b70, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue}))
            m->registerHook(getBase()+0xb21e0, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer}) != extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer}))
            m->registerHook(getBase()+0xb6860, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues}))
            m->registerHook(getBase()+0xba9a0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues}))
            m->registerHook(getBase()+0xb5be0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects}))
            m->registerHook(getBase()+0xb6f90, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem}))
            m->registerHook(getBase()+0xb9e20, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject}))
            m->registerHook(getBase()+0xb9b60, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand}))
            m->registerHook(getBase()+0xb73a0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers}))
            m->registerHook(getBase()+0xb5260, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect}))
            m->registerHook(getBase()+0xb6140, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode}))
            m->registerHook(getBase()+0xb11e0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity}) != extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity}))
            m->registerHook(getBase()+0xba990, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString}))
            m->registerHook(getBase()+0xb2210, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode}))
            m->registerHook(getBase()+0xb6630, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup}))
            m->registerHook(getBase()+0xb6f20, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects}))
            m->registerHook(getBase()+0xb6db0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup}))
            m->registerHook(getBase()+0xb7940, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup}))
            m->registerHook(getBase()+0xb79a0, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init}))
            m->registerHook(getBase()+0xafc90, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject}))
            m->registerHook(getBase()+0xb5cc0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull}))
            m->registerHook(getBase()+0xb5de0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition}) != extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition}))
            m->registerHook(getBase()+0xba680, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle}))
            m->registerHook(getBase()+0xb66e0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered}))
            m->registerHook(getBase()+0xb71b0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided}))
            m->registerHook(getBase()+0xb6d90, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups}))
            m->registerHook(getBase()+0xb96c0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer}))
            m->registerHook(getBase()+0xb55d0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing}) != extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing}))
            m->registerHook(getBase()+0xb69e0, extract_virtual(this, (void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject}))
            m->registerHook(getBase()+0xb5a90, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions}))
            m->registerHook(getBase()+0xb8fd0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions}))
            m->registerHook(getBase()+0xb86c0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep}) != extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep}))
            m->registerHook(getBase()+0xb7ea0, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject}))
            m->registerHook(getBase()+0xb5ae0, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions}) != extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions}))
            m->registerHook(getBase()+0xb8b50, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions}))
            m->registerHook(getBase()+0xb7fd0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton}))
            m->registerHook(getBase()+0xb9920, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle}))
            m->registerHook(getBase()+0xb6470, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels}))
            m->registerHook(getBase()+0xb9fc0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton}))
            m->registerHook(getBase()+0xb9a00, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup}))
            m->registerHook(getBase()+0xb7a60, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups}))
            m->registerHook(getBase()+0xb7a00, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection}))
            m->registerHook(getBase()+0xb7e00, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection}) != extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection}))
            m->registerHook(getBase()+0xb7cb0, extract_virtual(this, (void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters}) != extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters}))
            m->registerHook(getBase()+0xba300, extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue}))
            m->registerHook(getBase()+0xb9670, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos}) != extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos}))
            m->registerHook(getBase()+0xb6120, extract_virtual(this, (void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers}))
            m->registerHook(getBase()+0xaffe0, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel}))
            m->registerHook(getBase()+0xb1100, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup}))
            m->registerHook(getBase()+0xb7050, extract_virtual(this, (void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered}))
            m->registerHook(getBase()+0xb7020, extract_virtual(this, (void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect}))
            m->registerHook(getBase()+0xb5f90, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger}))
            m->registerHook(getBase()+0xb9ae0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup}))
            m->registerHook(getBase()+0xb75f0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered}))
            m->registerHook(getBase()+0xb75a0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility}) != extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility}))
            m->registerHook(getBase()+0xba910, extract_virtual(this, (void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand}) != extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand}))
            m->registerHook(getBase()+0xb7290, extract_virtual(this, (void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks}))
            m->registerHook(getBase()+0xb6a30, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor}))
            m->registerHook(getBase()+0xb7420, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters}))
            m->registerHook(getBase()+0xb9bc0, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos}))
            m->registerHook(getBase()+0xb95b0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity}) != extract_virtual(this, (void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity}))
            m->registerHook(getBase()+0xb1680, extract_virtual(this, (void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity}) != extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity}))
            m->registerHook(getBase()+0xb1590, extract_virtual(this, (void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2}) != extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2}))
            m->registerHook(getBase()+0xb63f0, extract_virtual(this, (void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2}));

        if (extract_virtual(&orig, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels}) != extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels}))
            m->registerHook(getBase()+0xb9f30, extract_virtual(this, (void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels}));
    }
};


class $GJColorSetupLayer : public $CacBase {
 public:
    $GJColorSetupLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJColorSetupLayer(bool dont_push) {}
    typedef GJColorSetupLayer* __thistype;

    virtual void updateSpriteColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xefe50))(this);
    }

    void apply_hooks() override {
        auto orig = $GJColorSetupLayer(true);
        if (extract_virtual(&orig, (void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors}) != extract_virtual(this, (void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors}))
            m->registerHook(getBase()+0xefe50, extract_virtual(this, (void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::updateSpriteColors}));
    }
};


class $GJDropDownLayer : public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJDropDownLayer(bool dont_push) {}
    typedef GJDropDownLayer* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x352530))(this, p0);
    }

    virtual void customSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352570))(this);
    }

    virtual void disableUI() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352580))(this);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x352910))(this);
    }

    virtual void enableUI() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525a0))(this);
    }

    virtual void enterAnimFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528a0))(this);
    }

    virtual void enterLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525c0))(this);
    }

    virtual void exitLayer(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x352670))(this, p0);
    }

    virtual void hideLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
    }

    virtual void init(char const* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, float)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
    }

    virtual void layerHidden() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528d0))(this);
    }

    virtual void layerVisible() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3528b0))(this);
    }

    virtual void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3525f0))(this);
    }

    virtual void showLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GJDropDownLayer(true);
        if (extract_virtual(&orig, (void($GJDropDownLayer::*)(char const*)){&$GJDropDownLayer::create}) != extract_virtual(this, (void($GJDropDownLayer::*)(char const*)){&$GJDropDownLayer::create}))
            m->registerHook(getBase()+0x352530, extract_virtual(this, (void($GJDropDownLayer::*)(char const*)){&$GJDropDownLayer::create}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup}))
            m->registerHook(getBase()+0x352570, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI}))
            m->registerHook(getBase()+0x352580, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw}))
            m->registerHook(getBase()+0x352910, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI}))
            m->registerHook(getBase()+0x3525a0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished}))
            m->registerHook(getBase()+0x3528a0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer}))
            m->registerHook(getBase()+0x3525c0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer}) != extract_virtual(this, (void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer}))
            m->registerHook(getBase()+0x352670, extract_virtual(this, (void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer}) != extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer}))
            m->registerHook(getBase()+0x3527b0, extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init}) != extract_virtual(this, (void($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init}))
            m->registerHook(getBase()+0x352100, extract_virtual(this, (void($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden}))
            m->registerHook(getBase()+0x3528d0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible}))
            m->registerHook(getBase()+0x3528b0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher}) != extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher}))
            m->registerHook(getBase()+0x3525f0, extract_virtual(this, (void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher}));

        if (extract_virtual(&orig, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer}) != extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer}))
            m->registerHook(getBase()+0x3526c0, extract_virtual(this, (void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer}));
    }
};


class $GJEffectManager : public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJEffectManager(bool dont_push) {}
    typedef GJEffectManager* __thistype;

    virtual void activeColorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
    }

    virtual void activeOpacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e10))(this, p0);
    }

    virtual void addAllInheritedColorActions(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
    }

    virtual void addGroupPulseEffect(PulseEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), PulseEffectAction*)>(m->getOriginal(getBase()+0x184c10))(this, p0);
    }

    virtual void calculateBaseActiveColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180f70))(this);
    }

    virtual void calculateInheritedColor(int p0, ColorAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, ColorAction*)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
    }

    virtual void calculateLightBGColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x185b90))(this, p0);
    }

    virtual void colorActionChanged(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
    }

    virtual void colorExists(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181da0))(this, p0);
    }

    virtual void colorForEffect(cocos2d::_ccColor3B p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
    }

    virtual cocos2d::_ccColor3B colorForGroupID(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<cocos2d::_ccColor3B(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
    }

    virtual void colorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
    }

    virtual void colorForPulseEffect(cocos2d::_ccColor3B const& p0, PulseEffectAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, PulseEffectAction*)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
    }

    virtual void countChangedForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
    }

    virtual void countForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a10))(this, p0);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1800f0))(this);
    }

    virtual void createFollowCommand(float p0, float p1, float p2, int p3, int p4, bool p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, int, int, bool, int)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void createPlayerFollowCommand(float p0, float p1, int p2, float p3, float p4, int p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, float, int, int)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createRotateCommand(int p0, float p1, int p2, int p3, int p4, float p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int, int, int, float, bool, int)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void getAllColorActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180980))(this);
    }

    virtual void getAllColorSprites() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1809e0))(this);
    }

    virtual void getColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180b00))(this, p0);
    }

    virtual void getColorSprite(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180d00))(this, p0);
    }

    virtual void getCurrentStateString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1867e0))(this);
    }

    virtual void getLoadedMoveOffset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x184390))(this);
    }

    virtual void getMixedColor(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
    }

    virtual void getOpacityActionForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
    }

    virtual void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185e90))(this);
    }

    virtual void handleObjectCollision(bool p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
    }

    virtual void hasActiveDualTouch() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185540))(this);
    }

    virtual void hasBeenTriggered(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
    }

    virtual void hasPulseEffectForGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184f60))(this, p0);
    }

    virtual bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x180230))(this);
    }

    virtual bool isGroupEnabled(int p0) {
        return reinterpret_cast<bool(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
    }

    virtual void keyForGroupIDColor(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
    }

    virtual void loadState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x188db0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
    }

    virtual void opacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180c80))(this, p0);
    }

    virtual float opacityModForGroup(int p0) {
        return reinterpret_cast<float(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184740))(this, p0);
    }

    virtual void playerButton(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
    }

    virtual void playerDied() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185860))(this);
    }

    virtual void postCollisionCheck() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182720))(this);
    }

    virtual void preCollisionCheck() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182680))(this);
    }

    virtual void prepareMoveActions(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
    }

    virtual void processColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180e70))(this);
    }

    virtual void processCopyColorPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181530))(this);
    }

    virtual void processInheritedColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181190))(this);
    }

    virtual void processPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x181040))(this);
    }

    virtual void registerCollisionTrigger(int p0, int p1, int p2, bool p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, bool, int)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void removeAllPulseActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1825e0))(this);
    }

    virtual void removeColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181d60))(this, p0);
    }

    virtual void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180690))(this);
    }

    virtual void resetColorCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x185280))(this);
    }

    virtual void resetEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1807d0))(this);
    }

    virtual void resetMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x180940))(this);
    }

    virtual void resetToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1853f0))(this);
    }

    virtual void resetTriggeredIDs() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x182630))(this);
    }

    virtual void runCountTrigger(int p0, int p1, bool p2, int p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool, int, bool, int)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runDeathTrigger(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
    }

    virtual OpacityEffectAction* runOpacityActionOnGroup(int p0, float p1, float p2, int p3) {
        return reinterpret_cast<OpacityEffectAction*(*)(decltype(this), int, float, float, int)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
    }

    virtual void runPulseEffect(int p0, bool p1, float p2, float p3, float p4, PulseEffectType p5, cocos2d::_ccColor3B p6, cocos2d::_ccHSVValue p7, int p8, bool p9, bool p10, bool p11, int p12) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    virtual void runTouchTriggerCommand(int p0, bool p1, TouchTriggerType p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, TouchTriggerType, bool, int)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
    }

    virtual void setColorAction(ColorAction* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*, int)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
    }

    virtual void setFollowing(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x186290))(this, p0);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e40))(this, p0);
    }

    virtual void spawnGroup(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
    }

    virtual void stopActionsForTrigger(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0x183150))(this, p0);
    }

    virtual void stopMoveActionsForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
    }

    virtual void storeTriggeredID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185380))(this, p0);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
    }

    virtual void traverseInheritanceChain(InheritanceNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*)>(m->getOriginal(getBase()+0x181850))(this, p0);
    }

    virtual void updateActiveOpacityEffects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1847e0))(this);
    }

    virtual void updateColorAction(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x184560))(this, p0);
    }

    virtual void updateColorEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181f40))(this, p0);
    }

    virtual void updateColors(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
    }

    virtual void updateEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181df0))(this, p0);
    }

    virtual void updateOpacityAction(OpacityEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction*)>(m->getOriginal(getBase()+0x184780))(this, p0);
    }

    virtual void updateOpacityEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
    }

    virtual void updatePulseEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182130))(this, p0);
    }

    virtual void updateSpawnTriggers(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182510))(this, p0);
    }

    virtual void wasFollowing(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
    }

    virtual void wouldCreateLoop(InheritanceNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*, int)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $GJEffectManager(true);
        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex}))
            m->registerHook(getBase()+0x180cb0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeColorForIndex}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex}))
            m->registerHook(getBase()+0x180e10, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::activeOpacityForIndex}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions}))
            m->registerHook(getBase()+0x1817a0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCArray*)){&$GJEffectManager::addAllInheritedColorActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect}) != extract_virtual(this, (void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect}))
            m->registerHook(getBase()+0x184c10, extract_virtual(this, (void($GJEffectManager::*)(PulseEffectAction*)){&$GJEffectManager::addGroupPulseEffect}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors}))
            m->registerHook(getBase()+0x180f70, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::calculateBaseActiveColors}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor}) != extract_virtual(this, (void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor}))
            m->registerHook(getBase()+0x1818f0, extract_virtual(this, (void($GJEffectManager::*)(int, ColorAction*)){&$GJEffectManager::calculateInheritedColor}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor}))
            m->registerHook(getBase()+0x185b90, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B)){&$GJEffectManager::calculateLightBGColor}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged}) != extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged}))
            m->registerHook(getBase()+0x181dc0, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::colorActionChanged}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists}))
            m->registerHook(getBase()+0x181da0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorExists}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect}))
            m->registerHook(getBase()+0x182650, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue)){&$GJEffectManager::colorForEffect}));

        if (extract_virtual(&orig, (cocos2d::_ccColor3B($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID}) != extract_virtual(this, (cocos2d::_ccColor3B($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID}))
            m->registerHook(getBase()+0x184f90, extract_virtual(this, (cocos2d::_ccColor3B($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::colorForGroupID}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex}))
            m->registerHook(getBase()+0x180ad0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::colorForIndex}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect}))
            m->registerHook(getBase()+0x181bf0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*)){&$GJEffectManager::colorForPulseEffect}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem}))
            m->registerHook(getBase()+0x185a40, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countChangedForItem}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem}))
            m->registerHook(getBase()+0x185a10, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::countForItem}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::create}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::create}))
            m->registerHook(getBase()+0x1800f0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::create}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand}) != extract_virtual(this, (void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand}))
            m->registerHook(getBase()+0x182ed0, extract_virtual(this, (void($GJEffectManager::*)(float, float, float, int, int, bool, int)){&$GJEffectManager::createFollowCommand}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand}))
            m->registerHook(getBase()+0x182cc0, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJEffectManager::createMoveCommand}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand}) != extract_virtual(this, (void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand}))
            m->registerHook(getBase()+0x182fe0, extract_virtual(this, (void($GJEffectManager::*)(float, float, int, float, float, int, int)){&$GJEffectManager::createPlayerFollowCommand}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand}) != extract_virtual(this, (void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand}))
            m->registerHook(getBase()+0x182df0, extract_virtual(this, (void($GJEffectManager::*)(int, float, int, int, int, float, bool, int)){&$GJEffectManager::createRotateCommand}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions}))
            m->registerHook(getBase()+0x180980, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites}))
            m->registerHook(getBase()+0x1809e0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getAllColorSprites}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction}))
            m->registerHook(getBase()+0x180b00, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorAction}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite}))
            m->registerHook(getBase()+0x180d00, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getColorSprite}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString}))
            m->registerHook(getBase()+0x1867e0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getCurrentStateString}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset}))
            m->registerHook(getBase()+0x184390, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getLoadedMoveOffset}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor}))
            m->registerHook(getBase()+0x185d30, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GJEffectManager::getMixedColor}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup}))
            m->registerHook(getBase()+0x1845b0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::getOpacityActionForGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::getSaveString}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getSaveString}))
            m->registerHook(getBase()+0x185e90, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::getSaveString}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision}) != extract_virtual(this, (void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision}))
            m->registerHook(getBase()+0x1828f0, extract_virtual(this, (void($GJEffectManager::*)(bool, int, int)){&$GJEffectManager::handleObjectCollision}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch}))
            m->registerHook(getBase()+0x185540, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::hasActiveDualTouch}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered}))
            m->registerHook(getBase()+0x1853b0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasBeenTriggered}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID}))
            m->registerHook(getBase()+0x184f60, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::hasPulseEffectForGroupID}));

        if (extract_virtual(&orig, (bool($GJEffectManager::*)()){&$GJEffectManager::init}) != extract_virtual(this, (bool($GJEffectManager::*)()){&$GJEffectManager::init}))
            m->registerHook(getBase()+0x180230, extract_virtual(this, (bool($GJEffectManager::*)()){&$GJEffectManager::init}));

        if (extract_virtual(&orig, (bool($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled}) != extract_virtual(this, (bool($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled}))
            m->registerHook(getBase()+0x1853d0, extract_virtual(this, (bool($GJEffectManager::*)(int)){&$GJEffectManager::isGroupEnabled}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor}) != extract_virtual(this, (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor}))
            m->registerHook(getBase()+0x184c90, extract_virtual(this, (void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool)){&$GJEffectManager::keyForGroupIDColor}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState}) != extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState}))
            m->registerHook(getBase()+0x188db0, extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::loadState}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided}) != extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided}))
            m->registerHook(getBase()+0x182a00, extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::objectsCollided}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex}))
            m->registerHook(getBase()+0x180c80, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::opacityForIndex}));

        if (extract_virtual(&orig, (float($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup}) != extract_virtual(this, (float($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup}))
            m->registerHook(getBase()+0x184740, extract_virtual(this, (float($GJEffectManager::*)(int)){&$GJEffectManager::opacityModForGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton}) != extract_virtual(this, (void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton}))
            m->registerHook(getBase()+0x1855a0, extract_virtual(this, (void($GJEffectManager::*)(bool, bool)){&$GJEffectManager::playerButton}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::playerDied}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::playerDied}))
            m->registerHook(getBase()+0x185860, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::playerDied}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck}))
            m->registerHook(getBase()+0x182720, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::postCollisionCheck}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck}))
            m->registerHook(getBase()+0x182680, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::preCollisionCheck}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions}) != extract_virtual(this, (void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions}))
            m->registerHook(getBase()+0x183660, extract_virtual(this, (void($GJEffectManager::*)(float, bool)){&$GJEffectManager::prepareMoveActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::processColors}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processColors}))
            m->registerHook(getBase()+0x180e70, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processColors}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions}))
            m->registerHook(getBase()+0x181530, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processCopyColorPulseActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors}))
            m->registerHook(getBase()+0x181190, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processInheritedColors}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions}))
            m->registerHook(getBase()+0x181040, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::processPulseActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger}) != extract_virtual(this, (void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger}))
            m->registerHook(getBase()+0x182b70, extract_virtual(this, (void($GJEffectManager::*)(int, int, int, bool, bool, int)){&$GJEffectManager::registerCollisionTrigger}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions}))
            m->registerHook(getBase()+0x1825e0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::removeAllPulseActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction}))
            m->registerHook(getBase()+0x181d60, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::removeColorAction}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::reset}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::reset}))
            m->registerHook(getBase()+0x180690, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::reset}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache}))
            m->registerHook(getBase()+0x185280, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetColorCache}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::resetEffects}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetEffects}))
            m->registerHook(getBase()+0x1807d0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions}))
            m->registerHook(getBase()+0x180940, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetMoveActions}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups}))
            m->registerHook(getBase()+0x1853f0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetToggledGroups}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs}))
            m->registerHook(getBase()+0x182630, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::resetTriggeredIDs}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger}) != extract_virtual(this, (void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger}))
            m->registerHook(getBase()+0x1858d0, extract_virtual(this, (void($GJEffectManager::*)(int, int, bool, int, bool, int)){&$GJEffectManager::runCountTrigger}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger}) != extract_virtual(this, (void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger}))
            m->registerHook(getBase()+0x1857a0, extract_virtual(this, (void($GJEffectManager::*)(int, bool, int)){&$GJEffectManager::runDeathTrigger}));

        if (extract_virtual(&orig, (OpacityEffectAction*($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup}) != extract_virtual(this, (OpacityEffectAction*($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup}))
            m->registerHook(getBase()+0x1845d0, extract_virtual(this, (OpacityEffectAction*($GJEffectManager::*)(int, float, float, int)){&$GJEffectManager::runOpacityActionOnGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect}) != extract_virtual(this, (void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect}))
            m->registerHook(getBase()+0x184890, extract_virtual(this, (void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)){&$GJEffectManager::runPulseEffect}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand}) != extract_virtual(this, (void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand}))
            m->registerHook(getBase()+0x185460, extract_virtual(this, (void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int)){&$GJEffectManager::runTouchTriggerCommand}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction}) != extract_virtual(this, (void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction}))
            m->registerHook(getBase()+0x181d00, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*, int)){&$GJEffectManager::setColorAction}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing}) != extract_virtual(this, (void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing}))
            m->registerHook(getBase()+0x185e00, extract_virtual(this, (void($GJEffectManager::*)(int, int, bool)){&$GJEffectManager::setFollowing}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString}) != extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString}))
            m->registerHook(getBase()+0x186290, extract_virtual(this, (void($GJEffectManager::*)(std::string)){&$GJEffectManager::setupFromString}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend}))
            m->registerHook(getBase()+0x180e40, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::shouldBlend}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup}) != extract_virtual(this, (void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup}))
            m->registerHook(getBase()+0x1852a0, extract_virtual(this, (void($GJEffectManager::*)(int, float, int)){&$GJEffectManager::spawnGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger}) != extract_virtual(this, (void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger}))
            m->registerHook(getBase()+0x183150, extract_virtual(this, (void($GJEffectManager::*)(EffectGameObject*)){&$GJEffectManager::stopActionsForTrigger}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup}))
            m->registerHook(getBase()+0x1830e0, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::stopMoveActionsForGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID}) != extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID}))
            m->registerHook(getBase()+0x185380, extract_virtual(this, (void($GJEffectManager::*)(int)){&$GJEffectManager::storeTriggeredID}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup}) != extract_virtual(this, (void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup}))
            m->registerHook(getBase()+0x182c80, extract_virtual(this, (void($GJEffectManager::*)(int, bool)){&$GJEffectManager::toggleGroup}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain}) != extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain}))
            m->registerHook(getBase()+0x181850, extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*)){&$GJEffectManager::traverseInheritanceChain}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects}) != extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects}))
            m->registerHook(getBase()+0x1847e0, extract_virtual(this, (void($GJEffectManager::*)()){&$GJEffectManager::updateActiveOpacityEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction}) != extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction}))
            m->registerHook(getBase()+0x184560, extract_virtual(this, (void($GJEffectManager::*)(ColorAction*)){&$GJEffectManager::updateColorAction}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects}) != extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects}))
            m->registerHook(getBase()+0x181f40, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateColorEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors}) != extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors}))
            m->registerHook(getBase()+0x180a40, extract_virtual(this, (void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$GJEffectManager::updateColors}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects}) != extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects}))
            m->registerHook(getBase()+0x181df0, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction}) != extract_virtual(this, (void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction}))
            m->registerHook(getBase()+0x184780, extract_virtual(this, (void($GJEffectManager::*)(OpacityEffectAction*)){&$GJEffectManager::updateOpacityAction}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects}) != extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects}))
            m->registerHook(getBase()+0x1823e0, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateOpacityEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects}) != extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects}))
            m->registerHook(getBase()+0x182130, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updatePulseEffects}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers}) != extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers}))
            m->registerHook(getBase()+0x182510, extract_virtual(this, (void($GJEffectManager::*)(float)){&$GJEffectManager::updateSpawnTriggers}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing}) != extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing}))
            m->registerHook(getBase()+0x185e60, extract_virtual(this, (void($GJEffectManager::*)(int, int)){&$GJEffectManager::wasFollowing}));

        if (extract_virtual(&orig, (void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop}) != extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop}))
            m->registerHook(getBase()+0x181820, extract_virtual(this, (void($GJEffectManager::*)(InheritanceNode*, int)){&$GJEffectManager::wouldCreateLoop}));
    }
};


class $GJFollowCommandLayer : public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJFollowCommandLayer(bool dont_push) {}
    typedef GJFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x16a550))(this, p0, p1);
    }

    virtual void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c8f0))(this, p0);
    }

    virtual void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x16c9e0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x16d480))(this, p0);
    }

    virtual void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16cfe0))(this);
    }

    virtual void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x16d1c0))(this);
    }

    void apply_hooks() override {
        auto orig = $GJFollowCommandLayer(true);
        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create}) != extract_virtual(this, (void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create}))
            m->registerHook(getBase()+0x16a550, extract_virtual(this, (void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJFollowCommandLayer::create}));

        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID}) != extract_virtual(this, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID}))
            m->registerHook(getBase()+0x16c8f0, extract_virtual(this, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID}));

        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2}) != extract_virtual(this, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2}))
            m->registerHook(getBase()+0x16c9e0, extract_virtual(this, (void($GJFollowCommandLayer::*)(cocos2d::CCObject*)){&$GJFollowCommandLayer::onUpdateGroupID2}));

        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged}) != extract_virtual(this, (void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged}))
            m->registerHook(getBase()+0x16d480, extract_virtual(this, (void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged}));

        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID}) != extract_virtual(this, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID}))
            m->registerHook(getBase()+0x16cfe0, extract_virtual(this, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID}));

        if (extract_virtual(&orig, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2}) != extract_virtual(this, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2}))
            m->registerHook(getBase()+0x16d1c0, extract_virtual(this, (void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::updateTargetGroupID2}));
    }
};


class $GJGameLevel : public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJGameLevel(bool dont_push) {}
    typedef GJGameLevel* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b83e0))(this);
    }

    virtual void getAudioFileName() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2dbe70))(this);
    }

    virtual void getCoinKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
    }

    virtual void getLengthKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2dbba0))(this, p0);
    }

    virtual void getNormalPercent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8b20))(this);
    }

    virtual void levelWasAltered() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2db530))(this);
    }

    virtual void savePercentage(int p0, bool p1, int p2, int p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, int, bool)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        auto orig = $GJGameLevel(true);
        if (extract_virtual(&orig, (void($GJGameLevel::*)()){&$GJGameLevel::create}) != extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::create}))
            m->registerHook(getBase()+0x2b83e0, extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::create}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName}) != extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName}))
            m->registerHook(getBase()+0x2dbe70, extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::getAudioFileName}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey}) != extract_virtual(this, (void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey}))
            m->registerHook(getBase()+0x2ce360, extract_virtual(this, (void($GJGameLevel::*)(int)){&$GJGameLevel::getCoinKey}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey}) != extract_virtual(this, (void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey}))
            m->registerHook(getBase()+0x2dbba0, extract_virtual(this, (void($GJGameLevel::*)(int)){&$GJGameLevel::getLengthKey}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent}) != extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent}))
            m->registerHook(getBase()+0x2b8b20, extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::getNormalPercent}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered}) != extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered}))
            m->registerHook(getBase()+0x2db530, extract_virtual(this, (void($GJGameLevel::*)()){&$GJGameLevel::levelWasAltered}));

        if (extract_virtual(&orig, (void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage}) != extract_virtual(this, (void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage}))
            m->registerHook(getBase()+0x2db700, extract_virtual(this, (void($GJGameLevel::*)(int, bool, int, int, bool)){&$GJGameLevel::savePercentage}));
    }
};


class $GJGroundLayer : public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJGroundLayer(bool dont_push) {}
    typedef GJGroundLayer* __thistype;

    virtual void create(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x355c00))(this, p0, p1);
    }

    virtual void deactivateGround() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356a40))(this);
    }

    virtual void getGroundY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356ac0))(this);
    }

    virtual void updateGround01Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356640))(this, p0);
    }

    virtual void updateGround02Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356710))(this, p0);
    }

    virtual void updateGroundPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
    }

    virtual void updateGroundWidth() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356790))(this);
    }

    void apply_hooks() override {
        auto orig = $GJGroundLayer(true);
        if (extract_virtual(&orig, (void($GJGroundLayer::*)(int, int)){&$GJGroundLayer::create}) != extract_virtual(this, (void($GJGroundLayer::*)(int, int)){&$GJGroundLayer::create}))
            m->registerHook(getBase()+0x355c00, extract_virtual(this, (void($GJGroundLayer::*)(int, int)){&$GJGroundLayer::create}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround}) != extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround}))
            m->registerHook(getBase()+0x356a40, extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::deactivateGround}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY}) != extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY}))
            m->registerHook(getBase()+0x356ac0, extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::getGroundY}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color}) != extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color}))
            m->registerHook(getBase()+0x356640, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround01Color}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color}) != extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color}))
            m->registerHook(getBase()+0x356710, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::_ccColor3B)){&$GJGroundLayer::updateGround02Color}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos}) != extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos}))
            m->registerHook(getBase()+0x3566c0, extract_virtual(this, (void($GJGroundLayer::*)(cocos2d::CCPoint)){&$GJGroundLayer::updateGroundPos}));

        if (extract_virtual(&orig, (void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth}) != extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth}))
            m->registerHook(getBase()+0x356790, extract_virtual(this, (void($GJGroundLayer::*)()){&$GJGroundLayer::updateGroundWidth}));
    }
};


class $GJMoveCommandLayer : public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJMoveCommandLayer(bool dont_push) {}
    typedef GJMoveCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36f8a0))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
    }

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374970))(this);
    }

    virtual void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x373350))(this, p0);
    }

    virtual void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374430))(this, p0);
    }

    virtual void textInputReturn(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374c10))(this, p0);
    }

    virtual void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
    }

    virtual void updateEditorLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374110))(this);
    }

    virtual void updateMoveTargetElements() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373ac0))(this);
    }

    virtual void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374050))(this);
    }

    virtual void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x374230))(this);
    }

    virtual void updateTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373680))(this);
    }

    virtual void updateTextInputLabel2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373760))(this);
    }

    virtual void updateValueXLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373840))(this);
    }

    virtual void updateValueYLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x373950))(this);
    }

    virtual void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $GJMoveCommandLayer(true);
        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create}))
            m->registerHook(getBase()+0x36f8a0, extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::create}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init}))
            m->registerHook(getBase()+0x36fac0, extract_virtual(this, (void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJMoveCommandLayer::init}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked}))
            m->registerHook(getBase()+0x374970, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID}))
            m->registerHook(getBase()+0x373350, extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2}))
            m->registerHook(getBase()+0x3734c0, extract_virtual(this, (void($GJMoveCommandLayer::*)(cocos2d::CCObject*)){&$GJMoveCommandLayer::onUpdateGroupID2}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged}))
            m->registerHook(getBase()+0x374470, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed}))
            m->registerHook(getBase()+0x374430, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn}))
            m->registerHook(getBase()+0x374c10, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset}))
            m->registerHook(getBase()+0x374b50, extract_virtual(this, (void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel}))
            m->registerHook(getBase()+0x374110, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateEditorLabel}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements}))
            m->registerHook(getBase()+0x373ac0, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateMoveTargetElements}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID}))
            m->registerHook(getBase()+0x374050, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2}))
            m->registerHook(getBase()+0x374230, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTargetGroupID2}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel}))
            m->registerHook(getBase()+0x373680, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2}))
            m->registerHook(getBase()+0x373760, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateTextInputLabel2}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel}))
            m->registerHook(getBase()+0x373840, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueXLabel}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel}) != extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel}))
            m->registerHook(getBase()+0x373950, extract_virtual(this, (void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::updateValueYLabel}));

        if (extract_virtual(&orig, (void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed}) != extract_virtual(this, (void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed}))
            m->registerHook(getBase()+0x373c20, extract_virtual(this, (void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed}));
    }
};


class $GJPFollowCommandLayer : public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJPFollowCommandLayer(bool dont_push) {}
    typedef GJPFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1aea20))(this, p0, p1);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1b1dc0))(this, p0);
    }

    virtual void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1b1a60))(this);
    }

    void apply_hooks() override {
        auto orig = $GJPFollowCommandLayer(true);
        if (extract_virtual(&orig, (void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create}) != extract_virtual(this, (void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create}))
            m->registerHook(getBase()+0x1aea20, extract_virtual(this, (void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJPFollowCommandLayer::create}));

        if (extract_virtual(&orig, (void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged}) != extract_virtual(this, (void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged}))
            m->registerHook(getBase()+0x1b1dc0, extract_virtual(this, (void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged}));

        if (extract_virtual(&orig, (void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID}) != extract_virtual(this, (void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID}))
            m->registerHook(getBase()+0x1b1a60, extract_virtual(this, (void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::updateTargetGroupID}));
    }
};


class $GJRobotSprite : public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJRobotSprite(bool dont_push) {}
    typedef GJRobotSprite* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34ac00))(this);
    }

    virtual void updateColor02(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
    }

    virtual void updateFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GJRobotSprite(true);
        if (extract_virtual(&orig, (void($GJRobotSprite::*)()){&$GJRobotSprite::create}) != extract_virtual(this, (void($GJRobotSprite::*)()){&$GJRobotSprite::create}))
            m->registerHook(getBase()+0x34ac00, extract_virtual(this, (void($GJRobotSprite::*)()){&$GJRobotSprite::create}));

        if (extract_virtual(&orig, (void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02}) != extract_virtual(this, (void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02}))
            m->registerHook(getBase()+0x34bbd0, extract_virtual(this, (void($GJRobotSprite::*)(cocos2d::_ccColor3B)){&$GJRobotSprite::updateColor02}));

        if (extract_virtual(&orig, (void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame}) != extract_virtual(this, (void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame}))
            m->registerHook(getBase()+0x34bdd0, extract_virtual(this, (void($GJRobotSprite::*)(int)){&$GJRobotSprite::updateFrame}));
    }
};


class $GJRotateCommandLayer : public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJRotateCommandLayer(bool dont_push) {}
    typedef GJRotateCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1ba0))(this, p0, p1);
    }

    virtual void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4bb0))(this, p0);
    }

    virtual void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4ca0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x58d0))(this, p0);
    }

    virtual void updateTargetGroupID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x54b0))(this);
    }

    virtual void updateTargetGroupID2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5690))(this);
    }

    void apply_hooks() override {
        auto orig = $GJRotateCommandLayer(true);
        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create}) != extract_virtual(this, (void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create}))
            m->registerHook(getBase()+0x1ba0, extract_virtual(this, (void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$GJRotateCommandLayer::create}));

        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID}) != extract_virtual(this, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID}))
            m->registerHook(getBase()+0x4bb0, extract_virtual(this, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID}));

        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2}) != extract_virtual(this, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2}))
            m->registerHook(getBase()+0x4ca0, extract_virtual(this, (void($GJRotateCommandLayer::*)(cocos2d::CCObject*)){&$GJRotateCommandLayer::onUpdateGroupID2}));

        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged}) != extract_virtual(this, (void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged}))
            m->registerHook(getBase()+0x58d0, extract_virtual(this, (void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged}));

        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID}) != extract_virtual(this, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID}))
            m->registerHook(getBase()+0x54b0, extract_virtual(this, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID}));

        if (extract_virtual(&orig, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2}) != extract_virtual(this, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2}))
            m->registerHook(getBase()+0x5690, extract_virtual(this, (void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::updateTargetGroupID2}));
    }
};


class $GJSearchObject : public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJSearchObject(bool dont_push) {}
    typedef GJSearchObject* __thistype;

    virtual void create(SearchType p0) {
        return reinterpret_cast<void(*)(decltype(this), SearchType)>(m->getOriginal(getBase()+0x2df120))(this, p0);
    }

    virtual void create(SearchType p0, std::string p1, std::string p2, std::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, int p17, int p18) {
        return reinterpret_cast<void(*)(decltype(this), SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)>(m->getOriginal(getBase()+0x2dee30))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    virtual void getPageObject(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2df9a0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GJSearchObject(true);
        if (extract_virtual(&orig, (void($GJSearchObject::*)(SearchType)){&$GJSearchObject::create}) != extract_virtual(this, (void($GJSearchObject::*)(SearchType)){&$GJSearchObject::create}))
            m->registerHook(getBase()+0x2df120, extract_virtual(this, (void($GJSearchObject::*)(SearchType)){&$GJSearchObject::create}));

        if (extract_virtual(&orig, (void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create}) != extract_virtual(this, (void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create}))
            m->registerHook(getBase()+0x2dee30, extract_virtual(this, (void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)){&$GJSearchObject::create}));

        if (extract_virtual(&orig, (void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject}) != extract_virtual(this, (void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject}))
            m->registerHook(getBase()+0x2df9a0, extract_virtual(this, (void($GJSearchObject::*)(int)){&$GJSearchObject::getPageObject}));
    }
};


class $GJSpecialColorSelect : public $CacBase {
 public:
    $GJSpecialColorSelect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJSpecialColorSelect(bool dont_push) {}
    typedef GJSpecialColorSelect* __thistype;

    virtual void textForColorIdx(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x383a50))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GJSpecialColorSelect(true);
        if (extract_virtual(&orig, (void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx}) != extract_virtual(this, (void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx}))
            m->registerHook(getBase()+0x383a50, extract_virtual(this, (void($GJSpecialColorSelect::*)(int)){&$GJSpecialColorSelect::textForColorIdx}));
    }
};


class $GJSpiderSprite : public $CacBase {
 public:
    $GJSpiderSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GJSpiderSprite(bool dont_push) {}
    typedef GJSpiderSprite* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34c5b0))(this);
    }

    void apply_hooks() override {
        auto orig = $GJSpiderSprite(true);
        if (extract_virtual(&orig, (void($GJSpiderSprite::*)()){&$GJSpiderSprite::create}) != extract_virtual(this, (void($GJSpiderSprite::*)()){&$GJSpiderSprite::create}))
            m->registerHook(getBase()+0x34c5b0, extract_virtual(this, (void($GJSpiderSprite::*)()){&$GJSpiderSprite::create}));
    }
};


class $GManager : public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GManager(bool dont_push) {}
    typedef GManager* __thistype;

    virtual void save() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26f300))(this);
    }

    virtual void saveData(DS_Dictionary* p0, std::string p1) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*, std::string)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
    }

    virtual void saveGMTo(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GManager(true);
        if (extract_virtual(&orig, (void($GManager::*)()){&$GManager::save}) != extract_virtual(this, (void($GManager::*)()){&$GManager::save}))
            m->registerHook(getBase()+0x26f300, extract_virtual(this, (void($GManager::*)()){&$GManager::save}));

        if (extract_virtual(&orig, (void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData}) != extract_virtual(this, (void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData}))
            m->registerHook(getBase()+0x26f4b0, extract_virtual(this, (void($GManager::*)(DS_Dictionary*, std::string)){&$GManager::saveData}));

        if (extract_virtual(&orig, (void($GManager::*)(std::string)){&$GManager::saveGMTo}) != extract_virtual(this, (void($GManager::*)(std::string)){&$GManager::saveGMTo}))
            m->registerHook(getBase()+0x26f3b0, extract_virtual(this, (void($GManager::*)(std::string)){&$GManager::saveGMTo}));
    }
};


class $GameLevelManager : public $CacBase {
 public:
    $GameLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameLevelManager(bool dont_push) {}
    typedef GameLevelManager* __thistype;

    virtual void createNewLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2b8180))(this);
    }

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2a8340))(this);
    }

    void apply_hooks() override {
        auto orig = $GameLevelManager(true);
        if (extract_virtual(&orig, (void($GameLevelManager::*)()){&$GameLevelManager::createNewLevel}) != extract_virtual(this, (void($GameLevelManager::*)()){&$GameLevelManager::createNewLevel}))
            m->registerHook(getBase()+0x2b8180, extract_virtual(this, (void($GameLevelManager::*)()){&$GameLevelManager::createNewLevel}));

        if (extract_virtual(&orig, (void($GameLevelManager::*)()){&$GameLevelManager::sharedState}) != extract_virtual(this, (void($GameLevelManager::*)()){&$GameLevelManager::sharedState}))
            m->registerHook(getBase()+0x2a8340, extract_virtual(this, (void($GameLevelManager::*)()){&$GameLevelManager::sharedState}));
    }
};


class $GameManager : public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameManager(bool dont_push) {}
    typedef GameManager* __thistype;

    virtual void accountStatusChanged() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
    }

    virtual _ccColor3B colorForIdx(int p0) {
        return reinterpret_cast<_ccColor3B(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
    }

    virtual void didExitPlayscene() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0230))(this);
    }

    virtual void doQuickSave() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
    }

    virtual void fadeInMusic(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
    }

    virtual void getBGTexture(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
    }

    virtual void getFontFile(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
    }

    virtual int getGameVariable(char const* p0) {
        return reinterpret_cast<int(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
    }

    virtual void getIntGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
    }

    virtual void getUGV(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
    }

    virtual void loadDeathEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
    }

    virtual void loadFont(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
    }

    virtual void reloadAll(bool p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
    }

    virtual void reloadAllStep5() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
    }

    virtual void reportPercentageForLevel(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
    }

    virtual int setGameVariable(char const* p0, bool p1) {
        return reinterpret_cast<int(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
    }

    virtual void setIntGameVariable(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x1cd0e0))(this, p0, p1);
    }

    virtual void setUGV(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
    }

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2b30))(this);
    }

    void apply_hooks() override {
        auto orig = $GameManager(true);
        if (extract_virtual(&orig, (void($GameManager::*)()){&$GameManager::accountStatusChanged}) != extract_virtual(this, (void($GameManager::*)()){&$GameManager::accountStatusChanged}))
            m->registerHook(getBase()+0x1cdad0, extract_virtual(this, (void($GameManager::*)()){&$GameManager::accountStatusChanged}));

        if (extract_virtual(&orig, (_ccColor3B($GameManager::*)(int)){&$GameManager::colorForIdx}) != extract_virtual(this, (_ccColor3B($GameManager::*)(int)){&$GameManager::colorForIdx}))
            m->registerHook(getBase()+0x1cbc80, extract_virtual(this, (_ccColor3B($GameManager::*)(int)){&$GameManager::colorForIdx}));

        if (extract_virtual(&orig, (void($GameManager::*)()){&$GameManager::didExitPlayscene}) != extract_virtual(this, (void($GameManager::*)()){&$GameManager::didExitPlayscene}))
            m->registerHook(getBase()+0x1d0230, extract_virtual(this, (void($GameManager::*)()){&$GameManager::didExitPlayscene}));

        if (extract_virtual(&orig, (void($GameManager::*)()){&$GameManager::doQuickSave}) != extract_virtual(this, (void($GameManager::*)()){&$GameManager::doQuickSave}))
            m->registerHook(getBase()+0x1d0200, extract_virtual(this, (void($GameManager::*)()){&$GameManager::doQuickSave}));

        if (extract_virtual(&orig, (void($GameManager::*)(char const*)){&$GameManager::fadeInMusic}) != extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::fadeInMusic}))
            m->registerHook(getBase()+0x1c2ff0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::fadeInMusic}));

        if (extract_virtual(&orig, (void($GameManager::*)(int)){&$GameManager::getBGTexture}) != extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getBGTexture}))
            m->registerHook(getBase()+0x1cca00, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getBGTexture}));

        if (extract_virtual(&orig, (void($GameManager::*)(int)){&$GameManager::getFontFile}) != extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getFontFile}))
            m->registerHook(getBase()+0x1cc5f0, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::getFontFile}));

        if (extract_virtual(&orig, (int($GameManager::*)(char const*)){&$GameManager::getGameVariable}) != extract_virtual(this, (int($GameManager::*)(char const*)){&$GameManager::getGameVariable}))
            m->registerHook(getBase()+0x1cccd0, extract_virtual(this, (int($GameManager::*)(char const*)){&$GameManager::getGameVariable}));

        if (extract_virtual(&orig, (void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable}) != extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable}))
            m->registerHook(getBase()+0x1cd1d0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getIntGameVariable}));

        if (extract_virtual(&orig, (void($GameManager::*)(char const*)){&$GameManager::getUGV}) != extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getUGV}))
            m->registerHook(getBase()+0x1ccfa0, extract_virtual(this, (void($GameManager::*)(char const*)){&$GameManager::getUGV}));

        if (extract_virtual(&orig, (void($GameManager::*)(int)){&$GameManager::loadDeathEffect}) != extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadDeathEffect}))
            m->registerHook(getBase()+0x1cc690, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadDeathEffect}));

        if (extract_virtual(&orig, (void($GameManager::*)(int)){&$GameManager::loadFont}) != extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadFont}))
            m->registerHook(getBase()+0x1cc550, extract_virtual(this, (void($GameManager::*)(int)){&$GameManager::loadFont}));

        if (extract_virtual(&orig, (void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll}) != extract_virtual(this, (void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll}))
            m->registerHook(getBase()+0x1d08a0, extract_virtual(this, (void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll}));

        if (extract_virtual(&orig, (void($GameManager::*)()){&$GameManager::reloadAllStep5}) != extract_virtual(this, (void($GameManager::*)()){&$GameManager::reloadAllStep5}))
            m->registerHook(getBase()+0x1d0b00, extract_virtual(this, (void($GameManager::*)()){&$GameManager::reloadAllStep5}));

        if (extract_virtual(&orig, (void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel}) != extract_virtual(this, (void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel}))
            m->registerHook(getBase()+0x1c5b00, extract_virtual(this, (void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel}));

        if (extract_virtual(&orig, (int($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable}) != extract_virtual(this, (int($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable}))
            m->registerHook(getBase()+0x1cca80, extract_virtual(this, (int($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable}));

        if (extract_virtual(&orig, (void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable}) != extract_virtual(this, (void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable}))
            m->registerHook(getBase()+0x1cd0e0, extract_virtual(this, (void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable}));

        if (extract_virtual(&orig, (void($GameManager::*)(char const*, bool)){&$GameManager::setUGV}) != extract_virtual(this, (void($GameManager::*)(char const*, bool)){&$GameManager::setUGV}))
            m->registerHook(getBase()+0x1cce50, extract_virtual(this, (void($GameManager::*)(char const*, bool)){&$GameManager::setUGV}));

        if (extract_virtual(&orig, (void($GameManager::*)()){&$GameManager::sharedState}) != extract_virtual(this, (void($GameManager::*)()){&$GameManager::sharedState}))
            m->registerHook(getBase()+0x1c2b30, extract_virtual(this, (void($GameManager::*)()){&$GameManager::sharedState}));
    }
};


class $GameObject : public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameObject(bool dont_push) {}
    typedef GameObject* __thistype;

    virtual void activateObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2faf60))(this);
    }

    virtual void activatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a20))(this, p0);
    }

    virtual void addColorSprite() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7fe0))(this);
    }

    virtual void addColorSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
    }

    virtual void addMainSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
    }

    virtual void addToGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
    }

    virtual void addToTempOffset(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
    }

    virtual void calculateOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b20))(this);
    }

    virtual void calculateSpawnXPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
    }

    virtual void canChangeCustomColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342db0))(this);
    }

    virtual void colorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
    }

    virtual void commonSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5570))(this);
    }

    virtual void copyGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
    }

    virtual void createWithFrame(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2f5490))(this, p0);
    }

    virtual void createWithKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2f4ce0))(this, p0);
    }

    virtual void customSetup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fbba0))(this);
    }

    virtual void deactivateObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
    }

    virtual void destroyObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
    }

    virtual void determineSlopeDirection() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33a9e0))(this);
    }

    virtual void getActiveColorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
    }

    virtual void getBallFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
    }

    virtual void getBoxOffset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3353d0))(this);
    }

    virtual void getColorIndex() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b90))(this);
    }

    virtual void getDidUpdateLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a20))(this);
    }

    virtual int getGroupID(int p0) {
        return reinterpret_cast<int(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
    }

    virtual void getLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3439d0))(this);
    }

    virtual void getMainColorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x334c30))(this);
    }

    virtual void getObjectRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352b0))(this);
    }

    virtual void getObjectRect(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
    }

    virtual void getObjectRect2(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
    }

    virtual void getObjectRectDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1d0))(this);
    }

    virtual void getObjectTextureRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3355b0))(this);
    }

    virtual void getObjectZOrder() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337d70))(this);
    }

    virtual void getOrientedRectDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1f0))(this);
    }

    virtual void getRScaleX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e50))(this);
    }

    virtual void getRScaleY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335e80))(this);
    }

    virtual void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d3d0))(this);
    }

    virtual void getSecondaryColorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x341c20))(this);
    }

    virtual void getSectionIdx() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a00))(this);
    }

    virtual void getStartPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc230))(this);
    }

    virtual void getType() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc210))(this);
    }

    virtual void groupWasDisabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b110))(this);
    }

    virtual void groupWasEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33b0f0))(this);
    }

    virtual void hasBeenActivated() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342a80))(this);
    }

    virtual void hasBeenActivatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a50))(this, p0);
    }

    virtual void hasSecondaryColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342f80))(this);
    }

    virtual void ignoreEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3352a0))(this);
    }

    virtual void ignoreFade() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335290))(this);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
    }

    virtual void isBasicTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343d10))(this);
    }

    virtual void isColorTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343b40))(this);
    }

    virtual void isFlipX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a40))(this);
    }

    virtual void isFlipY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335a50))(this);
    }

    virtual void isSpawnableTrigger() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343a60))(this);
    }

    virtual void isSpecialObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343c40))(this);
    }

    virtual void objectFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x33b720))(this, p0, p1);
    }

    virtual void playShineEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
    }

    virtual void powerOffObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369c0))(this);
    }

    virtual void powerOnObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369a0))(this);
    }

    virtual void quickUpdatePosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x335790))(this);
    }

    virtual void removeFromGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
    }

    virtual void removeGlow() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f7f70))(this);
    }

    virtual void resetGroupDisabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa7e0))(this);
    }

    virtual void saveActiveColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x33d250))(this);
    }

    virtual void selectObject(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x341f90))(this, p0);
    }

    virtual void setChildColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341f20))(this, p0);
    }

    virtual void setDefaultMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
    }

    virtual void setDidUpdateLastPosition(bool const& p0) {
        return reinterpret_cast<void(*)(decltype(this), bool const&)>(m->getOriginal(getBase()+0x343a30))(this, p0);
    }

    virtual void setGlowColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
    }

    virtual void setGlowOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x336200))(this, p0);
    }

    virtual void setLastPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
    }

    virtual void setMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x342e70))(this, p0);
    }

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341c90))(this, p0);
    }

    virtual void setObjectRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
    }

    virtual void setOrientedRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc200))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x335850))(this, p0);
    }

    virtual void setRScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335e10))(this, p0);
    }

    virtual void setRScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
    }

    virtual void setRScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335d60))(this, p0);
    }

    virtual void setSectionIdx(int const& p0) {
        return reinterpret_cast<void(*)(decltype(this), int const&)>(m->getOriginal(getBase()+0x343a10))(this, p0);
    }

    virtual void setStartPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
    }

    virtual void setType(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0xdc220))(this, p0);
    }

    virtual void setupCoinArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
    }

    virtual void setupCustomSprites() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x307f60))(this);
    }

    virtual void slopeFloorTop() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342800))(this);
    }

    virtual void slopeWallLeft() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3427e0))(this);
    }

    virtual void spawnXPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xdc1b0))(this);
    }

    virtual void triggerActivated(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x336990))(this, p0);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
    }

    virtual void updateCustomScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
    }

    virtual void updateMainColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343340))(this);
    }

    virtual void updateOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x342b50))(this);
    }

    virtual void updateSecondaryColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x343740))(this);
    }

    virtual void updateStartPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa590))(this);
    }

    virtual void updateStartValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa800))(this);
    }

    virtual void updateState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3369e0))(this);
    }

    virtual void updateSyncedAnimation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x337f00))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GameObject(true);
        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::activateObject}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::activateObject}))
            m->registerHook(getBase()+0x2faf60, extract_virtual(this, (void($GameObject::*)()){&$GameObject::activateObject}));

        if (extract_virtual(&orig, (void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer}) != extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer}))
            m->registerHook(getBase()+0x342a20, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::activatedByPlayer}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::addColorSprite}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::addColorSprite}))
            m->registerHook(getBase()+0x2f7fe0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::addColorSprite}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent}) != extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent}))
            m->registerHook(getBase()+0x2fb470, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addColorSpriteToParent}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent}) != extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent}))
            m->registerHook(getBase()+0x33a5b0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::addToGroup}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::addToGroup}))
            m->registerHook(getBase()+0x33ad00, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::addToGroup}));

        if (extract_virtual(&orig, (void($GameObject::*)(float, float)){&$GameObject::addToTempOffset}) != extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::addToTempOffset}))
            m->registerHook(getBase()+0x335700, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::addToTempOffset}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::calculateOrientedBox}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::calculateOrientedBox}))
            m->registerHook(getBase()+0x342b20, extract_virtual(this, (void($GameObject::*)()){&$GameObject::calculateOrientedBox}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::calculateSpawnXPos}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::calculateSpawnXPos}))
            m->registerHook(getBase()+0x336970, extract_virtual(this, (void($GameObject::*)()){&$GameObject::calculateSpawnXPos}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::canChangeCustomColor}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::canChangeCustomColor}))
            m->registerHook(getBase()+0x342db0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::canChangeCustomColor}));

        if (extract_virtual(&orig, (void($GameObject::*)(int, bool)){&$GameObject::colorForMode}) != extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::colorForMode}))
            m->registerHook(getBase()+0x343460, extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::colorForMode}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::commonSetup}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::commonSetup}))
            m->registerHook(getBase()+0x2f5570, extract_virtual(this, (void($GameObject::*)()){&$GameObject::commonSetup}));

        if (extract_virtual(&orig, (void($GameObject::*)(GameObject*)){&$GameObject::copyGroups}) != extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::copyGroups}))
            m->registerHook(getBase()+0x33ae30, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::copyGroups}));

        if (extract_virtual(&orig, (void($GameObject::*)(char const*)){&$GameObject::createWithFrame}) != extract_virtual(this, (void($GameObject::*)(char const*)){&$GameObject::createWithFrame}))
            m->registerHook(getBase()+0x2f5490, extract_virtual(this, (void($GameObject::*)(char const*)){&$GameObject::createWithFrame}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::createWithKey}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::createWithKey}))
            m->registerHook(getBase()+0x2f4ce0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::createWithKey}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::customSetup}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::customSetup}))
            m->registerHook(getBase()+0x2fbba0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::customSetup}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool)){&$GameObject::deactivateObject}) != extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::deactivateObject}))
            m->registerHook(getBase()+0x2fb8f0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::deactivateObject}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::destroyObject}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::destroyObject}))
            m->registerHook(getBase()+0x336a00, extract_virtual(this, (void($GameObject::*)()){&$GameObject::destroyObject}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::determineSlopeDirection}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::determineSlopeDirection}))
            m->registerHook(getBase()+0x33a9e0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::determineSlopeDirection}));

        if (extract_virtual(&orig, (void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode}) != extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode}))
            m->registerHook(getBase()+0x343860, extract_virtual(this, (void($GameObject::*)(int, bool)){&$GameObject::getActiveColorForMode}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::getBallFrame}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::getBallFrame}))
            m->registerHook(getBase()+0x341bf0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::getBallFrame}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getBoxOffset}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getBoxOffset}))
            m->registerHook(getBase()+0x3353d0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getBoxOffset}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getColorIndex}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getColorIndex}))
            m->registerHook(getBase()+0x343b90, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getColorIndex}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition}))
            m->registerHook(getBase()+0x343a20, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getDidUpdateLastPosition}));

        if (extract_virtual(&orig, (int($GameObject::*)(int)){&$GameObject::getGroupID}) != extract_virtual(this, (int($GameObject::*)(int)){&$GameObject::getGroupID}))
            m->registerHook(getBase()+0x33ae10, extract_virtual(this, (int($GameObject::*)(int)){&$GameObject::getGroupID}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getLastPosition}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getLastPosition}))
            m->registerHook(getBase()+0x3439d0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getLastPosition}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getMainColorMode}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getMainColorMode}))
            m->registerHook(getBase()+0x334c30, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getMainColorMode}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getObjectRect}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectRect}))
            m->registerHook(getBase()+0x3352b0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectRect}));

        if (extract_virtual(&orig, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect}) != extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect}))
            m->registerHook(getBase()+0x3352d0, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect}));

        if (extract_virtual(&orig, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect2}) != extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect2}))
            m->registerHook(getBase()+0x3354e0, extract_virtual(this, (void($GameObject::*)(float, float)){&$GameObject::getObjectRect2}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getObjectRectDirty}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectRectDirty}))
            m->registerHook(getBase()+0xdc1d0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectRectDirty}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getObjectTextureRect}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectTextureRect}))
            m->registerHook(getBase()+0x3355b0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectTextureRect}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getObjectZOrder}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectZOrder}))
            m->registerHook(getBase()+0x337d70, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getObjectZOrder}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getOrientedRectDirty}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getOrientedRectDirty}))
            m->registerHook(getBase()+0xdc1f0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getOrientedRectDirty}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getRScaleX}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getRScaleX}))
            m->registerHook(getBase()+0x335e50, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getRScaleX}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getRScaleY}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getRScaleY}))
            m->registerHook(getBase()+0x335e80, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getRScaleY}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getSaveString}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSaveString}))
            m->registerHook(getBase()+0x33d3d0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSaveString}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getSecondaryColorMode}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSecondaryColorMode}))
            m->registerHook(getBase()+0x341c20, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSecondaryColorMode}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getSectionIdx}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSectionIdx}))
            m->registerHook(getBase()+0x343a00, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getSectionIdx}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getStartPos}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getStartPos}))
            m->registerHook(getBase()+0xdc230, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getStartPos}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::getType}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::getType}))
            m->registerHook(getBase()+0xdc210, extract_virtual(this, (void($GameObject::*)()){&$GameObject::getType}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::groupWasDisabled}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::groupWasDisabled}))
            m->registerHook(getBase()+0x33b110, extract_virtual(this, (void($GameObject::*)()){&$GameObject::groupWasDisabled}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::groupWasEnabled}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::groupWasEnabled}))
            m->registerHook(getBase()+0x33b0f0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::groupWasEnabled}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::hasBeenActivated}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::hasBeenActivated}))
            m->registerHook(getBase()+0x342a80, extract_virtual(this, (void($GameObject::*)()){&$GameObject::hasBeenActivated}));

        if (extract_virtual(&orig, (void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer}) != extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer}))
            m->registerHook(getBase()+0x342a50, extract_virtual(this, (void($GameObject::*)(GameObject*)){&$GameObject::hasBeenActivatedByPlayer}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::hasSecondaryColor}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::hasSecondaryColor}))
            m->registerHook(getBase()+0x342f80, extract_virtual(this, (void($GameObject::*)()){&$GameObject::hasSecondaryColor}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::ignoreEnter}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::ignoreEnter}))
            m->registerHook(getBase()+0x3352a0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::ignoreEnter}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::ignoreFade}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::ignoreFade}))
            m->registerHook(getBase()+0x335290, extract_virtual(this, (void($GameObject::*)()){&$GameObject::ignoreFade}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture}) != extract_virtual(this, (void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture}))
            m->registerHook(getBase()+0x2f56a0, extract_virtual(this, (void($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isBasicTrigger}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isBasicTrigger}))
            m->registerHook(getBase()+0x343d10, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isBasicTrigger}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isColorTrigger}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isColorTrigger}))
            m->registerHook(getBase()+0x343b40, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isColorTrigger}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isFlipX}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isFlipX}))
            m->registerHook(getBase()+0x335a40, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isFlipX}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isFlipY}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isFlipY}))
            m->registerHook(getBase()+0x335a50, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isFlipY}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isSpawnableTrigger}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isSpawnableTrigger}))
            m->registerHook(getBase()+0x343a60, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isSpawnableTrigger}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::isSpecialObject}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::isSpecialObject}))
            m->registerHook(getBase()+0x343c40, extract_virtual(this, (void($GameObject::*)()){&$GameObject::isSpecialObject}));

        if (extract_virtual(&orig, (void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString}) != extract_virtual(this, (void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString}))
            m->registerHook(getBase()+0x33b720, extract_virtual(this, (void($GameObject::*)(std::string, bool)){&$GameObject::objectFromString}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::playShineEffect}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::playShineEffect}))
            m->registerHook(getBase()+0x2fa9d0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::playShineEffect}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::powerOffObject}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::powerOffObject}))
            m->registerHook(getBase()+0x3369c0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::powerOffObject}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::powerOnObject}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::powerOnObject}))
            m->registerHook(getBase()+0x3369a0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::powerOnObject}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::quickUpdatePosition}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::quickUpdatePosition}))
            m->registerHook(getBase()+0x335790, extract_virtual(this, (void($GameObject::*)()){&$GameObject::quickUpdatePosition}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::removeFromGroup}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::removeFromGroup}))
            m->registerHook(getBase()+0x33ada0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::removeFromGroup}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::removeGlow}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::removeGlow}))
            m->registerHook(getBase()+0x2f7f70, extract_virtual(this, (void($GameObject::*)()){&$GameObject::removeGlow}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::resetGroupDisabled}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::resetGroupDisabled}))
            m->registerHook(getBase()+0x2fa7e0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::resetGroupDisabled}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::saveActiveColors}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::saveActiveColors}))
            m->registerHook(getBase()+0x33d250, extract_virtual(this, (void($GameObject::*)()){&$GameObject::saveActiveColors}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject}) != extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject}))
            m->registerHook(getBase()+0x341f90, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B)){&$GameObject::selectObject}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor}) != extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor}))
            m->registerHook(getBase()+0x341f20, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode}))
            m->registerHook(getBase()+0x304fc0, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setDefaultMainColorMode}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition}) != extract_virtual(this, (void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition}))
            m->registerHook(getBase()+0x343a30, extract_virtual(this, (void($GameObject::*)(bool const&)){&$GameObject::setDidUpdateLastPosition}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor}) != extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor}))
            m->registerHook(getBase()+0x341ed0, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor}));

        if (extract_virtual(&orig, (void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity}) != extract_virtual(this, (void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity}))
            m->registerHook(getBase()+0x336200, extract_virtual(this, (void($GameObject::*)(unsigned char)){&$GameObject::setGlowOpacity}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition}) != extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition}))
            m->registerHook(getBase()+0x3439e0, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setLastPosition}));

        if (extract_virtual(&orig, (void($GameObject::*)(int)){&$GameObject::setMainColorMode}) != extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setMainColorMode}))
            m->registerHook(getBase()+0x342e70, extract_virtual(this, (void($GameObject::*)(int)){&$GameObject::setMainColorMode}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor}) != extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor}))
            m->registerHook(getBase()+0x341c90, extract_virtual(this, (void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty}) != extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty}))
            m->registerHook(getBase()+0xdc1e0, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty}));

        if (extract_virtual(&orig, (void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty}) != extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty}))
            m->registerHook(getBase()+0xdc200, extract_virtual(this, (void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition}) != extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition}))
            m->registerHook(getBase()+0x335850, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::setRScale}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScale}))
            m->registerHook(getBase()+0x335e10, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScale}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::setRScaleX}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleX}))
            m->registerHook(getBase()+0x335cb0, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleX}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::setRScaleY}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleY}))
            m->registerHook(getBase()+0x335d60, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::setRScaleY}));

        if (extract_virtual(&orig, (void($GameObject::*)(int const&)){&$GameObject::setSectionIdx}) != extract_virtual(this, (void($GameObject::*)(int const&)){&$GameObject::setSectionIdx}))
            m->registerHook(getBase()+0x343a10, extract_virtual(this, (void($GameObject::*)(int const&)){&$GameObject::setSectionIdx}));

        if (extract_virtual(&orig, (void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos}) != extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos}))
            m->registerHook(getBase()+0x2fa520, extract_virtual(this, (void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos}));

        if (extract_virtual(&orig, (void($GameObject::*)(GameObjectType)){&$GameObject::setType}) != extract_virtual(this, (void($GameObject::*)(GameObjectType)){&$GameObject::setType}))
            m->registerHook(getBase()+0xdc220, extract_virtual(this, (void($GameObject::*)(GameObjectType)){&$GameObject::setType}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::setupCoinArt}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::setupCoinArt}))
            m->registerHook(getBase()+0x337dd0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::setupCoinArt}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::setupCustomSprites}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::setupCustomSprites}))
            m->registerHook(getBase()+0x307f60, extract_virtual(this, (void($GameObject::*)()){&$GameObject::setupCustomSprites}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::slopeFloorTop}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::slopeFloorTop}))
            m->registerHook(getBase()+0x342800, extract_virtual(this, (void($GameObject::*)()){&$GameObject::slopeFloorTop}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::slopeWallLeft}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::slopeWallLeft}))
            m->registerHook(getBase()+0x3427e0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::slopeWallLeft}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::spawnXPosition}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::spawnXPosition}))
            m->registerHook(getBase()+0xdc1b0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::spawnXPosition}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::triggerActivated}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::triggerActivated}))
            m->registerHook(getBase()+0x336990, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::triggerActivated}));

        if (extract_virtual(&orig, (void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject}) != extract_virtual(this, (void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject}))
            m->registerHook(getBase()+0x2fa8f0, extract_virtual(this, (void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::updateCustomScale}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateCustomScale}))
            m->registerHook(getBase()+0x335eb0, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateCustomScale}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateMainColor}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateMainColor}))
            m->registerHook(getBase()+0x343340, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateMainColor}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateOrientedBox}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateOrientedBox}))
            m->registerHook(getBase()+0x342b50, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateOrientedBox}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateSecondaryColor}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateSecondaryColor}))
            m->registerHook(getBase()+0x343740, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateSecondaryColor}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateStartPos}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateStartPos}))
            m->registerHook(getBase()+0x2fa590, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateStartPos}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateStartValues}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateStartValues}))
            m->registerHook(getBase()+0x2fa800, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateStartValues}));

        if (extract_virtual(&orig, (void($GameObject::*)()){&$GameObject::updateState}) != extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateState}))
            m->registerHook(getBase()+0x3369e0, extract_virtual(this, (void($GameObject::*)()){&$GameObject::updateState}));

        if (extract_virtual(&orig, (void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation}) != extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation}))
            m->registerHook(getBase()+0x337f00, extract_virtual(this, (void($GameObject::*)(float)){&$GameObject::updateSyncedAnimation}));
    }
};


class $GameObjectCopy : public $CacBase {
 public:
    $GameObjectCopy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameObjectCopy(bool dont_push) {}
    typedef GameObjectCopy* __thistype;

    virtual void create(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x975a0))(this, p0);
    }

    virtual void resetObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x976a0))(this);
    }

    void apply_hooks() override {
        auto orig = $GameObjectCopy(true);
        if (extract_virtual(&orig, (void($GameObjectCopy::*)(GameObject*)){&$GameObjectCopy::create}) != extract_virtual(this, (void($GameObjectCopy::*)(GameObject*)){&$GameObjectCopy::create}))
            m->registerHook(getBase()+0x975a0, extract_virtual(this, (void($GameObjectCopy::*)(GameObject*)){&$GameObjectCopy::create}));

        if (extract_virtual(&orig, (void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject}) != extract_virtual(this, (void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject}))
            m->registerHook(getBase()+0x976a0, extract_virtual(this, (void($GameObjectCopy::*)()){&$GameObjectCopy::resetObject}));
    }
};


class $GameSoundManager : public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameSoundManager(bool dont_push) {}
    typedef GameSoundManager* __thistype;

    virtual void disableMetering() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d80))(this);
    }

    virtual void enableMetering() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362d00))(this);
    }

    virtual void getMeteringValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362db0))(this);
    }

    virtual void playBackgroundMusic(std::string p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, bool)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
    }

    virtual void playEffect(std::string p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float, float, float)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
    }

    virtual void sharedManager() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3610f0))(this);
    }

    virtual void stopBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
    }

    void apply_hooks() override {
        auto orig = $GameSoundManager(true);
        if (extract_virtual(&orig, (void($GameSoundManager::*)()){&$GameSoundManager::disableMetering}) != extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::disableMetering}))
            m->registerHook(getBase()+0x362d80, extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::disableMetering}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)()){&$GameSoundManager::enableMetering}) != extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::enableMetering}))
            m->registerHook(getBase()+0x362d00, extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::enableMetering}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue}) != extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue}))
            m->registerHook(getBase()+0x362db0, extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::getMeteringValue}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic}) != extract_virtual(this, (void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic}))
            m->registerHook(getBase()+0x362070, extract_virtual(this, (void($GameSoundManager::*)(std::string, bool, bool)){&$GameSoundManager::playBackgroundMusic}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect}) != extract_virtual(this, (void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect}))
            m->registerHook(getBase()+0x3623d0, extract_virtual(this, (void($GameSoundManager::*)(std::string, float, float, float)){&$GameSoundManager::playEffect}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)()){&$GameSoundManager::sharedManager}) != extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::sharedManager}))
            m->registerHook(getBase()+0x3610f0, extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::sharedManager}));

        if (extract_virtual(&orig, (void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic}) != extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic}))
            m->registerHook(getBase()+0x362130, extract_virtual(this, (void($GameSoundManager::*)()){&$GameSoundManager::stopBackgroundMusic}));
    }
};


class $GameStatsManager : public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameStatsManager(bool dont_push) {}
    typedef GameStatsManager* __thistype;

    virtual void awardCurrencyForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43600))(this, p0);
    }

    virtual void awardDiamondsForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43c60))(this, p0);
    }

    virtual void awardSecretKey() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x4b1e0))(this);
    }

    virtual void getSecretCoinKey(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x429f0))(this, p0);
    }

    virtual void getStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d310))(this, p0);
    }

    virtual void hasPendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42730))(this, p0);
    }

    virtual void hasSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x40730))(this, p0);
    }

    virtual void hasUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x427e0))(this, p0);
    }

    virtual void incrementStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
    }

    virtual void incrementStat(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
    }

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x38f20))(this);
    }

    virtual void storePendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42940))(this, p0);
    }

    virtual void storeSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42a10))(this, p0);
    }

    virtual void storeUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42890))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GameStatsManager(true);
        if (extract_virtual(&orig, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel}) != extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel}))
            m->registerHook(getBase()+0x43600, extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardCurrencyForLevel}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel}) != extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel}))
            m->registerHook(getBase()+0x43c60, extract_virtual(this, (void($GameStatsManager::*)(GJGameLevel*)){&$GameStatsManager::awardDiamondsForLevel}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey}) != extract_virtual(this, (void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey}))
            m->registerHook(getBase()+0x4b1e0, extract_virtual(this, (void($GameStatsManager::*)()){&$GameStatsManager::awardSecretKey}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey}))
            m->registerHook(getBase()+0x429f0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getSecretCoinKey}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat}))
            m->registerHook(getBase()+0x3d310, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::getStat}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin}))
            m->registerHook(getBase()+0x42730, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasPendingUserCoin}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin}))
            m->registerHook(getBase()+0x40730, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasSecretCoin}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin}))
            m->registerHook(getBase()+0x427e0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::hasUserCoin}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat}))
            m->registerHook(getBase()+0x3d6d0, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::incrementStat}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat}) != extract_virtual(this, (void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat}))
            m->registerHook(getBase()+0x3d6e0, extract_virtual(this, (void($GameStatsManager::*)(char const*, int)){&$GameStatsManager::incrementStat}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)()){&$GameStatsManager::sharedState}) != extract_virtual(this, (void($GameStatsManager::*)()){&$GameStatsManager::sharedState}))
            m->registerHook(getBase()+0x38f20, extract_virtual(this, (void($GameStatsManager::*)()){&$GameStatsManager::sharedState}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin}))
            m->registerHook(getBase()+0x42940, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storePendingUserCoin}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin}))
            m->registerHook(getBase()+0x42a10, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeSecretCoin}));

        if (extract_virtual(&orig, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin}) != extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin}))
            m->registerHook(getBase()+0x42890, extract_virtual(this, (void($GameStatsManager::*)(char const*)){&$GameStatsManager::storeUserCoin}));
    }
};


class $GameToolbox : public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GameToolbox(bool dont_push) {}
    typedef GameToolbox* __thistype;

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x28bdd0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

    virtual void getRelativeOffset(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x28c060))(this, p0, p1);
    }

    virtual void multipliedColorValue(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x28cb90))(this, p0, p1, p2);
    }

    virtual void stringSetupToDict(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d700))(this, p0, p1);
    }

    virtual void stringSetupToMap(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d4c0))(this, p0, p1);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x28c950))(this, p0, p1);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, float, float, float)>(m->getOriginal(getBase()+0x28c930))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        auto orig = $GameToolbox(true);
        if (extract_virtual(&orig, (void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton}) != extract_virtual(this, (void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton}))
            m->registerHook(getBase()+0x28bdd0, extract_virtual(this, (void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)){&$GameToolbox::createToggleButton}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset}) != extract_virtual(this, (void($GameToolbox::*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset}))
            m->registerHook(getBase()+0x28c060, extract_virtual(this, (void($GameToolbox::*)(GameObject*, cocos2d::CCPoint)){&$GameToolbox::getRelativeOffset}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue}) != extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue}))
            m->registerHook(getBase()+0x28cb90, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)){&$GameToolbox::multipliedColorValue}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict}) != extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict}))
            m->registerHook(getBase()+0x28d700, extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToDict}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap}) != extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap}))
            m->registerHook(getBase()+0x28d4c0, extract_virtual(this, (void($GameToolbox::*)(std::string, char const*)){&$GameToolbox::stringSetupToMap}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor}) != extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor}))
            m->registerHook(getBase()+0x28c950, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)){&$GameToolbox::transformColor}));

        if (extract_virtual(&orig, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor}) != extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor}))
            m->registerHook(getBase()+0x28c930, extract_virtual(this, (void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float)){&$GameToolbox::transformColor}));
    }
};


class $GravityEffectSprite : public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GravityEffectSprite(bool dont_push) {}
    typedef GravityEffectSprite* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d0a0))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80b20))(this);
    }

    virtual void updateSpritesColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $GravityEffectSprite(true);
        if (extract_virtual(&orig, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::create}) != extract_virtual(this, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::create}))
            m->registerHook(getBase()+0x6d0a0, extract_virtual(this, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::create}));

        if (extract_virtual(&orig, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::init}) != extract_virtual(this, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::init}))
            m->registerHook(getBase()+0x80b20, extract_virtual(this, (void($GravityEffectSprite::*)()){&$GravityEffectSprite::init}));

        if (extract_virtual(&orig, (void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor}) != extract_virtual(this, (void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor}))
            m->registerHook(getBase()+0x7ce30, extract_virtual(this, (void($GravityEffectSprite::*)(cocos2d::_ccColor3B)){&$GravityEffectSprite::updateSpritesColor}));
    }
};


class $GroupCommandObject : public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $GroupCommandObject(bool dont_push) {}
    typedef GroupCommandObject* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18b460))(this);
    }

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x16ece0))(this, p0);
    }

    virtual void easeToText(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
    }

    virtual void getEasedAction(cocos2d::CCActionInterval* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, int, float)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
    }

    virtual void runMoveCommand(cocos2d::CCPoint p0, float p1, int p2, float p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, int, float, bool, bool)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runRotateCommand(float p0, float p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, bool)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
    }

    void apply_hooks() override {
        auto orig = $GroupCommandObject(true);
        if (extract_virtual(&orig, (void($GroupCommandObject::*)()){&$GroupCommandObject::create}) != extract_virtual(this, (void($GroupCommandObject::*)()){&$GroupCommandObject::create}))
            m->registerHook(getBase()+0x18b460, extract_virtual(this, (void($GroupCommandObject::*)()){&$GroupCommandObject::create}));

        if (extract_virtual(&orig, (void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString}) != extract_virtual(this, (void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString}))
            m->registerHook(getBase()+0x16ece0, extract_virtual(this, (void($GroupCommandObject::*)(std::string)){&$GroupCommandObject::createFromString}));

        if (extract_virtual(&orig, (void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText}) != extract_virtual(this, (void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText}))
            m->registerHook(getBase()+0x16ecb0, extract_virtual(this, (void($GroupCommandObject::*)(int)){&$GroupCommandObject::easeToText}));

        if (extract_virtual(&orig, (void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction}) != extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction}))
            m->registerHook(getBase()+0x16e7b0, extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float)){&$GroupCommandObject::getEasedAction}));

        if (extract_virtual(&orig, (void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand}) != extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand}))
            m->registerHook(getBase()+0x16e640, extract_virtual(this, (void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool)){&$GroupCommandObject::runMoveCommand}));

        if (extract_virtual(&orig, (void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand}) != extract_virtual(this, (void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand}))
            m->registerHook(getBase()+0x16e8f0, extract_virtual(this, (void($GroupCommandObject::*)(float, float, int, float, bool)){&$GroupCommandObject::runRotateCommand}));
    }
};


class $HardStreak : public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $HardStreak(bool dont_push) {}
    typedef HardStreak* __thistype;

    virtual void addPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x5c950))(this, p0);
    }

    virtual void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c930))(this);
    }

    virtual void resumeStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c210))(this);
    }

    virtual void stopStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x5c8f0))(this);
    }

    void apply_hooks() override {
        auto orig = $HardStreak(true);
        if (extract_virtual(&orig, (void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint}) != extract_virtual(this, (void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint}))
            m->registerHook(getBase()+0x5c950, extract_virtual(this, (void($HardStreak::*)(cocos2d::CCPoint)){&$HardStreak::addPoint}));

        if (extract_virtual(&orig, (void($HardStreak::*)()){&$HardStreak::reset}) != extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::reset}))
            m->registerHook(getBase()+0x5c930, extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::reset}));

        if (extract_virtual(&orig, (void($HardStreak::*)()){&$HardStreak::resumeStroke}) != extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::resumeStroke}))
            m->registerHook(getBase()+0x5c210, extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::resumeStroke}));

        if (extract_virtual(&orig, (void($HardStreak::*)()){&$HardStreak::stopStroke}) != extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::stopStroke}))
            m->registerHook(getBase()+0x5c8f0, extract_virtual(this, (void($HardStreak::*)()){&$HardStreak::stopStroke}));
    }
};


class $InfoLayer : public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $InfoLayer(bool dont_push) {}
    typedef InfoLayer* __thistype;

    virtual void loadPage(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
    }

    virtual void onRefreshComments(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x459b60))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $InfoLayer(true);
        if (extract_virtual(&orig, (void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage}) != extract_virtual(this, (void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage}))
            m->registerHook(getBase()+0x458fb0, extract_virtual(this, (void($InfoLayer::*)(int, bool)){&$InfoLayer::loadPage}));

        if (extract_virtual(&orig, (void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments}) != extract_virtual(this, (void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments}))
            m->registerHook(getBase()+0x459b60, extract_virtual(this, (void($InfoLayer::*)(cocos2d::CCObject*)){&$InfoLayer::onRefreshComments}));
    }
};


class $LabelGameObject : public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LabelGameObject(bool dont_push) {}
    typedef LabelGameObject* __thistype;

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2f5520))(this);
    }

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $LabelGameObject(true);
        if (extract_virtual(&orig, (void($LabelGameObject::*)()){&$LabelGameObject::init}) != extract_virtual(this, (void($LabelGameObject::*)()){&$LabelGameObject::init}))
            m->registerHook(getBase()+0x2f5520, extract_virtual(this, (void($LabelGameObject::*)()){&$LabelGameObject::init}));

        if (extract_virtual(&orig, (void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor}) != extract_virtual(this, (void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor}))
            m->registerHook(getBase()+0xdbca0, extract_virtual(this, (void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor}));
    }
};


class $LevelBrowserLayer : public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LevelBrowserLayer(bool dont_push) {}
    typedef LevelBrowserLayer* __thistype;

    virtual void loadPage(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x253650))(this, p0);
    }

    virtual void scene(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x2511d0))(this, p0);
    }

    virtual void setIDPopupClosed(SetIDPopup* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(getBase()+0x2554f0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $LevelBrowserLayer(true);
        if (extract_virtual(&orig, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage}) != extract_virtual(this, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage}))
            m->registerHook(getBase()+0x253650, extract_virtual(this, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::loadPage}));

        if (extract_virtual(&orig, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene}) != extract_virtual(this, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene}))
            m->registerHook(getBase()+0x2511d0, extract_virtual(this, (void($LevelBrowserLayer::*)(GJSearchObject*)){&$LevelBrowserLayer::scene}));

        if (extract_virtual(&orig, (void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed}) != extract_virtual(this, (void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed}))
            m->registerHook(getBase()+0x2554f0, extract_virtual(this, (void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed}));
    }
};


class $LevelEditorLayer : public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LevelEditorLayer(bool dont_push) {}
    typedef LevelEditorLayer* __thistype;

    virtual void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
    }

    virtual GameObject* addObjectFromString(std::string p0) {
        return reinterpret_cast<GameObject*(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x94640))(this, p0);
    }

    virtual void addSpecial(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x94f30))(this, p0);
    }

    virtual void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0x9dab0))(this, p0, p1, p2);
    }

    virtual void addToRedoList(UndoObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), UndoObject*)>(m->getOriginal(getBase()+0x96f80))(this, p0);
    }

    virtual void addToUndoList(UndoObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), UndoObject*, bool)>(m->getOriginal(getBase()+0x94e20))(this, p0, p1);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x9c590))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
    }

    virtual void create(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x90fb0))(this, p0);
    }

    virtual void createBackground() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x929f0))(this);
    }

    virtual void createGroundLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92840))(this);
    }

    virtual void createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x92230))(this, p0);
    }

    virtual void createObjectsFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa2a70))(this);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xa04e0))(this, p0, p1, p2);
    }

    virtual void getLastObjectX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c860))(this);
    }

    virtual void getLevelString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97790))(this);
    }

    virtual void getNextColorChannel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a610))(this);
    }

    virtual void getNextFreeBlockID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a4e0))(this, p0);
    }

    virtual int getNextFreeGroupID(cocos2d::CCArray* p0) {
        return reinterpret_cast<int(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
    }

    virtual void getNextFreeItemID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a390))(this, p0);
    }

    virtual void getObjectRect(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96240))(this, p0, p1);
    }

    virtual void getRelativeOffset(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x96840))(this, p0);
    }

    virtual void handleAction(bool p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x91010))(this, p0);
    }

    virtual void levelSettingsUpdated() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93f30))(this);
    }

    virtual void objectAtPosition(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x960c0))(this, p0);
    }

    virtual void objectMoved(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x999f0))(this, p0);
    }

    virtual void objectsInRect(cocos2d::CCRect p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, bool)>(m->getOriginal(getBase()+0x95e60))(this, p0, p1);
    }

    virtual void onPlaytest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa06b0))(this);
    }

    virtual void onStopPlaytest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa1780))(this);
    }

    virtual void playMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa13c0))(this);
    }

    virtual void recreateGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9dbf0))(this);
    }

    virtual void redoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
    }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
    }

    virtual void removeAllObjectsOfType(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x96d40))(this, p0);
    }

    virtual void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0x9db60))(this, p0, p1);
    }

    virtual void removeObject(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
    }

    virtual void removeSpecial(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x969c0))(this, p0);
    }

    virtual void resetMovingObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9ddc0))(this);
    }

    virtual void resetObjectVector() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c4b0))(this);
    }

    virtual void resetToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9aa70))(this);
    }

    virtual void resetToggledGroupsAndObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9c3c0))(this);
    }

    virtual void resetUnusedColorChannels() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9a870))(this);
    }

    virtual void rotationForSlopeNearObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x95cd0))(this, p0);
    }

    virtual void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
    }

    virtual void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x90f20))(this, p0);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
    }

    virtual void sortStickyGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92b10))(this);
    }

    virtual void stopTriggersInGroup(int p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
    }

    virtual void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c7d0))(this, p0);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
    }

    virtual void toggleGroupPreview(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
    }

    virtual void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
    }

    virtual void undoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
    }

    virtual void updateBGAndGColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9b9b0))(this);
    }

    virtual void updateBlendValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bc60))(this);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
    }

    virtual void updateEditorMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93b50))(this);
    }

    virtual void updateGameObjectsNew() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9adc0))(this);
    }

    virtual void updateGround(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x93a60))(this, p0);
    }

    virtual void updateGroundWidth() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92af0))(this);
    }

    virtual void updateOptions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x91ed0))(this);
    }

    virtual void updateToggledGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x9bb10))(this);
    }

    virtual void updateVisibility(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x92c70))(this, p0);
    }

    virtual void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x9c800))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $LevelEditorLayer(true);
        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect}) != extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect}))
            m->registerHook(getBase()+0x9b520, extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect}));

        if (extract_virtual(&orig, (GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString}) != extract_virtual(this, (GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString}))
            m->registerHook(getBase()+0x94640, extract_virtual(this, (GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial}))
            m->registerHook(getBase()+0x94f30, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup}))
            m->registerHook(getBase()+0x9dab0, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList}) != extract_virtual(this, (void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList}))
            m->registerHook(getBase()+0x96f80, extract_virtual(this, (void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList}) != extract_virtual(this, (void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList}))
            m->registerHook(getBase()+0x94e20, extract_virtual(this, (void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround}))
            m->registerHook(getBase()+0xa2780, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues}) != extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues}))
            m->registerHook(getBase()+0x9c590, extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions}) != extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions}))
            m->registerHook(getBase()+0x9e620, extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::create}) != extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::create}))
            m->registerHook(getBase()+0x90fb0, extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::create}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground}))
            m->registerHook(getBase()+0x929f0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer}))
            m->registerHook(getBase()+0x92840, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject}) != extract_virtual(this, (void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject}))
            m->registerHook(getBase()+0x957c0, extract_virtual(this, (void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup}) != extract_virtual(this, (void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup}))
            m->registerHook(getBase()+0x92230, extract_virtual(this, (void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString}) != extract_virtual(this, (void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString}))
            m->registerHook(getBase()+0x94730, extract_virtual(this, (void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw}))
            m->registerHook(getBase()+0xa2a70, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity}) != extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity}))
            m->registerHook(getBase()+0xa04e0, extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX}))
            m->registerHook(getBase()+0x9c860, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString}))
            m->registerHook(getBase()+0x97790, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel}))
            m->registerHook(getBase()+0x9a610, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID}) != extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID}))
            m->registerHook(getBase()+0x9a4e0, extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID}));

        if (extract_virtual(&orig, (int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID}) != extract_virtual(this, (int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID}))
            m->registerHook(getBase()+0x9a1b0, extract_virtual(this, (int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID}) != extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID}))
            m->registerHook(getBase()+0x9a390, extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect}))
            m->registerHook(getBase()+0x96240, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset}))
            m->registerHook(getBase()+0x96840, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction}) != extract_virtual(this, (void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction}))
            m->registerHook(getBase()+0x97020, extract_virtual(this, (void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init}) != extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init}))
            m->registerHook(getBase()+0x91010, extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated}))
            m->registerHook(getBase()+0x93f30, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition}) != extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition}))
            m->registerHook(getBase()+0x960c0, extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved}))
            m->registerHook(getBase()+0x999f0, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect}) != extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect}))
            m->registerHook(getBase()+0x95e60, extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest}))
            m->registerHook(getBase()+0xa06b0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest}))
            m->registerHook(getBase()+0xa1780, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic}))
            m->registerHook(getBase()+0xa13c0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups}))
            m->registerHook(getBase()+0x9dbf0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction}))
            m->registerHook(getBase()+0x97750, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects}))
            m->registerHook(getBase()+0x93d80, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType}) != extract_virtual(this, (void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType}))
            m->registerHook(getBase()+0x96d40, extract_virtual(this, (void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup}))
            m->registerHook(getBase()+0x9db60, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject}))
            m->registerHook(getBase()+0x96890, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial}))
            m->registerHook(getBase()+0x969c0, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects}))
            m->registerHook(getBase()+0x9ddc0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector}))
            m->registerHook(getBase()+0x9c4b0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups}))
            m->registerHook(getBase()+0x9aa70, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects}))
            m->registerHook(getBase()+0x9c3c0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels}))
            m->registerHook(getBase()+0x9a870, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject}))
            m->registerHook(getBase()+0x95cd0, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect}) != extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect}))
            m->registerHook(getBase()+0x9bd30, extract_virtual(this, (void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene}) != extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene}))
            m->registerHook(getBase()+0x90f20, extract_virtual(this, (void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart}) != extract_virtual(this, (void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart}))
            m->registerHook(getBase()+0xa0ca0, extract_virtual(this, (void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups}))
            m->registerHook(getBase()+0x92b10, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup}) != extract_virtual(this, (void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup}))
            m->registerHook(getBase()+0x9c030, extract_virtual(this, (void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos}) != extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos}))
            m->registerHook(getBase()+0x9c7d0, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode}) != extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode}))
            m->registerHook(getBase()+0xa0200, extract_virtual(this, (void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview}) != extract_virtual(this, (void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview}))
            m->registerHook(getBase()+0x9bea0, extract_virtual(this, (void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors}) != extract_virtual(this, (void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors}))
            m->registerHook(getBase()+0x9ab50, extract_virtual(this, (void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction}))
            m->registerHook(getBase()+0x97770, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update}) != extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update}))
            m->registerHook(getBase()+0xa1b70, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors}))
            m->registerHook(getBase()+0x9b9b0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues}))
            m->registerHook(getBase()+0x9bc60, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor}) != extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor}))
            m->registerHook(getBase()+0x9c200, extract_virtual(this, (void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround}) != extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround}))
            m->registerHook(getBase()+0xa1a60, extract_virtual(this, (void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode}))
            m->registerHook(getBase()+0x93b50, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew}))
            m->registerHook(getBase()+0x9adc0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround}) != extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround}))
            m->registerHook(getBase()+0x93a60, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth}))
            m->registerHook(getBase()+0x92af0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions}))
            m->registerHook(getBase()+0x91ed0, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups}) != extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups}))
            m->registerHook(getBase()+0x9bb10, extract_virtual(this, (void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility}) != extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility}))
            m->registerHook(getBase()+0x92c70, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility}));

        if (extract_virtual(&orig, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime}) != extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime}))
            m->registerHook(getBase()+0x9c800, extract_virtual(this, (void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime}));
    }
};


class $LevelSettingsLayer : public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LevelSettingsLayer(bool dont_push) {}
    typedef LevelSettingsLayer* __thistype;

    virtual void create(LevelSettingsObject* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa7c30))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $LevelSettingsLayer(true);
        if (extract_virtual(&orig, (void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create}) != extract_virtual(this, (void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create}))
            m->registerHook(getBase()+0xa7c30, extract_virtual(this, (void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*)){&$LevelSettingsLayer::create}));
    }
};


class $LevelSettingsObject : public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LevelSettingsObject(bool dont_push) {}
    typedef LevelSettingsObject* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x92760))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xa5690))(this);
    }

    virtual void objectFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa5810))(this, p0);
    }

    virtual void objectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x945a0))(this, p0);
    }

    virtual void setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $LevelSettingsObject(true);
        if (extract_virtual(&orig, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::create}) != extract_virtual(this, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::create}))
            m->registerHook(getBase()+0x92760, extract_virtual(this, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::create}));

        if (extract_virtual(&orig, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::init}) != extract_virtual(this, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::init}))
            m->registerHook(getBase()+0xa5690, extract_virtual(this, (void($LevelSettingsObject::*)()){&$LevelSettingsObject::init}));

        if (extract_virtual(&orig, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict}) != extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict}))
            m->registerHook(getBase()+0xa5810, extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::objectFromDict}));

        if (extract_virtual(&orig, (void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString}) != extract_virtual(this, (void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString}))
            m->registerHook(getBase()+0x945a0, extract_virtual(this, (void($LevelSettingsObject::*)(std::string)){&$LevelSettingsObject::objectFromString}));

        if (extract_virtual(&orig, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode}) != extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode}))
            m->registerHook(getBase()+0xa6a30, extract_virtual(this, (void($LevelSettingsObject::*)(cocos2d::CCDictionary*)){&$LevelSettingsObject::setupColorsFromLegacyMode}));
    }
};


class $LevelTools : public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LevelTools(bool dont_push) {}
    typedef LevelTools* __thistype;

    virtual void getAudioString(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x293880))(this, p0);
    }

    virtual void verifyLevelIntegrity(std::string p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, int)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
    }

    virtual void xPosForTime(float p0, cocos2d::CCArray* p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCArray*, int)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        auto orig = $LevelTools(true);
        if (extract_virtual(&orig, (void($LevelTools::*)(int)){&$LevelTools::getAudioString}) != extract_virtual(this, (void($LevelTools::*)(int)){&$LevelTools::getAudioString}))
            m->registerHook(getBase()+0x293880, extract_virtual(this, (void($LevelTools::*)(int)){&$LevelTools::getAudioString}));

        if (extract_virtual(&orig, (void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity}) != extract_virtual(this, (void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity}))
            m->registerHook(getBase()+0x294360, extract_virtual(this, (void($LevelTools::*)(std::string, int)){&$LevelTools::verifyLevelIntegrity}));

        if (extract_virtual(&orig, (void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime}) != extract_virtual(this, (void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime}))
            m->registerHook(getBase()+0x293d90, extract_virtual(this, (void($LevelTools::*)(float, cocos2d::CCArray*, int)){&$LevelTools::xPosForTime}));
    }
};


class $LoadingLayer : public $CacBase {
 public:
    $LoadingLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LoadingLayer(bool dont_push) {}
    typedef LoadingLayer* __thistype;

    virtual void loadAssets() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1dfb20))(this);
    }

    void apply_hooks() override {
        auto orig = $LoadingLayer(true);
        if (extract_virtual(&orig, (void($LoadingLayer::*)()){&$LoadingLayer::loadAssets}) != extract_virtual(this, (void($LoadingLayer::*)()){&$LoadingLayer::loadAssets}))
            m->registerHook(getBase()+0x1dfb20, extract_virtual(this, (void($LoadingLayer::*)()){&$LoadingLayer::loadAssets}));
    }
};


class $LocalLevelManager : public $CacBase {
 public:
    $LocalLevelManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $LocalLevelManager(bool dont_push) {}
    typedef LocalLevelManager* __thistype;

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35dd60))(this);
    }

    void apply_hooks() override {
        auto orig = $LocalLevelManager(true);
        if (extract_virtual(&orig, (void($LocalLevelManager::*)()){&$LocalLevelManager::sharedState}) != extract_virtual(this, (void($LocalLevelManager::*)()){&$LocalLevelManager::sharedState}))
            m->registerHook(getBase()+0x35dd60, extract_virtual(this, (void($LocalLevelManager::*)()){&$LocalLevelManager::sharedState}));
    }
};


class $MenuGameLayer : public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $MenuGameLayer(bool dont_push) {}
    typedef MenuGameLayer* __thistype;

    virtual void resetPlayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28fdc0))(this);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $MenuGameLayer(true);
        if (extract_virtual(&orig, (void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer}) != extract_virtual(this, (void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer}))
            m->registerHook(getBase()+0x28fdc0, extract_virtual(this, (void($MenuGameLayer::*)()){&$MenuGameLayer::resetPlayer}));

        if (extract_virtual(&orig, (void($MenuGameLayer::*)(float)){&$MenuGameLayer::update}) != extract_virtual(this, (void($MenuGameLayer::*)(float)){&$MenuGameLayer::update}))
            m->registerHook(getBase()+0x28fa70, extract_virtual(this, (void($MenuGameLayer::*)(float)){&$MenuGameLayer::update}));
    }
};


class $MenuLayer : public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $MenuLayer(bool dont_push) {}
    typedef MenuLayer* __thistype;

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3160))(this);
    }

    virtual void onMoreGames(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
    }

    virtual void onQuit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $MenuLayer(true);
        if (extract_virtual(&orig, (void($MenuLayer::*)()){&$MenuLayer::keyBackClicked}) != extract_virtual(this, (void($MenuLayer::*)()){&$MenuLayer::keyBackClicked}))
            m->registerHook(getBase()+0x1d3160, extract_virtual(this, (void($MenuLayer::*)()){&$MenuLayer::keyBackClicked}));

        if (extract_virtual(&orig, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames}) != extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames}))
            m->registerHook(getBase()+0x1d2ad0, extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames}));

        if (extract_virtual(&orig, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit}) != extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit}))
            m->registerHook(getBase()+0x1d2b40, extract_virtual(this, (void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit}));
    }
};


class $MoreVideoOptionsLayer : public $CacBase {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $MoreVideoOptionsLayer(bool dont_push) {}
    typedef MoreVideoOptionsLayer* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x443c10))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
    }

    void apply_hooks() override {
        auto orig = $MoreVideoOptionsLayer(true);
        if (extract_virtual(&orig, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::create}) != extract_virtual(this, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::create}))
            m->registerHook(getBase()+0x443c10, extract_virtual(this, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::create}));

        if (extract_virtual(&orig, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init}) != extract_virtual(this, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init}))
            m->registerHook(getBase()+0x444150, extract_virtual(this, (void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init}));
    }
};


class $MusicDownloadManager : public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $MusicDownloadManager(bool dont_push) {}
    typedef MusicDownloadManager* __thistype;

    virtual void incrementPriorityForSong(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
    }

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2ee4c0))(this);
    }

    void apply_hooks() override {
        auto orig = $MusicDownloadManager(true);
        if (extract_virtual(&orig, (void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong}) != extract_virtual(this, (void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong}))
            m->registerHook(getBase()+0x2ef750, extract_virtual(this, (void($MusicDownloadManager::*)(int)){&$MusicDownloadManager::incrementPriorityForSong}));

        if (extract_virtual(&orig, (void($MusicDownloadManager::*)()){&$MusicDownloadManager::sharedState}) != extract_virtual(this, (void($MusicDownloadManager::*)()){&$MusicDownloadManager::sharedState}))
            m->registerHook(getBase()+0x2ee4c0, extract_virtual(this, (void($MusicDownloadManager::*)()){&$MusicDownloadManager::sharedState}));
    }
};


class $OBB2D : public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $OBB2D(bool dont_push) {}
    typedef OBB2D* __thistype;

    virtual void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
    }

    virtual void create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a890))(this, p0, p1, p2, p3);
    }

    virtual void getBoundingRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35b2b0))(this);
    }

    virtual void overlaps(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0a0))(this, p0);
    }

    virtual void overlaps1Way(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $OBB2D(true);
        if (extract_virtual(&orig, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter}) != extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter}))
            m->registerHook(getBase()+0x35a9c0, extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter}));

        if (extract_virtual(&orig, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create}) != extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create}))
            m->registerHook(getBase()+0x35a890, extract_virtual(this, (void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create}));

        if (extract_virtual(&orig, (void($OBB2D::*)()){&$OBB2D::getBoundingRect}) != extract_virtual(this, (void($OBB2D::*)()){&$OBB2D::getBoundingRect}))
            m->registerHook(getBase()+0x35b2b0, extract_virtual(this, (void($OBB2D::*)()){&$OBB2D::getBoundingRect}));

        if (extract_virtual(&orig, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps}) != extract_virtual(this, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps}))
            m->registerHook(getBase()+0x35b0a0, extract_virtual(this, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps}));

        if (extract_virtual(&orig, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way}) != extract_virtual(this, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way}))
            m->registerHook(getBase()+0x35b0d0, extract_virtual(this, (void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way}));
    }
};


class $ObjectToolbox : public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ObjectToolbox(bool dont_push) {}
    typedef ObjectToolbox* __thistype;

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2d80))(this);
    }

    virtual c_string intKeyToFrame(int p0) {
        return reinterpret_cast<c_string(*)(decltype(this), int)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
    }

    virtual void sharedState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x3b2bc0))(this);
    }

    void apply_hooks() override {
        auto orig = $ObjectToolbox(true);
        if (extract_virtual(&orig, (void($ObjectToolbox::*)()){&$ObjectToolbox::init}) != extract_virtual(this, (void($ObjectToolbox::*)()){&$ObjectToolbox::init}))
            m->registerHook(getBase()+0x3b2d80, extract_virtual(this, (void($ObjectToolbox::*)()){&$ObjectToolbox::init}));

        if (extract_virtual(&orig, (c_string($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame}) != extract_virtual(this, (c_string($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame}))
            m->registerHook(getBase()+0x4173b0, extract_virtual(this, (c_string($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame}));

        if (extract_virtual(&orig, (void($ObjectToolbox::*)()){&$ObjectToolbox::sharedState}) != extract_virtual(this, (void($ObjectToolbox::*)()){&$ObjectToolbox::sharedState}))
            m->registerHook(getBase()+0x3b2bc0, extract_virtual(this, (void($ObjectToolbox::*)()){&$ObjectToolbox::sharedState}));
    }
};


class $OpacityEffectAction : public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $OpacityEffectAction(bool dont_push) {}
    typedef OpacityEffectAction* __thistype;

    virtual OpacityEffectAction* create(float p0, float p1, float p2, int p3) {
        return reinterpret_cast<OpacityEffectAction*(*)(decltype(this), float, float, float, int)>(m->getOriginal(getBase()+0x1789f0))(this, p0, p1, p2, p3);
    }

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x178c10))(this, p0);
    }

    virtual void init(float p0, float p1, float p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, int)>(m->getOriginal(getBase()+0x178b00))(this, p0, p1, p2, p3);
    }

    virtual void step(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x178b90))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $OpacityEffectAction(true);
        if (extract_virtual(&orig, (OpacityEffectAction*($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::create}) != extract_virtual(this, (OpacityEffectAction*($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::create}))
            m->registerHook(getBase()+0x1789f0, extract_virtual(this, (OpacityEffectAction*($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::create}));

        if (extract_virtual(&orig, (void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString}) != extract_virtual(this, (void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString}))
            m->registerHook(getBase()+0x178c10, extract_virtual(this, (void($OpacityEffectAction::*)(std::string)){&$OpacityEffectAction::createFromString}));

        if (extract_virtual(&orig, (void($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init}) != extract_virtual(this, (void($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init}))
            m->registerHook(getBase()+0x178b00, extract_virtual(this, (void($OpacityEffectAction::*)(float, float, float, int)){&$OpacityEffectAction::init}));

        if (extract_virtual(&orig, (void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step}) != extract_virtual(this, (void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step}))
            m->registerHook(getBase()+0x178b90, extract_virtual(this, (void($OpacityEffectAction::*)(float)){&$OpacityEffectAction::step}));
    }
};


class $PauseLayer : public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PauseLayer(bool dont_push) {}
    typedef PauseLayer* __thistype;

    virtual void create(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x20b1e0))(this, p0);
    }

    virtual void onEdit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x20c630))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $PauseLayer(true);
        if (extract_virtual(&orig, (void($PauseLayer::*)(bool)){&$PauseLayer::create}) != extract_virtual(this, (void($PauseLayer::*)(bool)){&$PauseLayer::create}))
            m->registerHook(getBase()+0x20b1e0, extract_virtual(this, (void($PauseLayer::*)(bool)){&$PauseLayer::create}));

        if (extract_virtual(&orig, (void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit}) != extract_virtual(this, (void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit}))
            m->registerHook(getBase()+0x20c630, extract_virtual(this, (void($PauseLayer::*)(cocos2d::CCObject*)){&$PauseLayer::onEdit}));
    }
};


class $PlatformToolbox : public $CacBase {
 public:
    $PlatformToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PlatformToolbox(bool dont_push) {}
    typedef PlatformToolbox* __thistype;

    virtual void hideCursor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c340))(this);
    }

    virtual void showCursor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27c360))(this);
    }

    void apply_hooks() override {
        auto orig = $PlatformToolbox(true);
        if (extract_virtual(&orig, (void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor}) != extract_virtual(this, (void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor}))
            m->registerHook(getBase()+0x27c340, extract_virtual(this, (void($PlatformToolbox::*)()){&$PlatformToolbox::hideCursor}));

        if (extract_virtual(&orig, (void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor}) != extract_virtual(this, (void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor}))
            m->registerHook(getBase()+0x27c360, extract_virtual(this, (void($PlatformToolbox::*)()){&$PlatformToolbox::showCursor}));
    }
};


class $PlayLayer : public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PlayLayer(bool dont_push) {}
    typedef PlayLayer* __thistype;

    virtual void addCircle(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
    }

    virtual void addObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x70e50))(this, p0);
    }

    virtual void addToGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77680))(this, p0);
    }

    virtual void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
    }

    virtual void animateInGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
    }

    virtual void animateOutGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6f350))(this, p0);
    }

    virtual void animateOutGroundFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7de80))(this);
    }

    virtual void applyEnterEffect(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c310))(this, p0);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void cameraMoveX(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
    }

    virtual void cameraMoveY(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
    }

    virtual void circleWaveWillBeRemoved(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e110))(this, p0);
    }

    virtual void claimParticle(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
    }

    virtual void clearPickedUpItems() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cfa0))(this);
    }

    virtual void colorObject(int p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
    }

    virtual void commitJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x737e0))(this);
    }

    virtual void create(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b590))(this, p0);
    }

    virtual void createCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e470))(this);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x6d130))(this, p0);
    }

    virtual void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
    }

    virtual void currencyWillExit(CurrencyRewardLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(getBase()+0x7e070))(this, p0);
    }

    virtual void delayedResetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e050))(this);
    }

    virtual void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
    }

    virtual void dialogClosed(DialogLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d160))(this);
    }

    virtual void enterDualMode(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
    }

    virtual void exitAirMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7dd40))(this);
    }

    virtual void exitBirdMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
    }

    virtual void exitDartMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
    }

    virtual void exitFlyMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
    }

    virtual void exitRobotMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de20))(this, p0);
    }

    virtual void exitRollMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de60))(this, p0);
    }

    virtual void exitSpiderMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de40))(this, p0);
    }

    virtual void flipFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e150))(this);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
    }

    virtual void flipObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76130))(this);
    }

    virtual void fullReset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f8e0))(this);
    }

    virtual void getLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f840))(this);
    }

    virtual void getMaxPortalY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b4e0))(this);
    }

    virtual void getMinPortalY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7b550))(this);
    }

    virtual void getObjectsState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e9d0))(this);
    }

    virtual void getOtherPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
    }

    virtual void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
    }

    virtual void getParticleKey2(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x767b0))(this, p0);
    }

    virtual void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
    }

    virtual void getTempMilliTime() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x778e0))(this);
    }

    virtual void gravityEffectFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7cec0))(this);
    }

    virtual void hasItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
    }

    virtual void hasUniqueCoin(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77510))(this, p0);
    }

    virtual void incrementJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ff40))(this);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
    }

    virtual void isFlipping() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x76100))(this);
    }

    virtual void levelComplete() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72b80))(this);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
    }

    virtual void loadDefaultColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ef30))(this);
    }

    virtual void loadFromCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7f000))(this, p0);
    }

    virtual void loadLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7efc0))(this);
    }

    virtual void loadSavedObjectsState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
    }

    virtual void markCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7ef60))(this);
    }

    virtual void moveCameraToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x7c980))(this, p0);
    }

    virtual void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x806e0))(this);
    }

    virtual void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80710))(this);
    }

    virtual void onQuit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72710))(this);
    }

    virtual void optimizeColorGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dad0))(this);
    }

    virtual void optimizeOpacityGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dc20))(this);
    }

    virtual void optimizeSaveRequiredGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6dd70))(this);
    }

    virtual void pauseGame(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x802d0))(this, p0);
    }

    virtual void pickupItem(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
    }

    virtual void playAnimationCommand(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
    }

    virtual void playEndAnimationToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x759a0))(this, p0);
    }

    virtual void playExitDualEffect(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
    }

    virtual void playFlashEffect(float p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
    }

    virtual void playGravityEffect(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
    }

    virtual void playSpeedParticle(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77030))(this, p0);
    }

    virtual void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
    }

    virtual void prepareSpawnObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fc00))(this);
    }

    virtual void processItems() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x735c0))(this);
    }

    virtual void processLoadedMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a7c0))(this);
    }

    virtual void recordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
    }

    virtual void registerActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77620))(this, p0);
    }

    virtual void registerStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777b0))(this, p0);
    }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x727b0))(this);
    }

    virtual void removeFromGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77750))(this, p0);
    }

    virtual void removeLastCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7f870))(this);
    }

    virtual void removePlayer2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d630))(this);
    }

    virtual void resetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
    }

    virtual void resume() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80480))(this);
    }

    virtual void resumeAndRestart() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x80400))(this);
    }

    virtual void saveRecordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
    }

    virtual void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b500))(this, p0);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0x6f560))(this, p0);
    }

    virtual void setupReplay(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
    }

    virtual void shakeCamera(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x771b0))(this, p0);
    }

    virtual void showCompleteEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x738e0))(this);
    }

    virtual void showCompleteText() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73be0))(this);
    }

    virtual void showEndLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74450))(this);
    }

    virtual void showHint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7deb0))(this);
    }

    virtual void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void showRetryLayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ba0))(this);
    }

    virtual void showTwoPlayerGuide() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6df00))(this);
    }

    virtual void sortGroups() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d9e0))(this);
    }

    virtual void spawnCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x73820))(this);
    }

    virtual void spawnFirework() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x74200))(this);
    }

    virtual void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
    }

    virtual void spawnPlayer2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7d170))(this);
    }

    virtual void startGame() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x726b0))(this);
    }

    virtual void startMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x72910))(this);
    }

    virtual void startRecording() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fec0))(this);
    }

    virtual void startRecordingDelayed() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fed0))(this);
    }

    virtual void stopCameraShake() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75900))(this);
    }

    virtual void stopRecording() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6d090))(this);
    }

    virtual void storeCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
    }

    virtual void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
    }

    virtual void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
    }

    virtual void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
    }

    virtual void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
    }

    virtual void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d120))(this, p0);
    }

    virtual void timeForXPos2(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
    }

    virtual void toggleBGEffectVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
    }

    virtual void toggleFlipped(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
    }

    virtual void toggleGhostEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
    }

    virtual void toggleGlitter(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x70e00))(this, p0);
    }

    virtual void togglePracticeMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
    }

    virtual void toggleProgressbar() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6eeb0))(this);
    }

    virtual void tryStartRecord() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fe00))(this);
    }

    virtual void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
    }

    virtual void unregisterActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77660))(this, p0);
    }

    virtual void unregisterStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777f0))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77900))(this, p0);
    }

    virtual void updateAttempts() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcd0))(this);
    }

    virtual void updateCamera(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
    }

    virtual void updateEffectPositions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a6d0))(this);
    }

    virtual void updateLevelColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6f1e0))(this);
    }

    virtual void updateMoveObjectsLastPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7a720))(this);
    }

    virtual void updateProgressbar() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6ed70))(this);
    }

    virtual void updateReplay(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x78b60))(this, p0);
    }

    virtual void updateTimeMod(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
    }

    virtual void updateVisibility() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6fb90))(this);
    }

    virtual void vfDChk() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7fcb0))(this);
    }

    virtual void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x75ef0))(this);
    }

    virtual void visitWithColorFlash() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x761f0))(this);
    }

    virtual void willSwitchToMode(int p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
    }

    virtual void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d140))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $PlayLayer(true);
        if (extract_virtual(&orig, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle}) != extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle}))
            m->registerHook(getBase()+0x7e0f0, extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject}))
            m->registerHook(getBase()+0x70e50, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld}))
            m->registerHook(getBase()+0x77680, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects}))
            m->registerHook(getBase()+0x7cfc0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround}))
            m->registerHook(getBase()+0x7d710, extract_virtual(this, (void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround}))
            m->registerHook(getBase()+0x7d9d0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround}))
            m->registerHook(getBase()+0x6f350, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished}))
            m->registerHook(getBase()+0x7de80, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect}))
            m->registerHook(getBase()+0x7c310, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues}) != extract_virtual(this, (void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues}))
            m->registerHook(getBase()+0x7aa10, extract_virtual(this, (void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX}) != extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX}))
            m->registerHook(getBase()+0x7cbe0, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY}) != extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY}))
            m->registerHook(getBase()+0x7cc60, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions}))
            m->registerHook(getBase()+0x78c90, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved}) != extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved}))
            m->registerHook(getBase()+0x7e110, extract_virtual(this, (void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle}) != extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle}))
            m->registerHook(getBase()+0x76ba0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems}))
            m->registerHook(getBase()+0x7cfa0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject}) != extract_virtual(this, (void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject}))
            m->registerHook(getBase()+0x77810, extract_virtual(this, (void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::commitJumps}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::commitJumps}))
            m->registerHook(getBase()+0x737e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::commitJumps}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::create}) != extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::create}))
            m->registerHook(getBase()+0x6b590, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::create}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::createCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::createCheckpoint}))
            m->registerHook(getBase()+0x7e470, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::createCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup}) != extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup}))
            m->registerHook(getBase()+0x6d130, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle}) != extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle}))
            m->registerHook(getBase()+0x76800, extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit}) != extract_virtual(this, (void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit}))
            m->registerHook(getBase()+0x7e070, extract_virtual(this, (void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel}))
            m->registerHook(getBase()+0x7e050, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer}))
            m->registerHook(getBase()+0x7ab80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed}) != extract_virtual(this, (void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed}))
            m->registerHook(getBase()+0x7e0b0, extract_virtual(this, (void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::draw}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::draw}))
            m->registerHook(getBase()+0x7d160, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::draw}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode}))
            m->registerHook(getBase()+0x7d6a0, extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::exitAirMode}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::exitAirMode}))
            m->registerHook(getBase()+0x7dd40, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::exitAirMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode}))
            m->registerHook(getBase()+0x7dd80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode}))
            m->registerHook(getBase()+0x7ddd0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode}))
            m->registerHook(getBase()+0x7dcf0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode}))
            m->registerHook(getBase()+0x7de20, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode}))
            m->registerHook(getBase()+0x7de60, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode}))
            m->registerHook(getBase()+0x7de40, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::flipFinished}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::flipFinished}))
            m->registerHook(getBase()+0x7e150, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::flipFinished}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity}))
            m->registerHook(getBase()+0x7cd10, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::flipObjects}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::flipObjects}))
            m->registerHook(getBase()+0x76130, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::flipObjects}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::fullReset}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::fullReset}))
            m->registerHook(getBase()+0x7f8e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::fullReset}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint}))
            m->registerHook(getBase()+0x7f840, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY}))
            m->registerHook(getBase()+0x7b4e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::getMinPortalY}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getMinPortalY}))
            m->registerHook(getBase()+0x7b550, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getMinPortalY}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::getObjectsState}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getObjectsState}))
            m->registerHook(getBase()+0x7e9d0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getObjectsState}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer}))
            m->registerHook(getBase()+0x7dcc0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey}) != extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey}))
            m->registerHook(getBase()+0x764d0, extract_virtual(this, (void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2}) != extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2}))
            m->registerHook(getBase()+0x767b0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod}))
            m->registerHook(getBase()+0x7c2a0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime}))
            m->registerHook(getBase()+0x778e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished}))
            m->registerHook(getBase()+0x7cec0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int)){&$PlayLayer::hasItem}) != extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::hasItem}))
            m->registerHook(getBase()+0x7cee0, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::hasItem}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin}))
            m->registerHook(getBase()+0x77510, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::incrementJumps}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::incrementJumps}))
            m->registerHook(getBase()+0x7ff40, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::incrementJumps}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init}) != extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init}))
            m->registerHook(getBase()+0x6b5f0, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::isFlipping}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::isFlipping}))
            m->registerHook(getBase()+0x76100, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::isFlipping}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::levelComplete}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::levelComplete}))
            m->registerHook(getBase()+0x72b80, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::levelComplete}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash}))
            m->registerHook(getBase()+0x75cc0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash}))
            m->registerHook(getBase()+0x75bf0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors}))
            m->registerHook(getBase()+0x6ef30, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint}))
            m->registerHook(getBase()+0x7f000, extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint}))
            m->registerHook(getBase()+0x7efc0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState}) != extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState}))
            m->registerHook(getBase()+0x7f3d0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::markCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::markCheckpoint}))
            m->registerHook(getBase()+0x7ef60, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::markCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos}))
            m->registerHook(getBase()+0x7c980, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish}))
            m->registerHook(getBase()+0x806e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::onExit}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onExit}))
            m->registerHook(getBase()+0x80710, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onExit}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::onQuit}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onQuit}))
            m->registerHook(getBase()+0x72710, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::onQuit}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups}))
            m->registerHook(getBase()+0x6dad0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups}))
            m->registerHook(getBase()+0x6dc20, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups}))
            m->registerHook(getBase()+0x6dd70, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame}))
            m->registerHook(getBase()+0x802d0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem}))
            m->registerHook(getBase()+0x7c1d0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand}) != extract_virtual(this, (void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand}))
            m->registerHook(getBase()+0x75930, extract_virtual(this, (void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos}))
            m->registerHook(getBase()+0x759a0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect}))
            m->registerHook(getBase()+0x7d1d0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect}) != extract_virtual(this, (void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect}))
            m->registerHook(getBase()+0x75e50, extract_virtual(this, (void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect}))
            m->registerHook(getBase()+0x7b5a0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle}))
            m->registerHook(getBase()+0x77030, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode}))
            m->registerHook(getBase()+0x7b820, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects}))
            m->registerHook(getBase()+0x7fc00, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::processItems}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::processItems}))
            m->registerHook(getBase()+0x735c0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::processItems}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions}))
            m->registerHook(getBase()+0x7a7c0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction}) != extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction}))
            m->registerHook(getBase()+0x7e190, extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject}))
            m->registerHook(getBase()+0x77620, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject}))
            m->registerHook(getBase()+0x777b0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::removeAllObjects}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removeAllObjects}))
            m->registerHook(getBase()+0x727b0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removeAllObjects}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld}))
            m->registerHook(getBase()+0x77750, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint}))
            m->registerHook(getBase()+0x7f870, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::removePlayer2}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removePlayer2}))
            m->registerHook(getBase()+0x7d630, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::removePlayer2}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::resetLevel}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resetLevel}))
            m->registerHook(getBase()+0x71c50, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resetLevel}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::resume}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resume}))
            m->registerHook(getBase()+0x80480, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resume}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart}))
            m->registerHook(getBase()+0x80400, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction}) != extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction}))
            m->registerHook(getBase()+0x78750, extract_virtual(this, (void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene}) != extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene}))
            m->registerHook(getBase()+0x6b500, extract_virtual(this, (void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart}) != extract_virtual(this, (void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart}))
            m->registerHook(getBase()+0x6f560, extract_virtual(this, (void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay}) != extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay}))
            m->registerHook(getBase()+0x7e1e0, extract_virtual(this, (void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera}) != extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera}))
            m->registerHook(getBase()+0x744a0, extract_virtual(this, (void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend}) != extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend}))
            m->registerHook(getBase()+0x771b0, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect}))
            m->registerHook(getBase()+0x738e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showCompleteText}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showCompleteText}))
            m->registerHook(getBase()+0x73be0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showCompleteText}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showEndLayer}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showEndLayer}))
            m->registerHook(getBase()+0x74450, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showEndLayer}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showHint}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showHint}))
            m->registerHook(getBase()+0x7deb0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showHint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest}) != extract_virtual(this, (void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest}))
            m->registerHook(getBase()+0x74580, extract_virtual(this, (void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showRetryLayer}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showRetryLayer}))
            m->registerHook(getBase()+0x75ba0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showRetryLayer}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide}))
            m->registerHook(getBase()+0x6df00, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::sortGroups}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::sortGroups}))
            m->registerHook(getBase()+0x6d9e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::sortGroups}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::spawnCircle}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnCircle}))
            m->registerHook(getBase()+0x73820, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnCircle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::spawnFirework}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnFirework}))
            m->registerHook(getBase()+0x74200, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnFirework}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle}) != extract_virtual(this, (void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle}))
            m->registerHook(getBase()+0x76330, extract_virtual(this, (void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2}))
            m->registerHook(getBase()+0x7d170, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::startGame}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startGame}))
            m->registerHook(getBase()+0x726b0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startGame}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::startMusic}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startMusic}))
            m->registerHook(getBase()+0x72910, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startMusic}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::startRecording}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startRecording}))
            m->registerHook(getBase()+0x7fec0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startRecording}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed}))
            m->registerHook(getBase()+0x7fed0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::stopCameraShake}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::stopCameraShake}))
            m->registerHook(getBase()+0x75900, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::stopCameraShake}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::stopRecording}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::stopRecording}))
            m->registerHook(getBase()+0x6d090, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::stopRecording}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint}) != extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint}))
            m->registerHook(getBase()+0x7ef10, extract_virtual(this, (void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode}))
            m->registerHook(getBase()+0x7baf0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode}))
            m->registerHook(getBase()+0x7bc80, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode}))
            m->registerHook(getBase()+0x7bbe0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode}))
            m->registerHook(getBase()+0x7bd20, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos}))
            m->registerHook(getBase()+0x7d120, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2}) != extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2}))
            m->registerHook(getBase()+0x293eb0, extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility}))
            m->registerHook(getBase()+0x7fe80, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode}))
            m->registerHook(getBase()+0x7bf90, extract_virtual(this, (void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped}) != extract_virtual(this, (void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped}))
            m->registerHook(getBase()+0x7bdc0, extract_virtual(this, (void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect}) != extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect}))
            m->registerHook(getBase()+0x7fe40, extract_virtual(this, (void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter}))
            m->registerHook(getBase()+0x70e00, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode}) != extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode}))
            m->registerHook(getBase()+0x7f9e0, extract_virtual(this, (void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar}))
            m->registerHook(getBase()+0x6eeb0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::tryStartRecord}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::tryStartRecord}))
            m->registerHook(getBase()+0x7fe00, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::tryStartRecord}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle}) != extract_virtual(this, (void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle}))
            m->registerHook(getBase()+0x76e00, extract_virtual(this, (void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject}))
            m->registerHook(getBase()+0x77660, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject}) != extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject}))
            m->registerHook(getBase()+0x777f0, extract_virtual(this, (void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::update}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::update}))
            m->registerHook(getBase()+0x77900, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::update}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateAttempts}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateAttempts}))
            m->registerHook(getBase()+0x7fcd0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateAttempts}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::updateCamera}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateCamera}))
            m->registerHook(getBase()+0x6e2b0, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateCamera}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor}) != extract_virtual(this, (void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor}))
            m->registerHook(getBase()+0x7c7f0, extract_virtual(this, (void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround}) != extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround}))
            m->registerHook(getBase()+0x7caa0, extract_virtual(this, (void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions}))
            m->registerHook(getBase()+0x7a6d0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateLevelColors}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateLevelColors}))
            m->registerHook(getBase()+0x6f1e0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateLevelColors}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition}))
            m->registerHook(getBase()+0x7a720, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateProgressbar}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateProgressbar}))
            m->registerHook(getBase()+0x6ed70, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateProgressbar}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::updateReplay}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateReplay}))
            m->registerHook(getBase()+0x78b60, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::updateReplay}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod}) != extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod}))
            m->registerHook(getBase()+0x786f0, extract_virtual(this, (void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction}) != extract_virtual(this, (void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction}))
            m->registerHook(getBase()+0x7ffb0, extract_virtual(this, (void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::updateVisibility}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateVisibility}))
            m->registerHook(getBase()+0x6fb90, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::updateVisibility}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::vfDChk}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::vfDChk}))
            m->registerHook(getBase()+0x7fcb0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::vfDChk}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::visit}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::visit}))
            m->registerHook(getBase()+0x75ef0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::visit}));

        if (extract_virtual(&orig, (void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash}) != extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash}))
            m->registerHook(getBase()+0x761f0, extract_virtual(this, (void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode}) != extract_virtual(this, (void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode}))
            m->registerHook(getBase()+0x7b9e0, extract_virtual(this, (void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode}));

        if (extract_virtual(&orig, (void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime}) != extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime}))
            m->registerHook(getBase()+0x7d140, extract_virtual(this, (void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime}));
    }
};


class $PlayerCheckpoint : public $CacBase {
 public:
    $PlayerCheckpoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PlayerCheckpoint(bool dont_push) {}
    typedef PlayerCheckpoint* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x7e8c0))(this);
    }

    void apply_hooks() override {
        auto orig = $PlayerCheckpoint(true);
        if (extract_virtual(&orig, (void($PlayerCheckpoint::*)()){&$PlayerCheckpoint::create}) != extract_virtual(this, (void($PlayerCheckpoint::*)()){&$PlayerCheckpoint::create}))
            m->registerHook(getBase()+0x7e8c0, extract_virtual(this, (void($PlayerCheckpoint::*)()){&$PlayerCheckpoint::create}));
    }
};


class $PlayerObject : public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PlayerObject(bool dont_push) {}
    typedef PlayerObject* __thistype;

    virtual void activateStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21aef0))(this);
    }

    virtual void addAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
    }

    virtual void addToTouchedRings(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22b800))(this, p0);
    }

    virtual void animationFinished(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
    }

    virtual void boostPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
    }

    virtual void bumpPlayer(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
    }

    virtual void buttonDown(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
    }

    virtual void checkSnapJumpToObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
    }

    virtual void collidedWithObject(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
    }

    virtual void collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
    }

    virtual void collidedWithSlope(float p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, bool)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
    }

    virtual void convertToClosestRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21c860))(this, p0);
    }

    virtual void copyAttributes(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
    }

    virtual void create(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x217260))(this, p0, p1, p2);
    }

    virtual void deactivateParticle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a540))(this);
    }

    virtual void deactivateStreak(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218b30))(this, p0);
    }

    virtual void fadeOutStreak2(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x225890))(this, p0);
    }

    virtual void flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
    }

    virtual void flipGravity(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
    }

    virtual void flipMod() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4c0))(this);
    }

    virtual void getActiveMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b950))(this);
    }

    virtual void getModifiedSlopeYVel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21bff0))(this);
    }

    virtual void getOldPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a830))(this, p0);
    }

    virtual void getOrientedBox() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dee0))(this);
    }

    virtual void getRealPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d5f0))(this);
    }

    virtual void getSecondColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cee0))(this);
    }

    virtual void gravityDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e930))(this);
    }

    virtual void gravityUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e900))(this);
    }

    virtual void hardFlipGravity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b860))(this);
    }

    virtual void hitGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x220a30))(this, p0);
    }

    virtual void incrementJumps() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c050))(this);
    }

    virtual void init(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
    }

    virtual void isBoostValid(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d650))(this, p0);
    }

    virtual void isFlying() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a4e0))(this);
    }

    virtual void isSafeFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
    }

    virtual void isSafeMode(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
    }

    virtual void isSafeSpiderFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221be0))(this, p0);
    }

    virtual void levelFlipFinished() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b060))(this);
    }

    virtual void levelFlipping() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a510))(this);
    }

    virtual void levelWillFlip() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21b020))(this);
    }

    virtual void loadFromCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e420))(this, p0);
    }

    virtual void lockPlayer() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d680))(this);
    }

    virtual void logValues() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x221220))(this);
    }

    virtual void modeDidChange() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bfd0))(this);
    }

    virtual void placeStreakPoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21af90))(this);
    }

    virtual void playBurstEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c780))(this);
    }

    virtual void playDeathEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225930))(this);
    }

    virtual void playDynamicSpiderRun() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222ec0))(this);
    }

    virtual void playerDestroyed(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
    }

    virtual void playerIsFalling() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c730))(this);
    }

    virtual void playerTeleported() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b840))(this);
    }

    virtual void playingEndEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22d7e0))(this);
    }

    virtual void postCollision(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
    }

    virtual void preCollision() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ccc0))(this);
    }

    virtual void preSlopeCollision(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
    }

    virtual void propellPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
    }

    virtual void pushButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
    }

    virtual void pushDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbd0))(this);
    }

    virtual void pushPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
    }

    virtual void releaseButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
    }

    virtual void removeAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218ac0))(this);
    }

    virtual void removePendingCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2237b0))(this);
    }

    virtual void resetAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21adb0))(this);
    }

    virtual void resetCollisionLog() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cc20))(this);
    }

    virtual void resetObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223170))(this);
    }

    virtual void resetPlayerIcon() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22be00))(this);
    }

    virtual void resetStateVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x223760))(this);
    }

    virtual void resetStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21ae10))(this);
    }

    virtual void ringJump(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
    }

    virtual void runBallRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
    }

    virtual void runBallRotation2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21cb10))(this);
    }

    virtual void runNormalRotation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21c960))(this);
    }

    virtual void runRotateAction(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c570))(this, p0);
    }

    virtual void saveToCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
    }

    virtual void setFlipX(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e720))(this, p0);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x22d400))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e870))(this, p0);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e830))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x219610))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
    }

    virtual void setupStreak() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x218720))(this);
    }

    virtual void spawnCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x225480))(this);
    }

    virtual void spawnCircle2() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2252a0))(this);
    }

    virtual void spawnDualCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2255c0))(this);
    }

    virtual void spawnFromPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
    }

    virtual void spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
    }

    virtual void spawnScaleCircle() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2251b0))(this);
    }

    virtual void specialGroundHit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22dbf0))(this);
    }

    virtual void speedDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e970))(this);
    }

    virtual void speedUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e950))(this);
    }

    virtual void spiderTestJump(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21b160))(this, p0);
    }

    virtual void startDashing(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x221d70))(this, p0);
    }

    virtual void stopBurstEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22c680))(this);
    }

    virtual void stopDashing() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222990))(this);
    }

    virtual void stopRotation(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c830))(this, p0);
    }

    virtual void storeCollision(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
    }

    virtual void switchedToMode(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
    }

    virtual void testForMoving(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
    }

    virtual void toggleBirdMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224070))(this, p0);
    }

    virtual void toggleDartMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
    }

    virtual void toggleFlyMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223820))(this, p0);
    }

    virtual void toggleGhostEffect(GhostType p0) {
        return reinterpret_cast<void(*)(decltype(this), GhostType)>(m->getOriginal(getBase()+0x225000))(this, p0);
    }

    virtual void togglePlayerScale(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
    }

    virtual void toggleRobotMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223c70))(this, p0);
    }

    virtual void toggleRollMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223b20))(this, p0);
    }

    virtual void toggleSpiderMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224830))(this, p0);
    }

    virtual void toggleVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
    }

    virtual void touchedObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22e660))(this, p0);
    }

    virtual void tryPlaceCheckpoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a950))(this);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
    }

    virtual void updateCheckpointMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218980))(this, p0);
    }

    virtual void updateCheckpointTest() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a890))(this);
    }

    virtual void updateCollide(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
    }

    virtual void updateCollideBottom(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
    }

    virtual void updateCollideTop(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
    }

    virtual void updateDashAnimation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a570))(this);
    }

    virtual void updateDashArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x222520))(this);
    }

    virtual void updateGlowColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22cf10))(this);
    }

    virtual void updateJump(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x219680))(this, p0);
    }

    virtual void updateJumpVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a740))(this);
    }

    virtual void updatePlayerBirdFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
    }

    virtual void updatePlayerDartFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c260))(this, p0);
    }

    virtual void updatePlayerFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c470))(this, p0);
    }

    virtual void updatePlayerGlow() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22bc50))(this);
    }

    virtual void updatePlayerRobotFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d620))(this, p0);
    }

    virtual void updatePlayerRollFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
    }

    virtual void updatePlayerScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22b8b0))(this);
    }

    virtual void updatePlayerShipFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
    }

    virtual void updatePlayerSpiderFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d650))(this, p0);
    }

    virtual void updatePlayerSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218440))(this, p0);
    }

    virtual void updateRobotAnimationSpeed() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df40))(this);
    }

    virtual void updateRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
    }

    virtual void updateRotation(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
    }

    virtual void updateShipRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221310))(this, p0);
    }

    virtual void updateShipSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218510))(this, p0);
    }

    virtual void updateSlopeRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221030))(this, p0);
    }

    virtual void updateSlopeYVelocity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e920))(this, p0);
    }

    virtual void updateSpecial(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a790))(this, p0);
    }

    virtual void updateStateVariables() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x21a770))(this);
    }

    virtual void updateTimeMod(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
    }

    virtual void usingWallLimitedMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22df00))(this);
    }

    virtual void yStartDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e9b0))(this);
    }

    virtual void yStartUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x22e990))(this);
    }

    void apply_hooks() override {
        auto orig = $PlayerObject(true);
        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::activateStreak}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::activateStreak}))
            m->registerHook(getBase()+0x21aef0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::activateStreak}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::addAllParticles}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::addAllParticles}))
            m->registerHook(getBase()+0x2189b0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::addAllParticles}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings}) != extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings}))
            m->registerHook(getBase()+0x22b800, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::addToTouchedRings}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished}) != extract_virtual(this, (void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished}))
            m->registerHook(getBase()+0x22e9d0, extract_virtual(this, (void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer}))
            m->registerHook(getBase()+0x21d6b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::boostPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer}) != extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer}))
            m->registerHook(getBase()+0x22d890, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::bumpPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown}) != extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown}))
            m->registerHook(getBase()+0x22b7e0, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::buttonDown}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject}) != extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject}))
            m->registerHook(getBase()+0x2217f0, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::checkSnapJumpToObject}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject}) != extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject}))
            m->registerHook(getBase()+0x21d880, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::collidedWithObject}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject}) != extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject}))
            m->registerHook(getBase()+0x21f0b0, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect)){&$PlayerObject::collidedWithObject}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope}) != extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope}))
            m->registerHook(getBase()+0x21d8d0, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*, bool)){&$PlayerObject::collidedWithSlope}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation}))
            m->registerHook(getBase()+0x21c860, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::convertToClosestRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes}) != extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes}))
            m->registerHook(getBase()+0x22dc70, extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::copyAttributes}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create}) != extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create}))
            m->registerHook(getBase()+0x217260, extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::create}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::deactivateParticle}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::deactivateParticle}))
            m->registerHook(getBase()+0x21a540, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::deactivateParticle}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak}))
            m->registerHook(getBase()+0x218b30, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::deactivateStreak}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2}))
            m->registerHook(getBase()+0x225890, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::fadeOutStreak2}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer}) != extract_virtual(this, (void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer}))
            m->registerHook(getBase()+0x221c80, extract_virtual(this, (void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)){&$PlayerObject::flashPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity}) != extract_virtual(this, (void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity}))
            m->registerHook(getBase()+0x21c090, extract_virtual(this, (void($PlayerObject::*)(bool, bool)){&$PlayerObject::flipGravity}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::flipMod}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::flipMod}))
            m->registerHook(getBase()+0x21a4c0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::flipMod}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::getActiveMode}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getActiveMode}))
            m->registerHook(getBase()+0x22b950, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getActiveMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel}))
            m->registerHook(getBase()+0x21bff0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getModifiedSlopeYVel}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition}))
            m->registerHook(getBase()+0x21a830, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::getOldPosition}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::getOrientedBox}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getOrientedBox}))
            m->registerHook(getBase()+0x22dee0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getOrientedBox}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::getRealPosition}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getRealPosition}))
            m->registerHook(getBase()+0x22d5f0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getRealPosition}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::getSecondColor}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getSecondColor}))
            m->registerHook(getBase()+0x22cee0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::getSecondColor}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::gravityDown}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::gravityDown}))
            m->registerHook(getBase()+0x22e930, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::gravityDown}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::gravityUp}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::gravityUp}))
            m->registerHook(getBase()+0x22e900, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::gravityUp}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity}))
            m->registerHook(getBase()+0x22b860, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::hardFlipGravity}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::hitGround}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::hitGround}))
            m->registerHook(getBase()+0x220a30, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::hitGround}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::incrementJumps}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::incrementJumps}))
            m->registerHook(getBase()+0x21c050, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::incrementJumps}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init}) != extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init}))
            m->registerHook(getBase()+0x2172e0, extract_virtual(this, (void($PlayerObject::*)(int, int, cocos2d::CCLayer*)){&$PlayerObject::init}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid}))
            m->registerHook(getBase()+0x21d650, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isBoostValid}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::isFlying}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::isFlying}))
            m->registerHook(getBase()+0x21a4e0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::isFlying}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip}))
            m->registerHook(getBase()+0x2209f0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeFlip}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode}))
            m->registerHook(getBase()+0x2209b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip}))
            m->registerHook(getBase()+0x221be0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::isSafeSpiderFlip}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished}))
            m->registerHook(getBase()+0x21b060, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelFlipFinished}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::levelFlipping}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelFlipping}))
            m->registerHook(getBase()+0x21a510, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelFlipping}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::levelWillFlip}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelWillFlip}))
            m->registerHook(getBase()+0x21b020, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::levelWillFlip}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint}) != extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint}))
            m->registerHook(getBase()+0x22e420, extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::loadFromCheckpoint}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::lockPlayer}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::lockPlayer}))
            m->registerHook(getBase()+0x22d680, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::lockPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::logValues}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::logValues}))
            m->registerHook(getBase()+0x221220, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::logValues}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::modeDidChange}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::modeDidChange}))
            m->registerHook(getBase()+0x22bfd0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::modeDidChange}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint}))
            m->registerHook(getBase()+0x21af90, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::placeStreakPoint}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playBurstEffect}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playBurstEffect}))
            m->registerHook(getBase()+0x21c780, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playBurstEffect}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playDeathEffect}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playDeathEffect}))
            m->registerHook(getBase()+0x225930, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playDeathEffect}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun}))
            m->registerHook(getBase()+0x222ec0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playDynamicSpiderRun}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed}))
            m->registerHook(getBase()+0x2256d0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::playerDestroyed}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playerIsFalling}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playerIsFalling}))
            m->registerHook(getBase()+0x21c730, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playerIsFalling}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playerTeleported}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playerTeleported}))
            m->registerHook(getBase()+0x22b840, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playerTeleported}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::playingEndEffect}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playingEndEffect}))
            m->registerHook(getBase()+0x22d7e0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::playingEndEffect}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::postCollision}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::postCollision}))
            m->registerHook(getBase()+0x21cd10, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::postCollision}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::preCollision}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::preCollision}))
            m->registerHook(getBase()+0x21ccc0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::preCollision}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision}) != extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision}))
            m->registerHook(getBase()+0x21ec80, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::preSlopeCollision}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer}))
            m->registerHook(getBase()+0x22d8e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::propellPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton}) != extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton}))
            m->registerHook(getBase()+0x22aa00, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::pushButton}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::pushDown}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::pushDown}))
            m->registerHook(getBase()+0x22dbd0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::pushDown}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer}))
            m->registerHook(getBase()+0x22dbb0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::pushPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton}) != extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton}))
            m->registerHook(getBase()+0x22b6f0, extract_virtual(this, (void($PlayerObject::*)(PlayerButton)){&$PlayerObject::releaseButton}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::removeAllParticles}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::removeAllParticles}))
            m->registerHook(getBase()+0x218ac0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::removeAllParticles}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint}))
            m->registerHook(getBase()+0x2237b0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::removePendingCheckpoint}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetAllParticles}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetAllParticles}))
            m->registerHook(getBase()+0x21adb0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetAllParticles}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog}))
            m->registerHook(getBase()+0x21cc20, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetCollisionLog}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetObject}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetObject}))
            m->registerHook(getBase()+0x223170, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetObject}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon}))
            m->registerHook(getBase()+0x22be00, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetPlayerIcon}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetStateVariables}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetStateVariables}))
            m->registerHook(getBase()+0x223760, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetStateVariables}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::resetStreak}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetStreak}))
            m->registerHook(getBase()+0x21ae10, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::resetStreak}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump}) != extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump}))
            m->registerHook(getBase()+0x22abf0, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::ringJump}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation}))
            m->registerHook(getBase()+0x21ca10, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::runBallRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::runBallRotation2}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::runBallRotation2}))
            m->registerHook(getBase()+0x21cb10, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::runBallRotation2}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::runNormalRotation}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::runNormalRotation}))
            m->registerHook(getBase()+0x21c960, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::runNormalRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction}))
            m->registerHook(getBase()+0x21c570, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::runRotateAction}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint}) != extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint}))
            m->registerHook(getBase()+0x22e2f0, extract_virtual(this, (void($PlayerObject::*)(PlayerCheckpoint*)){&$PlayerObject::saveToCheckpoint}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor}) != extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor}))
            m->registerHook(getBase()+0x22cdf0, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX}))
            m->registerHook(getBase()+0x22e720, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY}))
            m->registerHook(getBase()+0x22e7b0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity}) != extract_virtual(this, (void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity}))
            m->registerHook(getBase()+0x22d400, extract_virtual(this, (void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition}) != extract_virtual(this, (void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition}))
            m->registerHook(getBase()+0x22c8b0, extract_virtual(this, (void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::setRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setRotation}))
            m->registerHook(getBase()+0x22e6e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::setScale}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScale}))
            m->registerHook(getBase()+0x22e870, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScale}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleX}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleX}))
            m->registerHook(getBase()+0x22e7f0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleX}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleY}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleY}))
            m->registerHook(getBase()+0x22e830, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::setScaleY}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor}) != extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor}))
            m->registerHook(getBase()+0x219610, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setSecondColor}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::setVisible}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setVisible}))
            m->registerHook(getBase()+0x22e8b0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::setVisible}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::setupStreak}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::setupStreak}))
            m->registerHook(getBase()+0x218720, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::setupStreak}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle}))
            m->registerHook(getBase()+0x225480, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle2}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle2}))
            m->registerHook(getBase()+0x2252a0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnCircle2}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle}))
            m->registerHook(getBase()+0x2255c0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnDualCircle}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer}) != extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer}))
            m->registerHook(getBase()+0x22dde0, extract_virtual(this, (void($PlayerObject::*)(PlayerObject*)){&$PlayerObject::spawnFromPlayer}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle}) != extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle}))
            m->registerHook(getBase()+0x225350, extract_virtual(this, (void($PlayerObject::*)(cocos2d::_ccColor3B, float)){&$PlayerObject::spawnPortalCircle}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle}))
            m->registerHook(getBase()+0x2251b0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::spawnScaleCircle}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::specialGroundHit}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::specialGroundHit}))
            m->registerHook(getBase()+0x22dbf0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::specialGroundHit}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::speedDown}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::speedDown}))
            m->registerHook(getBase()+0x22e970, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::speedDown}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::speedUp}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::speedUp}))
            m->registerHook(getBase()+0x22e950, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::speedUp}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump}))
            m->registerHook(getBase()+0x21b160, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::spiderTestJump}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing}) != extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing}))
            m->registerHook(getBase()+0x221d70, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::startDashing}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect}))
            m->registerHook(getBase()+0x22c680, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::stopBurstEffect}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::stopDashing}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::stopDashing}))
            m->registerHook(getBase()+0x222990, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::stopDashing}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation}))
            m->registerHook(getBase()+0x21c830, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::stopRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision}) != extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision}))
            m->registerHook(getBase()+0x21cc60, extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::storeCollision}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode}) != extract_virtual(this, (void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode}))
            m->registerHook(getBase()+0x22b9a0, extract_virtual(this, (void($PlayerObject::*)(GameObjectType)){&$PlayerObject::switchedToMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving}) != extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving}))
            m->registerHook(getBase()+0x21eb70, extract_virtual(this, (void($PlayerObject::*)(float, GameObject*)){&$PlayerObject::testForMoving}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode}))
            m->registerHook(getBase()+0x224070, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleBirdMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode}))
            m->registerHook(getBase()+0x2243f0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleDartMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode}))
            m->registerHook(getBase()+0x223820, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleFlyMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect}) != extract_virtual(this, (void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect}))
            m->registerHook(getBase()+0x225000, extract_virtual(this, (void($PlayerObject::*)(GhostType)){&$PlayerObject::toggleGhostEffect}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale}))
            m->registerHook(getBase()+0x224bd0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::togglePlayerScale}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode}))
            m->registerHook(getBase()+0x223c70, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRobotMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode}))
            m->registerHook(getBase()+0x223b20, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleRollMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode}))
            m->registerHook(getBase()+0x224830, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleSpiderMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility}))
            m->registerHook(getBase()+0x21abf0, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::toggleVisibility}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject}) != extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject}))
            m->registerHook(getBase()+0x22e660, extract_virtual(this, (void($PlayerObject::*)(GameObject*)){&$PlayerObject::touchedObject}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint}))
            m->registerHook(getBase()+0x21a950, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::tryPlaceCheckpoint}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::update}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::update}))
            m->registerHook(getBase()+0x218bf0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::update}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode}) != extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode}))
            m->registerHook(getBase()+0x218980, extract_virtual(this, (void($PlayerObject::*)(bool)){&$PlayerObject::updateCheckpointMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest}))
            m->registerHook(getBase()+0x21a890, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateCheckpointTest}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide}) != extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide}))
            m->registerHook(getBase()+0x220f10, extract_virtual(this, (void($PlayerObject::*)(bool, int)){&$PlayerObject::updateCollide}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom}) != extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom}))
            m->registerHook(getBase()+0x221790, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideBottom}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop}) != extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop}))
            m->registerHook(getBase()+0x221c20, extract_virtual(this, (void($PlayerObject::*)(float, int)){&$PlayerObject::updateCollideTop}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation}))
            m->registerHook(getBase()+0x21a570, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateDashAnimation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateDashArt}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateDashArt}))
            m->registerHook(getBase()+0x222520, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateDashArt}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateGlowColor}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateGlowColor}))
            m->registerHook(getBase()+0x22cf10, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateGlowColor}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateJump}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateJump}))
            m->registerHook(getBase()+0x219680, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateJump}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables}))
            m->registerHook(getBase()+0x21a740, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateJumpVariables}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame}))
            m->registerHook(getBase()+0x22bfe0, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerBirdFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame}))
            m->registerHook(getBase()+0x22c260, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerDartFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame}))
            m->registerHook(getBase()+0x22c470, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow}))
            m->registerHook(getBase()+0x22bc50, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerGlow}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame}))
            m->registerHook(getBase()+0x22d620, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRobotFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame}))
            m->registerHook(getBase()+0x22c6a0, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerRollFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale}))
            m->registerHook(getBase()+0x22b8b0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updatePlayerScale}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame}))
            m->registerHook(getBase()+0x22ba40, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerShipFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame}) != extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame}))
            m->registerHook(getBase()+0x22d650, extract_virtual(this, (void($PlayerObject::*)(int)){&$PlayerObject::updatePlayerSpiderFrame}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra}) != extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra}))
            m->registerHook(getBase()+0x218440, extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updatePlayerSpriteExtra}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed}))
            m->registerHook(getBase()+0x22df40, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateRobotAnimationSpeed}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateRotation}))
            m->registerHook(getBase()+0x2214b0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation}) != extract_virtual(this, (void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation}))
            m->registerHook(getBase()+0x221230, extract_virtual(this, (void($PlayerObject::*)(float, float)){&$PlayerObject::updateRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation}))
            m->registerHook(getBase()+0x221310, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateShipRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra}) != extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra}))
            m->registerHook(getBase()+0x218510, extract_virtual(this, (void($PlayerObject::*)(std::string)){&$PlayerObject::updateShipSpriteExtra}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation}))
            m->registerHook(getBase()+0x221030, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeRotation}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity}))
            m->registerHook(getBase()+0x22e920, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSlopeYVelocity}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial}))
            m->registerHook(getBase()+0x21a790, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateSpecial}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::updateStateVariables}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateStateVariables}))
            m->registerHook(getBase()+0x21a770, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::updateStateVariables}));

        if (extract_virtual(&orig, (void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod}) != extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod}))
            m->registerHook(getBase()+0x2185e0, extract_virtual(this, (void($PlayerObject::*)(float)){&$PlayerObject::updateTimeMod}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode}))
            m->registerHook(getBase()+0x22df00, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::usingWallLimitedMode}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::yStartDown}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::yStartDown}))
            m->registerHook(getBase()+0x22e9b0, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::yStartDown}));

        if (extract_virtual(&orig, (void($PlayerObject::*)()){&$PlayerObject::yStartUp}) != extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::yStartUp}))
            m->registerHook(getBase()+0x22e990, extract_virtual(this, (void($PlayerObject::*)()){&$PlayerObject::yStartUp}));
    }
};


class $PulseEffectAction : public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $PulseEffectAction(bool dont_push) {}
    typedef PulseEffectAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x179e90))(this, p0);
    }

    virtual void getSaveString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x17a850))(this);
    }

    void apply_hooks() override {
        auto orig = $PulseEffectAction(true);
        if (extract_virtual(&orig, (void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString}) != extract_virtual(this, (void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString}))
            m->registerHook(getBase()+0x179e90, extract_virtual(this, (void($PulseEffectAction::*)(std::string)){&$PulseEffectAction::createFromString}));

        if (extract_virtual(&orig, (void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString}) != extract_virtual(this, (void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString}))
            m->registerHook(getBase()+0x17a850, extract_virtual(this, (void($PulseEffectAction::*)()){&$PulseEffectAction::getSaveString}));
    }
};


class $RetryLevelLayer : public $CacBase {
 public:
    $RetryLevelLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $RetryLevelLayer(bool dont_push) {}
    typedef RetryLevelLayer* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x28dd60))(this);
    }

    void apply_hooks() override {
        auto orig = $RetryLevelLayer(true);
        if (extract_virtual(&orig, (void($RetryLevelLayer::*)()){&$RetryLevelLayer::create}) != extract_virtual(this, (void($RetryLevelLayer::*)()){&$RetryLevelLayer::create}))
            m->registerHook(getBase()+0x28dd60, extract_virtual(this, (void($RetryLevelLayer::*)()){&$RetryLevelLayer::create}));
    }
};


class $SetGroupIDLayer : public $CacBase {
 public:
    $SetGroupIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetGroupIDLayer(bool dont_push) {}
    typedef SetGroupIDLayer* __thistype;

    virtual void onNextGroupID1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1967a0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x197af0))(this, p0);
    }

    virtual void updateGroupIDLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x197260))(this);
    }

    void apply_hooks() override {
        auto orig = $SetGroupIDLayer(true);
        if (extract_virtual(&orig, (void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1}) != extract_virtual(this, (void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1}))
            m->registerHook(getBase()+0x1967a0, extract_virtual(this, (void($SetGroupIDLayer::*)(cocos2d::CCObject*)){&$SetGroupIDLayer::onNextGroupID1}));

        if (extract_virtual(&orig, (void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged}) != extract_virtual(this, (void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged}))
            m->registerHook(getBase()+0x197af0, extract_virtual(this, (void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged}));

        if (extract_virtual(&orig, (void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel}) != extract_virtual(this, (void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel}))
            m->registerHook(getBase()+0x197260, extract_virtual(this, (void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::updateGroupIDLabel}));
    }
};


class $SetIDLayer : public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetIDLayer(bool dont_push) {}
    typedef SetIDLayer* __thistype;

    virtual void create(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x168f20))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $SetIDLayer(true);
        if (extract_virtual(&orig, (void($SetIDLayer::*)(GameObject*)){&$SetIDLayer::create}) != extract_virtual(this, (void($SetIDLayer::*)(GameObject*)){&$SetIDLayer::create}))
            m->registerHook(getBase()+0x168f20, extract_virtual(this, (void($SetIDLayer::*)(GameObject*)){&$SetIDLayer::create}));
    }
};


class $SetItemIDLayer : public $CacBase {
 public:
    $SetItemIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetItemIDLayer(bool dont_push) {}
    typedef SetItemIDLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x5a830))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $SetItemIDLayer(true);
        if (extract_virtual(&orig, (void($SetItemIDLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create}) != extract_virtual(this, (void($SetItemIDLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create}))
            m->registerHook(getBase()+0x5a830, extract_virtual(this, (void($SetItemIDLayer::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetItemIDLayer::create}));
    }
};


class $SetTargetIDLayer : public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetTargetIDLayer(bool dont_push) {}
    typedef SetTargetIDLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1, std::string p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, std::string)>(m->getOriginal(getBase()+0x159d20))(this, p0, p1, p2);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15aed0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15b6c0))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15b4a0))(this);
    }

    void apply_hooks() override {
        auto orig = $SetTargetIDLayer(true);
        if (extract_virtual(&orig, (void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create}) != extract_virtual(this, (void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create}))
            m->registerHook(getBase()+0x159d20, extract_virtual(this, (void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string)){&$SetTargetIDLayer::create}));

        if (extract_virtual(&orig, (void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow}) != extract_virtual(this, (void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow}))
            m->registerHook(getBase()+0x15aed0, extract_virtual(this, (void($SetTargetIDLayer::*)(cocos2d::CCObject*)){&$SetTargetIDLayer::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged}) != extract_virtual(this, (void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged}))
            m->registerHook(getBase()+0x15b6c0, extract_virtual(this, (void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged}));

        if (extract_virtual(&orig, (void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID}) != extract_virtual(this, (void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID}))
            m->registerHook(getBase()+0x15b4a0, extract_virtual(this, (void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::updateTargetID}));
    }
};


class $SetupAnimationPopup : public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupAnimationPopup(bool dont_push) {}
    typedef SetupAnimationPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x208b70))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x209fc0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x20ab30))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x20a910))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupAnimationPopup(true);
        if (extract_virtual(&orig, (void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create}) != extract_virtual(this, (void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create}))
            m->registerHook(getBase()+0x208b70, extract_virtual(this, (void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupAnimationPopup::create}));

        if (extract_virtual(&orig, (void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x209fc0, extract_virtual(this, (void($SetupAnimationPopup::*)(cocos2d::CCObject*)){&$SetupAnimationPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged}) != extract_virtual(this, (void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged}))
            m->registerHook(getBase()+0x20ab30, extract_virtual(this, (void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID}) != extract_virtual(this, (void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID}))
            m->registerHook(getBase()+0x20a910, extract_virtual(this, (void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::updateTargetID}));
    }
};


class $SetupCollisionTriggerPopup : public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupCollisionTriggerPopup(bool dont_push) {}
    typedef SetupCollisionTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1d6120))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d77b0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1d84d0))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d82b0))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupCollisionTriggerPopup(true);
        if (extract_virtual(&orig, (void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create}) != extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create}))
            m->registerHook(getBase()+0x1d6120, extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCollisionTriggerPopup::create}));

        if (extract_virtual(&orig, (void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x1d77b0, extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCollisionTriggerPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged}) != extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged}))
            m->registerHook(getBase()+0x1d84d0, extract_virtual(this, (void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID}) != extract_virtual(this, (void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID}))
            m->registerHook(getBase()+0x1d82b0, extract_virtual(this, (void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::updateTargetID}));
    }
};


class $SetupCountTriggerPopup : public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupCountTriggerPopup(bool dont_push) {}
    typedef SetupCountTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x15c6c0))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x15dd40))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x15e9a0))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x15e8a0))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupCountTriggerPopup(true);
        if (extract_virtual(&orig, (void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create}) != extract_virtual(this, (void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create}))
            m->registerHook(getBase()+0x15c6c0, extract_virtual(this, (void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupCountTriggerPopup::create}));

        if (extract_virtual(&orig, (void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x15dd40, extract_virtual(this, (void($SetupCountTriggerPopup::*)(cocos2d::CCObject*)){&$SetupCountTriggerPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged}) != extract_virtual(this, (void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged}))
            m->registerHook(getBase()+0x15e9a0, extract_virtual(this, (void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID}) != extract_virtual(this, (void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID}))
            m->registerHook(getBase()+0x15e8a0, extract_virtual(this, (void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::updateTargetID}));
    }
};


class $SetupInstantCountPopup : public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupInstantCountPopup(bool dont_push) {}
    typedef SetupInstantCountPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x352c10))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x354520))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x355270))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x355170))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupInstantCountPopup(true);
        if (extract_virtual(&orig, (void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create}) != extract_virtual(this, (void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create}))
            m->registerHook(getBase()+0x352c10, extract_virtual(this, (void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInstantCountPopup::create}));

        if (extract_virtual(&orig, (void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x354520, extract_virtual(this, (void($SetupInstantCountPopup::*)(cocos2d::CCObject*)){&$SetupInstantCountPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged}) != extract_virtual(this, (void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged}))
            m->registerHook(getBase()+0x355270, extract_virtual(this, (void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID}) != extract_virtual(this, (void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID}))
            m->registerHook(getBase()+0x355170, extract_virtual(this, (void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::updateTargetID}));
    }
};


class $SetupInteractObjectPopup : public $CacBase {
 public:
    $SetupInteractObjectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupInteractObjectPopup(bool dont_push) {}
    typedef SetupInteractObjectPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x29a400))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x29bbc0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x29c2b0))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x29c120))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupInteractObjectPopup(true);
        if (extract_virtual(&orig, (void($SetupInteractObjectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create}) != extract_virtual(this, (void($SetupInteractObjectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create}))
            m->registerHook(getBase()+0x29a400, extract_virtual(this, (void($SetupInteractObjectPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupInteractObjectPopup::create}));

        if (extract_virtual(&orig, (void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x29bbc0, extract_virtual(this, (void($SetupInteractObjectPopup::*)(cocos2d::CCObject*)){&$SetupInteractObjectPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged}) != extract_virtual(this, (void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged}))
            m->registerHook(getBase()+0x29c2b0, extract_virtual(this, (void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID}) != extract_virtual(this, (void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID}))
            m->registerHook(getBase()+0x29c120, extract_virtual(this, (void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::updateTargetID}));
    }
};


class $SetupObjectTogglePopup : public $CacBase {
 public:
    $SetupObjectTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupObjectTogglePopup(bool dont_push) {}
    typedef SetupObjectTogglePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0860))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1c0a40))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1c1c40))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1c2660))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1c2440))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupObjectTogglePopup(true);
        if (extract_virtual(&orig, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create}) != extract_virtual(this, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create}))
            m->registerHook(getBase()+0x1c0860, extract_virtual(this, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::create}));

        if (extract_virtual(&orig, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init}) != extract_virtual(this, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init}))
            m->registerHook(getBase()+0x1c0a40, extract_virtual(this, (void($SetupObjectTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupObjectTogglePopup::init}));

        if (extract_virtual(&orig, (void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x1c1c40, extract_virtual(this, (void($SetupObjectTogglePopup::*)(cocos2d::CCObject*)){&$SetupObjectTogglePopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged}) != extract_virtual(this, (void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged}))
            m->registerHook(getBase()+0x1c2660, extract_virtual(this, (void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID}) != extract_virtual(this, (void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID}))
            m->registerHook(getBase()+0x1c2440, extract_virtual(this, (void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::updateTargetID}));
    }
};


class $SetupOpacityPopup : public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupOpacityPopup(bool dont_push) {}
    typedef SetupOpacityPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x32b70))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x340a0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x34a60))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x34760))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupOpacityPopup(true);
        if (extract_virtual(&orig, (void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create}) != extract_virtual(this, (void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create}))
            m->registerHook(getBase()+0x32b70, extract_virtual(this, (void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupOpacityPopup::create}));

        if (extract_virtual(&orig, (void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x340a0, extract_virtual(this, (void($SetupOpacityPopup::*)(cocos2d::CCObject*)){&$SetupOpacityPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged}) != extract_virtual(this, (void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged}))
            m->registerHook(getBase()+0x34a60, extract_virtual(this, (void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID}) != extract_virtual(this, (void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID}))
            m->registerHook(getBase()+0x34760, extract_virtual(this, (void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::updateTargetID}));
    }
};


class $SetupPickupTriggerPopup : public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupPickupTriggerPopup(bool dont_push) {}
    typedef SetupPickupTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x35e70))(this, p0, p1);
    }

    virtual void onItemIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37100))(this, p0);
    }

    virtual void onNextItemID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x37260))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x37ca0))(this, p0);
    }

    virtual void updateItemID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x37ab0))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupPickupTriggerPopup(true);
        if (extract_virtual(&orig, (void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create}) != extract_virtual(this, (void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create}))
            m->registerHook(getBase()+0x35e70, extract_virtual(this, (void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPickupTriggerPopup::create}));

        if (extract_virtual(&orig, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow}) != extract_virtual(this, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow}))
            m->registerHook(getBase()+0x37100, extract_virtual(this, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onItemIDArrow}));

        if (extract_virtual(&orig, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID}) != extract_virtual(this, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID}))
            m->registerHook(getBase()+0x37260, extract_virtual(this, (void($SetupPickupTriggerPopup::*)(cocos2d::CCObject*)){&$SetupPickupTriggerPopup::onNextItemID}));

        if (extract_virtual(&orig, (void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged}) != extract_virtual(this, (void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged}))
            m->registerHook(getBase()+0x37ca0, extract_virtual(this, (void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID}) != extract_virtual(this, (void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID}))
            m->registerHook(getBase()+0x37ab0, extract_virtual(this, (void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::updateItemID}));
    }
};


class $SetupPulsePopup : public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupPulsePopup(bool dont_push) {}
    typedef SetupPulsePopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e6d40))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
    }

    virtual void onSelectPulseMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
    }

    virtual void onSelectTargetMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eac30))(this, p0);
    }

    virtual void onUpdateCustomColor(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eaef0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1ec960))(this, p0);
    }

    virtual void updateCopyColorTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebf20))(this);
    }

    virtual void updateEditorLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ec310))(this);
    }

    virtual void updateFadeOutLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ebbe0))(this);
    }

    virtual void updateTextInputLabel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1eb8d0))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupPulsePopup(true);
        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged}) != extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged}))
            m->registerHook(getBase()+0x1ec680, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create}) != extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create}))
            m->registerHook(getBase()+0x1e6d40, extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::create}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init}) != extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init}))
            m->registerHook(getBase()+0x1e7010, extract_virtual(this, (void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupPulsePopup::init}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode}) != extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode}))
            m->registerHook(getBase()+0x1eb020, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectPulseMode}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode}) != extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode}))
            m->registerHook(getBase()+0x1eac30, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onSelectTargetMode}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor}) != extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor}))
            m->registerHook(getBase()+0x1eaef0, extract_virtual(this, (void($SetupPulsePopup::*)(cocos2d::CCObject*)){&$SetupPulsePopup::onUpdateCustomColor}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged}) != extract_virtual(this, (void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged}))
            m->registerHook(getBase()+0x1ec960, extract_virtual(this, (void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel}) != extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel}))
            m->registerHook(getBase()+0x1ebf20, extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateCopyColorTextInputLabel}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel}) != extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel}))
            m->registerHook(getBase()+0x1ec310, extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateEditorLabel}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel}) != extract_virtual(this, (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel}))
            m->registerHook(getBase()+0x1eba20, extract_virtual(this, (void($SetupPulsePopup::*)(bool)){&$SetupPulsePopup::updateFadeOutLabel}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID}) != extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID}))
            m->registerHook(getBase()+0x1ebbe0, extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTargetID}));

        if (extract_virtual(&orig, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel}) != extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel}))
            m->registerHook(getBase()+0x1eb8d0, extract_virtual(this, (void($SetupPulsePopup::*)()){&$SetupPulsePopup::updateTextInputLabel}));
    }
};


class $SetupShakePopup : public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupShakePopup(bool dont_push) {}
    typedef SetupShakePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x3adc00))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $SetupShakePopup(true);
        if (extract_virtual(&orig, (void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create}) != extract_virtual(this, (void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create}))
            m->registerHook(getBase()+0x3adc00, extract_virtual(this, (void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupShakePopup::create}));
    }
};


class $SetupSpawnPopup : public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupSpawnPopup(bool dont_push) {}
    typedef SetupSpawnPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x139790))(this, p0, p1);
    }

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x13ad80))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x13b990))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13b770))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupSpawnPopup(true);
        if (extract_virtual(&orig, (void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create}) != extract_virtual(this, (void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create}))
            m->registerHook(getBase()+0x139790, extract_virtual(this, (void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupSpawnPopup::create}));

        if (extract_virtual(&orig, (void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton}) != extract_virtual(this, (void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton}))
            m->registerHook(getBase()+0x13b0e0, extract_virtual(this, (void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)){&$SetupSpawnPopup::createToggleButton}));

        if (extract_virtual(&orig, (void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x13ad80, extract_virtual(this, (void($SetupSpawnPopup::*)(cocos2d::CCObject*)){&$SetupSpawnPopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged}) != extract_virtual(this, (void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged}))
            m->registerHook(getBase()+0x13b990, extract_virtual(this, (void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID}) != extract_virtual(this, (void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID}))
            m->registerHook(getBase()+0x13b770, extract_virtual(this, (void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::updateTargetID}));
    }
};


class $SetupTouchTogglePopup : public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SetupTouchTogglePopup(bool dont_push) {}
    typedef SetupTouchTogglePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1576a0))(this, p0, p1);
    }

    virtual void onTargetIDArrow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x158b60))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x1596a0))(this, p0);
    }

    virtual void updateTargetID() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x159480))(this);
    }

    void apply_hooks() override {
        auto orig = $SetupTouchTogglePopup(true);
        if (extract_virtual(&orig, (void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create}) != extract_virtual(this, (void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create}))
            m->registerHook(getBase()+0x1576a0, extract_virtual(this, (void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*)){&$SetupTouchTogglePopup::create}));

        if (extract_virtual(&orig, (void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow}) != extract_virtual(this, (void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow}))
            m->registerHook(getBase()+0x158b60, extract_virtual(this, (void($SetupTouchTogglePopup::*)(cocos2d::CCObject*)){&$SetupTouchTogglePopup::onTargetIDArrow}));

        if (extract_virtual(&orig, (void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged}) != extract_virtual(this, (void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged}))
            m->registerHook(getBase()+0x1596a0, extract_virtual(this, (void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged}));

        if (extract_virtual(&orig, (void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID}) != extract_virtual(this, (void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID}))
            m->registerHook(getBase()+0x159480, extract_virtual(this, (void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::updateTargetID}));
    }
};


class $SimplePlayer : public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SimplePlayer(bool dont_push) {}
    typedef SimplePlayer* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1b6140))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
    }

    virtual void updateColors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ba1f0))(this);
    }

    virtual void updatePlayerFrame(int p0, IconType p1) {
        return reinterpret_cast<void(*)(decltype(this), int, IconType)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $SimplePlayer(true);
        if (extract_virtual(&orig, (void($SimplePlayer::*)(int)){&$SimplePlayer::create}) != extract_virtual(this, (void($SimplePlayer::*)(int)){&$SimplePlayer::create}))
            m->registerHook(getBase()+0x1b6140, extract_virtual(this, (void($SimplePlayer::*)(int)){&$SimplePlayer::create}));

        if (extract_virtual(&orig, (void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor}) != extract_virtual(this, (void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor}))
            m->registerHook(getBase()+0x1bace0, extract_virtual(this, (void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setSecondColor}));

        if (extract_virtual(&orig, (void($SimplePlayer::*)()){&$SimplePlayer::updateColors}) != extract_virtual(this, (void($SimplePlayer::*)()){&$SimplePlayer::updateColors}))
            m->registerHook(getBase()+0x1ba1f0, extract_virtual(this, (void($SimplePlayer::*)()){&$SimplePlayer::updateColors}));

        if (extract_virtual(&orig, (void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame}) != extract_virtual(this, (void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame}))
            m->registerHook(getBase()+0x1b62f0, extract_virtual(this, (void($SimplePlayer::*)(int, IconType)){&$SimplePlayer::updatePlayerFrame}));
    }
};


class $Slider : public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $Slider(bool dont_push) {}
    typedef Slider* __thistype;

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)>(m->getOriginal(getBase()+0x18dd80))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, float)>(m->getOriginal(getBase()+0x18dc40))(this, p0, p1, p2);
    }

    virtual void getValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
    }

    virtual void setBarVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x18e280))(this, p0);
    }

    virtual void setValue(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x18e170))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $Slider(true);
        if (extract_virtual(&orig, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create}) != extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create}))
            m->registerHook(getBase()+0x18dd80, extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)){&$Slider::create}));

        if (extract_virtual(&orig, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create}) != extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create}))
            m->registerHook(getBase()+0x18dc40, extract_virtual(this, (void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float)){&$Slider::create}));

        if (extract_virtual(&orig, (void($Slider::*)()){&$Slider::getValue}) != extract_virtual(this, (void($Slider::*)()){&$Slider::getValue}))
            m->registerHook(getBase()+0x18e0c0, extract_virtual(this, (void($Slider::*)()){&$Slider::getValue}));

        if (extract_virtual(&orig, (void($Slider::*)(bool)){&$Slider::setBarVisibility}) != extract_virtual(this, (void($Slider::*)(bool)){&$Slider::setBarVisibility}))
            m->registerHook(getBase()+0x18e280, extract_virtual(this, (void($Slider::*)(bool)){&$Slider::setBarVisibility}));

        if (extract_virtual(&orig, (void($Slider::*)(float)){&$Slider::setValue}) != extract_virtual(this, (void($Slider::*)(float)){&$Slider::setValue}))
            m->registerHook(getBase()+0x18e170, extract_virtual(this, (void($Slider::*)(float)){&$Slider::setValue}));
    }
};


class $SliderThumb : public $CacBase {
 public:
    $SliderThumb() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SliderThumb(bool dont_push) {}
    typedef SliderThumb* __thistype;

    virtual void getValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x18ce80))(this);
    }

    void apply_hooks() override {
        auto orig = $SliderThumb(true);
        if (extract_virtual(&orig, (void($SliderThumb::*)()){&$SliderThumb::getValue}) != extract_virtual(this, (void($SliderThumb::*)()){&$SliderThumb::getValue}))
            m->registerHook(getBase()+0x18ce80, extract_virtual(this, (void($SliderThumb::*)()){&$SliderThumb::getValue}));
    }
};


class $SpawnTriggerAction : public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SpawnTriggerAction(bool dont_push) {}
    typedef SpawnTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17bf50))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $SpawnTriggerAction(true);
        if (extract_virtual(&orig, (void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString}) != extract_virtual(this, (void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString}))
            m->registerHook(getBase()+0x17bf50, extract_virtual(this, (void($SpawnTriggerAction::*)(std::string)){&$SpawnTriggerAction::createFromString}));
    }
};


class $SpeedObject : public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $SpeedObject(bool dont_push) {}
    typedef SpeedObject* __thistype;

    virtual void create(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77450))(this, p0, p1, p2);
    }

    virtual void init(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        auto orig = $SpeedObject(true);
        if (extract_virtual(&orig, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::create}) != extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::create}))
            m->registerHook(getBase()+0x77450, extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::create}));

        if (extract_virtual(&orig, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init}) != extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init}))
            m->registerHook(getBase()+0x77400, extract_virtual(this, (void($SpeedObject::*)(GameObject*, int, float)){&$SpeedObject::init}));
    }
};


class $TeleportPortalObject : public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $TeleportPortalObject(bool dont_push) {}
    typedef TeleportPortalObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xdaa50))(this, p0);
    }

    virtual void getTeleportXOff(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xdac20))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $TeleportPortalObject(true);
        if (extract_virtual(&orig, (void($TeleportPortalObject::*)(char const*)){&$TeleportPortalObject::create}) != extract_virtual(this, (void($TeleportPortalObject::*)(char const*)){&$TeleportPortalObject::create}))
            m->registerHook(getBase()+0xdaa50, extract_virtual(this, (void($TeleportPortalObject::*)(char const*)){&$TeleportPortalObject::create}));

        if (extract_virtual(&orig, (void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff}) != extract_virtual(this, (void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff}))
            m->registerHook(getBase()+0xdac20, extract_virtual(this, (void($TeleportPortalObject::*)(cocos2d::CCNode*)){&$TeleportPortalObject::getTeleportXOff}));
    }
};


class $TextArea : public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $TextArea(bool dont_push) {}
    typedef TextArea* __thistype;

    virtual void create(std::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*, float, float, cocos2d::CCPoint, float, bool)>(m->getOriginal(getBase()+0x19eb40))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    void apply_hooks() override {
        auto orig = $TextArea(true);
        if (extract_virtual(&orig, (void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create}) != extract_virtual(this, (void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create}))
            m->registerHook(getBase()+0x19eb40, extract_virtual(this, (void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool)){&$TextArea::create}));
    }
};


class $TextInputDelegate : public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $TextInputDelegate(bool dont_push) {}
    typedef TextInputDelegate* __thistype;

    virtual void allowTextInput(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6210))(this, p0);
    }

    virtual void textInputOpened(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6200))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $TextInputDelegate(true);
        if (extract_virtual(&orig, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput}) != extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput}))
            m->registerHook(getBase()+0x6210, extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput}));

        if (extract_virtual(&orig, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened}) != extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened}))
            m->registerHook(getBase()+0x6200, extract_virtual(this, (void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened}));
    }
};


class $ToggleTriggerAction : public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ToggleTriggerAction(bool dont_push) {}
    typedef ToggleTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1765e0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $ToggleTriggerAction(true);
        if (extract_virtual(&orig, (void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString}) != extract_virtual(this, (void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString}))
            m->registerHook(getBase()+0x1765e0, extract_virtual(this, (void($ToggleTriggerAction::*)(std::string)){&$ToggleTriggerAction::createFromString}));
    }
};


class $TouchToggleAction : public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $TouchToggleAction(bool dont_push) {}
    typedef TouchToggleAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x177e10))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $TouchToggleAction(true);
        if (extract_virtual(&orig, (void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString}) != extract_virtual(this, (void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString}))
            m->registerHook(getBase()+0x177e10, extract_virtual(this, (void($TouchToggleAction::*)(std::string)){&$TouchToggleAction::createFromString}));
    }
};


class $UILayer : public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $UILayer(bool dont_push) {}
    typedef UILayer* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x27fd10))(this);
    }

    virtual void disableMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280960))(this);
    }

    virtual void enableMenu() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x280940))(this);
    }

    virtual void pCommand(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x280830))(this, p0);
    }

    virtual void toggleCheckpointsMenu(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x280430))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $UILayer(true);
        if (extract_virtual(&orig, (void($UILayer::*)()){&$UILayer::create}) != extract_virtual(this, (void($UILayer::*)()){&$UILayer::create}))
            m->registerHook(getBase()+0x27fd10, extract_virtual(this, (void($UILayer::*)()){&$UILayer::create}));

        if (extract_virtual(&orig, (void($UILayer::*)()){&$UILayer::disableMenu}) != extract_virtual(this, (void($UILayer::*)()){&$UILayer::disableMenu}))
            m->registerHook(getBase()+0x280960, extract_virtual(this, (void($UILayer::*)()){&$UILayer::disableMenu}));

        if (extract_virtual(&orig, (void($UILayer::*)()){&$UILayer::enableMenu}) != extract_virtual(this, (void($UILayer::*)()){&$UILayer::enableMenu}))
            m->registerHook(getBase()+0x280940, extract_virtual(this, (void($UILayer::*)()){&$UILayer::enableMenu}));

        if (extract_virtual(&orig, (void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand}) != extract_virtual(this, (void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand}))
            m->registerHook(getBase()+0x280830, extract_virtual(this, (void($UILayer::*)(cocos2d::CCNode*)){&$UILayer::pCommand}));

        if (extract_virtual(&orig, (void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu}) != extract_virtual(this, (void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu}))
            m->registerHook(getBase()+0x280430, extract_virtual(this, (void($UILayer::*)(bool)){&$UILayer::toggleCheckpointsMenu}));
    }
};


class $UndoObject : public $CacBase {
 public:
    $UndoObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $UndoObject(bool dont_push) {}
    typedef UndoObject* __thistype;

    virtual void create(GameObject* p0, UndoCommand p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, UndoCommand)>(m->getOriginal(getBase()+0x94ea0))(this, p0, p1);
    }

    virtual void createWithArray(cocos2d::CCArray* p0, UndoCommand p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, UndoCommand)>(m->getOriginal(getBase()+0x96ee0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $UndoObject(true);
        if (extract_virtual(&orig, (void($UndoObject::*)(GameObject*, UndoCommand)){&$UndoObject::create}) != extract_virtual(this, (void($UndoObject::*)(GameObject*, UndoCommand)){&$UndoObject::create}))
            m->registerHook(getBase()+0x94ea0, extract_virtual(this, (void($UndoObject::*)(GameObject*, UndoCommand)){&$UndoObject::create}));

        if (extract_virtual(&orig, (void($UndoObject::*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray}) != extract_virtual(this, (void($UndoObject::*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray}))
            m->registerHook(getBase()+0x96ee0, extract_virtual(this, (void($UndoObject::*)(cocos2d::CCArray*, UndoCommand)){&$UndoObject::createWithArray}));
    }
};


class $CCActionTween : public $CacBase {
 public:
    $CCActionTween() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCActionTween(bool dont_push) {}
    typedef CCActionTween* __thistype;

    virtual void create(float p0, char const* p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*, float, float)>(m->getOriginal(getBase()+0x447590))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        auto orig = $CCActionTween(true);
        if (extract_virtual(&orig, (void($CCActionTween::*)(float, char const*, float, float)){&$CCActionTween::create}) != extract_virtual(this, (void($CCActionTween::*)(float, char const*, float, float)){&$CCActionTween::create}))
            m->registerHook(getBase()+0x447590, extract_virtual(this, (void($CCActionTween::*)(float, char const*, float, float)){&$CCActionTween::create}));
    }
};


class $CCAnimate : public $CacBase {
 public:
    $CCAnimate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCAnimate(bool dont_push) {}
    typedef CCAnimate* __thistype;

    virtual void create(cocos2d::CCAnimation* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAnimation*)>(m->getOriginal(getBase()+0x1f8fc0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCAnimate(true);
        if (extract_virtual(&orig, (void($CCAnimate::*)(cocos2d::CCAnimation*)){&$CCAnimate::create}) != extract_virtual(this, (void($CCAnimate::*)(cocos2d::CCAnimation*)){&$CCAnimate::create}))
            m->registerHook(getBase()+0x1f8fc0, extract_virtual(this, (void($CCAnimate::*)(cocos2d::CCAnimation*)){&$CCAnimate::create}));
    }
};


class $CCAnimation : public $CacBase {
 public:
    $CCAnimation() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCAnimation(bool dont_push) {}
    typedef CCAnimation* __thistype;

    virtual void createWithSpriteFrames(cocos2d::CCArray* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float)>(m->getOriginal(getBase()+0x140df0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCAnimation(true);
        if (extract_virtual(&orig, (void($CCAnimation::*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames}) != extract_virtual(this, (void($CCAnimation::*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames}))
            m->registerHook(getBase()+0x140df0, extract_virtual(this, (void($CCAnimation::*)(cocos2d::CCArray*, float)){&$CCAnimation::createWithSpriteFrames}));
    }
};


class $CCArray : public $CacBase {
 public:
    $CCArray() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCArray(bool dont_push) {}
    typedef CCArray* __thistype;

    virtual void addObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419f90))(this, p0);
    }

    virtual void addObjectNew(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a450))(this, p0);
    }

    virtual void addObjectsFromArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41a2d0))(this, p0);
    }

    virtual void containsObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a3e0))(this, p0);
    }

    virtual void count() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a2f0))(this);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x419cb0))(this);
    }

    virtual void createWithObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419d50))(this, p0);
    }

    virtual void fastRemoveObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a520))(this, p0);
    }

    virtual void fastRemoveObjectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a500))(this, p0);
    }

    virtual void fastRemoveObjectAtIndexNew(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a510))(this, p0);
    }

    virtual void lastObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a360))(this);
    }

    virtual void objectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a340))(this, p0);
    }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41a4f0))(this);
    }

    virtual void removeLastObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x41a470))(this, p0);
    }

    virtual void removeObject(cocos2d::CCObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, bool)>(m->getOriginal(getBase()+0x41a490))(this, p0, p1);
    }

    virtual void removeObjectAtIndex(unsigned int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int, bool)>(m->getOriginal(getBase()+0x41a4b0))(this, p0, p1);
    }

    virtual void stringAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a320))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCArray(true);
        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject}))
            m->registerHook(getBase()+0x419f90, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew}))
            m->registerHook(getBase()+0x41a450, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::addObjectNew}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray}))
            m->registerHook(getBase()+0x41a2d0, extract_virtual(this, (void($CCArray::*)(cocos2d::CCArray*)){&$CCArray::addObjectsFromArray}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::containsObject}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::containsObject}))
            m->registerHook(getBase()+0x41a3e0, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::containsObject}));

        if (extract_virtual(&orig, (void($CCArray::*)()){&$CCArray::count}) != extract_virtual(this, (void($CCArray::*)()){&$CCArray::count}))
            m->registerHook(getBase()+0x41a2f0, extract_virtual(this, (void($CCArray::*)()){&$CCArray::count}));

        if (extract_virtual(&orig, (void($CCArray::*)()){&$CCArray::create}) != extract_virtual(this, (void($CCArray::*)()){&$CCArray::create}))
            m->registerHook(getBase()+0x419cb0, extract_virtual(this, (void($CCArray::*)()){&$CCArray::create}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::createWithObject}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::createWithObject}))
            m->registerHook(getBase()+0x419d50, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::createWithObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject}))
            m->registerHook(getBase()+0x41a520, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*)){&$CCArray::fastRemoveObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex}) != extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex}))
            m->registerHook(getBase()+0x41a500, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndex}));

        if (extract_virtual(&orig, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew}) != extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew}))
            m->registerHook(getBase()+0x41a510, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::fastRemoveObjectAtIndexNew}));

        if (extract_virtual(&orig, (void($CCArray::*)()){&$CCArray::lastObject}) != extract_virtual(this, (void($CCArray::*)()){&$CCArray::lastObject}))
            m->registerHook(getBase()+0x41a360, extract_virtual(this, (void($CCArray::*)()){&$CCArray::lastObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex}) != extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex}))
            m->registerHook(getBase()+0x41a340, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::objectAtIndex}));

        if (extract_virtual(&orig, (void($CCArray::*)()){&$CCArray::removeAllObjects}) != extract_virtual(this, (void($CCArray::*)()){&$CCArray::removeAllObjects}))
            m->registerHook(getBase()+0x41a4f0, extract_virtual(this, (void($CCArray::*)()){&$CCArray::removeAllObjects}));

        if (extract_virtual(&orig, (void($CCArray::*)(bool)){&$CCArray::removeLastObject}) != extract_virtual(this, (void($CCArray::*)(bool)){&$CCArray::removeLastObject}))
            m->registerHook(getBase()+0x41a470, extract_virtual(this, (void($CCArray::*)(bool)){&$CCArray::removeLastObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject}) != extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject}))
            m->registerHook(getBase()+0x41a490, extract_virtual(this, (void($CCArray::*)(cocos2d::CCObject*, bool)){&$CCArray::removeObject}));

        if (extract_virtual(&orig, (void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex}) != extract_virtual(this, (void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex}))
            m->registerHook(getBase()+0x41a4b0, extract_virtual(this, (void($CCArray::*)(unsigned int, bool)){&$CCArray::removeObjectAtIndex}));

        if (extract_virtual(&orig, (void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex}) != extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex}))
            m->registerHook(getBase()+0x41a320, extract_virtual(this, (void($CCArray::*)(unsigned int)){&$CCArray::stringAtIndex}));
    }
};


class $CCBezierTo : public $CacBase {
 public:
    $CCBezierTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCBezierTo(bool dont_push) {}
    typedef CCBezierTo* __thistype;

    virtual void create(float p0, cocos2d::_ccBezierConfig const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::_ccBezierConfig const&)>(m->getOriginal(getBase()+0x1f6c10))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCBezierTo(true);
        if (extract_virtual(&orig, (void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create}) != extract_virtual(this, (void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create}))
            m->registerHook(getBase()+0x1f6c10, extract_virtual(this, (void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&)){&$CCBezierTo::create}));
    }
};


class $CCCallFunc : public $CacBase {
 public:
    $CCCallFunc() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCCallFunc(bool dont_push) {}
    typedef CCCallFunc* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x454d90))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCCallFunc(true);
        if (extract_virtual(&orig, (void($CCCallFunc::*)(int)){&$CCCallFunc::create}) != extract_virtual(this, (void($CCCallFunc::*)(int)){&$CCCallFunc::create}))
            m->registerHook(getBase()+0x454d90, extract_virtual(this, (void($CCCallFunc::*)(int)){&$CCCallFunc::create}));
    }
};


class $CCCopying : public $CacBase {
 public:
    $CCCopying() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCCopying(bool dont_push) {}
    typedef CCCopying* __thistype;

    virtual void copyWithZone(cocos2d::CCZone* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCZone*)>(m->getOriginal(getBase()+0x250c90))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCCopying(true);
        if (extract_virtual(&orig, (void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone}) != extract_virtual(this, (void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone}))
            m->registerHook(getBase()+0x250c90, extract_virtual(this, (void($CCCopying::*)(cocos2d::CCZone*)){&$CCCopying::copyWithZone}));
    }
};


class $CCDelayTime : public $CacBase {
 public:
    $CCDelayTime() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCDelayTime(bool dont_push) {}
    typedef CCDelayTime* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f4380))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCDelayTime(true);
        if (extract_virtual(&orig, (void($CCDelayTime::*)(float)){&$CCDelayTime::create}) != extract_virtual(this, (void($CCDelayTime::*)(float)){&$CCDelayTime::create}))
            m->registerHook(getBase()+0x1f4380, extract_virtual(this, (void($CCDelayTime::*)(float)){&$CCDelayTime::create}));
    }
};


class $CCDictionary : public $CacBase {
 public:
    $CCDictionary() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCDictionary(bool dont_push) {}
    typedef CCDictionary* __thistype;

    virtual void allKeys() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190450))(this);
    }

    virtual void count() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190430))(this);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x192650))(this);
    }

    virtual void objectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190bb0))(this, p0);
    }

    virtual void objectForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x190870))(this, p0);
    }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x190220))(this);
    }

    virtual void removeObjectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x1921d0))(this, p0);
    }

    virtual void setObject(cocos2d::CCObject* p0, long p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, long)>(m->getOriginal(getBase()+0x191790))(this, p0, p1);
    }

    virtual void setObject(cocos2d::CCObject* p0, std::string const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string const&)>(m->getOriginal(getBase()+0x190dc0))(this, p0, p1);
    }

    virtual void valueForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190cf0))(this, p0);
    }

    virtual void valueForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x1907a0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCDictionary(true);
        if (extract_virtual(&orig, (void($CCDictionary::*)()){&$CCDictionary::allKeys}) != extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::allKeys}))
            m->registerHook(getBase()+0x190450, extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::allKeys}));

        if (extract_virtual(&orig, (void($CCDictionary::*)()){&$CCDictionary::count}) != extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::count}))
            m->registerHook(getBase()+0x190430, extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::count}));

        if (extract_virtual(&orig, (void($CCDictionary::*)()){&$CCDictionary::create}) != extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::create}))
            m->registerHook(getBase()+0x192650, extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::create}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(long)){&$CCDictionary::objectForKey}) != extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::objectForKey}))
            m->registerHook(getBase()+0x190bb0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::objectForKey}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey}) != extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey}))
            m->registerHook(getBase()+0x190870, extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::objectForKey}));

        if (extract_virtual(&orig, (void($CCDictionary::*)()){&$CCDictionary::removeAllObjects}) != extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::removeAllObjects}))
            m->registerHook(getBase()+0x190220, extract_virtual(this, (void($CCDictionary::*)()){&$CCDictionary::removeAllObjects}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey}) != extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey}))
            m->registerHook(getBase()+0x1921d0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::removeObjectForKey}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject}) != extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject}))
            m->registerHook(getBase()+0x191790, extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, long)){&$CCDictionary::setObject}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject}) != extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject}))
            m->registerHook(getBase()+0x190dc0, extract_virtual(this, (void($CCDictionary::*)(cocos2d::CCObject*, std::string const&)){&$CCDictionary::setObject}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(long)){&$CCDictionary::valueForKey}) != extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::valueForKey}))
            m->registerHook(getBase()+0x190cf0, extract_virtual(this, (void($CCDictionary::*)(long)){&$CCDictionary::valueForKey}));

        if (extract_virtual(&orig, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey}) != extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey}))
            m->registerHook(getBase()+0x1907a0, extract_virtual(this, (void($CCDictionary::*)(std::string const&)){&$CCDictionary::valueForKey}));
    }
};


class $CCDirector : public $CacBase {
 public:
    $CCDirector() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCDirector(bool dont_push) {}
    typedef CCDirector* __thistype;

    virtual void getScreenBottom() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b210))(this);
    }

    virtual void getScreenLeft() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b220))(this);
    }

    virtual void getScreenRight() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b230))(this);
    }

    virtual void getScreenScaleFactorH() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b1e0))(this);
    }

    virtual void getScreenScaleFactorW() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b1f0))(this);
    }

    virtual void getScreenTop() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24b200))(this);
    }

    virtual void getTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24afa0))(this);
    }

    virtual void getWinSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x24a0f0))(this);
    }

    virtual void pushScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a620))(this, p0);
    }

    virtual void replaceScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a6d0))(this, p0);
    }

    virtual void resetSmoothFixCounter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x249bc0))(this);
    }

    virtual void sharedDirector() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x248cb0))(this);
    }

    void apply_hooks() override {
        auto orig = $CCDirector(true);
        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenBottom}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenBottom}))
            m->registerHook(getBase()+0x24b210, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenBottom}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenLeft}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenLeft}))
            m->registerHook(getBase()+0x24b220, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenLeft}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenRight}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenRight}))
            m->registerHook(getBase()+0x24b230, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenRight}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorH}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorH}))
            m->registerHook(getBase()+0x24b1e0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorH}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorW}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorW}))
            m->registerHook(getBase()+0x24b1f0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenScaleFactorW}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getScreenTop}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenTop}))
            m->registerHook(getBase()+0x24b200, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getScreenTop}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getTouchDispatcher}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getTouchDispatcher}))
            m->registerHook(getBase()+0x24afa0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getTouchDispatcher}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::getWinSize}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getWinSize}))
            m->registerHook(getBase()+0x24a0f0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::getWinSize}));

        if (extract_virtual(&orig, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene}) != extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene}))
            m->registerHook(getBase()+0x24a620, extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::pushScene}));

        if (extract_virtual(&orig, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene}) != extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene}))
            m->registerHook(getBase()+0x24a6d0, extract_virtual(this, (void($CCDirector::*)(cocos2d::CCScene*)){&$CCDirector::replaceScene}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::resetSmoothFixCounter}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::resetSmoothFixCounter}))
            m->registerHook(getBase()+0x249bc0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::resetSmoothFixCounter}));

        if (extract_virtual(&orig, (void($CCDirector::*)()){&$CCDirector::sharedDirector}) != extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::sharedDirector}))
            m->registerHook(getBase()+0x248cb0, extract_virtual(this, (void($CCDirector::*)()){&$CCDirector::sharedDirector}));
    }
};


class $CCDrawNode : public $CacBase {
 public:
    $CCDrawNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCDrawNode(bool dont_push) {}
    typedef CCDrawNode* __thistype;

    virtual void clear() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x379e80))(this);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x378d00))(this);
    }

    virtual void drawPolygon(cocos2d::CCPoint* p0, unsigned int p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3797f0))(this, p0, p1, p2, p3, p4);
    }

    virtual void drawSegment(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, float p2, cocos2d::_ccColor4F const& p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3792d0))(this, p0, p1, p2, p3);
    }

    virtual void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x379ea0))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x378e00))(this);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc const&)>(m->getOriginal(getBase()+0x379eb0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCDrawNode(true);
        if (extract_virtual(&orig, (void($CCDrawNode::*)()){&$CCDrawNode::clear}) != extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::clear}))
            m->registerHook(getBase()+0x379e80, extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::clear}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)()){&$CCDrawNode::create}) != extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::create}))
            m->registerHook(getBase()+0x378d00, extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::create}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon}) != extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon}))
            m->registerHook(getBase()+0x3797f0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawPolygon}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment}) != extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment}))
            m->registerHook(getBase()+0x3792d0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)){&$CCDrawNode::drawSegment}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)()){&$CCDrawNode::getBlendFunc}) != extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::getBlendFunc}))
            m->registerHook(getBase()+0x379ea0, extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::getBlendFunc}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)()){&$CCDrawNode::init}) != extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::init}))
            m->registerHook(getBase()+0x378e00, extract_virtual(this, (void($CCDrawNode::*)()){&$CCDrawNode::init}));

        if (extract_virtual(&orig, (void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc}) != extract_virtual(this, (void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc}))
            m->registerHook(getBase()+0x379eb0, extract_virtual(this, (void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&)){&$CCDrawNode::setBlendFunc}));
    }
};


class $CCEaseElasticOut : public $CacBase {
 public:
    $CCEaseElasticOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCEaseElasticOut(bool dont_push) {}
    typedef CCEaseElasticOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a3080))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCEaseElasticOut(true);
        if (extract_virtual(&orig, (void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create}) != extract_virtual(this, (void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create}))
            m->registerHook(getBase()+0x2a3080, extract_virtual(this, (void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseElasticOut::create}));
    }
};


class $CCEaseIn : public $CacBase {
 public:
    $CCEaseIn() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCEaseIn(bool dont_push) {}
    typedef CCEaseIn* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1960))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCEaseIn(true);
        if (extract_virtual(&orig, (void($CCEaseIn::*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create}) != extract_virtual(this, (void($CCEaseIn::*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create}))
            m->registerHook(getBase()+0x2a1960, extract_virtual(this, (void($CCEaseIn::*)(cocos2d::CCActionInterval*, float)){&$CCEaseIn::create}));
    }
};


class $CCEaseInOut : public $CacBase {
 public:
    $CCEaseInOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCEaseInOut(bool dont_push) {}
    typedef CCEaseInOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1d80))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCEaseInOut(true);
        if (extract_virtual(&orig, (void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create}) != extract_virtual(this, (void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create}))
            m->registerHook(getBase()+0x2a1d80, extract_virtual(this, (void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseInOut::create}));
    }
};


class $CCEaseOut : public $CacBase {
 public:
    $CCEaseOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCEaseOut(bool dont_push) {}
    typedef CCEaseOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1b70))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCEaseOut(true);
        if (extract_virtual(&orig, (void($CCEaseOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create}) != extract_virtual(this, (void($CCEaseOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create}))
            m->registerHook(getBase()+0x2a1b70, extract_virtual(this, (void($CCEaseOut::*)(cocos2d::CCActionInterval*, float)){&$CCEaseOut::create}));
    }
};


class $CCFadeOut : public $CacBase {
 public:
    $CCFadeOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCFadeOut(bool dont_push) {}
    typedef CCFadeOut* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f7d80))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCFadeOut(true);
        if (extract_virtual(&orig, (void($CCFadeOut::*)(float)){&$CCFadeOut::create}) != extract_virtual(this, (void($CCFadeOut::*)(float)){&$CCFadeOut::create}))
            m->registerHook(getBase()+0x1f7d80, extract_virtual(this, (void($CCFadeOut::*)(float)){&$CCFadeOut::create}));
    }
};


class $CCFadeTo : public $CacBase {
 public:
    $CCFadeTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCFadeTo(bool dont_push) {}
    typedef CCFadeTo* __thistype;

    virtual void create(float p0, unsigned char p1) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char)>(m->getOriginal(getBase()+0x1f7ff0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCFadeTo(true);
        if (extract_virtual(&orig, (void($CCFadeTo::*)(float, unsigned char)){&$CCFadeTo::create}) != extract_virtual(this, (void($CCFadeTo::*)(float, unsigned char)){&$CCFadeTo::create}))
            m->registerHook(getBase()+0x1f7ff0, extract_virtual(this, (void($CCFadeTo::*)(float, unsigned char)){&$CCFadeTo::create}));
    }
};


class $CCHide : public $CacBase {
 public:
    $CCHide() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCHide(bool dont_push) {}
    typedef CCHide* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x4543e0))(this);
    }

    void apply_hooks() override {
        auto orig = $CCHide(true);
        if (extract_virtual(&orig, (void($CCHide::*)()){&$CCHide::create}) != extract_virtual(this, (void($CCHide::*)()){&$CCHide::create}))
            m->registerHook(getBase()+0x4543e0, extract_virtual(this, (void($CCHide::*)()){&$CCHide::create}));
    }
};


class $CCImage : public $CacBase {
 public:
    $CCImage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCImage(bool dont_push) {}
    typedef CCImage* __thistype;

    virtual void initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), void*, int, cocos2d::CCImage::EImageFormat, int, int, int)>(m->getOriginal(getBase()+0x24fcb0))(this, p0, p1, p2, p3, p4, p5);
    }

    void apply_hooks() override {
        auto orig = $CCImage(true);
        if (extract_virtual(&orig, (void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData}) != extract_virtual(this, (void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData}))
            m->registerHook(getBase()+0x24fcb0, extract_virtual(this, (void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int)){&$CCImage::initWithImageData}));
    }
};


class $CCKeyboardDelegate : public $CacBase {
 public:
    $CCKeyboardDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCKeyboardDelegate(bool dont_push) {}
    typedef CCKeyboardDelegate* __thistype;

    virtual void keyUp(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x61a0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCKeyboardDelegate(true);
        if (extract_virtual(&orig, (void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp}) != extract_virtual(this, (void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp}))
            m->registerHook(getBase()+0x61a0, extract_virtual(this, (void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes)){&$CCKeyboardDelegate::keyUp}));
    }
};


class $CCLabelBMFont : public $CacBase {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCLabelBMFont(bool dont_push) {}
    typedef CCLabelBMFont* __thistype;

    virtual void create(char const* p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, char const*)>(m->getOriginal(getBase()+0x347660))(this, p0, p1);
    }

    virtual void limitLabelWidth(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x34a6e0))(this, p0, p1, p2);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x34a5d0))(this, p0);
    }

    virtual void setString(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x3489e0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCLabelBMFont(true);
        if (extract_virtual(&orig, (void($CCLabelBMFont::*)(char const*, char const*)){&$CCLabelBMFont::create}) != extract_virtual(this, (void($CCLabelBMFont::*)(char const*, char const*)){&$CCLabelBMFont::create}))
            m->registerHook(getBase()+0x347660, extract_virtual(this, (void($CCLabelBMFont::*)(char const*, char const*)){&$CCLabelBMFont::create}));

        if (extract_virtual(&orig, (void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth}) != extract_virtual(this, (void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth}))
            m->registerHook(getBase()+0x34a6e0, extract_virtual(this, (void($CCLabelBMFont::*)(float, float, float)){&$CCLabelBMFont::limitLabelWidth}));

        if (extract_virtual(&orig, (void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale}) != extract_virtual(this, (void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale}))
            m->registerHook(getBase()+0x34a5d0, extract_virtual(this, (void($CCLabelBMFont::*)(float)){&$CCLabelBMFont::setScale}));

        if (extract_virtual(&orig, (void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString}) != extract_virtual(this, (void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString}))
            m->registerHook(getBase()+0x3489e0, extract_virtual(this, (void($CCLabelBMFont::*)(char const*, bool)){&$CCLabelBMFont::setString}));
    }
};


class $CCLayer : public $CacBase {
 public:
    $CCLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCLayer(bool dont_push) {}
    typedef CCLayer* __thistype;

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2734d0))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273650))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2735d0))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273550))(this, p0, p1);
    }

    virtual void ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2736d0))(this, p0, p1);
    }

    virtual void ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273850))(this, p0, p1);
    }

    virtual void ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2737d0))(this, p0, p1);
    }

    virtual void ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273750))(this, p0, p1);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272a00))(this);
    }

    virtual void didAccelerate(cocos2d::CCAcceleration* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAcceleration*)>(m->getOriginal(getBase()+0x272ea0))(this, p0);
    }

    virtual void getTouchMode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e10))(this);
    }

    virtual void getTouchPriority() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e00))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2729a0))(this);
    }

    virtual void isAccelerometerEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272e20))(this);
    }

    virtual void isKeyboardEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273010))(this);
    }

    virtual void isKeypadEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272f70))(this);
    }

    virtual void isMouseEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273090))(this);
    }

    virtual void isTouchEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272ce0))(this);
    }

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273160))(this);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x273280))(this, p0);
    }

    virtual void keyMenuClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273200))(this);
    }

    virtual void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273300))(this);
    }

    virtual void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273490))(this);
    }

    virtual void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2733c0))(this);
    }

    virtual void registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, bool)>(m->getOriginal(getBase()+0x272bd0))(this, p0, p1, p2, p3);
    }

    virtual void registerWithTouchDispatcher() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272b40))(this);
    }

    virtual void setAccelerometerEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272e30))(this, p0);
    }

    virtual void setAccelerometerInterval(double p0) {
        return reinterpret_cast<void(*)(decltype(this), double)>(m->getOriginal(getBase()+0x272e70))(this, p0);
    }

    virtual void setKeyboardEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x273020))(this, p0);
    }

    virtual void setKeypadEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272f80))(this, p0);
    }

    virtual void setMouseEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2730a0))(this, p0);
    }

    virtual void setTouchEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272cf0))(this, p0);
    }

    virtual void setTouchMode(cocos2d::ccTouchesMode p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccTouchesMode)>(m->getOriginal(getBase()+0x272d60))(this, p0);
    }

    virtual void setTouchPriority(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x272db0))(this, p0);
    }

    virtual void unregisterScriptTouchHandler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x272c30))(this);
    }

    void apply_hooks() override {
        auto orig = $CCLayer(true);
        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan}))
            m->registerHook(getBase()+0x2734d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchBegan}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled}))
            m->registerHook(getBase()+0x273650, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchCancelled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded}))
            m->registerHook(getBase()+0x2735d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchEnded}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved}))
            m->registerHook(getBase()+0x273550, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCLayer::ccTouchMoved}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan}))
            m->registerHook(getBase()+0x2736d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesBegan}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled}))
            m->registerHook(getBase()+0x273850, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesCancelled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded}))
            m->registerHook(getBase()+0x2737d0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesEnded}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved}))
            m->registerHook(getBase()+0x273750, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*)){&$CCLayer::ccTouchesMoved}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::create}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::create}))
            m->registerHook(getBase()+0x272a00, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::create}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate}))
            m->registerHook(getBase()+0x272ea0, extract_virtual(this, (void($CCLayer::*)(cocos2d::CCAcceleration*)){&$CCLayer::didAccelerate}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::getTouchMode}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::getTouchMode}))
            m->registerHook(getBase()+0x272e10, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::getTouchMode}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::getTouchPriority}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::getTouchPriority}))
            m->registerHook(getBase()+0x272e00, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::getTouchPriority}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::init}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::init}))
            m->registerHook(getBase()+0x2729a0, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::init}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::isAccelerometerEnabled}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isAccelerometerEnabled}))
            m->registerHook(getBase()+0x272e20, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isAccelerometerEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::isKeyboardEnabled}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isKeyboardEnabled}))
            m->registerHook(getBase()+0x273010, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isKeyboardEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::isKeypadEnabled}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isKeypadEnabled}))
            m->registerHook(getBase()+0x272f70, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isKeypadEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::isMouseEnabled}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isMouseEnabled}))
            m->registerHook(getBase()+0x273090, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isMouseEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::isTouchEnabled}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isTouchEnabled}))
            m->registerHook(getBase()+0x272ce0, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::isTouchEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::keyBackClicked}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::keyBackClicked}))
            m->registerHook(getBase()+0x273160, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::keyBackClicked}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown}))
            m->registerHook(getBase()+0x273280, extract_virtual(this, (void($CCLayer::*)(cocos2d::enumKeyCodes)){&$CCLayer::keyDown}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::keyMenuClicked}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::keyMenuClicked}))
            m->registerHook(getBase()+0x273200, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::keyMenuClicked}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::onEnter}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onEnter}))
            m->registerHook(getBase()+0x273300, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onEnter}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::onEnterTransitionDidFinish}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onEnterTransitionDidFinish}))
            m->registerHook(getBase()+0x273490, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onEnterTransitionDidFinish}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::onExit}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onExit}))
            m->registerHook(getBase()+0x2733c0, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::onExit}));

        if (extract_virtual(&orig, (void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler}) != extract_virtual(this, (void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler}))
            m->registerHook(getBase()+0x272bd0, extract_virtual(this, (void($CCLayer::*)(int, bool, int, bool)){&$CCLayer::registerScriptTouchHandler}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::registerWithTouchDispatcher}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::registerWithTouchDispatcher}))
            m->registerHook(getBase()+0x272b40, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::registerWithTouchDispatcher}));

        if (extract_virtual(&orig, (void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled}) != extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled}))
            m->registerHook(getBase()+0x272e30, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setAccelerometerEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval}) != extract_virtual(this, (void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval}))
            m->registerHook(getBase()+0x272e70, extract_virtual(this, (void($CCLayer::*)(double)){&$CCLayer::setAccelerometerInterval}));

        if (extract_virtual(&orig, (void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled}) != extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled}))
            m->registerHook(getBase()+0x273020, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeyboardEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled}) != extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled}))
            m->registerHook(getBase()+0x272f80, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setKeypadEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled}) != extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled}))
            m->registerHook(getBase()+0x2730a0, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setMouseEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled}) != extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled}))
            m->registerHook(getBase()+0x272cf0, extract_virtual(this, (void($CCLayer::*)(bool)){&$CCLayer::setTouchEnabled}));

        if (extract_virtual(&orig, (void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode}) != extract_virtual(this, (void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode}))
            m->registerHook(getBase()+0x272d60, extract_virtual(this, (void($CCLayer::*)(cocos2d::ccTouchesMode)){&$CCLayer::setTouchMode}));

        if (extract_virtual(&orig, (void($CCLayer::*)(int)){&$CCLayer::setTouchPriority}) != extract_virtual(this, (void($CCLayer::*)(int)){&$CCLayer::setTouchPriority}))
            m->registerHook(getBase()+0x272db0, extract_virtual(this, (void($CCLayer::*)(int)){&$CCLayer::setTouchPriority}));

        if (extract_virtual(&orig, (void($CCLayer::*)()){&$CCLayer::unregisterScriptTouchHandler}) != extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::unregisterScriptTouchHandler}))
            m->registerHook(getBase()+0x272c30, extract_virtual(this, (void($CCLayer::*)()){&$CCLayer::unregisterScriptTouchHandler}));
    }
};


class $CCLayerColor : public $CacBase {
 public:
    $CCLayerColor() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCLayerColor(bool dont_push) {}
    typedef CCLayerColor* __thistype;

    virtual void create(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x2745e0))(this, p0, p1, p2);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274b50))(this);
    }

    virtual void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274480))(this);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274800))(this);
    }

    virtual void initWithColor(cocos2d::_ccColor4B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&)>(m->getOriginal(getBase()+0x2749a0))(this, p0);
    }

    virtual void initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x274850))(this, p0, p1, p2);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x2744a0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x274c20))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2749f0))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x274db0))(this, p0);
    }

    virtual void updateColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274ae0))(this);
    }

    void apply_hooks() override {
        auto orig = $CCLayerColor(true);
        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create}))
            m->registerHook(getBase()+0x2745e0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::create}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)()){&$CCLayerColor::draw}) != extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::draw}))
            m->registerHook(getBase()+0x274b50, extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::draw}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)()){&$CCLayerColor::getBlendFunc}) != extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::getBlendFunc}))
            m->registerHook(getBase()+0x274480, extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::getBlendFunc}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)()){&$CCLayerColor::init}) != extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::init}))
            m->registerHook(getBase()+0x274800, extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::init}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor}))
            m->registerHook(getBase()+0x2749a0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&)){&$CCLayerColor::initWithColor}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor}))
            m->registerHook(getBase()+0x274850, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float)){&$CCLayerColor::initWithColor}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc}))
            m->registerHook(getBase()+0x2744a0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccBlendFunc)){&$CCLayerColor::setBlendFunc}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor}))
            m->registerHook(getBase()+0x274c20, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::_ccColor3B const&)){&$CCLayerColor::setColor}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize}) != extract_virtual(this, (void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize}))
            m->registerHook(getBase()+0x2749f0, extract_virtual(this, (void($CCLayerColor::*)(cocos2d::CCSize const&)){&$CCLayerColor::setContentSize}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity}) != extract_virtual(this, (void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity}))
            m->registerHook(getBase()+0x274db0, extract_virtual(this, (void($CCLayerColor::*)(unsigned char)){&$CCLayerColor::setOpacity}));

        if (extract_virtual(&orig, (void($CCLayerColor::*)()){&$CCLayerColor::updateColor}) != extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::updateColor}))
            m->registerHook(getBase()+0x274ae0, extract_virtual(this, (void($CCLayerColor::*)()){&$CCLayerColor::updateColor}));
    }
};


class $CCLayerRGBA : public $CacBase {
 public:
    $CCLayerRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCLayerRGBA(bool dont_push) {}
    typedef CCLayerRGBA* __thistype;

    virtual void getColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273d60))(this);
    }

    virtual void getDisplayedColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273d80))(this);
    }

    virtual void getDisplayedOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273c00))(this);
    }

    virtual void getOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x273be0))(this);
    }

    virtual void isCascadeColorEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x274230))(this);
    }

    virtual void isCascadeOpacityEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2741f0))(this);
    }

    virtual void isOpacityModifyRGB() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6190))(this);
    }

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274250))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274210))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6180))(this, p0);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x2740b0))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x273f20))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCLayerRGBA(true);
        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getColor}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getColor}))
            m->registerHook(getBase()+0x273d60, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getColor}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedColor}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedColor}))
            m->registerHook(getBase()+0x273d80, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedColor}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedOpacity}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedOpacity}))
            m->registerHook(getBase()+0x273c00, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getDisplayedOpacity}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getOpacity}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getOpacity}))
            m->registerHook(getBase()+0x273be0, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::getOpacity}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeColorEnabled}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeColorEnabled}))
            m->registerHook(getBase()+0x274230, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeColorEnabled}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeOpacityEnabled}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeOpacityEnabled}))
            m->registerHook(getBase()+0x2741f0, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isCascadeOpacityEnabled}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isOpacityModifyRGB}) != extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isOpacityModifyRGB}))
            m->registerHook(getBase()+0x6190, extract_virtual(this, (void($CCLayerRGBA::*)()){&$CCLayerRGBA::isOpacityModifyRGB}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled}) != extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled}))
            m->registerHook(getBase()+0x274250, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeColorEnabled}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled}) != extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled}))
            m->registerHook(getBase()+0x274210, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setCascadeOpacityEnabled}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB}) != extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB}))
            m->registerHook(getBase()+0x6180, extract_virtual(this, (void($CCLayerRGBA::*)(bool)){&$CCLayerRGBA::setOpacityModifyRGB}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor}) != extract_virtual(this, (void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor}))
            m->registerHook(getBase()+0x2740b0, extract_virtual(this, (void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&)){&$CCLayerRGBA::updateDisplayedColor}));

        if (extract_virtual(&orig, (void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity}) != extract_virtual(this, (void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity}))
            m->registerHook(getBase()+0x273f20, extract_virtual(this, (void($CCLayerRGBA::*)(unsigned char)){&$CCLayerRGBA::updateDisplayedOpacity}));
    }
};


class $CCMenu : public $CacBase {
 public:
    $CCMenu() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMenu(bool dont_push) {}
    typedef CCMenu* __thistype;

    virtual void alignItemsHorizontallyWithPadding(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x4393e0))(this, p0);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x438720))(this);
    }

    virtual void createWithArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x4387e0))(this, p0);
    }

    virtual void createWithItem(cocos2d::CCMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCMenuItem*)>(m->getOriginal(getBase()+0x438b80))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCMenu(true);
        if (extract_virtual(&orig, (void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding}) != extract_virtual(this, (void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding}))
            m->registerHook(getBase()+0x4393e0, extract_virtual(this, (void($CCMenu::*)(float)){&$CCMenu::alignItemsHorizontallyWithPadding}));

        if (extract_virtual(&orig, (void($CCMenu::*)()){&$CCMenu::create}) != extract_virtual(this, (void($CCMenu::*)()){&$CCMenu::create}))
            m->registerHook(getBase()+0x438720, extract_virtual(this, (void($CCMenu::*)()){&$CCMenu::create}));

        if (extract_virtual(&orig, (void($CCMenu::*)(cocos2d::CCArray*)){&$CCMenu::createWithArray}) != extract_virtual(this, (void($CCMenu::*)(cocos2d::CCArray*)){&$CCMenu::createWithArray}))
            m->registerHook(getBase()+0x4387e0, extract_virtual(this, (void($CCMenu::*)(cocos2d::CCArray*)){&$CCMenu::createWithArray}));

        if (extract_virtual(&orig, (void($CCMenu::*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem}) != extract_virtual(this, (void($CCMenu::*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem}))
            m->registerHook(getBase()+0x438b80, extract_virtual(this, (void($CCMenu::*)(cocos2d::CCMenuItem*)){&$CCMenu::createWithItem}));
    }
};


class $CCMotionStreak : public $CacBase {
 public:
    $CCMotionStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMotionStreak(bool dont_push) {}
    typedef CCMotionStreak* __thistype;

    virtual void reset() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2ee190))(this);
    }

    virtual void resumeStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2edb30))(this);
    }

    virtual void stopStroke() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2edb20))(this);
    }

    void apply_hooks() override {
        auto orig = $CCMotionStreak(true);
        if (extract_virtual(&orig, (void($CCMotionStreak::*)()){&$CCMotionStreak::reset}) != extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::reset}))
            m->registerHook(getBase()+0x2ee190, extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::reset}));

        if (extract_virtual(&orig, (void($CCMotionStreak::*)()){&$CCMotionStreak::resumeStroke}) != extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::resumeStroke}))
            m->registerHook(getBase()+0x2edb30, extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::resumeStroke}));

        if (extract_virtual(&orig, (void($CCMotionStreak::*)()){&$CCMotionStreak::stopStroke}) != extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::stopStroke}))
            m->registerHook(getBase()+0x2edb20, extract_virtual(this, (void($CCMotionStreak::*)()){&$CCMotionStreak::stopStroke}));
    }
};


class $CCMouseDelegate : public $CacBase {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMouseDelegate(bool dont_push) {}
    typedef CCMouseDelegate* __thistype;

    virtual void rightKeyDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61b0))(this);
    }

    virtual void rightKeyUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61c0))(this);
    }

    virtual void scrollWheel(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x61d0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCMouseDelegate(true);
        if (extract_virtual(&orig, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyDown}) != extract_virtual(this, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyDown}))
            m->registerHook(getBase()+0x61b0, extract_virtual(this, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyDown}));

        if (extract_virtual(&orig, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyUp}) != extract_virtual(this, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyUp}))
            m->registerHook(getBase()+0x61c0, extract_virtual(this, (void($CCMouseDelegate::*)()){&$CCMouseDelegate::rightKeyUp}));

        if (extract_virtual(&orig, (void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel}) != extract_virtual(this, (void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel}))
            m->registerHook(getBase()+0x61d0, extract_virtual(this, (void($CCMouseDelegate::*)(float, float)){&$CCMouseDelegate::scrollWheel}));
    }
};


class $CCMoveBy : public $CacBase {
 public:
    $CCMoveBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMoveBy(bool dont_push) {}
    typedef CCMoveBy* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f50e0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCMoveBy(true);
        if (extract_virtual(&orig, (void($CCMoveBy::*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create}) != extract_virtual(this, (void($CCMoveBy::*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create}))
            m->registerHook(getBase()+0x1f50e0, extract_virtual(this, (void($CCMoveBy::*)(float, cocos2d::CCPoint const&)){&$CCMoveBy::create}));
    }
};


class $CCMoveTo : public $CacBase {
 public:
    $CCMoveTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCMoveTo(bool dont_push) {}
    typedef CCMoveTo* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f54d0))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCMoveTo(true);
        if (extract_virtual(&orig, (void($CCMoveTo::*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create}) != extract_virtual(this, (void($CCMoveTo::*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create}))
            m->registerHook(getBase()+0x1f54d0, extract_virtual(this, (void($CCMoveTo::*)(float, cocos2d::CCPoint const&)){&$CCMoveTo::create}));
    }
};


class $CCNode : public $CacBase {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCNode(bool dont_push) {}
    typedef CCNode* __thistype;

    virtual void _setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x122990))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x1233d0))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1233b0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1232a0))(this, p0, p1, p2);
    }

    virtual void addComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a40))(this, p0);
    }

    virtual void cleanup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123100))(this);
    }

    virtual void convertToNodeSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124750))(this, p0);
    }

    virtual void convertToWorldSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124790))(this, p0);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1230a0))(this);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123840))(this);
    }

    virtual void getActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ee0))(this, p0);
    }

    virtual void getActionManager() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123e50))(this);
    }

    virtual void getAnchorPoint() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d80))(this);
    }

    virtual void getAnchorPointInPoints() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d70))(this);
    }

    virtual void getCamera() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122cb0))(this);
    }

    virtual cocos2d::CCNode* getChildByTag(int p0) {
        return reinterpret_cast<cocos2d::CCNode*(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123220))(this, p0);
    }

    virtual void getChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122c80))(this);
    }

    virtual void getChildrenCount() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122c90))(this);
    }

    virtual void getContentSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122e00))(this);
    }

    virtual void getGLServerState() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f90))(this);
    }

    virtual void getGrid() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d00))(this);
    }

    virtual void getOrderOfArrival() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f50))(this);
    }

    virtual void getParent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ed0))(this);
    }

    virtual void getPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b60))(this);
    }

    virtual void getPosition(float* p0, float* p1) {
        return reinterpret_cast<void(*)(decltype(this), float*, float*)>(m->getOriginal(getBase()+0x122b90))(this, p0, p1);
    }

    virtual void getPositionX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122be0))(this);
    }

    virtual void getPositionY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122bf0))(this);
    }

    virtual void getRotation() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a00))(this);
    }

    virtual void getRotationX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a50))(this);
    }

    virtual void getRotationY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122a80))(this);
    }

    virtual void getScale() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ab0))(this);
    }

    virtual void getScaleX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b00))(this);
    }

    virtual void getScaleY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122b30))(this);
    }

    virtual void getScaledContentSize() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122e10))(this);
    }

    virtual void getScheduler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123f70))(this);
    }

    virtual void getShaderProgram() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f70))(this);
    }

    virtual void getSkewX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122920))(this);
    }

    virtual void getSkewY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122950))(this);
    }

    virtual void getUserData() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f30))(this);
    }

    virtual void getUserObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122f80))(this);
    }

    virtual void getVertexZ() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1229e0))(this);
    }

    virtual void getZOrder() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122980))(this);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122f00))(this, p0);
    }

    virtual void init() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122910))(this);
    }

    virtual void isIgnoreAnchorPointForPosition() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ef0))(this);
    }

    virtual void isRunning() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122ec0))(this);
    }

    virtual void isVisible() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x122d50))(this);
    }

    virtual void nodeToParentTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124210))(this);
    }

    virtual void nodeToWorldTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124670))(this);
    }

    virtual void onEnter() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123a90))(this);
    }

    virtual void onEnterTransitionDidFinish() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123b90))(this);
    }

    virtual void onExit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123ca0))(this);
    }

    virtual void onExitTransitionDidStart() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123c00))(this);
    }

    virtual void parentToNodeTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1245d0))(this);
    }

    virtual void pauseSchedulerAndActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123d60))(this);
    }

    virtual void registerScriptHandler(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123d90))(this, p0);
    }

    virtual void removeAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123600))(this);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123620))(this, p0);
    }

    virtual void removeAllComponents() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124aa0))(this);
    }

    virtual void removeChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x123460))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x123480))(this, p0, p1);
    }

    virtual void removeChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1235a0))(this, p0);
    }

    virtual void removeChildByTag(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x1235c0))(this, p0, p1);
    }

    virtual void removeComponent(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x124a60))(this, p0);
    }

    virtual void removeComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a80))(this, p0);
    }

    virtual void removeFromParent() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1233f0))(this);
    }

    virtual void removeFromParentAndCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123410))(this, p0);
    }

    virtual void removeMeAndCleanup() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123440))(this);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x123760))(this, p0, p1);
    }

    virtual void resumeSchedulerAndActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123b60))(this);
    }

    virtual void runAction(cocos2d::CCAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAction*)>(m->getOriginal(getBase()+0x123e60))(this, p0);
    }

    virtual void schedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x1240b0))(this, p0);
    }

    virtual void schedule(Cacao::CC_SCHED p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, float)>(m->getOriginal(getBase()+0x124120))(this, p0, p1);
    }

    virtual void scheduleUpdate() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123f80))(this);
    }

    virtual void setActionManager(cocos2d::CCActionManager* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionManager*)>(m->getOriginal(getBase()+0x123e00))(this, p0);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122d90))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x122e50))(this, p0);
    }

    virtual void setGLServerState(cocos2d::ccGLServerState p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccGLServerState)>(m->getOriginal(getBase()+0x122fa0))(this, p0);
    }

    virtual void setGrid(cocos2d::CCGridBase* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGridBase*)>(m->getOriginal(getBase()+0x122d10))(this, p0);
    }

    virtual void setOrderOfArrival(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x122f60))(this, p0);
    }

    virtual void setParent(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x122ee0))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122b70))(this, p0);
    }

    virtual void setPosition(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ba0))(this, p0, p1);
    }

    virtual void setPositionX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c00))(this, p0);
    }

    virtual void setPositionY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c40))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a10))(this, p0);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a60))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a90))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122ac0))(this, p0);
    }

    virtual void setScale(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ae0))(this, p0, p1);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b10))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b40))(this, p0);
    }

    virtual void setScheduler(cocos2d::CCScheduler* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScheduler*)>(m->getOriginal(getBase()+0x123f20))(this, p0);
    }

    virtual void setShaderProgram(cocos2d::CCGLProgram* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGLProgram*)>(m->getOriginal(getBase()+0x122ff0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122930))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122960))(this, p0);
    }

    virtual void setUserData(void* p0) {
        return reinterpret_cast<void(*)(decltype(this), void*)>(m->getOriginal(getBase()+0x122f40))(this, p0);
    }

    virtual void setUserObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x122fb0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1229f0))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122d60))(this, p0);
    }

    virtual void setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1229a0))(this, p0);
    }

    virtual void sortAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1237b0))(this);
    }

    virtual void stopActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ec0))(this, p0);
    }

    virtual void stopAllActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123190))(this);
    }

    virtual void unregisterScriptHandler() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123dc0))(this);
    }

    virtual void unschedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x124180))(this, p0);
    }

    virtual void unscheduleAllSelectors() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1231b0))(this);
    }

    virtual void unscheduleUpdate() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124060))(this);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1241a0))(this, p0);
    }

    virtual void updateTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1249d0))(this);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x1249c0))(this, p0, p1);
    }

    virtual void visit() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x123850))(this);
    }

    virtual void worldToNodeTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124710))(this);
    }

    void apply_hooks() override {
        auto orig = $CCNode(true);
        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::_setZOrder}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::_setZOrder}))
            m->registerHook(getBase()+0x122990, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::_setZOrder}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild}))
            m->registerHook(getBase()+0x1233d0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::addChild}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild}))
            m->registerHook(getBase()+0x1233b0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::addChild}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild}))
            m->registerHook(getBase()+0x1232a0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int, int)){&$CCNode::addChild}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent}))
            m->registerHook(getBase()+0x124a40, extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::addComponent}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::cleanup}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::cleanup}))
            m->registerHook(getBase()+0x123100, extract_virtual(this, (void($CCNode::*)()){&$CCNode::cleanup}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace}))
            m->registerHook(getBase()+0x124750, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToNodeSpace}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace}))
            m->registerHook(getBase()+0x124790, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::convertToWorldSpace}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::create}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::create}))
            m->registerHook(getBase()+0x1230a0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::create}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::draw}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::draw}))
            m->registerHook(getBase()+0x123840, extract_virtual(this, (void($CCNode::*)()){&$CCNode::draw}));

        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::getActionByTag}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::getActionByTag}))
            m->registerHook(getBase()+0x123ee0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::getActionByTag}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getActionManager}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getActionManager}))
            m->registerHook(getBase()+0x123e50, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getActionManager}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getAnchorPoint}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getAnchorPoint}))
            m->registerHook(getBase()+0x122d80, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getAnchorPoint}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getAnchorPointInPoints}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getAnchorPointInPoints}))
            m->registerHook(getBase()+0x122d70, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getAnchorPointInPoints}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getCamera}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getCamera}))
            m->registerHook(getBase()+0x122cb0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getCamera}));

        if (extract_virtual(&orig, (cocos2d::CCNode*($CCNode::*)(int)){&$CCNode::getChildByTag}) != extract_virtual(this, (cocos2d::CCNode*($CCNode::*)(int)){&$CCNode::getChildByTag}))
            m->registerHook(getBase()+0x123220, extract_virtual(this, (cocos2d::CCNode*($CCNode::*)(int)){&$CCNode::getChildByTag}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getChildren}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getChildren}))
            m->registerHook(getBase()+0x122c80, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getChildren}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getChildrenCount}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getChildrenCount}))
            m->registerHook(getBase()+0x122c90, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getChildrenCount}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getContentSize}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getContentSize}))
            m->registerHook(getBase()+0x122e00, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getContentSize}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getGLServerState}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getGLServerState}))
            m->registerHook(getBase()+0x122f90, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getGLServerState}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getGrid}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getGrid}))
            m->registerHook(getBase()+0x122d00, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getGrid}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getOrderOfArrival}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getOrderOfArrival}))
            m->registerHook(getBase()+0x122f50, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getOrderOfArrival}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getParent}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getParent}))
            m->registerHook(getBase()+0x122ed0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getParent}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getPosition}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPosition}))
            m->registerHook(getBase()+0x122b60, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)(float*, float*)){&$CCNode::getPosition}) != extract_virtual(this, (void($CCNode::*)(float*, float*)){&$CCNode::getPosition}))
            m->registerHook(getBase()+0x122b90, extract_virtual(this, (void($CCNode::*)(float*, float*)){&$CCNode::getPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getPositionX}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPositionX}))
            m->registerHook(getBase()+0x122be0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPositionX}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getPositionY}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPositionY}))
            m->registerHook(getBase()+0x122bf0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getPositionY}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getRotation}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotation}))
            m->registerHook(getBase()+0x122a00, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotation}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getRotationX}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotationX}))
            m->registerHook(getBase()+0x122a50, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotationX}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getRotationY}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotationY}))
            m->registerHook(getBase()+0x122a80, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getRotationY}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getScale}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScale}))
            m->registerHook(getBase()+0x122ab0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScale}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getScaleX}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaleX}))
            m->registerHook(getBase()+0x122b00, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaleX}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getScaleY}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaleY}))
            m->registerHook(getBase()+0x122b30, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaleY}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getScaledContentSize}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaledContentSize}))
            m->registerHook(getBase()+0x122e10, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScaledContentSize}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getScheduler}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScheduler}))
            m->registerHook(getBase()+0x123f70, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getScheduler}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getShaderProgram}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getShaderProgram}))
            m->registerHook(getBase()+0x122f70, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getShaderProgram}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getSkewX}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getSkewX}))
            m->registerHook(getBase()+0x122920, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getSkewX}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getSkewY}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getSkewY}))
            m->registerHook(getBase()+0x122950, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getSkewY}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getUserData}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getUserData}))
            m->registerHook(getBase()+0x122f30, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getUserData}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getUserObject}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getUserObject}))
            m->registerHook(getBase()+0x122f80, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getUserObject}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getVertexZ}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getVertexZ}))
            m->registerHook(getBase()+0x1229e0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getVertexZ}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::getZOrder}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::getZOrder}))
            m->registerHook(getBase()+0x122980, extract_virtual(this, (void($CCNode::*)()){&$CCNode::getZOrder}));

        if (extract_virtual(&orig, (void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition}) != extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition}))
            m->registerHook(getBase()+0x122f00, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::ignoreAnchorPointForPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::init}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::init}))
            m->registerHook(getBase()+0x122910, extract_virtual(this, (void($CCNode::*)()){&$CCNode::init}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::isIgnoreAnchorPointForPosition}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::isIgnoreAnchorPointForPosition}))
            m->registerHook(getBase()+0x122ef0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::isIgnoreAnchorPointForPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::isRunning}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::isRunning}))
            m->registerHook(getBase()+0x122ec0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::isRunning}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::isVisible}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::isVisible}))
            m->registerHook(getBase()+0x122d50, extract_virtual(this, (void($CCNode::*)()){&$CCNode::isVisible}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::nodeToParentTransform}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::nodeToParentTransform}))
            m->registerHook(getBase()+0x124210, extract_virtual(this, (void($CCNode::*)()){&$CCNode::nodeToParentTransform}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::nodeToWorldTransform}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::nodeToWorldTransform}))
            m->registerHook(getBase()+0x124670, extract_virtual(this, (void($CCNode::*)()){&$CCNode::nodeToWorldTransform}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::onEnter}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::onEnter}))
            m->registerHook(getBase()+0x123a90, extract_virtual(this, (void($CCNode::*)()){&$CCNode::onEnter}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::onEnterTransitionDidFinish}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::onEnterTransitionDidFinish}))
            m->registerHook(getBase()+0x123b90, extract_virtual(this, (void($CCNode::*)()){&$CCNode::onEnterTransitionDidFinish}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::onExit}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::onExit}))
            m->registerHook(getBase()+0x123ca0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::onExit}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::onExitTransitionDidStart}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::onExitTransitionDidStart}))
            m->registerHook(getBase()+0x123c00, extract_virtual(this, (void($CCNode::*)()){&$CCNode::onExitTransitionDidStart}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::parentToNodeTransform}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::parentToNodeTransform}))
            m->registerHook(getBase()+0x1245d0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::parentToNodeTransform}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::pauseSchedulerAndActions}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::pauseSchedulerAndActions}))
            m->registerHook(getBase()+0x123d60, extract_virtual(this, (void($CCNode::*)()){&$CCNode::pauseSchedulerAndActions}));

        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::registerScriptHandler}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::registerScriptHandler}))
            m->registerHook(getBase()+0x123d90, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::registerScriptHandler}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::removeAllChildren}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeAllChildren}))
            m->registerHook(getBase()+0x123600, extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeAllChildren}));

        if (extract_virtual(&orig, (void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup}) != extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup}))
            m->registerHook(getBase()+0x123620, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeAllChildrenWithCleanup}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::removeAllComponents}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeAllComponents}))
            m->registerHook(getBase()+0x124aa0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeAllComponents}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild}))
            m->registerHook(getBase()+0x123460, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::removeChild}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild}))
            m->registerHook(getBase()+0x123480, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, bool)){&$CCNode::removeChild}));

        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::removeChildByTag}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::removeChildByTag}))
            m->registerHook(getBase()+0x1235a0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::removeChildByTag}));

        if (extract_virtual(&orig, (void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag}) != extract_virtual(this, (void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag}))
            m->registerHook(getBase()+0x1235c0, extract_virtual(this, (void($CCNode::*)(int, bool)){&$CCNode::removeChildByTag}));

        if (extract_virtual(&orig, (void($CCNode::*)(char const*)){&$CCNode::removeComponent}) != extract_virtual(this, (void($CCNode::*)(char const*)){&$CCNode::removeComponent}))
            m->registerHook(getBase()+0x124a60, extract_virtual(this, (void($CCNode::*)(char const*)){&$CCNode::removeComponent}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent}))
            m->registerHook(getBase()+0x124a80, extract_virtual(this, (void($CCNode::*)(cocos2d::CCComponent*)){&$CCNode::removeComponent}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::removeFromParent}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeFromParent}))
            m->registerHook(getBase()+0x1233f0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeFromParent}));

        if (extract_virtual(&orig, (void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup}) != extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup}))
            m->registerHook(getBase()+0x123410, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::removeFromParentAndCleanup}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::removeMeAndCleanup}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeMeAndCleanup}))
            m->registerHook(getBase()+0x123440, extract_virtual(this, (void($CCNode::*)()){&$CCNode::removeMeAndCleanup}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild}))
            m->registerHook(getBase()+0x123760, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*, int)){&$CCNode::reorderChild}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::resumeSchedulerAndActions}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::resumeSchedulerAndActions}))
            m->registerHook(getBase()+0x123b60, extract_virtual(this, (void($CCNode::*)()){&$CCNode::resumeSchedulerAndActions}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction}))
            m->registerHook(getBase()+0x123e60, extract_virtual(this, (void($CCNode::*)(cocos2d::CCAction*)){&$CCNode::runAction}));

        if (extract_virtual(&orig, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule}) != extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule}))
            m->registerHook(getBase()+0x1240b0, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::schedule}));

        if (extract_virtual(&orig, (void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule}) != extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule}))
            m->registerHook(getBase()+0x124120, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED, float)){&$CCNode::schedule}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::scheduleUpdate}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::scheduleUpdate}))
            m->registerHook(getBase()+0x123f80, extract_virtual(this, (void($CCNode::*)()){&$CCNode::scheduleUpdate}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager}))
            m->registerHook(getBase()+0x123e00, extract_virtual(this, (void($CCNode::*)(cocos2d::CCActionManager*)){&$CCNode::setActionManager}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint}))
            m->registerHook(getBase()+0x122d90, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setAnchorPoint}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize}))
            m->registerHook(getBase()+0x122e50, extract_virtual(this, (void($CCNode::*)(cocos2d::CCSize const&)){&$CCNode::setContentSize}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState}) != extract_virtual(this, (void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState}))
            m->registerHook(getBase()+0x122fa0, extract_virtual(this, (void($CCNode::*)(cocos2d::ccGLServerState)){&$CCNode::setGLServerState}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid}))
            m->registerHook(getBase()+0x122d10, extract_virtual(this, (void($CCNode::*)(cocos2d::CCGridBase*)){&$CCNode::setGrid}));

        if (extract_virtual(&orig, (void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival}) != extract_virtual(this, (void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival}))
            m->registerHook(getBase()+0x122f60, extract_virtual(this, (void($CCNode::*)(unsigned int)){&$CCNode::setOrderOfArrival}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent}))
            m->registerHook(getBase()+0x122ee0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCNode*)){&$CCNode::setParent}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition}))
            m->registerHook(getBase()+0x122b70, extract_virtual(this, (void($CCNode::*)(cocos2d::CCPoint const&)){&$CCNode::setPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)(float, float)){&$CCNode::setPosition}) != extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setPosition}))
            m->registerHook(getBase()+0x122ba0, extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setPosition}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setPositionX}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionX}))
            m->registerHook(getBase()+0x122c00, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionX}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setPositionY}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionY}))
            m->registerHook(getBase()+0x122c40, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setPositionY}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setRotation}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotation}))
            m->registerHook(getBase()+0x122a10, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotation}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setRotationX}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationX}))
            m->registerHook(getBase()+0x122a60, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationX}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setRotationY}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationY}))
            m->registerHook(getBase()+0x122a90, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setRotationY}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setScale}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScale}))
            m->registerHook(getBase()+0x122ac0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScale}));

        if (extract_virtual(&orig, (void($CCNode::*)(float, float)){&$CCNode::setScale}) != extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setScale}))
            m->registerHook(getBase()+0x122ae0, extract_virtual(this, (void($CCNode::*)(float, float)){&$CCNode::setScale}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setScaleX}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleX}))
            m->registerHook(getBase()+0x122b10, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleX}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setScaleY}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleY}))
            m->registerHook(getBase()+0x122b40, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setScaleY}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler}))
            m->registerHook(getBase()+0x123f20, extract_virtual(this, (void($CCNode::*)(cocos2d::CCScheduler*)){&$CCNode::setScheduler}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram}))
            m->registerHook(getBase()+0x122ff0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCGLProgram*)){&$CCNode::setShaderProgram}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setSkewX}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewX}))
            m->registerHook(getBase()+0x122930, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewX}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setSkewY}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewY}))
            m->registerHook(getBase()+0x122960, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setSkewY}));

        if (extract_virtual(&orig, (void($CCNode::*)(void*)){&$CCNode::setUserData}) != extract_virtual(this, (void($CCNode::*)(void*)){&$CCNode::setUserData}))
            m->registerHook(getBase()+0x122f40, extract_virtual(this, (void($CCNode::*)(void*)){&$CCNode::setUserData}));

        if (extract_virtual(&orig, (void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject}) != extract_virtual(this, (void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject}))
            m->registerHook(getBase()+0x122fb0, extract_virtual(this, (void($CCNode::*)(cocos2d::CCObject*)){&$CCNode::setUserObject}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::setVertexZ}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setVertexZ}))
            m->registerHook(getBase()+0x1229f0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::setVertexZ}));

        if (extract_virtual(&orig, (void($CCNode::*)(bool)){&$CCNode::setVisible}) != extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::setVisible}))
            m->registerHook(getBase()+0x122d60, extract_virtual(this, (void($CCNode::*)(bool)){&$CCNode::setVisible}));

        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::setZOrder}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::setZOrder}))
            m->registerHook(getBase()+0x1229a0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::setZOrder}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::sortAllChildren}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::sortAllChildren}))
            m->registerHook(getBase()+0x1237b0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::sortAllChildren}));

        if (extract_virtual(&orig, (void($CCNode::*)(int)){&$CCNode::stopActionByTag}) != extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::stopActionByTag}))
            m->registerHook(getBase()+0x123ec0, extract_virtual(this, (void($CCNode::*)(int)){&$CCNode::stopActionByTag}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::stopAllActions}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::stopAllActions}))
            m->registerHook(getBase()+0x123190, extract_virtual(this, (void($CCNode::*)()){&$CCNode::stopAllActions}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::unregisterScriptHandler}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::unregisterScriptHandler}))
            m->registerHook(getBase()+0x123dc0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::unregisterScriptHandler}));

        if (extract_virtual(&orig, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule}) != extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule}))
            m->registerHook(getBase()+0x124180, extract_virtual(this, (void($CCNode::*)(Cacao::CC_SCHED)){&$CCNode::unschedule}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::unscheduleAllSelectors}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::unscheduleAllSelectors}))
            m->registerHook(getBase()+0x1231b0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::unscheduleAllSelectors}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::unscheduleUpdate}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::unscheduleUpdate}))
            m->registerHook(getBase()+0x124060, extract_virtual(this, (void($CCNode::*)()){&$CCNode::unscheduleUpdate}));

        if (extract_virtual(&orig, (void($CCNode::*)(float)){&$CCNode::update}) != extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::update}))
            m->registerHook(getBase()+0x1241a0, extract_virtual(this, (void($CCNode::*)(float)){&$CCNode::update}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::updateTransform}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::updateTransform}))
            m->registerHook(getBase()+0x1249d0, extract_virtual(this, (void($CCNode::*)()){&$CCNode::updateTransform}));

        if (extract_virtual(&orig, (void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction}) != extract_virtual(this, (void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction}))
            m->registerHook(getBase()+0x1249c0, extract_virtual(this, (void($CCNode::*)(float, char const*)){&$CCNode::updateTweenAction}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::visit}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::visit}))
            m->registerHook(getBase()+0x123850, extract_virtual(this, (void($CCNode::*)()){&$CCNode::visit}));

        if (extract_virtual(&orig, (void($CCNode::*)()){&$CCNode::worldToNodeTransform}) != extract_virtual(this, (void($CCNode::*)()){&$CCNode::worldToNodeTransform}))
            m->registerHook(getBase()+0x124710, extract_virtual(this, (void($CCNode::*)()){&$CCNode::worldToNodeTransform}));
    }
};


class $CCNodeRGBA : public $CacBase {
 public:
    $CCNodeRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCNodeRGBA(bool dont_push) {}
    typedef CCNodeRGBA* __thistype;

    virtual void getColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125020))(this);
    }

    virtual void getDisplayedColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125040))(this);
    }

    virtual void getDisplayedOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124cf0))(this);
    }

    virtual void getOpacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124cd0))(this);
    }

    virtual void isCascadeColorEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x125320))(this);
    }

    virtual void isCascadeOpacityEnabled() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x124fe0))(this);
    }

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125340))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125000))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCNodeRGBA(true);
        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getColor}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getColor}))
            m->registerHook(getBase()+0x125020, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getColor}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedColor}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedColor}))
            m->registerHook(getBase()+0x125040, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedColor}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedOpacity}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedOpacity}))
            m->registerHook(getBase()+0x124cf0, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getDisplayedOpacity}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getOpacity}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getOpacity}))
            m->registerHook(getBase()+0x124cd0, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::getOpacity}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeColorEnabled}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeColorEnabled}))
            m->registerHook(getBase()+0x125320, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeColorEnabled}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeOpacityEnabled}) != extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeOpacityEnabled}))
            m->registerHook(getBase()+0x124fe0, extract_virtual(this, (void($CCNodeRGBA::*)()){&$CCNodeRGBA::isCascadeOpacityEnabled}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled}) != extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled}))
            m->registerHook(getBase()+0x125340, extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeColorEnabled}));

        if (extract_virtual(&orig, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled}) != extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled}))
            m->registerHook(getBase()+0x125000, extract_virtual(this, (void($CCNodeRGBA::*)(bool)){&$CCNodeRGBA::setCascadeOpacityEnabled}));
    }
};


class $CCObject : public $CacBase {
 public:
    $CCObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCObject(bool dont_push) {}
    typedef CCObject* __thistype;

    virtual void acceptVisitor(cocos2d::CCDataVisitor& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDataVisitor&)>(m->getOriginal(getBase()+0x250f30))(this, p0);
    }

    virtual void autorelease() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ed0))(this);
    }

    virtual void canEncode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250f90))(this);
    }

    virtual void encodeWithCoder(DS_Dictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(getBase()+0x250f70))(this, p0);
    }

    virtual void getTag() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250f50))(this);
    }

    virtual void isEqual(cocos2d::CCObject const* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject const*)>(m->getOriginal(getBase()+0x250f20))(this, p0);
    }

    virtual void release() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ea0))(this);
    }

    virtual void retain() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x250ec0))(this);
    }

    virtual void setTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x250f60))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x32660))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCObject(true);
        if (extract_virtual(&orig, (void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor}) != extract_virtual(this, (void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor}))
            m->registerHook(getBase()+0x250f30, extract_virtual(this, (void($CCObject::*)(cocos2d::CCDataVisitor&)){&$CCObject::acceptVisitor}));

        if (extract_virtual(&orig, (void($CCObject::*)()){&$CCObject::autorelease}) != extract_virtual(this, (void($CCObject::*)()){&$CCObject::autorelease}))
            m->registerHook(getBase()+0x250ed0, extract_virtual(this, (void($CCObject::*)()){&$CCObject::autorelease}));

        if (extract_virtual(&orig, (void($CCObject::*)()){&$CCObject::canEncode}) != extract_virtual(this, (void($CCObject::*)()){&$CCObject::canEncode}))
            m->registerHook(getBase()+0x250f90, extract_virtual(this, (void($CCObject::*)()){&$CCObject::canEncode}));

        if (extract_virtual(&orig, (void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder}) != extract_virtual(this, (void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder}))
            m->registerHook(getBase()+0x250f70, extract_virtual(this, (void($CCObject::*)(DS_Dictionary*)){&$CCObject::encodeWithCoder}));

        if (extract_virtual(&orig, (void($CCObject::*)()){&$CCObject::getTag}) != extract_virtual(this, (void($CCObject::*)()){&$CCObject::getTag}))
            m->registerHook(getBase()+0x250f50, extract_virtual(this, (void($CCObject::*)()){&$CCObject::getTag}));

        if (extract_virtual(&orig, (void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual}) != extract_virtual(this, (void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual}))
            m->registerHook(getBase()+0x250f20, extract_virtual(this, (void($CCObject::*)(cocos2d::CCObject const*)){&$CCObject::isEqual}));

        if (extract_virtual(&orig, (void($CCObject::*)()){&$CCObject::release}) != extract_virtual(this, (void($CCObject::*)()){&$CCObject::release}))
            m->registerHook(getBase()+0x250ea0, extract_virtual(this, (void($CCObject::*)()){&$CCObject::release}));

        if (extract_virtual(&orig, (void($CCObject::*)()){&$CCObject::retain}) != extract_virtual(this, (void($CCObject::*)()){&$CCObject::retain}))
            m->registerHook(getBase()+0x250ec0, extract_virtual(this, (void($CCObject::*)()){&$CCObject::retain}));

        if (extract_virtual(&orig, (void($CCObject::*)(int)){&$CCObject::setTag}) != extract_virtual(this, (void($CCObject::*)(int)){&$CCObject::setTag}))
            m->registerHook(getBase()+0x250f60, extract_virtual(this, (void($CCObject::*)(int)){&$CCObject::setTag}));

        if (extract_virtual(&orig, (void($CCObject::*)(float)){&$CCObject::update}) != extract_virtual(this, (void($CCObject::*)(float)){&$CCObject::update}))
            m->registerHook(getBase()+0x32660, extract_virtual(this, (void($CCObject::*)(float)){&$CCObject::update}));
    }
};


class $CCParticleSystem : public $CacBase {
 public:
    $CCParticleSystem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCParticleSystem(bool dont_push) {}
    typedef CCParticleSystem* __thistype;

    virtual void resetSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd50))(this);
    }

    virtual void resumeSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd40))(this);
    }

    virtual void stopSystem() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x46bd10))(this);
    }

    void apply_hooks() override {
        auto orig = $CCParticleSystem(true);
        if (extract_virtual(&orig, (void($CCParticleSystem::*)()){&$CCParticleSystem::resetSystem}) != extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::resetSystem}))
            m->registerHook(getBase()+0x46bd50, extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::resetSystem}));

        if (extract_virtual(&orig, (void($CCParticleSystem::*)()){&$CCParticleSystem::resumeSystem}) != extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::resumeSystem}))
            m->registerHook(getBase()+0x46bd40, extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::resumeSystem}));

        if (extract_virtual(&orig, (void($CCParticleSystem::*)()){&$CCParticleSystem::stopSystem}) != extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::stopSystem}))
            m->registerHook(getBase()+0x46bd10, extract_virtual(this, (void($CCParticleSystem::*)()){&$CCParticleSystem::stopSystem}));
    }
};


class $CCParticleSystemQuad : public $CacBase {
 public:
    $CCParticleSystemQuad() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCParticleSystemQuad(bool dont_push) {}
    typedef CCParticleSystemQuad* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x36b000))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCParticleSystemQuad(true);
        if (extract_virtual(&orig, (void($CCParticleSystemQuad::*)(char const*)){&$CCParticleSystemQuad::create}) != extract_virtual(this, (void($CCParticleSystemQuad::*)(char const*)){&$CCParticleSystemQuad::create}))
            m->registerHook(getBase()+0x36b000, extract_virtual(this, (void($CCParticleSystemQuad::*)(char const*)){&$CCParticleSystemQuad::create}));
    }
};


class $CCPoint : public $CacBase {
 public:
    $CCPoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCPoint(bool dont_push) {}
    typedef CCPoint* __thistype;

    virtual void equals(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1371d0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCPoint(true);
        if (extract_virtual(&orig, (void($CCPoint::*)(cocos2d::CCPoint const&)){&$CCPoint::equals}) != extract_virtual(this, (void($CCPoint::*)(cocos2d::CCPoint const&)){&$CCPoint::equals}))
            m->registerHook(getBase()+0x1371d0, extract_virtual(this, (void($CCPoint::*)(cocos2d::CCPoint const&)){&$CCPoint::equals}));
    }
};


class $CCRect : public $CacBase {
 public:
    $CCRect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCRect(bool dont_push) {}
    typedef CCRect* __thistype;

    virtual void containsPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1377b0))(this, p0);
    }

    virtual void equals(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1376a0))(this, p0);
    }

    virtual void getMaxX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137710))(this);
    }

    virtual void getMaxY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137760))(this);
    }

    virtual void getMinX() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x137750))(this);
    }

    virtual void getMinY() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1377a0))(this);
    }

    virtual void intersectsRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x137800))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCRect(true);
        if (extract_virtual(&orig, (void($CCRect::*)(cocos2d::CCPoint const&)){&$CCRect::containsPoint}) != extract_virtual(this, (void($CCRect::*)(cocos2d::CCPoint const&)){&$CCRect::containsPoint}))
            m->registerHook(getBase()+0x1377b0, extract_virtual(this, (void($CCRect::*)(cocos2d::CCPoint const&)){&$CCRect::containsPoint}));

        if (extract_virtual(&orig, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::equals}) != extract_virtual(this, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::equals}))
            m->registerHook(getBase()+0x1376a0, extract_virtual(this, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::equals}));

        if (extract_virtual(&orig, (void($CCRect::*)()){&$CCRect::getMaxX}) != extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMaxX}))
            m->registerHook(getBase()+0x137710, extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMaxX}));

        if (extract_virtual(&orig, (void($CCRect::*)()){&$CCRect::getMaxY}) != extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMaxY}))
            m->registerHook(getBase()+0x137760, extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMaxY}));

        if (extract_virtual(&orig, (void($CCRect::*)()){&$CCRect::getMinX}) != extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMinX}))
            m->registerHook(getBase()+0x137750, extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMinX}));

        if (extract_virtual(&orig, (void($CCRect::*)()){&$CCRect::getMinY}) != extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMinY}))
            m->registerHook(getBase()+0x1377a0, extract_virtual(this, (void($CCRect::*)()){&$CCRect::getMinY}));

        if (extract_virtual(&orig, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::intersectsRect}) != extract_virtual(this, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::intersectsRect}))
            m->registerHook(getBase()+0x137800, extract_virtual(this, (void($CCRect::*)(cocos2d::CCRect const&)){&$CCRect::intersectsRect}));
    }
};


class $CCRenderTexture : public $CacBase {
 public:
    $CCRenderTexture() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCRenderTexture(bool dont_push) {}
    typedef CCRenderTexture* __thistype;

    virtual void begin() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35ce10))(this);
    }

    virtual void create(int p0, int p1, cocos2d::CCTexture2DPixelFormat p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCTexture2DPixelFormat)>(m->getOriginal(getBase()+0x35c720))(this, p0, p1, p2);
    }

    virtual void end() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x35d2c0))(this);
    }

    virtual void newCCImage(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x35d7d0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCRenderTexture(true);
        if (extract_virtual(&orig, (void($CCRenderTexture::*)()){&$CCRenderTexture::begin}) != extract_virtual(this, (void($CCRenderTexture::*)()){&$CCRenderTexture::begin}))
            m->registerHook(getBase()+0x35ce10, extract_virtual(this, (void($CCRenderTexture::*)()){&$CCRenderTexture::begin}));

        if (extract_virtual(&orig, (void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create}) != extract_virtual(this, (void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create}))
            m->registerHook(getBase()+0x35c720, extract_virtual(this, (void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat)){&$CCRenderTexture::create}));

        if (extract_virtual(&orig, (void($CCRenderTexture::*)()){&$CCRenderTexture::end}) != extract_virtual(this, (void($CCRenderTexture::*)()){&$CCRenderTexture::end}))
            m->registerHook(getBase()+0x35d2c0, extract_virtual(this, (void($CCRenderTexture::*)()){&$CCRenderTexture::end}));

        if (extract_virtual(&orig, (void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage}) != extract_virtual(this, (void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage}))
            m->registerHook(getBase()+0x35d7d0, extract_virtual(this, (void($CCRenderTexture::*)(bool)){&$CCRenderTexture::newCCImage}));
    }
};


class $CCRepeatForever : public $CacBase {
 public:
    $CCRepeatForever() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCRepeatForever(bool dont_push) {}
    typedef CCRepeatForever* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*)>(m->getOriginal(getBase()+0x1f3920))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCRepeatForever(true);
        if (extract_virtual(&orig, (void($CCRepeatForever::*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create}) != extract_virtual(this, (void($CCRepeatForever::*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create}))
            m->registerHook(getBase()+0x1f3920, extract_virtual(this, (void($CCRepeatForever::*)(cocos2d::CCActionInterval*)){&$CCRepeatForever::create}));
    }
};


class $CCRotateBy : public $CacBase {
 public:
    $CCRotateBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCRotateBy(bool dont_push) {}
    typedef CCRotateBy* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f4c50))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCRotateBy(true);
        if (extract_virtual(&orig, (void($CCRotateBy::*)(float, float)){&$CCRotateBy::create}) != extract_virtual(this, (void($CCRotateBy::*)(float, float)){&$CCRotateBy::create}))
            m->registerHook(getBase()+0x1f4c50, extract_virtual(this, (void($CCRotateBy::*)(float, float)){&$CCRotateBy::create}));
    }
};


class $CCScaleTo : public $CacBase {
 public:
    $CCScaleTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCScaleTo(bool dont_push) {}
    typedef CCScaleTo* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f6ff0))(this, p0, p1);
    }

    virtual void create(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x1f70f0))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        auto orig = $CCScaleTo(true);
        if (extract_virtual(&orig, (void($CCScaleTo::*)(float, float)){&$CCScaleTo::create}) != extract_virtual(this, (void($CCScaleTo::*)(float, float)){&$CCScaleTo::create}))
            m->registerHook(getBase()+0x1f6ff0, extract_virtual(this, (void($CCScaleTo::*)(float, float)){&$CCScaleTo::create}));

        if (extract_virtual(&orig, (void($CCScaleTo::*)(float, float, float)){&$CCScaleTo::create}) != extract_virtual(this, (void($CCScaleTo::*)(float, float, float)){&$CCScaleTo::create}))
            m->registerHook(getBase()+0x1f70f0, extract_virtual(this, (void($CCScaleTo::*)(float, float, float)){&$CCScaleTo::create}));
    }
};


class $CCScene : public $CacBase {
 public:
    $CCScene() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCScene(bool dont_push) {}
    typedef CCScene* __thistype;

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13c140))(this);
    }

    void apply_hooks() override {
        auto orig = $CCScene(true);
        if (extract_virtual(&orig, (void($CCScene::*)()){&$CCScene::create}) != extract_virtual(this, (void($CCScene::*)()){&$CCScene::create}))
            m->registerHook(getBase()+0x13c140, extract_virtual(this, (void($CCScene::*)()){&$CCScene::create}));
    }
};


class $CCScheduler : public $CacBase {
 public:
    $CCScheduler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCScheduler(bool dont_push) {}
    typedef CCScheduler* __thistype;

    virtual void scheduleSelector(Cacao::CC_SCHED p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)>(m->getOriginal(getBase()+0x242b20))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, int, bool)>(m->getOriginal(getBase()+0x2438d0))(this, p0, p1, p2);
    }

    virtual void unscheduleAllForTarget(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x243e40))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCScheduler(true);
        if (extract_virtual(&orig, (void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector}) != extract_virtual(this, (void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector}))
            m->registerHook(getBase()+0x242b20, extract_virtual(this, (void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)){&$CCScheduler::scheduleSelector}));

        if (extract_virtual(&orig, (void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget}) != extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget}))
            m->registerHook(getBase()+0x2438d0, extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*, int, bool)){&$CCScheduler::scheduleUpdateForTarget}));

        if (extract_virtual(&orig, (void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget}) != extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget}))
            m->registerHook(getBase()+0x243e40, extract_virtual(this, (void($CCScheduler::*)(cocos2d::CCObject*)){&$CCScheduler::unscheduleAllForTarget}));
    }
};


class $CCSprite : public $CacBase {
 public:
    $CCSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCSprite(bool dont_push) {}
    typedef CCSprite* __thistype;

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x134190))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1341a0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1341b0))(this, p0, p1, p2);
    }

    virtual void create() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x132df0))(this);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132a80))(this, p0);
    }

    virtual void createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x132cb0))(this, p0);
    }

    virtual void createWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132dc0))(this, p0);
    }

    virtual void displayFrame() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135760))(this);
    }

    virtual void draw() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x134070))(this);
    }

    virtual void getBatchNode() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135910))(this);
    }

    virtual void getBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x505a0))(this);
    }

    virtual void getTexture() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135c00))(this);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134b60))(this, p0);
    }

    virtual void initWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x133180))(this, p0);
    }

    virtual void initWithFile(char const* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133210))(this, p0, p1);
    }

    virtual void initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x133270))(this, p0);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1330f0))(this, p0, p1);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(getBase()+0x132f10))(this, p0, p1, p2);
    }

    virtual void isDirty() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x505b0))(this);
    }

    virtual void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x1356d0))(this, p0);
    }

    virtual void isOpacityModifyRGB() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135350))(this);
    }

    virtual void refreshTextureRect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x133520))(this);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134340))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x134300))(this, p0, p1);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x134270))(this, p0, p1);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134af0))(this, p0);
    }

    virtual void setBatchNode(cocos2d::CCSpriteBatchNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteBatchNode*)>(m->getOriginal(getBase()+0x135920))(this, p0);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x50590))(this, p0);
    }

    virtual void setChildOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x134f50))(this, p0);
    }

    virtual void setDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x505c0))(this, p0);
    }

    virtual void setDirtyRecursively(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1345b0))(this, p0);
    }

    virtual void setDisplayFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x135610))(this, p0);
    }

    virtual void setDisplayFrameWithAnimationName(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x135680))(this, p0, p1);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134c30))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x135200))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134650))(this, p0);
    }

    virtual void setReorderChildDirtyRecursively() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x134550))(this);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134740))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1347b0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134820))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134890))(this, p0);
    }

    virtual void setTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x135a90))(this, p0);
    }

    virtual void setTextureCoords(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133910))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133560))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&, bool, cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x133580))(this, p0, p1, p2);
    }

    virtual void setVertexRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1338f0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134a80))(this, p0);
    }

    virtual void sortAllChildren() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1343f0))(this);
    }

    virtual void updateBlendFunc() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x135a20))(this);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x135370))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x1354c0))(this, p0);
    }

    virtual void updateTransform() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x133b70))(this);
    }

    void apply_hooks() override {
        auto orig = $CCSprite(true);
        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild}))
            m->registerHook(getBase()+0x134190, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*)){&$CCSprite::addChild}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild}))
            m->registerHook(getBase()+0x1341a0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::addChild}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild}))
            m->registerHook(getBase()+0x1341b0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int, int)){&$CCSprite::addChild}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::create}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::create}))
            m->registerHook(getBase()+0x132df0, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::create}));

        if (extract_virtual(&orig, (void($CCSprite::*)(char const*)){&$CCSprite::create}) != extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::create}))
            m->registerHook(getBase()+0x132a80, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::create}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame}))
            m->registerHook(getBase()+0x132cb0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::createWithSpriteFrame}));

        if (extract_virtual(&orig, (void($CCSprite::*)(char const*)){&$CCSprite::createWithSpriteFrameName}) != extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::createWithSpriteFrameName}))
            m->registerHook(getBase()+0x132dc0, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::createWithSpriteFrameName}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::displayFrame}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::displayFrame}))
            m->registerHook(getBase()+0x135760, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::displayFrame}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::draw}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::draw}))
            m->registerHook(getBase()+0x134070, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::draw}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::getBatchNode}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getBatchNode}))
            m->registerHook(getBase()+0x135910, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getBatchNode}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::getBlendFunc}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getBlendFunc}))
            m->registerHook(getBase()+0x505a0, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getBlendFunc}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::getTexture}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getTexture}))
            m->registerHook(getBase()+0x135c00, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::getTexture}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition}))
            m->registerHook(getBase()+0x134b60, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::ignoreAnchorPointForPosition}));

        if (extract_virtual(&orig, (void($CCSprite::*)(char const*)){&$CCSprite::initWithFile}) != extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::initWithFile}))
            m->registerHook(getBase()+0x133180, extract_virtual(this, (void($CCSprite::*)(char const*)){&$CCSprite::initWithFile}));

        if (extract_virtual(&orig, (void($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile}) != extract_virtual(this, (void($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile}))
            m->registerHook(getBase()+0x133210, extract_virtual(this, (void($CCSprite::*)(char const*, cocos2d::CCRect const&)){&$CCSprite::initWithFile}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame}))
            m->registerHook(getBase()+0x133270, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::initWithSpriteFrame}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture}))
            m->registerHook(getBase()+0x1330f0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSprite::initWithTexture}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture}))
            m->registerHook(getBase()+0x132f10, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSprite::initWithTexture}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::isDirty}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::isDirty}))
            m->registerHook(getBase()+0x505b0, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::isDirty}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed}))
            m->registerHook(getBase()+0x1356d0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::isFrameDisplayed}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::isOpacityModifyRGB}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::isOpacityModifyRGB}))
            m->registerHook(getBase()+0x135350, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::isOpacityModifyRGB}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::refreshTextureRect}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::refreshTextureRect}))
            m->registerHook(getBase()+0x133520, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::refreshTextureRect}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup}))
            m->registerHook(getBase()+0x134340, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::removeAllChildrenWithCleanup}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild}))
            m->registerHook(getBase()+0x134300, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, bool)){&$CCSprite::removeChild}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild}))
            m->registerHook(getBase()+0x134270, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCNode*, int)){&$CCSprite::reorderChild}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint}))
            m->registerHook(getBase()+0x134af0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setAnchorPoint}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode}))
            m->registerHook(getBase()+0x135920, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteBatchNode*)){&$CCSprite::setBatchNode}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc}))
            m->registerHook(getBase()+0x50590, extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccBlendFunc)){&$CCSprite::setBlendFunc}));

        if (extract_virtual(&orig, (void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity}) != extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity}))
            m->registerHook(getBase()+0x134f50, extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::setChildOpacity}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::setDirty}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirty}))
            m->registerHook(getBase()+0x505c0, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirty}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively}))
            m->registerHook(getBase()+0x1345b0, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setDirtyRecursively}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame}))
            m->registerHook(getBase()+0x135610, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCSpriteFrame*)){&$CCSprite::setDisplayFrame}));

        if (extract_virtual(&orig, (void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName}) != extract_virtual(this, (void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName}))
            m->registerHook(getBase()+0x135680, extract_virtual(this, (void($CCSprite::*)(char const*, int)){&$CCSprite::setDisplayFrameWithAnimationName}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::setFlipY}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setFlipY}))
            m->registerHook(getBase()+0x134c30, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setFlipY}));

        if (extract_virtual(&orig, (void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB}) != extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB}))
            m->registerHook(getBase()+0x135200, extract_virtual(this, (void($CCSprite::*)(bool)){&$CCSprite::setOpacityModifyRGB}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition}))
            m->registerHook(getBase()+0x134650, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCPoint const&)){&$CCSprite::setPosition}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::setReorderChildDirtyRecursively}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::setReorderChildDirtyRecursively}))
            m->registerHook(getBase()+0x134550, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::setReorderChildDirtyRecursively}));

        if (extract_virtual(&orig, (void($CCSprite::*)(float)){&$CCSprite::setRotationX}) != extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationX}))
            m->registerHook(getBase()+0x134740, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationX}));

        if (extract_virtual(&orig, (void($CCSprite::*)(float)){&$CCSprite::setRotationY}) != extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationY}))
            m->registerHook(getBase()+0x1347b0, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setRotationY}));

        if (extract_virtual(&orig, (void($CCSprite::*)(float)){&$CCSprite::setSkewX}) != extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewX}))
            m->registerHook(getBase()+0x134820, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewX}));

        if (extract_virtual(&orig, (void($CCSprite::*)(float)){&$CCSprite::setSkewY}) != extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewY}))
            m->registerHook(getBase()+0x134890, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setSkewY}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture}))
            m->registerHook(getBase()+0x135a90, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCTexture2D*)){&$CCSprite::setTexture}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords}))
            m->registerHook(getBase()+0x133910, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureCoords}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect}))
            m->registerHook(getBase()+0x133560, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setTextureRect}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect}))
            m->registerHook(getBase()+0x133580, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&)){&$CCSprite::setTextureRect}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect}))
            m->registerHook(getBase()+0x1338f0, extract_virtual(this, (void($CCSprite::*)(cocos2d::CCRect const&)){&$CCSprite::setVertexRect}));

        if (extract_virtual(&orig, (void($CCSprite::*)(float)){&$CCSprite::setVertexZ}) != extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setVertexZ}))
            m->registerHook(getBase()+0x134a80, extract_virtual(this, (void($CCSprite::*)(float)){&$CCSprite::setVertexZ}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::sortAllChildren}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::sortAllChildren}))
            m->registerHook(getBase()+0x1343f0, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::sortAllChildren}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::updateBlendFunc}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::updateBlendFunc}))
            m->registerHook(getBase()+0x135a20, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::updateBlendFunc}));

        if (extract_virtual(&orig, (void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor}) != extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor}))
            m->registerHook(getBase()+0x135370, extract_virtual(this, (void($CCSprite::*)(cocos2d::_ccColor3B const&)){&$CCSprite::updateDisplayedColor}));

        if (extract_virtual(&orig, (void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity}) != extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity}))
            m->registerHook(getBase()+0x1354c0, extract_virtual(this, (void($CCSprite::*)(unsigned char)){&$CCSprite::updateDisplayedOpacity}));

        if (extract_virtual(&orig, (void($CCSprite::*)()){&$CCSprite::updateTransform}) != extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::updateTransform}))
            m->registerHook(getBase()+0x133b70, extract_virtual(this, (void($CCSprite::*)()){&$CCSprite::updateTransform}));
    }
};


class $CCSpriteBatchNode : public $CacBase {
 public:
    $CCSpriteBatchNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCSpriteBatchNode(bool dont_push) {}
    typedef CCSpriteBatchNode* __thistype;

    virtual void createWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, unsigned int)>(m->getOriginal(getBase()+0xbb310))(this, p0, p1);
    }

    virtual void getUsedAtlasCapacity() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xbc6b0))(this);
    }

    virtual void increaseAtlasCapacity(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0xbc670))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCSpriteBatchNode(true);
        if (extract_virtual(&orig, (void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture}) != extract_virtual(this, (void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture}))
            m->registerHook(getBase()+0xbb310, extract_virtual(this, (void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int)){&$CCSpriteBatchNode::createWithTexture}));

        if (extract_virtual(&orig, (void($CCSpriteBatchNode::*)()){&$CCSpriteBatchNode::getUsedAtlasCapacity}) != extract_virtual(this, (void($CCSpriteBatchNode::*)()){&$CCSpriteBatchNode::getUsedAtlasCapacity}))
            m->registerHook(getBase()+0xbc6b0, extract_virtual(this, (void($CCSpriteBatchNode::*)()){&$CCSpriteBatchNode::getUsedAtlasCapacity}));

        if (extract_virtual(&orig, (void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity}) != extract_virtual(this, (void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity}))
            m->registerHook(getBase()+0xbc670, extract_virtual(this, (void($CCSpriteBatchNode::*)(unsigned int)){&$CCSpriteBatchNode::increaseAtlasCapacity}));
    }
};


class $CCSpriteFrameCache : public $CacBase {
 public:
    $CCSpriteFrameCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCSpriteFrameCache(bool dont_push) {}
    typedef CCSpriteFrameCache* __thistype;

    virtual void addSpriteFramesWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x199a10))(this, p0);
    }

    virtual void sharedSpriteFrameCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x198970))(this);
    }

    virtual void spriteFrameByName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x19a7e0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCSpriteFrameCache(true);
        if (extract_virtual(&orig, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile}) != extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile}))
            m->registerHook(getBase()+0x199a10, extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::addSpriteFramesWithFile}));

        if (extract_virtual(&orig, (void($CCSpriteFrameCache::*)()){&$CCSpriteFrameCache::sharedSpriteFrameCache}) != extract_virtual(this, (void($CCSpriteFrameCache::*)()){&$CCSpriteFrameCache::sharedSpriteFrameCache}))
            m->registerHook(getBase()+0x198970, extract_virtual(this, (void($CCSpriteFrameCache::*)()){&$CCSpriteFrameCache::sharedSpriteFrameCache}));

        if (extract_virtual(&orig, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName}) != extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName}))
            m->registerHook(getBase()+0x19a7e0, extract_virtual(this, (void($CCSpriteFrameCache::*)(char const*)){&$CCSpriteFrameCache::spriteFrameByName}));
    }
};


class $CCString : public $CacBase {
 public:
    $CCString() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCString(bool dont_push) {}
    typedef CCString* __thistype;

    virtual void boolValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c810))(this);
    }

    virtual void doubleValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c7f0))(this);
    }

    virtual void floatValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c7d0))(this);
    }

    virtual void getCString() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c470))(this);
    }

    virtual void intValue() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x44c780))(this);
    }

    void apply_hooks() override {
        auto orig = $CCString(true);
        if (extract_virtual(&orig, (void($CCString::*)()){&$CCString::boolValue}) != extract_virtual(this, (void($CCString::*)()){&$CCString::boolValue}))
            m->registerHook(getBase()+0x44c810, extract_virtual(this, (void($CCString::*)()){&$CCString::boolValue}));

        if (extract_virtual(&orig, (void($CCString::*)()){&$CCString::doubleValue}) != extract_virtual(this, (void($CCString::*)()){&$CCString::doubleValue}))
            m->registerHook(getBase()+0x44c7f0, extract_virtual(this, (void($CCString::*)()){&$CCString::doubleValue}));

        if (extract_virtual(&orig, (void($CCString::*)()){&$CCString::floatValue}) != extract_virtual(this, (void($CCString::*)()){&$CCString::floatValue}))
            m->registerHook(getBase()+0x44c7d0, extract_virtual(this, (void($CCString::*)()){&$CCString::floatValue}));

        if (extract_virtual(&orig, (void($CCString::*)()){&$CCString::getCString}) != extract_virtual(this, (void($CCString::*)()){&$CCString::getCString}))
            m->registerHook(getBase()+0x44c470, extract_virtual(this, (void($CCString::*)()){&$CCString::getCString}));

        if (extract_virtual(&orig, (void($CCString::*)()){&$CCString::intValue}) != extract_virtual(this, (void($CCString::*)()){&$CCString::intValue}))
            m->registerHook(getBase()+0x44c780, extract_virtual(this, (void($CCString::*)()){&$CCString::intValue}));
    }
};


class $CCTexture2D : public $CacBase {
 public:
    $CCTexture2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTexture2D(bool dont_push) {}
    typedef CCTexture2D* __thistype;

    virtual void initWithImage(cocos2d::CCImage* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCImage*)>(m->getOriginal(getBase()+0x246940))(this, p0);
    }

    virtual void setTexParameters(cocos2d::_ccTexParams* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccTexParams*)>(m->getOriginal(getBase()+0x247980))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCTexture2D(true);
        if (extract_virtual(&orig, (void($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage}) != extract_virtual(this, (void($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage}))
            m->registerHook(getBase()+0x246940, extract_virtual(this, (void($CCTexture2D::*)(cocos2d::CCImage*)){&$CCTexture2D::initWithImage}));

        if (extract_virtual(&orig, (void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters}) != extract_virtual(this, (void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters}))
            m->registerHook(getBase()+0x247980, extract_virtual(this, (void($CCTexture2D::*)(cocos2d::_ccTexParams*)){&$CCTexture2D::setTexParameters}));
    }
};


class $CCTextureCache : public $CacBase {
 public:
    $CCTextureCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTextureCache(bool dont_push) {}
    typedef CCTextureCache* __thistype;

    virtual void addImage(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x358120))(this, p0, p1);
    }

    virtual void sharedTextureCache() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x356e00))(this);
    }

    void apply_hooks() override {
        auto orig = $CCTextureCache(true);
        if (extract_virtual(&orig, (void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage}) != extract_virtual(this, (void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage}))
            m->registerHook(getBase()+0x358120, extract_virtual(this, (void($CCTextureCache::*)(char const*, bool)){&$CCTextureCache::addImage}));

        if (extract_virtual(&orig, (void($CCTextureCache::*)()){&$CCTextureCache::sharedTextureCache}) != extract_virtual(this, (void($CCTextureCache::*)()){&$CCTextureCache::sharedTextureCache}))
            m->registerHook(getBase()+0x356e00, extract_virtual(this, (void($CCTextureCache::*)()){&$CCTextureCache::sharedTextureCache}));
    }
};


class $CCTintTo : public $CacBase {
 public:
    $CCTintTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTintTo(bool dont_push) {}
    typedef CCTintTo* __thistype;

    virtual void create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char, unsigned char, unsigned char)>(m->getOriginal(getBase()+0x1f82a0))(this, p0, p1, p2, p3);
    }

    void apply_hooks() override {
        auto orig = $CCTintTo(true);
        if (extract_virtual(&orig, (void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create}) != extract_virtual(this, (void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create}))
            m->registerHook(getBase()+0x1f82a0, extract_virtual(this, (void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char)){&$CCTintTo::create}));
    }
};


class $CCTouchDispatcher : public $CacBase {
 public:
    $CCTouchDispatcher() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTouchDispatcher(bool dont_push) {}
    typedef CCTouchDispatcher* __thistype;

    virtual void decrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f70))(this, p0);
    }

    virtual void incrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f60))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCTouchDispatcher(true);
        if (extract_virtual(&orig, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio}) != extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio}))
            m->registerHook(getBase()+0x280f70, extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::decrementForcePrio}));

        if (extract_virtual(&orig, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio}) != extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio}))
            m->registerHook(getBase()+0x280f60, extract_virtual(this, (void($CCTouchDispatcher::*)(int)){&$CCTouchDispatcher::incrementForcePrio}));
    }
};


class $CCTransitionFade : public $CacBase {
 public:
    $CCTransitionFade() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCTransitionFade(bool dont_push) {}
    typedef CCTransitionFade* __thistype;

    virtual void create(float p0, cocos2d::CCScene* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCScene*)>(m->getOriginal(getBase()+0x8ea30))(this, p0, p1);
    }

    void apply_hooks() override {
        auto orig = $CCTransitionFade(true);
        if (extract_virtual(&orig, (void($CCTransitionFade::*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create}) != extract_virtual(this, (void($CCTransitionFade::*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create}))
            m->registerHook(getBase()+0x8ea30, extract_virtual(this, (void($CCTransitionFade::*)(float, cocos2d::CCScene*)){&$CCTransitionFade::create}));
    }
};


class $ZipUtils : public $CacBase {
 public:
    $ZipUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $ZipUtils(bool dont_push) {}
    typedef ZipUtils* __thistype;

    virtual void compressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xe9a50))(this, p0, p1, p2);
    }

    virtual void decompressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xea380))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        auto orig = $ZipUtils(true);
        if (extract_virtual(&orig, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::compressString}) != extract_virtual(this, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::compressString}))
            m->registerHook(getBase()+0xe9a50, extract_virtual(this, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::compressString}));

        if (extract_virtual(&orig, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString}) != extract_virtual(this, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString}))
            m->registerHook(getBase()+0xea380, extract_virtual(this, (void($ZipUtils::*)(std::string, bool, int)){&$ZipUtils::decompressString}));
    }
};


class $CCControlColourPicker : public $CacBase {
 public:
    $CCControlColourPicker() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCControlColourPicker(bool dont_push) {}
    typedef CCControlColourPicker* __thistype;

    virtual void setColorValue(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1aac10))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCControlColourPicker(true);
        if (extract_virtual(&orig, (void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue}) != extract_virtual(this, (void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue}))
            m->registerHook(getBase()+0x1aac10, extract_virtual(this, (void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&)){&$CCControlColourPicker::setColorValue}));
    }
};


class $CCControlUtils : public $CacBase {
 public:
    $CCControlUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCControlUtils(bool dont_push) {}
    typedef CCControlUtils* __thistype;

    virtual void HSVfromRGB(cocos2d::extension::RGBA p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::RGBA)>(m->getOriginal(getBase()+0x1e6750))(this, p0);
    }

    virtual void RGBfromHSV(cocos2d::extension::HSV p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::HSV)>(m->getOriginal(getBase()+0x1e6850))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCControlUtils(true);
        if (extract_virtual(&orig, (void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB}) != extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB}))
            m->registerHook(getBase()+0x1e6750, extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::RGBA)){&$CCControlUtils::HSVfromRGB}));

        if (extract_virtual(&orig, (void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV}) != extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV}))
            m->registerHook(getBase()+0x1e6850, extract_virtual(this, (void($CCControlUtils::*)(cocos2d::extension::HSV)){&$CCControlUtils::RGBfromHSV}));
    }
};


class $CCScale9Sprite : public $CacBase {
 public:
    $CCScale9Sprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    $CCScale9Sprite(bool dont_push) {}
    typedef CCScale9Sprite* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2130d0))(this, p0);
    }

    virtual void create(char const* p0, cocos2d::CCRect p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x212ef0))(this, p0, p1);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2127c0))(this, p0);
    }

    void apply_hooks() override {
        auto orig = $CCScale9Sprite(true);
        if (extract_virtual(&orig, (void($CCScale9Sprite::*)(char const*)){&$CCScale9Sprite::create}) != extract_virtual(this, (void($CCScale9Sprite::*)(char const*)){&$CCScale9Sprite::create}))
            m->registerHook(getBase()+0x2130d0, extract_virtual(this, (void($CCScale9Sprite::*)(char const*)){&$CCScale9Sprite::create}));

        if (extract_virtual(&orig, (void($CCScale9Sprite::*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create}) != extract_virtual(this, (void($CCScale9Sprite::*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create}))
            m->registerHook(getBase()+0x212ef0, extract_virtual(this, (void($CCScale9Sprite::*)(char const*, cocos2d::CCRect)){&$CCScale9Sprite::create}));

        if (extract_virtual(&orig, (void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize}) != extract_virtual(this, (void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize}))
            m->registerHook(getBase()+0x2127c0, extract_virtual(this, (void($CCScale9Sprite::*)(cocos2d::CCSize const&)){&$CCScale9Sprite::setContentSize}));
    }
};
