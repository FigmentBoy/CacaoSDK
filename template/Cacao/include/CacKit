//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif
#define CAC_HOOKS void __cacinj() __attribute__((constructor)); void __cacinj() {
#define END_CAC_HOOKS \
    for(auto& i : __cackit::glob) {i->apply_hooks();};m->enable();}

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};


class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}


class $AnimatedGameObject : public $CacBase {
 public:
    $AnimatedGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $AnimatedGameObject* __thistype;

    virtual void playAnimation(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xc93d0))(this, p0);
    }

    virtual void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0xc8450))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($AnimatedGameObject::*)(int);
        m->registerHook(getBase()+0xc93d0, extract_virtual(this, tf0{&$AnimatedGameObject::playAnimation}));

		using tf1 = void($AnimatedGameObject::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0xc8450, extract_virtual(this, tf1{&$AnimatedGameObject::updateChildSpriteColor}));
    }
};


class $AudioEffectsLayer : public $CacBase {
 public:
    $AudioEffectsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $AudioEffectsLayer* __thistype;

    virtual void audioStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x271f40))(this, p0);
    }

    virtual void create(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x271a00))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($AudioEffectsLayer::*)(float);
        m->registerHook(getBase()+0x271f40, extract_virtual(this, tf0{&$AudioEffectsLayer::audioStep}));

		using tf1 = void($AudioEffectsLayer::*)(std::string);
        m->registerHook(getBase()+0x271a00, extract_virtual(this, tf1{&$AudioEffectsLayer::create}));
    }
};


class $ButtonSprite : public $CacBase {
 public:
    $ButtonSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ButtonSprite* __thistype;

    virtual void updateBGImage(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x502d0))(this, p0);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x4fa10))(this, p0);
    }

    virtual void create(char const* p0, int p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, int, float, bool)>(m->getOriginal(getBase()+0x4fa40))(this, p0, p1, p2, p3, p4);
    }

void apply_hooks() override {
		using tf0 = void($ButtonSprite::*)(char const*);
        m->registerHook(getBase()+0x502d0, extract_virtual(this, tf0{&$ButtonSprite::updateBGImage}));

		using tf1 = void($ButtonSprite::*)(char const*);
        m->registerHook(getBase()+0x4fa10, extract_virtual(this, tf1{&$ButtonSprite::create}));

		using tf2 = void($ButtonSprite::*)(char const*, int, int, float, bool);
        m->registerHook(getBase()+0x4fa40, extract_virtual(this, tf2{&$ButtonSprite::create}));
    }
};


class $CCAnimatedSprite : public $CacBase {
 public:
    $CCAnimatedSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCAnimatedSprite* __thistype;

    virtual void runAnimation(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1a6430))(this, p0);
    }

    virtual void tweenToAnimation(std::string p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float)>(m->getOriginal(getBase()+0x1a65b0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCAnimatedSprite::*)(std::string);
        m->registerHook(getBase()+0x1a6430, extract_virtual(this, tf0{&$CCAnimatedSprite::runAnimation}));

		using tf1 = void($CCAnimatedSprite::*)(std::string, float);
        m->registerHook(getBase()+0x1a65b0, extract_virtual(this, tf1{&$CCAnimatedSprite::tweenToAnimation}));
    }
};


class $CCCircleWave : public $CacBase {
 public:
    $CCCircleWave() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCCircleWave* __thistype;

    virtual void create(float p0, float p1, float p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool)>(m->getOriginal(getBase()+0xbd270))(this, p0, p1, p2, p3);
    }

    virtual void create(float p0, float p1, float p2, bool p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, bool, bool)>(m->getOriginal(getBase()+0xbd290))(this, p0, p1, p2, p3, p4);
    }

    virtual void followObject(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0xbd670))(this, p0, p1);
    }

    virtual void updatePosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xbd630))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCCircleWave::*)(float, float, float, bool);
        m->registerHook(getBase()+0xbd270, extract_virtual(this, tf0{&$CCCircleWave::create}));

		using tf1 = void($CCCircleWave::*)(float, float, float, bool, bool);
        m->registerHook(getBase()+0xbd290, extract_virtual(this, tf1{&$CCCircleWave::create}));

		using tf2 = void($CCCircleWave::*)(cocos2d::CCNode*, bool);
        m->registerHook(getBase()+0xbd670, extract_virtual(this, tf2{&$CCCircleWave::followObject}));

		using tf3 = void($CCCircleWave::*)(float);
        m->registerHook(getBase()+0xbd630, extract_virtual(this, tf3{&$CCCircleWave::updatePosition}));
    }
};


class $CCLightFlash : public $CacBase {
 public:
    $CCLightFlash() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCLightFlash* __thistype;

    virtual void playEffect(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13, float p14, float p15, int p16, bool p17, bool p18, float p19) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float)>(m->getOriginal(getBase()+0x295900))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19);
    }

void apply_hooks() override {
		using tf0 = void($CCLightFlash::*)(cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
        m->registerHook(getBase()+0x295900, extract_virtual(this, tf0{&$CCLightFlash::playEffect}));
    }
};


class $CCMenuItemToggler : public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMenuItemToggler* __thistype;

    virtual void toggle(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x38950))(this, p0);
    }

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x38a40))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x38400))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CCMenuItemToggler::*)(bool);
        m->registerHook(getBase()+0x38950, extract_virtual(this, tf0{&$CCMenuItemToggler::toggle}));

		using tf1 = void($CCMenuItemToggler::*)(float);
        m->registerHook(getBase()+0x38a40, extract_virtual(this, tf1{&$CCMenuItemToggler::setSizeMult}));

		using tf2 = void($CCMenuItemToggler::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL);
        m->registerHook(getBase()+0x38400, extract_virtual(this, tf2{&$CCMenuItemToggler::create}));
    }
};


class $CCSpritePlus : public $CacBase {
 public:
    $CCSpritePlus() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSpritePlus* __thistype;

    virtual void initWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x248670))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCSpritePlus::*)(char const*);
        m->registerHook(getBase()+0x248670, extract_virtual(this, tf0{&$CCSpritePlus::initWithSpriteFrameName}));
    }
};


class $CCTextInputNode : public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTextInputNode* __thistype;

    virtual void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x5da90))(this, p0);
    }

    virtual void setLabelPlaceholderScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da70))(this, p0);
    }

    virtual void setString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d3e0))(this, p0);
    }

    virtual void create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        return reinterpret_cast<void(*)(decltype(this), float, float, char const*, char const*, int, char const*)>(m->getOriginal(getBase()+0x5cfb0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void setAllowedChars(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x5d360))(this, p0);
    }

    virtual void setMaxLabelScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da30))(this, p0);
    }

    virtual void setMaxLabelWidth(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x5da50))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCTextInputNode::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x5da90, extract_virtual(this, tf0{&$CCTextInputNode::setLabelPlaceholderColor}));

		using tf1 = void($CCTextInputNode::*)(float);
        m->registerHook(getBase()+0x5da70, extract_virtual(this, tf1{&$CCTextInputNode::setLabelPlaceholderScale}));

		using tf2 = void($CCTextInputNode::*)(std::string);
        m->registerHook(getBase()+0x5d3e0, extract_virtual(this, tf2{&$CCTextInputNode::setString}));

		using tf3 = void($CCTextInputNode::*)(float, float, char const*, char const*, int, char const*);
        m->registerHook(getBase()+0x5cfb0, extract_virtual(this, tf3{&$CCTextInputNode::create}));

		using tf4 = void($CCTextInputNode::*)(std::string);
        m->registerHook(getBase()+0x5d360, extract_virtual(this, tf4{&$CCTextInputNode::setAllowedChars}));

		using tf5 = void($CCTextInputNode::*)(float);
        m->registerHook(getBase()+0x5da30, extract_virtual(this, tf5{&$CCTextInputNode::setMaxLabelScale}));

		using tf6 = void($CCTextInputNode::*)(float);
        m->registerHook(getBase()+0x5da50, extract_virtual(this, tf6{&$CCTextInputNode::setMaxLabelWidth}));
    }
};


class $CollisionBlockPopup : public $CacBase {
 public:
    $CollisionBlockPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CollisionBlockPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x130010))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CollisionBlockPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x130010, extract_virtual(this, tf0{&$CollisionBlockPopup::create}));
    }
};


class $CollisionTriggerAction : public $CacBase {
 public:
    $CollisionTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CollisionTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x176ee0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CollisionTriggerAction::*)(std::string);
        m->registerHook(getBase()+0x176ee0, extract_virtual(this, tf0{&$CollisionTriggerAction::createFromString}));
    }
};


class $ColorAction : public $CacBase {
 public:
    $ColorAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ColorAction* __thistype;

    virtual void setupFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0x17f310))(this, p0);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17f270))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($ColorAction::*)(cocos2d::CCDictionary*);
        m->registerHook(getBase()+0x17f310, extract_virtual(this, tf0{&$ColorAction::setupFromDict}));

		using tf1 = void($ColorAction::*)(std::string);
        m->registerHook(getBase()+0x17f270, extract_virtual(this, tf1{&$ColorAction::setupFromString}));
    }
};


class $ColorChannelSprite : public $CacBase {
 public:
    $ColorChannelSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ColorChannelSprite* __thistype;

    virtual void updateValues(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x16e2e0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($ColorChannelSprite::*)(ColorAction*);
        m->registerHook(getBase()+0x16e2e0, extract_virtual(this, tf0{&$ColorChannelSprite::updateValues}));
    }
};


class $ColorSelectPopup : public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ColorSelectPopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x423320))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41eb70))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
    }

    virtual void onDefault(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4220e0))(this, p0);
    }

    virtual void onMultiTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422680))(this, p0);
    }

    virtual void onPlayerColor1(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x422500))(this, p0);
    }

    virtual void onPlayerColor2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4225c0))(this, p0);
    }

    virtual void onSpawnedByTrigger(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227f0))(this, p0);
    }

    virtual void onToggleHSVMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4227b0))(this, p0);
    }

    virtual void onTouchTriggered(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x4228b0))(this, p0);
    }

    virtual void sliderChanged(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x421ca0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($ColorSelectPopup::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x423320, extract_virtual(this, tf0{&$ColorSelectPopup::colorValueChanged}));

		using tf1 = void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x41eb70, extract_virtual(this, tf1{&$ColorSelectPopup::create}));

		using tf2 = void($ColorSelectPopup::*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*);
        m->registerHook(getBase()+0x41ee70, extract_virtual(this, tf2{&$ColorSelectPopup::init}));

		using tf3 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x4220e0, extract_virtual(this, tf3{&$ColorSelectPopup::onDefault}));

		using tf4 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x422680, extract_virtual(this, tf4{&$ColorSelectPopup::onMultiTrigger}));

		using tf5 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x422500, extract_virtual(this, tf5{&$ColorSelectPopup::onPlayerColor1}));

		using tf6 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x4225c0, extract_virtual(this, tf6{&$ColorSelectPopup::onPlayerColor2}));

		using tf7 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x4227f0, extract_virtual(this, tf7{&$ColorSelectPopup::onSpawnedByTrigger}));

		using tf8 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x4227b0, extract_virtual(this, tf8{&$ColorSelectPopup::onToggleHSVMode}));

		using tf9 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x4228b0, extract_virtual(this, tf9{&$ColorSelectPopup::onTouchTriggered}));

		using tf10 = void($ColorSelectPopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x421ca0, extract_virtual(this, tf10{&$ColorSelectPopup::sliderChanged}));
    }
};


class $CountTriggerAction : public $CacBase {
 public:
    $CountTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CountTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1754f0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CountTriggerAction::*)(std::string);
        m->registerHook(getBase()+0x1754f0, extract_virtual(this, tf0{&$CountTriggerAction::createFromString}));
    }
};


class $CustomizeObjectLayer : public $CacBase {
 public:
    $CustomizeObjectLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CustomizeObjectLayer* __thistype;

    virtual void colorSelectClosed(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xe1050))(this, p0);
    }

    virtual void create(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd340))(this, p0, p1);
    }

    virtual void init(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xdd560))(this, p0, p1);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0xe1430))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CustomizeObjectLayer::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0xe1050, extract_virtual(this, tf0{&$CustomizeObjectLayer::colorSelectClosed}));

		using tf1 = void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0xdd340, extract_virtual(this, tf1{&$CustomizeObjectLayer::create}));

		using tf2 = void($CustomizeObjectLayer::*)(GameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0xdd560, extract_virtual(this, tf2{&$CustomizeObjectLayer::init}));

		using tf3 = void($CustomizeObjectLayer::*)(CCTextInputNode*);
        m->registerHook(getBase()+0xe1470, extract_virtual(this, tf3{&$CustomizeObjectLayer::textChanged}));

		using tf4 = void($CustomizeObjectLayer::*)(CCTextInputNode*);
        m->registerHook(getBase()+0xe1430, extract_virtual(this, tf4{&$CustomizeObjectLayer::textInputClosed}));
    }
};


class $DialogLayer : public $CacBase {
 public:
    $DialogLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $DialogLayer* __thistype;

    virtual void create(DialogObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), DialogObject*, int)>(m->getOriginal(getBase()+0x2047c0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($DialogLayer::*)(DialogObject*, int);
        m->registerHook(getBase()+0x2047c0, extract_virtual(this, tf0{&$DialogLayer::create}));
    }
};


class $DialogObject : public $CacBase {
 public:
    $DialogObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $DialogObject* __thistype;

    virtual void create(std::string p0, std::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, std::string, int, float, bool, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x204410))(this, p0, p1, p2, p3, p4, p5);
    }

void apply_hooks() override {
		using tf0 = void($DialogObject::*)(std::string, std::string, int, float, bool, cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x204410, extract_virtual(this, tf0{&$DialogObject::create}));
    }
};


class $DrawGridLayer : public $CacBase {
 public:
    $DrawGridLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $DrawGridLayer* __thistype;

    virtual void addPlayer2Point(cocos2d::CCPoint p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0xa25b0))(this, p0, p1);
    }

    virtual void addPlayerPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0xa39c0))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, LevelEditorLayer*)>(m->getOriginal(getBase()+0x920c0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($DrawGridLayer::*)(cocos2d::CCPoint, bool);
        m->registerHook(getBase()+0xa25b0, extract_virtual(this, tf0{&$DrawGridLayer::addPlayer2Point}));

		using tf1 = void($DrawGridLayer::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0xa39c0, extract_virtual(this, tf1{&$DrawGridLayer::addPlayerPoint}));

		using tf2 = void($DrawGridLayer::*)(cocos2d::CCNode*, LevelEditorLayer*);
        m->registerHook(getBase()+0x920c0, extract_virtual(this, tf2{&$DrawGridLayer::create}));
    }
};


class $EditorOptionsLayer : public $CacBase {
 public:
    $EditorOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EditorOptionsLayer* __thistype;

    virtual void onButtonsPerRow(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x147b30))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($EditorOptionsLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x147b30, extract_virtual(this, tf0{&$EditorOptionsLayer::onButtonsPerRow}));
    }
};


class $EditorUI : public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EditorUI* __thistype;

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x8a80))(this, p0);
    }

    virtual void editObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x195a0))(this, p0);
    }

    virtual void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23470))(this, p0, p1);
    }

    virtual void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x24b10))(this, p0, p1);
    }

    virtual void scaleChanged(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x25490))(this, p0);
    }

    virtual void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
    }

    virtual void disableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1c0f0))(this, p0);
    }

    virtual void enableButton(CreateMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(getBase()+0x1bff0))(this, p0);
    }

    virtual void getCreateBtn(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x1f6c0))(this, p0, p1);
    }

    virtual void onDuplicate(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x18ba0))(this, p0);
    }

    virtual void pasteObjects(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x232d0))(this, p0);
    }

    virtual void redoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb8e0))(this, p0);
    }

    virtual void selectObjects(cocos2d::CCArray* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(getBase()+0x23940))(this, p0, p1);
    }

    virtual void undoLastAction(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0xb830))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($EditorUI::*)(LevelEditorLayer*);
        m->registerHook(getBase()+0x8a80, extract_virtual(this, tf0{&$EditorUI::create}));

		using tf1 = void($EditorUI::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x195a0, extract_virtual(this, tf1{&$EditorUI::editObject}));

		using tf2 = void($EditorUI::*)(cocos2d::CCArray*, bool);
        m->registerHook(getBase()+0x23470, extract_virtual(this, tf2{&$EditorUI::getGroupCenter}));

		using tf3 = void($EditorUI::*)(GameObject*, cocos2d::CCPoint);
        m->registerHook(getBase()+0x24b10, extract_virtual(this, tf3{&$EditorUI::moveObject}));

		using tf4 = void($EditorUI::*)(float);
        m->registerHook(getBase()+0x25490, extract_virtual(this, tf4{&$EditorUI::scaleChanged}));

		using tf5 = void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint);
        m->registerHook(getBase()+0x252e0, extract_virtual(this, tf5{&$EditorUI::scaleObjects}));

		using tf6 = void($EditorUI::*)(CreateMenuItem*);
        m->registerHook(getBase()+0x1c0f0, extract_virtual(this, tf6{&$EditorUI::disableButton}));

		using tf7 = void($EditorUI::*)(CreateMenuItem*);
        m->registerHook(getBase()+0x1bff0, extract_virtual(this, tf7{&$EditorUI::enableButton}));

		using tf8 = void($EditorUI::*)(int, int);
        m->registerHook(getBase()+0x1f6c0, extract_virtual(this, tf8{&$EditorUI::getCreateBtn}));

		using tf9 = void($EditorUI::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x18ba0, extract_virtual(this, tf9{&$EditorUI::onDuplicate}));

		using tf10 = void($EditorUI::*)(std::string);
        m->registerHook(getBase()+0x232d0, extract_virtual(this, tf10{&$EditorUI::pasteObjects}));

		using tf11 = void($EditorUI::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0xb8e0, extract_virtual(this, tf11{&$EditorUI::redoLastAction}));

		using tf12 = void($EditorUI::*)(cocos2d::CCArray*, bool);
        m->registerHook(getBase()+0x23940, extract_virtual(this, tf12{&$EditorUI::selectObjects}));

		using tf13 = void($EditorUI::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0xb830, extract_virtual(this, tf13{&$EditorUI::undoLastAction}));
    }
};


class $EffectGameObject : public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EffectGameObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xc9790))(this, p0);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($EffectGameObject::*)(char const*);
        m->registerHook(getBase()+0xc9790, extract_virtual(this, tf0{&$EffectGameObject::create}));

		using tf1 = void($EffectGameObject::*)(GJBaseGameLayer*);
        m->registerHook(getBase()+0xc9870, extract_virtual(this, tf1{&$EffectGameObject::triggerObject}));
    }
};


class $EndPortalObject : public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EndPortalObject* __thistype;

    virtual void updateColors(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1dacb0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($EndPortalObject::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x1dacb0, extract_virtual(this, tf0{&$EndPortalObject::updateColors}));
    }
};


class $FMODAudioEngine : public $CacBase {
 public:
    $FMODAudioEngine() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $FMODAudioEngine* __thistype;

    virtual void fadeBackgroundMusic(bool p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, float)>(m->getOriginal(getBase()+0x20fd50))(this, p0, p1);
    }

    virtual void setBackgroundMusicTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x20fe10))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($FMODAudioEngine::*)(bool, float);
        m->registerHook(getBase()+0x20fd50, extract_virtual(this, tf0{&$FMODAudioEngine::fadeBackgroundMusic}));

		using tf1 = void($FMODAudioEngine::*)(float);
        m->registerHook(getBase()+0x20fe10, extract_virtual(this, tf1{&$FMODAudioEngine::setBackgroundMusicTime}));
    }
};


class $GJBaseGameLayer : public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJBaseGameLayer* __thistype;

    virtual void addObjectCounter(LabelGameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(getBase()+0xb9eb0))(this, p0, p1);
    }

    virtual void addToGroup(GameObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(getBase()+0xb77f0))(this, p0, p1, p2);
    }

    virtual void addToGroups(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0xb7780))(this, p0, p1);
    }

    virtual void addToSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7b70))(this, p0);
    }

    virtual void atlasValue(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb21e0))(this, p0);
    }

    virtual void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb6860))(this, p0, p1);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5be0))(this, p0, p1, p2, p3);
    }

    virtual void collectItem(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
    }

    virtual void collectedObject(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb9b60))(this, p0);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void damagingObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb6140))(this, p0);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0xba990))(this, p0, p1, p2);
    }

    virtual void getGroundHeightForMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6630))(this, p0);
    }

    virtual void getGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb6f20))(this, p0);
    }

    virtual void getMoveDeltaForObjects(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6db0))(this, p0, p1);
    }

    virtual void getOptimizedGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7940))(this, p0);
    }

    virtual void getStaticGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb79a0))(this, p0);
    }

    virtual void isGroupDisabledForObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb5cc0))(this, p0);
    }

    virtual void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb5de0))(this, p0, p1);
    }

    virtual void loadUpToPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xba680))(this, p0);
    }

    virtual void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(getBase()+0xb66e0))(this, p0, p1);
    }

    virtual void objectTriggered(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb71b0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb6d90))(this, p0, p1);
    }

    virtual void parentForZLayer(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0xb55d0))(this, p0, p1, p2);
    }

    virtual void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0xb69e0))(this, p0, p1);
    }

    virtual void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5a90))(this, p0, p1, p2, p3, p4);
    }

    virtual void processMoveActionsStep(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb7ea0))(this, p0);
    }

    virtual void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(getBase()+0xb5ae0))(this, p0, p1, p2, p3);
    }

    virtual void processPlayerFollowActions(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb8b50))(this, p0);
    }

    virtual void pushButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
    }

    virtual void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(getBase()+0xb6470))(this, p0, p1, p2);
    }

    virtual void releaseButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
    }

    virtual void removeFromGroup(GameObject* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(getBase()+0xb7a60))(this, p0, p1);
    }

    virtual void removeFromGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7a00))(this, p0);
    }

    virtual void removeObjectFromSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7e00))(this, p0);
    }

    virtual void reorderObjectSection(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0xb7cb0))(this, p0);
    }

    virtual void resetGroupCounters(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba300))(this, p0);
    }

    virtual void sectionForPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xb6120))(this, p0);
    }

    virtual void spawnGroupTriggered(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0xb7020))(this, p0, p1, p2);
    }

    virtual void staticObjectsInRect(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb5f90))(this, p0);
    }

    virtual void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(getBase()+0xb9ae0))(this, p0, p1, p2, p3, p4);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75f0))(this, p0, p1);
    }

    virtual void togglePlayerVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xba910))(this, p0);
    }

    virtual void triggerMoveCommand(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateCounters(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9bc0))(this, p0, p1);
    }

    virtual void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0xb95b0))(this, p0);
    }

    virtual void updateLayerCapacity(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0xb1680))(this, p0);
    }

    virtual void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(getBase()+0xb1590))(this, p0, p1, p2, p3);
    }

    virtual void updateOBB2(cocos2d::CCRect p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(getBase()+0xb63f0))(this, p0);
    }

    virtual void spawnGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0xb7050))(this, p0);
    }

    virtual void toggleGroupTriggered(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb75a0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJBaseGameLayer::*)(LabelGameObject*, int);
        m->registerHook(getBase()+0xb9eb0, extract_virtual(this, tf0{&$GJBaseGameLayer::addObjectCounter}));

		using tf1 = void($GJBaseGameLayer::*)(GameObject*, int, bool);
        m->registerHook(getBase()+0xb77f0, extract_virtual(this, tf1{&$GJBaseGameLayer::addToGroup}));

		using tf2 = void($GJBaseGameLayer::*)(GameObject*, bool);
        m->registerHook(getBase()+0xb7780, extract_virtual(this, tf2{&$GJBaseGameLayer::addToGroups}));

		using tf3 = void($GJBaseGameLayer::*)(GameObject*);
        m->registerHook(getBase()+0xb7b70, extract_virtual(this, tf3{&$GJBaseGameLayer::addToSection}));

		using tf4 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb21e0, extract_virtual(this, tf4{&$GJBaseGameLayer::atlasValue}));

		using tf5 = void($GJBaseGameLayer::*)(PlayerObject*, GameObject*);
        m->registerHook(getBase()+0xb6860, extract_virtual(this, tf5{&$GJBaseGameLayer::bumpPlayer}));

		using tf6 = void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*);
        m->registerHook(getBase()+0xba9a0, extract_virtual(this, tf6{&$GJBaseGameLayer::calculateColorValues}));

		using tf7 = void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*);
        m->registerHook(getBase()+0xb5be0, extract_virtual(this, tf7{&$GJBaseGameLayer::calculateOpacityValues}));

		using tf8 = void($GJBaseGameLayer::*)(int, int);
        m->registerHook(getBase()+0xb9e20, extract_virtual(this, tf8{&$GJBaseGameLayer::collectItem}));

		using tf9 = void($GJBaseGameLayer::*)(EffectGameObject*);
        m->registerHook(getBase()+0xb9b60, extract_virtual(this, tf9{&$GJBaseGameLayer::collectedObject}));

		using tf10 = void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int);
        m->registerHook(getBase()+0xb73a0, extract_virtual(this, tf10{&$GJBaseGameLayer::createMoveCommand}));

		using tf11 = void($GJBaseGameLayer::*)(cocos2d::CCRect);
        m->registerHook(getBase()+0xb6140, extract_virtual(this, tf11{&$GJBaseGameLayer::damagingObjectsInRect}));

		using tf12 = void($GJBaseGameLayer::*)(PlayerObject*, bool, bool);
        m->registerHook(getBase()+0xba990, extract_virtual(this, tf12{&$GJBaseGameLayer::flipGravity}));

		using tf13 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb6630, extract_virtual(this, tf13{&$GJBaseGameLayer::getGroundHeightForMode}));

		using tf14 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb6f20, extract_virtual(this, tf14{&$GJBaseGameLayer::getGroup}));

		using tf15 = void($GJBaseGameLayer::*)(int, int);
        m->registerHook(getBase()+0xb6db0, extract_virtual(this, tf15{&$GJBaseGameLayer::getMoveDeltaForObjects}));

		using tf16 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb7940, extract_virtual(this, tf16{&$GJBaseGameLayer::getOptimizedGroup}));

		using tf17 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb79a0, extract_virtual(this, tf17{&$GJBaseGameLayer::getStaticGroup}));

		using tf18 = void($GJBaseGameLayer::*)(GameObject*);
        m->registerHook(getBase()+0xb5cc0, extract_virtual(this, tf18{&$GJBaseGameLayer::isGroupDisabledForObject}));

		using tf19 = void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0xb5de0, extract_virtual(this, tf19{&$GJBaseGameLayer::isGroupDisabledForObjectFull}));

		using tf20 = void($GJBaseGameLayer::*)(float);
        m->registerHook(getBase()+0xba680, extract_virtual(this, tf20{&$GJBaseGameLayer::loadUpToPosition}));

		using tf21 = void($GJBaseGameLayer::*)(GameObject*, GameObject*);
        m->registerHook(getBase()+0xb66e0, extract_virtual(this, tf21{&$GJBaseGameLayer::objectIntersectsCircle}));

		using tf22 = void($GJBaseGameLayer::*)(EffectGameObject*);
        m->registerHook(getBase()+0xb71b0, extract_virtual(this, tf22{&$GJBaseGameLayer::objectTriggered}));

		using tf23 = void($GJBaseGameLayer::*)(int, int);
        m->registerHook(getBase()+0xb6d90, extract_virtual(this, tf23{&$GJBaseGameLayer::objectsCollided}));

		using tf24 = void($GJBaseGameLayer::*)(int, bool, int);
        m->registerHook(getBase()+0xb55d0, extract_virtual(this, tf24{&$GJBaseGameLayer::parentForZLayer}));

		using tf25 = void($GJBaseGameLayer::*)(PlayerObject*, GameObject*);
        m->registerHook(getBase()+0xb69e0, extract_virtual(this, tf25{&$GJBaseGameLayer::playerTouchedRing}));

		using tf26 = void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*);
        m->registerHook(getBase()+0xb5a90, extract_virtual(this, tf26{&$GJBaseGameLayer::processColorObject}));

		using tf27 = void($GJBaseGameLayer::*)(float);
        m->registerHook(getBase()+0xb7ea0, extract_virtual(this, tf27{&$GJBaseGameLayer::processMoveActionsStep}));

		using tf28 = void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*);
        m->registerHook(getBase()+0xb5ae0, extract_virtual(this, tf28{&$GJBaseGameLayer::processOpacityObject}));

		using tf29 = void($GJBaseGameLayer::*)(float);
        m->registerHook(getBase()+0xb8b50, extract_virtual(this, tf29{&$GJBaseGameLayer::processPlayerFollowActions}));

		using tf30 = void($GJBaseGameLayer::*)(int, bool);
        m->registerHook(getBase()+0xb9920, extract_virtual(this, tf30{&$GJBaseGameLayer::pushButton}));

		using tf31 = void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float);
        m->registerHook(getBase()+0xb6470, extract_virtual(this, tf31{&$GJBaseGameLayer::rectIntersectsCircle}));

		using tf32 = void($GJBaseGameLayer::*)(int, bool);
        m->registerHook(getBase()+0xb9a00, extract_virtual(this, tf32{&$GJBaseGameLayer::releaseButton}));

		using tf33 = void($GJBaseGameLayer::*)(GameObject*, int);
        m->registerHook(getBase()+0xb7a60, extract_virtual(this, tf33{&$GJBaseGameLayer::removeFromGroup}));

		using tf34 = void($GJBaseGameLayer::*)(GameObject*);
        m->registerHook(getBase()+0xb7a00, extract_virtual(this, tf34{&$GJBaseGameLayer::removeFromGroups}));

		using tf35 = void($GJBaseGameLayer::*)(GameObject*);
        m->registerHook(getBase()+0xb7e00, extract_virtual(this, tf35{&$GJBaseGameLayer::removeObjectFromSection}));

		using tf36 = void($GJBaseGameLayer::*)(GameObject*);
        m->registerHook(getBase()+0xb7cb0, extract_virtual(this, tf36{&$GJBaseGameLayer::reorderObjectSection}));

		using tf37 = void($GJBaseGameLayer::*)(bool);
        m->registerHook(getBase()+0xba300, extract_virtual(this, tf37{&$GJBaseGameLayer::resetGroupCounters}));

		using tf38 = void($GJBaseGameLayer::*)(float);
        m->registerHook(getBase()+0xb6120, extract_virtual(this, tf38{&$GJBaseGameLayer::sectionForPos}));

		using tf39 = void($GJBaseGameLayer::*)(int, float, int);
        m->registerHook(getBase()+0xb7020, extract_virtual(this, tf39{&$GJBaseGameLayer::spawnGroupTriggered}));

		using tf40 = void($GJBaseGameLayer::*)(cocos2d::CCRect);
        m->registerHook(getBase()+0xb5f90, extract_virtual(this, tf40{&$GJBaseGameLayer::staticObjectsInRect}));

		using tf41 = void($GJBaseGameLayer::*)(int, int, int, bool, int);
        m->registerHook(getBase()+0xb9ae0, extract_virtual(this, tf41{&$GJBaseGameLayer::testInstantCountTrigger}));

		using tf42 = void($GJBaseGameLayer::*)(int, bool);
        m->registerHook(getBase()+0xb75f0, extract_virtual(this, tf42{&$GJBaseGameLayer::toggleGroup}));

		using tf43 = void($GJBaseGameLayer::*)(bool);
        m->registerHook(getBase()+0xba910, extract_virtual(this, tf43{&$GJBaseGameLayer::togglePlayerVisibility}));

		using tf44 = void($GJBaseGameLayer::*)(EffectGameObject*);
        m->registerHook(getBase()+0xb7290, extract_virtual(this, tf44{&$GJBaseGameLayer::triggerMoveCommand}));

		using tf45 = void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*);
        m->registerHook(getBase()+0xb7420, extract_virtual(this, tf45{&$GJBaseGameLayer::updateColor}));

		using tf46 = void($GJBaseGameLayer::*)(int, int);
        m->registerHook(getBase()+0xb9bc0, extract_virtual(this, tf46{&$GJBaseGameLayer::updateCounters}));

		using tf47 = void($GJBaseGameLayer::*)(cocos2d::CCArray*);
        m->registerHook(getBase()+0xb95b0, extract_virtual(this, tf47{&$GJBaseGameLayer::updateDisabledObjectsLastPos}));

		using tf48 = void($GJBaseGameLayer::*)(std::string);
        m->registerHook(getBase()+0xb1680, extract_virtual(this, tf48{&$GJBaseGameLayer::updateLayerCapacity}));

		using tf49 = void($GJBaseGameLayer::*)(int, int, int, int);
        m->registerHook(getBase()+0xb1590, extract_virtual(this, tf49{&$GJBaseGameLayer::updateLegacyLayerCapacity}));

		using tf50 = void($GJBaseGameLayer::*)(cocos2d::CCRect);
        m->registerHook(getBase()+0xb63f0, extract_virtual(this, tf50{&$GJBaseGameLayer::updateOBB2}));

		using tf51 = void($GJBaseGameLayer::*)(int);
        m->registerHook(getBase()+0xb7050, extract_virtual(this, tf51{&$GJBaseGameLayer::spawnGroup}));

		using tf52 = void($GJBaseGameLayer::*)(int, bool);
        m->registerHook(getBase()+0xb75a0, extract_virtual(this, tf52{&$GJBaseGameLayer::toggleGroupTriggered}));
    }
};


class $GJDropDownLayer : public $CacBase {
 public:
    $GJDropDownLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJDropDownLayer* __thistype;

    virtual void init(char const* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, float)>(m->getOriginal(getBase()+0x352100))(this, p0, p1);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x352530))(this, p0);
    }

    virtual void exitLayer(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x352670))(this, p0);
    }

    virtual void hideLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3527b0))(this, p0);
    }

    virtual void showLayer(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x3526c0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GJDropDownLayer::*)(char const*, float);
        m->registerHook(getBase()+0x352100, extract_virtual(this, tf0{&$GJDropDownLayer::init}));

		using tf1 = void($GJDropDownLayer::*)(char const*);
        m->registerHook(getBase()+0x352530, extract_virtual(this, tf1{&$GJDropDownLayer::create}));

		using tf2 = void($GJDropDownLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x352670, extract_virtual(this, tf2{&$GJDropDownLayer::exitLayer}));

		using tf3 = void($GJDropDownLayer::*)(bool);
        m->registerHook(getBase()+0x3527b0, extract_virtual(this, tf3{&$GJDropDownLayer::hideLayer}));

		using tf4 = void($GJDropDownLayer::*)(bool);
        m->registerHook(getBase()+0x3526c0, extract_virtual(this, tf4{&$GJDropDownLayer::showLayer}));
    }
};


class $GJEffectManager : public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJEffectManager* __thistype;

    virtual void activeColorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180cb0))(this, p0);
    }

    virtual void activeOpacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e10))(this, p0);
    }

    virtual void addAllInheritedColorActions(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1817a0))(this, p0);
    }

    virtual void addGroupPulseEffect(PulseEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), PulseEffectAction*)>(m->getOriginal(getBase()+0x184c10))(this, p0);
    }

    virtual void calculateInheritedColor(int p0, ColorAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, ColorAction*)>(m->getOriginal(getBase()+0x1818f0))(this, p0, p1);
    }

    virtual void calculateLightBGColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x185b90))(this, p0);
    }

    virtual void colorActionChanged(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x181dc0))(this, p0);
    }

    virtual void colorExists(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181da0))(this, p0);
    }

    virtual void colorForEffect(cocos2d::_ccColor3B p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x182650))(this, p0, p1);
    }

    virtual void colorForGroupID(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184f90))(this, p0, p1, p2);
    }

    virtual void colorForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180ad0))(this, p0);
    }

    virtual void colorForPulseEffect(cocos2d::_ccColor3B const& p0, PulseEffectAction* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, PulseEffectAction*)>(m->getOriginal(getBase()+0x181bf0))(this, p0, p1);
    }

    virtual void countChangedForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
    }

    virtual void countForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a10))(this, p0);
    }

    virtual void createFollowCommand(float p0, float p1, float p2, int p3, int p4, bool p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, int, int, bool, int)>(m->getOriginal(getBase()+0x182ed0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0x182cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void createPlayerFollowCommand(float p0, float p1, int p2, float p3, float p4, int p5, int p6) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, float, int, int)>(m->getOriginal(getBase()+0x182fe0))(this, p0, p1, p2, p3, p4, p5, p6);
    }

    virtual void createRotateCommand(int p0, float p1, int p2, int p3, int p4, float p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int, int, int, float, bool, int)>(m->getOriginal(getBase()+0x182df0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void getColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180b00))(this, p0);
    }

    virtual void getColorSprite(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180d00))(this, p0);
    }

    virtual void getMixedColor(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x185d30))(this, p0, p1, p2);
    }

    virtual void getOpacityActionForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1845b0))(this, p0);
    }

    virtual void handleObjectCollision(bool p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int)>(m->getOriginal(getBase()+0x1828f0))(this, p0, p1, p2);
    }

    virtual void hasBeenTriggered(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853b0))(this, p0);
    }

    virtual void hasPulseEffectForGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184f60))(this, p0);
    }

    virtual void isGroupEnabled(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
    }

    virtual void keyForGroupIDColor(int p0, cocos2d::_ccColor3B const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B const&, bool)>(m->getOriginal(getBase()+0x184c90))(this, p0, p1, p2);
    }

    virtual void loadState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x188db0))(this, p0);
    }

    virtual void objectsCollided(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x182a00))(this, p0, p1);
    }

    virtual void opacityForIndex(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180c80))(this, p0);
    }

    virtual void opacityModForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x184740))(this, p0);
    }

    virtual void playerButton(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
    }

    virtual void prepareMoveActions(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x183660))(this, p0, p1);
    }

    virtual void registerCollisionTrigger(int p0, int p1, int p2, bool p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, bool, int)>(m->getOriginal(getBase()+0x182b70))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void removeColorAction(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x181d60))(this, p0);
    }

    virtual void runCountTrigger(int p0, int p1, bool p2, int p3, bool p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool, int, bool, int)>(m->getOriginal(getBase()+0x1858d0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runDeathTrigger(int p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(getBase()+0x1857a0))(this, p0, p1, p2);
    }

    virtual void runOpacityActionOnGroup(int p0, float p1, float p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), int, float, float, int)>(m->getOriginal(getBase()+0x1845d0))(this, p0, p1, p2, p3);
    }

    virtual void runPulseEffect(int p0, bool p1, float p2, float p3, float p4, PulseEffectType p5, cocos2d::_ccColor3B p6, cocos2d::_ccHSVValue p7, int p8, bool p9, bool p10, bool p11, int p12) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int)>(m->getOriginal(getBase()+0x184890))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12);
    }

    virtual void runTouchTriggerCommand(int p0, bool p1, TouchTriggerType p2, bool p3, int p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, TouchTriggerType, bool, int)>(m->getOriginal(getBase()+0x185460))(this, p0, p1, p2, p3, p4);
    }

    virtual void setColorAction(ColorAction* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*, int)>(m->getOriginal(getBase()+0x181d00))(this, p0, p1);
    }

    virtual void setFollowing(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x185e00))(this, p0, p1, p2);
    }

    virtual void setupFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x186290))(this, p0);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x180e40))(this, p0);
    }

    virtual void spawnGroup(int p0, float p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(getBase()+0x1852a0))(this, p0, p1, p2);
    }

    virtual void stopActionsForTrigger(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0x183150))(this, p0);
    }

    virtual void stopMoveActionsForGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1830e0))(this, p0);
    }

    virtual void storeTriggeredID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185380))(this, p0);
    }

    virtual void toggleGroup(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x182c80))(this, p0, p1);
    }

    virtual void traverseInheritanceChain(InheritanceNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*)>(m->getOriginal(getBase()+0x181850))(this, p0);
    }

    virtual void updateColorAction(ColorAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), ColorAction*)>(m->getOriginal(getBase()+0x184560))(this, p0);
    }

    virtual void updateColorEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181f40))(this, p0);
    }

    virtual void updateColors(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x180a40))(this, p0, p1);
    }

    virtual void updateEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x181df0))(this, p0);
    }

    virtual void updateOpacityAction(OpacityEffectAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), OpacityEffectAction*)>(m->getOriginal(getBase()+0x184780))(this, p0);
    }

    virtual void updateOpacityEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1823e0))(this, p0);
    }

    virtual void updatePulseEffects(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182130))(this, p0);
    }

    virtual void updateSpawnTriggers(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x182510))(this, p0);
    }

    virtual void wasFollowing(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x185e60))(this, p0, p1);
    }

    virtual void wouldCreateLoop(InheritanceNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), InheritanceNode*, int)>(m->getOriginal(getBase()+0x181820))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180cb0, extract_virtual(this, tf0{&$GJEffectManager::activeColorForIndex}));

		using tf1 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180e10, extract_virtual(this, tf1{&$GJEffectManager::activeOpacityForIndex}));

		using tf2 = void($GJEffectManager::*)(cocos2d::CCArray*);
        m->registerHook(getBase()+0x1817a0, extract_virtual(this, tf2{&$GJEffectManager::addAllInheritedColorActions}));

		using tf3 = void($GJEffectManager::*)(PulseEffectAction*);
        m->registerHook(getBase()+0x184c10, extract_virtual(this, tf3{&$GJEffectManager::addGroupPulseEffect}));

		using tf4 = void($GJEffectManager::*)(int, ColorAction*);
        m->registerHook(getBase()+0x1818f0, extract_virtual(this, tf4{&$GJEffectManager::calculateInheritedColor}));

		using tf5 = void($GJEffectManager::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x185b90, extract_virtual(this, tf5{&$GJEffectManager::calculateLightBGColor}));

		using tf6 = void($GJEffectManager::*)(ColorAction*);
        m->registerHook(getBase()+0x181dc0, extract_virtual(this, tf6{&$GJEffectManager::colorActionChanged}));

		using tf7 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x181da0, extract_virtual(this, tf7{&$GJEffectManager::colorExists}));

		using tf8 = void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccHSVValue);
        m->registerHook(getBase()+0x182650, extract_virtual(this, tf8{&$GJEffectManager::colorForEffect}));

		using tf9 = void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool);
        m->registerHook(getBase()+0x184f90, extract_virtual(this, tf9{&$GJEffectManager::colorForGroupID}));

		using tf10 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180ad0, extract_virtual(this, tf10{&$GJEffectManager::colorForIndex}));

		using tf11 = void($GJEffectManager::*)(cocos2d::_ccColor3B const&, PulseEffectAction*);
        m->registerHook(getBase()+0x181bf0, extract_virtual(this, tf11{&$GJEffectManager::colorForPulseEffect}));

		using tf12 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x185a40, extract_virtual(this, tf12{&$GJEffectManager::countChangedForItem}));

		using tf13 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x185a10, extract_virtual(this, tf13{&$GJEffectManager::countForItem}));

		using tf14 = void($GJEffectManager::*)(float, float, float, int, int, bool, int);
        m->registerHook(getBase()+0x182ed0, extract_virtual(this, tf14{&$GJEffectManager::createFollowCommand}));

		using tf15 = void($GJEffectManager::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int);
        m->registerHook(getBase()+0x182cc0, extract_virtual(this, tf15{&$GJEffectManager::createMoveCommand}));

		using tf16 = void($GJEffectManager::*)(float, float, int, float, float, int, int);
        m->registerHook(getBase()+0x182fe0, extract_virtual(this, tf16{&$GJEffectManager::createPlayerFollowCommand}));

		using tf17 = void($GJEffectManager::*)(int, float, int, int, int, float, bool, int);
        m->registerHook(getBase()+0x182df0, extract_virtual(this, tf17{&$GJEffectManager::createRotateCommand}));

		using tf18 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180b00, extract_virtual(this, tf18{&$GJEffectManager::getColorAction}));

		using tf19 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180d00, extract_virtual(this, tf19{&$GJEffectManager::getColorSprite}));

		using tf20 = void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float);
        m->registerHook(getBase()+0x185d30, extract_virtual(this, tf20{&$GJEffectManager::getMixedColor}));

		using tf21 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x1845b0, extract_virtual(this, tf21{&$GJEffectManager::getOpacityActionForGroup}));

		using tf22 = void($GJEffectManager::*)(bool, int, int);
        m->registerHook(getBase()+0x1828f0, extract_virtual(this, tf22{&$GJEffectManager::handleObjectCollision}));

		using tf23 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x1853b0, extract_virtual(this, tf23{&$GJEffectManager::hasBeenTriggered}));

		using tf24 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x184f60, extract_virtual(this, tf24{&$GJEffectManager::hasPulseEffectForGroupID}));

		using tf25 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x1853d0, extract_virtual(this, tf25{&$GJEffectManager::isGroupEnabled}));

		using tf26 = void($GJEffectManager::*)(int, cocos2d::_ccColor3B const&, bool);
        m->registerHook(getBase()+0x184c90, extract_virtual(this, tf26{&$GJEffectManager::keyForGroupIDColor}));

		using tf27 = void($GJEffectManager::*)(std::string);
        m->registerHook(getBase()+0x188db0, extract_virtual(this, tf27{&$GJEffectManager::loadState}));

		using tf28 = void($GJEffectManager::*)(int, int);
        m->registerHook(getBase()+0x182a00, extract_virtual(this, tf28{&$GJEffectManager::objectsCollided}));

		using tf29 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180c80, extract_virtual(this, tf29{&$GJEffectManager::opacityForIndex}));

		using tf30 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x184740, extract_virtual(this, tf30{&$GJEffectManager::opacityModForGroup}));

		using tf31 = void($GJEffectManager::*)(bool, bool);
        m->registerHook(getBase()+0x1855a0, extract_virtual(this, tf31{&$GJEffectManager::playerButton}));

		using tf32 = void($GJEffectManager::*)(float, bool);
        m->registerHook(getBase()+0x183660, extract_virtual(this, tf32{&$GJEffectManager::prepareMoveActions}));

		using tf33 = void($GJEffectManager::*)(int, int, int, bool, bool, int);
        m->registerHook(getBase()+0x182b70, extract_virtual(this, tf33{&$GJEffectManager::registerCollisionTrigger}));

		using tf34 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x181d60, extract_virtual(this, tf34{&$GJEffectManager::removeColorAction}));

		using tf35 = void($GJEffectManager::*)(int, int, bool, int, bool, int);
        m->registerHook(getBase()+0x1858d0, extract_virtual(this, tf35{&$GJEffectManager::runCountTrigger}));

		using tf36 = void($GJEffectManager::*)(int, bool, int);
        m->registerHook(getBase()+0x1857a0, extract_virtual(this, tf36{&$GJEffectManager::runDeathTrigger}));

		using tf37 = void($GJEffectManager::*)(int, float, float, int);
        m->registerHook(getBase()+0x1845d0, extract_virtual(this, tf37{&$GJEffectManager::runOpacityActionOnGroup}));

		using tf38 = void($GJEffectManager::*)(int, bool, float, float, float, PulseEffectType, cocos2d::_ccColor3B, cocos2d::_ccHSVValue, int, bool, bool, bool, int);
        m->registerHook(getBase()+0x184890, extract_virtual(this, tf38{&$GJEffectManager::runPulseEffect}));

		using tf39 = void($GJEffectManager::*)(int, bool, TouchTriggerType, bool, int);
        m->registerHook(getBase()+0x185460, extract_virtual(this, tf39{&$GJEffectManager::runTouchTriggerCommand}));

		using tf40 = void($GJEffectManager::*)(ColorAction*, int);
        m->registerHook(getBase()+0x181d00, extract_virtual(this, tf40{&$GJEffectManager::setColorAction}));

		using tf41 = void($GJEffectManager::*)(int, int, bool);
        m->registerHook(getBase()+0x185e00, extract_virtual(this, tf41{&$GJEffectManager::setFollowing}));

		using tf42 = void($GJEffectManager::*)(std::string);
        m->registerHook(getBase()+0x186290, extract_virtual(this, tf42{&$GJEffectManager::setupFromString}));

		using tf43 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x180e40, extract_virtual(this, tf43{&$GJEffectManager::shouldBlend}));

		using tf44 = void($GJEffectManager::*)(int, float, int);
        m->registerHook(getBase()+0x1852a0, extract_virtual(this, tf44{&$GJEffectManager::spawnGroup}));

		using tf45 = void($GJEffectManager::*)(EffectGameObject*);
        m->registerHook(getBase()+0x183150, extract_virtual(this, tf45{&$GJEffectManager::stopActionsForTrigger}));

		using tf46 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x1830e0, extract_virtual(this, tf46{&$GJEffectManager::stopMoveActionsForGroup}));

		using tf47 = void($GJEffectManager::*)(int);
        m->registerHook(getBase()+0x185380, extract_virtual(this, tf47{&$GJEffectManager::storeTriggeredID}));

		using tf48 = void($GJEffectManager::*)(int, bool);
        m->registerHook(getBase()+0x182c80, extract_virtual(this, tf48{&$GJEffectManager::toggleGroup}));

		using tf49 = void($GJEffectManager::*)(InheritanceNode*);
        m->registerHook(getBase()+0x181850, extract_virtual(this, tf49{&$GJEffectManager::traverseInheritanceChain}));

		using tf50 = void($GJEffectManager::*)(ColorAction*);
        m->registerHook(getBase()+0x184560, extract_virtual(this, tf50{&$GJEffectManager::updateColorAction}));

		using tf51 = void($GJEffectManager::*)(float);
        m->registerHook(getBase()+0x181f40, extract_virtual(this, tf51{&$GJEffectManager::updateColorEffects}));

		using tf52 = void($GJEffectManager::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x180a40, extract_virtual(this, tf52{&$GJEffectManager::updateColors}));

		using tf53 = void($GJEffectManager::*)(float);
        m->registerHook(getBase()+0x181df0, extract_virtual(this, tf53{&$GJEffectManager::updateEffects}));

		using tf54 = void($GJEffectManager::*)(OpacityEffectAction*);
        m->registerHook(getBase()+0x184780, extract_virtual(this, tf54{&$GJEffectManager::updateOpacityAction}));

		using tf55 = void($GJEffectManager::*)(float);
        m->registerHook(getBase()+0x1823e0, extract_virtual(this, tf55{&$GJEffectManager::updateOpacityEffects}));

		using tf56 = void($GJEffectManager::*)(float);
        m->registerHook(getBase()+0x182130, extract_virtual(this, tf56{&$GJEffectManager::updatePulseEffects}));

		using tf57 = void($GJEffectManager::*)(float);
        m->registerHook(getBase()+0x182510, extract_virtual(this, tf57{&$GJEffectManager::updateSpawnTriggers}));

		using tf58 = void($GJEffectManager::*)(int, int);
        m->registerHook(getBase()+0x185e60, extract_virtual(this, tf58{&$GJEffectManager::wasFollowing}));

		using tf59 = void($GJEffectManager::*)(InheritanceNode*, int);
        m->registerHook(getBase()+0x181820, extract_virtual(this, tf59{&$GJEffectManager::wouldCreateLoop}));
    }
};


class $GJFollowCommandLayer : public $CacBase {
 public:
    $GJFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x16a550))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x16a550, extract_virtual(this, tf0{&$GJFollowCommandLayer::create}));
    }
};


class $GJGameLevel : public $CacBase {
 public:
    $GJGameLevel() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJGameLevel* __thistype;

    virtual void getCoinKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ce360))(this, p0);
    }

    virtual void savePercentage(int p0, bool p1, int p2, int p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, int, bool)>(m->getOriginal(getBase()+0x2db700))(this, p0, p1, p2, p3, p4);
    }

void apply_hooks() override {
		using tf0 = void($GJGameLevel::*)(int);
        m->registerHook(getBase()+0x2ce360, extract_virtual(this, tf0{&$GJGameLevel::getCoinKey}));

		using tf1 = void($GJGameLevel::*)(int, bool, int, int, bool);
        m->registerHook(getBase()+0x2db700, extract_virtual(this, tf1{&$GJGameLevel::savePercentage}));
    }
};


class $GJGroundLayer : public $CacBase {
 public:
    $GJGroundLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJGroundLayer* __thistype;

    virtual void create(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x355c00))(this, p0, p1);
    }

    virtual void updateGround01Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356640))(this, p0);
    }

    virtual void updateGround02Color(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x356710))(this, p0);
    }

    virtual void updateGroundPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x3566c0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GJGroundLayer::*)(int, int);
        m->registerHook(getBase()+0x355c00, extract_virtual(this, tf0{&$GJGroundLayer::create}));

		using tf1 = void($GJGroundLayer::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x356640, extract_virtual(this, tf1{&$GJGroundLayer::updateGround01Color}));

		using tf2 = void($GJGroundLayer::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x356710, extract_virtual(this, tf2{&$GJGroundLayer::updateGround02Color}));

		using tf3 = void($GJGroundLayer::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0x3566c0, extract_virtual(this, tf3{&$GJGroundLayer::updateGroundPos}));
    }
};


class $GJMoveCommandLayer : public $CacBase {
 public:
    $GJMoveCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJMoveCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36f8a0))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x36fac0))(this, p0, p1);
    }

    virtual void onUpdateGroupID(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x373350))(this, p0);
    }

    virtual void onUpdateGroupID2(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x3734c0))(this, p0);
    }

    virtual void textChanged(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374470))(this, p0);
    }

    virtual void textInputClosed(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374430))(this, p0);
    }

    virtual void textInputReturn(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x374c10))(this, p0);
    }

    virtual void textInputShouldOffset(CCTextInputNode* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(getBase()+0x374b50))(this, p0, p1);
    }

    virtual void valuePopupClosed(ConfigureValuePopup* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(getBase()+0x373c20))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x36f8a0, extract_virtual(this, tf0{&$GJMoveCommandLayer::create}));

		using tf1 = void($GJMoveCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x36fac0, extract_virtual(this, tf1{&$GJMoveCommandLayer::init}));

		using tf2 = void($GJMoveCommandLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x373350, extract_virtual(this, tf2{&$GJMoveCommandLayer::onUpdateGroupID}));

		using tf3 = void($GJMoveCommandLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x3734c0, extract_virtual(this, tf3{&$GJMoveCommandLayer::onUpdateGroupID2}));

		using tf4 = void($GJMoveCommandLayer::*)(CCTextInputNode*);
        m->registerHook(getBase()+0x374470, extract_virtual(this, tf4{&$GJMoveCommandLayer::textChanged}));

		using tf5 = void($GJMoveCommandLayer::*)(CCTextInputNode*);
        m->registerHook(getBase()+0x374430, extract_virtual(this, tf5{&$GJMoveCommandLayer::textInputClosed}));

		using tf6 = void($GJMoveCommandLayer::*)(CCTextInputNode*);
        m->registerHook(getBase()+0x374c10, extract_virtual(this, tf6{&$GJMoveCommandLayer::textInputReturn}));

		using tf7 = void($GJMoveCommandLayer::*)(CCTextInputNode*, float);
        m->registerHook(getBase()+0x374b50, extract_virtual(this, tf7{&$GJMoveCommandLayer::textInputShouldOffset}));

		using tf8 = void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float);
        m->registerHook(getBase()+0x373c20, extract_virtual(this, tf8{&$GJMoveCommandLayer::valuePopupClosed}));
    }
};


class $GJPFollowCommandLayer : public $CacBase {
 public:
    $GJPFollowCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJPFollowCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1aea20))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJPFollowCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1aea20, extract_virtual(this, tf0{&$GJPFollowCommandLayer::create}));
    }
};


class $GJRobotSprite : public $CacBase {
 public:
    $GJRobotSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJRobotSprite* __thistype;

    virtual void updateColor02(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x34bbd0))(this, p0);
    }

    virtual void updateFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x34bdd0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GJRobotSprite::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x34bbd0, extract_virtual(this, tf0{&$GJRobotSprite::updateColor02}));

		using tf1 = void($GJRobotSprite::*)(int);
        m->registerHook(getBase()+0x34bdd0, extract_virtual(this, tf1{&$GJRobotSprite::updateFrame}));
    }
};


class $GJRotateCommandLayer : public $CacBase {
 public:
    $GJRotateCommandLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJRotateCommandLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1ba0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GJRotateCommandLayer::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1ba0, extract_virtual(this, tf0{&$GJRotateCommandLayer::create}));
    }
};


class $GManager : public $CacBase {
 public:
    $GManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GManager* __thistype;

    virtual void saveData(DS_Dictionary* p0, std::string p1) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*, std::string)>(m->getOriginal(getBase()+0x26f4b0))(this, p0, p1);
    }

    virtual void saveGMTo(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x26f3b0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GManager::*)(DS_Dictionary*, std::string);
        m->registerHook(getBase()+0x26f4b0, extract_virtual(this, tf0{&$GManager::saveData}));

		using tf1 = void($GManager::*)(std::string);
        m->registerHook(getBase()+0x26f3b0, extract_virtual(this, tf1{&$GManager::saveGMTo}));
    }
};


class $GameManager : public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GameManager* __thistype;

    virtual void colorForIdx(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cbc80))(this, p0);
    }

    virtual void fadeInMusic(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1c2ff0))(this, p0);
    }

    virtual void getBGTexture(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cca00))(this, p0);
    }

    virtual void getFontFile(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc5f0))(this, p0);
    }

    virtual void getGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cccd0))(this, p0);
    }

    virtual void getIntGameVariable(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1cd1d0))(this, p0);
    }

    virtual void getUGV(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x1ccfa0))(this, p0);
    }

    virtual void loadDeathEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc690))(this, p0);
    }

    virtual void loadFont(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1cc550))(this, p0);
    }

    virtual void reportPercentageForLevel(int p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(getBase()+0x1c5b00))(this, p0, p1, p2);
    }

    virtual void setUGV(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cce50))(this, p0, p1);
    }

    virtual void reloadAll(bool p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(getBase()+0x1d08a0))(this, p0, p1, p2);
    }

    virtual void setGameVariable(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x1cca80))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($GameManager::*)(int);
        m->registerHook(getBase()+0x1cbc80, extract_virtual(this, tf0{&$GameManager::colorForIdx}));

		using tf1 = void($GameManager::*)(char const*);
        m->registerHook(getBase()+0x1c2ff0, extract_virtual(this, tf1{&$GameManager::fadeInMusic}));

		using tf2 = void($GameManager::*)(int);
        m->registerHook(getBase()+0x1cca00, extract_virtual(this, tf2{&$GameManager::getBGTexture}));

		using tf3 = void($GameManager::*)(int);
        m->registerHook(getBase()+0x1cc5f0, extract_virtual(this, tf3{&$GameManager::getFontFile}));

		using tf4 = void($GameManager::*)(char const*);
        m->registerHook(getBase()+0x1cccd0, extract_virtual(this, tf4{&$GameManager::getGameVariable}));

		using tf5 = void($GameManager::*)(char const*);
        m->registerHook(getBase()+0x1cd1d0, extract_virtual(this, tf5{&$GameManager::getIntGameVariable}));

		using tf6 = void($GameManager::*)(char const*);
        m->registerHook(getBase()+0x1ccfa0, extract_virtual(this, tf6{&$GameManager::getUGV}));

		using tf7 = void($GameManager::*)(int);
        m->registerHook(getBase()+0x1cc690, extract_virtual(this, tf7{&$GameManager::loadDeathEffect}));

		using tf8 = void($GameManager::*)(int);
        m->registerHook(getBase()+0x1cc550, extract_virtual(this, tf8{&$GameManager::loadFont}));

		using tf9 = void($GameManager::*)(int, int, bool);
        m->registerHook(getBase()+0x1c5b00, extract_virtual(this, tf9{&$GameManager::reportPercentageForLevel}));

		using tf10 = void($GameManager::*)(char const*, bool);
        m->registerHook(getBase()+0x1cce50, extract_virtual(this, tf10{&$GameManager::setUGV}));

		using tf11 = void($GameManager::*)(bool, bool, bool);
        m->registerHook(getBase()+0x1d08a0, extract_virtual(this, tf11{&$GameManager::reloadAll}));

		using tf12 = void($GameManager::*)(char const*, bool);
        m->registerHook(getBase()+0x1cca80, extract_virtual(this, tf12{&$GameManager::setGameVariable}));
    }
};


class $GameObject : public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GameObject* __thistype;

    virtual void activatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a20))(this, p0);
    }

    virtual void addColorSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb470))(this, p0);
    }

    virtual void addMainSpriteToParent(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x33a5b0))(this, p0);
    }

    virtual void addToGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ad00))(this, p0);
    }

    virtual void addToTempOffset(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x335700))(this, p0, p1);
    }

    virtual void colorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343460))(this, p0, p1);
    }

    virtual void copyGroups(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x33ae30))(this, p0);
    }

    virtual void createWithFrame(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2f5490))(this, p0);
    }

    virtual void createWithKey(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2f4ce0))(this, p0);
    }

    virtual void customObjectSetup(std::map<std::string, std::string, std::less<std::string>, std::allocator<std::pair<std::string const, std::string> > >& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::map<std::string, std::string, std::less<std::string>, std::allocator<std::pair<std::string const, std::string> > >&)>(m->getOriginal(getBase()+0xdc1a0))(this, p0);
    }

    virtual void deactivateObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2fb8f0))(this, p0);
    }

    virtual void getActiveColorForMode(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x343860))(this, p0, p1);
    }

    virtual void getBallFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x341bf0))(this, p0);
    }

    virtual void getGroupID(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ae10))(this, p0);
    }

    virtual void getObjectRect(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3352d0))(this, p0, p1);
    }

    virtual void getObjectRect2(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x3354e0))(this, p0, p1);
    }

    virtual void hasBeenActivatedByPlayer(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x342a50))(this, p0);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x2f56a0))(this, p0);
    }

    virtual void objectFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x33b720))(this, p0, p1);
    }

    virtual void removeFromGroup(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x33ada0))(this, p0);
    }

    virtual void setChildColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341f20))(this, p0);
    }

    virtual void setDefaultMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x304fc0))(this, p0);
    }

    virtual void setDidUpdateLastPosition(bool const& p0) {
        return reinterpret_cast<void(*)(decltype(this), bool const&)>(m->getOriginal(getBase()+0x343a30))(this, p0);
    }

    virtual void setGlowColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341ed0))(this, p0);
    }

    virtual void setGlowOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x336200))(this, p0);
    }

    virtual void setLastPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x3439e0))(this, p0);
    }

    virtual void setMainColorMode(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x342e70))(this, p0);
    }

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x341c90))(this, p0);
    }

    virtual void setObjectRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc1e0))(this, p0);
    }

    virtual void setOrientedRectDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0xdc200))(this, p0);
    }

    virtual void setRScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335e10))(this, p0);
    }

    virtual void setRScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335cb0))(this, p0);
    }

    virtual void setRScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335d60))(this, p0);
    }

    virtual void setSectionIdx(int const& p0) {
        return reinterpret_cast<void(*)(decltype(this), int const&)>(m->getOriginal(getBase()+0x343a10))(this, p0);
    }

    virtual void setStartPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x2fa520))(this, p0);
    }

    virtual void setType(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0xdc220))(this, p0);
    }

    virtual void triggerActivated(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x336990))(this, p0);
    }

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0x2fa8f0))(this, p0);
    }

    virtual void updateCustomScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x335eb0))(this, p0);
    }

    virtual void updateSyncedAnimation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x337f00))(this, p0);
    }

    virtual void selectObject(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x341f90))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x335850))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GameObject::*)(GameObject*);
        m->registerHook(getBase()+0x342a20, extract_virtual(this, tf0{&$GameObject::activatedByPlayer}));

		using tf1 = void($GameObject::*)(bool);
        m->registerHook(getBase()+0x2fb470, extract_virtual(this, tf1{&$GameObject::addColorSpriteToParent}));

		using tf2 = void($GameObject::*)(bool);
        m->registerHook(getBase()+0x33a5b0, extract_virtual(this, tf2{&$GameObject::addMainSpriteToParent}));

		using tf3 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x33ad00, extract_virtual(this, tf3{&$GameObject::addToGroup}));

		using tf4 = void($GameObject::*)(float, float);
        m->registerHook(getBase()+0x335700, extract_virtual(this, tf4{&$GameObject::addToTempOffset}));

		using tf5 = void($GameObject::*)(int, bool);
        m->registerHook(getBase()+0x343460, extract_virtual(this, tf5{&$GameObject::colorForMode}));

		using tf6 = void($GameObject::*)(GameObject*);
        m->registerHook(getBase()+0x33ae30, extract_virtual(this, tf6{&$GameObject::copyGroups}));

		using tf7 = void($GameObject::*)(char const*);
        m->registerHook(getBase()+0x2f5490, extract_virtual(this, tf7{&$GameObject::createWithFrame}));

		using tf8 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x2f4ce0, extract_virtual(this, tf8{&$GameObject::createWithKey}));

		using tf9 = void($GameObject::*)(std::map<std::string, std::string, std::less<std::string>, std::allocator<std::pair<std::string const, std::string> > >&);
        m->registerHook(getBase()+0xdc1a0, extract_virtual(this, tf9{&$GameObject::customObjectSetup}));

		using tf10 = void($GameObject::*)(bool);
        m->registerHook(getBase()+0x2fb8f0, extract_virtual(this, tf10{&$GameObject::deactivateObject}));

		using tf11 = void($GameObject::*)(int, bool);
        m->registerHook(getBase()+0x343860, extract_virtual(this, tf11{&$GameObject::getActiveColorForMode}));

		using tf12 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x341bf0, extract_virtual(this, tf12{&$GameObject::getBallFrame}));

		using tf13 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x33ae10, extract_virtual(this, tf13{&$GameObject::getGroupID}));

		using tf14 = void($GameObject::*)(float, float);
        m->registerHook(getBase()+0x3352d0, extract_virtual(this, tf14{&$GameObject::getObjectRect}));

		using tf15 = void($GameObject::*)(float, float);
        m->registerHook(getBase()+0x3354e0, extract_virtual(this, tf15{&$GameObject::getObjectRect2}));

		using tf16 = void($GameObject::*)(GameObject*);
        m->registerHook(getBase()+0x342a50, extract_virtual(this, tf16{&$GameObject::hasBeenActivatedByPlayer}));

		using tf17 = void($GameObject::*)(cocos2d::CCTexture2D*);
        m->registerHook(getBase()+0x2f56a0, extract_virtual(this, tf17{&$GameObject::initWithTexture}));

		using tf18 = void($GameObject::*)(std::string, bool);
        m->registerHook(getBase()+0x33b720, extract_virtual(this, tf18{&$GameObject::objectFromString}));

		using tf19 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x33ada0, extract_virtual(this, tf19{&$GameObject::removeFromGroup}));

		using tf20 = void($GameObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x341f20, extract_virtual(this, tf20{&$GameObject::setChildColor}));

		using tf21 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x304fc0, extract_virtual(this, tf21{&$GameObject::setDefaultMainColorMode}));

		using tf22 = void($GameObject::*)(bool const&);
        m->registerHook(getBase()+0x343a30, extract_virtual(this, tf22{&$GameObject::setDidUpdateLastPosition}));

		using tf23 = void($GameObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x341ed0, extract_virtual(this, tf23{&$GameObject::setGlowColor}));

		using tf24 = void($GameObject::*)(unsigned char);
        m->registerHook(getBase()+0x336200, extract_virtual(this, tf24{&$GameObject::setGlowOpacity}));

		using tf25 = void($GameObject::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x3439e0, extract_virtual(this, tf25{&$GameObject::setLastPosition}));

		using tf26 = void($GameObject::*)(int);
        m->registerHook(getBase()+0x342e70, extract_virtual(this, tf26{&$GameObject::setMainColorMode}));

		using tf27 = void($GameObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x341c90, extract_virtual(this, tf27{&$GameObject::setObjectColor}));

		using tf28 = void($GameObject::*)(bool);
        m->registerHook(getBase()+0xdc1e0, extract_virtual(this, tf28{&$GameObject::setObjectRectDirty}));

		using tf29 = void($GameObject::*)(bool);
        m->registerHook(getBase()+0xdc200, extract_virtual(this, tf29{&$GameObject::setOrientedRectDirty}));

		using tf30 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x335e10, extract_virtual(this, tf30{&$GameObject::setRScale}));

		using tf31 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x335cb0, extract_virtual(this, tf31{&$GameObject::setRScaleX}));

		using tf32 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x335d60, extract_virtual(this, tf32{&$GameObject::setRScaleY}));

		using tf33 = void($GameObject::*)(int const&);
        m->registerHook(getBase()+0x343a10, extract_virtual(this, tf33{&$GameObject::setSectionIdx}));

		using tf34 = void($GameObject::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0x2fa520, extract_virtual(this, tf34{&$GameObject::setStartPos}));

		using tf35 = void($GameObject::*)(GameObjectType);
        m->registerHook(getBase()+0xdc220, extract_virtual(this, tf35{&$GameObject::setType}));

		using tf36 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x336990, extract_virtual(this, tf36{&$GameObject::triggerActivated}));

		using tf37 = void($GameObject::*)(GJBaseGameLayer*);
        m->registerHook(getBase()+0x2fa8f0, extract_virtual(this, tf37{&$GameObject::triggerObject}));

		using tf38 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x335eb0, extract_virtual(this, tf38{&$GameObject::updateCustomScale}));

		using tf39 = void($GameObject::*)(float);
        m->registerHook(getBase()+0x337f00, extract_virtual(this, tf39{&$GameObject::updateSyncedAnimation}));

		using tf40 = void($GameObject::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x341f90, extract_virtual(this, tf40{&$GameObject::selectObject}));

		using tf41 = void($GameObject::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x335850, extract_virtual(this, tf41{&$GameObject::setPosition}));
    }
};


class $GameSoundManager : public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GameSoundManager* __thistype;

    virtual void playBackgroundMusic(std::string p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, bool)>(m->getOriginal(getBase()+0x362070))(this, p0, p1, p2);
    }

    virtual void playEffect(std::string p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), std::string, float, float, float)>(m->getOriginal(getBase()+0x3623d0))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($GameSoundManager::*)(std::string, bool, bool);
        m->registerHook(getBase()+0x362070, extract_virtual(this, tf0{&$GameSoundManager::playBackgroundMusic}));

		using tf1 = void($GameSoundManager::*)(std::string, float, float, float);
        m->registerHook(getBase()+0x3623d0, extract_virtual(this, tf1{&$GameSoundManager::playEffect}));
    }
};


class $GameStatsManager : public $CacBase {
 public:
    $GameStatsManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GameStatsManager* __thistype;

    virtual void awardCurrencyForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43600))(this, p0);
    }

    virtual void awardDiamondsForLevel(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x43c60))(this, p0);
    }

    virtual void getSecretCoinKey(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x429f0))(this, p0);
    }

    virtual void getStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d310))(this, p0);
    }

    virtual void hasPendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42730))(this, p0);
    }

    virtual void hasSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x40730))(this, p0);
    }

    virtual void hasUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x427e0))(this, p0);
    }

    virtual void incrementStat(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x3d6d0))(this, p0);
    }

    virtual void incrementStat(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x3d6e0))(this, p0, p1);
    }

    virtual void storePendingUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42940))(this, p0);
    }

    virtual void storeSecretCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42a10))(this, p0);
    }

    virtual void storeUserCoin(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x42890))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GameStatsManager::*)(GJGameLevel*);
        m->registerHook(getBase()+0x43600, extract_virtual(this, tf0{&$GameStatsManager::awardCurrencyForLevel}));

		using tf1 = void($GameStatsManager::*)(GJGameLevel*);
        m->registerHook(getBase()+0x43c60, extract_virtual(this, tf1{&$GameStatsManager::awardDiamondsForLevel}));

		using tf2 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x429f0, extract_virtual(this, tf2{&$GameStatsManager::getSecretCoinKey}));

		using tf3 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x3d310, extract_virtual(this, tf3{&$GameStatsManager::getStat}));

		using tf4 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x42730, extract_virtual(this, tf4{&$GameStatsManager::hasPendingUserCoin}));

		using tf5 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x40730, extract_virtual(this, tf5{&$GameStatsManager::hasSecretCoin}));

		using tf6 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x427e0, extract_virtual(this, tf6{&$GameStatsManager::hasUserCoin}));

		using tf7 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x3d6d0, extract_virtual(this, tf7{&$GameStatsManager::incrementStat}));

		using tf8 = void($GameStatsManager::*)(char const*, int);
        m->registerHook(getBase()+0x3d6e0, extract_virtual(this, tf8{&$GameStatsManager::incrementStat}));

		using tf9 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x42940, extract_virtual(this, tf9{&$GameStatsManager::storePendingUserCoin}));

		using tf10 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x42a10, extract_virtual(this, tf10{&$GameStatsManager::storeSecretCoin}));

		using tf11 = void($GameStatsManager::*)(char const*);
        m->registerHook(getBase()+0x42890, extract_virtual(this, tf11{&$GameStatsManager::storeUserCoin}));
    }
};


class $GameToolbox : public $CacBase {
 public:
    $GameToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GameToolbox* __thistype;

    virtual void multipliedColorValue(cocos2d::_ccColor3B p0, cocos2d::_ccColor3B p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x28cb90))(this, p0, p1, p2);
    }

    virtual void stringSetupToDict(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d700))(this, p0, p1);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, float, float, float)>(m->getOriginal(getBase()+0x28c930))(this, p0, p1, p2, p3);
    }

    virtual void transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue)>(m->getOriginal(getBase()+0x28c950))(this, p0, p1);
    }

    virtual void stringSetupToMap(std::string p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(getBase()+0x28d4c0))(this, p0, p1);
    }

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x28bdd0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
    }

void apply_hooks() override {
		using tf0 = void($GameToolbox::*)(cocos2d::_ccColor3B, cocos2d::_ccColor3B, float);
        m->registerHook(getBase()+0x28cb90, extract_virtual(this, tf0{&$GameToolbox::multipliedColorValue}));

		using tf1 = void($GameToolbox::*)(std::string, char const*);
        m->registerHook(getBase()+0x28d700, extract_virtual(this, tf1{&$GameToolbox::stringSetupToDict}));

		using tf2 = void($GameToolbox::*)(cocos2d::_ccColor3B const&, float, float, float);
        m->registerHook(getBase()+0x28c930, extract_virtual(this, tf2{&$GameToolbox::transformColor}));

		using tf3 = void($GameToolbox::*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue);
        m->registerHook(getBase()+0x28c950, extract_virtual(this, tf3{&$GameToolbox::transformColor}));

		using tf4 = void($GameToolbox::*)(std::string, char const*);
        m->registerHook(getBase()+0x28d4c0, extract_virtual(this, tf4{&$GameToolbox::stringSetupToMap}));

		using tf5 = void($GameToolbox::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
        m->registerHook(getBase()+0x28bdd0, extract_virtual(this, tf5{&$GameToolbox::createToggleButton}));
    }
};


class $GravityEffectSprite : public $CacBase {
 public:
    $GravityEffectSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GravityEffectSprite* __thistype;

    virtual void updateSpritesColor(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x7ce30))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GravityEffectSprite::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x7ce30, extract_virtual(this, tf0{&$GravityEffectSprite::updateSpritesColor}));
    }
};


class $GroupCommandObject : public $CacBase {
 public:
    $GroupCommandObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GroupCommandObject* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x16ece0))(this, p0);
    }

    virtual void easeToText(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x16ecb0))(this, p0);
    }

    virtual void getEasedAction(cocos2d::CCActionInterval* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, int, float)>(m->getOriginal(getBase()+0x16e7b0))(this, p0, p1, p2);
    }

    virtual void runMoveCommand(cocos2d::CCPoint p0, float p1, int p2, float p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, int, float, bool, bool)>(m->getOriginal(getBase()+0x16e640))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void runRotateCommand(float p0, float p1, int p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), float, float, int, float, bool)>(m->getOriginal(getBase()+0x16e8f0))(this, p0, p1, p2, p3, p4);
    }

void apply_hooks() override {
		using tf0 = void($GroupCommandObject::*)(std::string);
        m->registerHook(getBase()+0x16ece0, extract_virtual(this, tf0{&$GroupCommandObject::createFromString}));

		using tf1 = void($GroupCommandObject::*)(int);
        m->registerHook(getBase()+0x16ecb0, extract_virtual(this, tf1{&$GroupCommandObject::easeToText}));

		using tf2 = void($GroupCommandObject::*)(cocos2d::CCActionInterval*, int, float);
        m->registerHook(getBase()+0x16e7b0, extract_virtual(this, tf2{&$GroupCommandObject::getEasedAction}));

		using tf3 = void($GroupCommandObject::*)(cocos2d::CCPoint, float, int, float, bool, bool);
        m->registerHook(getBase()+0x16e640, extract_virtual(this, tf3{&$GroupCommandObject::runMoveCommand}));

		using tf4 = void($GroupCommandObject::*)(float, float, int, float, bool);
        m->registerHook(getBase()+0x16e8f0, extract_virtual(this, tf4{&$GroupCommandObject::runRotateCommand}));
    }
};


class $HardStreak : public $CacBase {
 public:
    $HardStreak() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $HardStreak* __thistype;

    virtual void addPoint(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x5c950))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($HardStreak::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0x5c950, extract_virtual(this, tf0{&$HardStreak::addPoint}));
    }
};


class $LabelGameObject : public $CacBase {
 public:
    $LabelGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LabelGameObject* __thistype;

    virtual void setObjectColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0xdbca0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($LabelGameObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0xdbca0, extract_virtual(this, tf0{&$LabelGameObject::setObjectColor}));
    }
};


class $LevelEditorLayer : public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LevelEditorLayer* __thistype;

    virtual void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(getBase()+0x9b520))(this, p0, p1, p2, p3);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0xa2780))(this, p0, p1, p2);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x9e620))(this, p0, p1);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x92230))(this, p0);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x91010))(this, p0);
    }

    virtual void objectMoved(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x999f0))(this, p0);
    }

    virtual void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(getBase()+0x9bd30))(this, p0, p1, p2, p3, p4);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0xa0ca0))(this, p0);
    }

    virtual void stopTriggersInGroup(int p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(getBase()+0x9c030))(this, p0, p1);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0xa0200))(this, p0, p1, p2, p3);
    }

    virtual void toggleGroupPreview(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x9bea0))(this, p0, p1);
    }

    virtual void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(getBase()+0x9ab50))(this, p0, p1);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this, p0);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0xa1a60))(this, p0, p1, p2);
    }

    virtual void addObjectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x94640))(this, p0);
    }

    virtual void createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(getBase()+0x957c0))(this, p0, p1, p2);
    }

    virtual void createObjectsFromString(std::string p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(getBase()+0x94730))(this, p0, p1);
    }

    virtual void getNextFreeGroupID(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x9a1b0))(this, p0);
    }

    virtual void handleAction(bool p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x97020))(this, p0, p1);
    }

    virtual void removeObject(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x96890))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($LevelEditorLayer::*)(EffectGameObject*, float, float, float);
        m->registerHook(getBase()+0x9b520, extract_virtual(this, tf0{&$LevelEditorLayer::activateTriggerEffect}));

		using tf1 = void($LevelEditorLayer::*)(GameObject*, float, bool);
        m->registerHook(getBase()+0xa2780, extract_virtual(this, tf1{&$LevelEditorLayer::animateInDualGround}));

		using tf2 = void($LevelEditorLayer::*)(PlayerObject*, float);
        m->registerHook(getBase()+0x9e620, extract_virtual(this, tf2{&$LevelEditorLayer::checkCollisions}));

		using tf3 = void($LevelEditorLayer::*)(std::string);
        m->registerHook(getBase()+0x92230, extract_virtual(this, tf3{&$LevelEditorLayer::createObjectsFromSetup}));

		using tf4 = void($LevelEditorLayer::*)(GJGameLevel*);
        m->registerHook(getBase()+0x91010, extract_virtual(this, tf4{&$LevelEditorLayer::init}));

		using tf5 = void($LevelEditorLayer::*)(GameObject*);
        m->registerHook(getBase()+0x999f0, extract_virtual(this, tf5{&$LevelEditorLayer::objectMoved}));

		using tf6 = void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool);
        m->registerHook(getBase()+0x9bd30, extract_virtual(this, tf6{&$LevelEditorLayer::runColorEffect}));

		using tf7 = void($LevelEditorLayer::*)(LevelSettingsObject*);
        m->registerHook(getBase()+0xa0ca0, extract_virtual(this, tf7{&$LevelEditorLayer::setupLevelStart}));

		using tf8 = void($LevelEditorLayer::*)(int, float);
        m->registerHook(getBase()+0x9c030, extract_virtual(this, tf8{&$LevelEditorLayer::stopTriggersInGroup}));

		using tf9 = void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool);
        m->registerHook(getBase()+0xa0200, extract_virtual(this, tf9{&$LevelEditorLayer::toggleDualMode}));

		using tf10 = void($LevelEditorLayer::*)(int, bool);
        m->registerHook(getBase()+0x9bea0, extract_virtual(this, tf10{&$LevelEditorLayer::toggleGroupPreview}));

		using tf11 = void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*);
        m->registerHook(getBase()+0x9ab50, extract_virtual(this, tf11{&$LevelEditorLayer::transferDefaultColors}));

		using tf12 = void($LevelEditorLayer::*)(float);
        m->registerHook(getBase()+0xa1b70, extract_virtual(this, tf12{&$LevelEditorLayer::update}));

		using tf13 = void($LevelEditorLayer::*)(PlayerObject*, int, bool);
        m->registerHook(getBase()+0xa1a60, extract_virtual(this, tf13{&$LevelEditorLayer::updateDualGround}));

		using tf14 = void($LevelEditorLayer::*)(std::string);
        m->registerHook(getBase()+0x94640, extract_virtual(this, tf14{&$LevelEditorLayer::addObjectFromString}));

		using tf15 = void($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool);
        m->registerHook(getBase()+0x957c0, extract_virtual(this, tf15{&$LevelEditorLayer::createObject}));

		using tf16 = void($LevelEditorLayer::*)(std::string, bool);
        m->registerHook(getBase()+0x94730, extract_virtual(this, tf16{&$LevelEditorLayer::createObjectsFromString}));

		using tf17 = void($LevelEditorLayer::*)(cocos2d::CCArray*);
        m->registerHook(getBase()+0x9a1b0, extract_virtual(this, tf17{&$LevelEditorLayer::getNextFreeGroupID}));

		using tf18 = void($LevelEditorLayer::*)(bool, cocos2d::CCArray*);
        m->registerHook(getBase()+0x97020, extract_virtual(this, tf18{&$LevelEditorLayer::handleAction}));

		using tf19 = void($LevelEditorLayer::*)(GameObject*, bool);
        m->registerHook(getBase()+0x96890, extract_virtual(this, tf19{&$LevelEditorLayer::removeObject}));
    }
};


class $LevelSettingsLayer : public $CacBase {
 public:
    $LevelSettingsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LevelSettingsLayer* __thistype;

    virtual void create(LevelSettingsObject* p0, LevelEditorLayer* p1) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*, LevelEditorLayer*)>(m->getOriginal(getBase()+0xa7c30))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($LevelSettingsLayer::*)(LevelSettingsObject*, LevelEditorLayer*);
        m->registerHook(getBase()+0xa7c30, extract_virtual(this, tf0{&$LevelSettingsLayer::create}));
    }
};


class $LevelSettingsObject : public $CacBase {
 public:
    $LevelSettingsObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LevelSettingsObject* __thistype;

    virtual void objectFromDict(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa5810))(this, p0);
    }

    virtual void objectFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x945a0))(this, p0);
    }

    virtual void setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(getBase()+0xa6a30))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($LevelSettingsObject::*)(cocos2d::CCDictionary*);
        m->registerHook(getBase()+0xa5810, extract_virtual(this, tf0{&$LevelSettingsObject::objectFromDict}));

		using tf1 = void($LevelSettingsObject::*)(std::string);
        m->registerHook(getBase()+0x945a0, extract_virtual(this, tf1{&$LevelSettingsObject::objectFromString}));

		using tf2 = void($LevelSettingsObject::*)(cocos2d::CCDictionary*);
        m->registerHook(getBase()+0xa6a30, extract_virtual(this, tf2{&$LevelSettingsObject::setupColorsFromLegacyMode}));
    }
};


class $LevelTools : public $CacBase {
 public:
    $LevelTools() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LevelTools* __thistype;

    virtual void getAudioString(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x293880))(this, p0);
    }

    virtual void verifyLevelIntegrity(std::string p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), std::string, int)>(m->getOriginal(getBase()+0x294360))(this, p0, p1);
    }

    virtual void xPosForTime(float p0, cocos2d::CCArray* p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCArray*, int)>(m->getOriginal(getBase()+0x293d90))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($LevelTools::*)(int);
        m->registerHook(getBase()+0x293880, extract_virtual(this, tf0{&$LevelTools::getAudioString}));

		using tf1 = void($LevelTools::*)(std::string, int);
        m->registerHook(getBase()+0x294360, extract_virtual(this, tf1{&$LevelTools::verifyLevelIntegrity}));

		using tf2 = void($LevelTools::*)(float, cocos2d::CCArray*, int);
        m->registerHook(getBase()+0x293d90, extract_virtual(this, tf2{&$LevelTools::xPosForTime}));
    }
};


class $MenuGameLayer : public $CacBase {
 public:
    $MenuGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $MenuGameLayer* __thistype;

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x28fa70))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($MenuGameLayer::*)(float);
        m->registerHook(getBase()+0x28fa70, extract_virtual(this, tf0{&$MenuGameLayer::update}));
    }
};


class $MusicDownloadManager : public $CacBase {
 public:
    $MusicDownloadManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $MusicDownloadManager* __thistype;

    virtual void incrementPriorityForSong(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x2ef750))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($MusicDownloadManager::*)(int);
        m->registerHook(getBase()+0x2ef750, extract_virtual(this, tf0{&$MusicDownloadManager::incrementPriorityForSong}));
    }
};


class $OBB2D : public $CacBase {
 public:
    $OBB2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $OBB2D* __thistype;

    virtual void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a9c0))(this, p0, p1, p2, p3);
    }

    virtual void create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x35a890))(this, p0, p1, p2, p3);
    }

    virtual void overlaps1Way(OBB2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(getBase()+0x35b0d0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($OBB2D::*)(cocos2d::CCPoint, float, float, float);
        m->registerHook(getBase()+0x35a9c0, extract_virtual(this, tf0{&$OBB2D::calculateWithCenter}));

		using tf1 = void($OBB2D::*)(cocos2d::CCPoint, float, float, float);
        m->registerHook(getBase()+0x35a890, extract_virtual(this, tf1{&$OBB2D::create}));

		using tf2 = void($OBB2D::*)(OBB2D*);
        m->registerHook(getBase()+0x35b0d0, extract_virtual(this, tf2{&$OBB2D::overlaps1Way}));
    }
};


class $ObjectToolbox : public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ObjectToolbox* __thistype;

    virtual void intKeyToFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x4173b0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($ObjectToolbox::*)(int);
        m->registerHook(getBase()+0x4173b0, extract_virtual(this, tf0{&$ObjectToolbox::intKeyToFrame}));
    }
};


class $OpacityEffectAction : public $CacBase {
 public:
    $OpacityEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $OpacityEffectAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x178c10))(this, p0);
    }

    virtual void step(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x178b90))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($OpacityEffectAction::*)(std::string);
        m->registerHook(getBase()+0x178c10, extract_virtual(this, tf0{&$OpacityEffectAction::createFromString}));

		using tf1 = void($OpacityEffectAction::*)(float);
        m->registerHook(getBase()+0x178b90, extract_virtual(this, tf1{&$OpacityEffectAction::step}));
    }
};


class $PauseLayer : public $CacBase {
 public:
    $PauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $PauseLayer* __thistype;

    virtual void create(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x20b1e0))(this, p0);
    }

    virtual void onEdit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x20c630))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($PauseLayer::*)(bool);
        m->registerHook(getBase()+0x20b1e0, extract_virtual(this, tf0{&$PauseLayer::create}));

		using tf1 = void($PauseLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x20c630, extract_virtual(this, tf1{&$PauseLayer::onEdit}));
    }
};


class $PlayLayer : public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $PlayLayer* __thistype;

    virtual void addCircle(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e0f0))(this, p0);
    }

    virtual void addObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x70e50))(this, p0);
    }

    virtual void addToGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77680))(this, p0);
    }

    virtual void addToSpeedObjects(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7cfc0))(this, p0);
    }

    virtual void animateInDualGround(GameObject* p0, float p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(getBase()+0x7d710))(this, p0, p1, p2);
    }

    virtual void animateInGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7d9d0))(this, p0);
    }

    virtual void animateOutGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6f350))(this, p0);
    }

    virtual void applyEnterEffect(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c310))(this, p0);
    }

    virtual void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(getBase()+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void cameraMoveX(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cbe0))(this, p0, p1, p2);
    }

    virtual void cameraMoveY(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x7cc60))(this, p0, p1, p2);
    }

    virtual void checkCollisions(PlayerObject* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(getBase()+0x78c90))(this, p0, p1);
    }

    virtual void claimParticle(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x76ba0))(this, p0);
    }

    virtual void colorObject(int p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x77810))(this, p0, p1);
    }

    virtual void create(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b590))(this, p0);
    }

    virtual void createObjectsFromSetup(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x6d130))(this, p0);
    }

    virtual void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x76800))(this, p0, p1, p2, p3);
    }

    virtual void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7ab80))(this, p0, p1);
    }

    virtual void enterDualMode(GameObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(getBase()+0x7d6a0))(this, p0, p1);
    }

    virtual void exitBirdMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dd80))(this, p0);
    }

    virtual void exitDartMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7ddd0))(this, p0);
    }

    virtual void exitFlyMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcf0))(this, p0);
    }

    virtual void exitRobotMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de20))(this, p0);
    }

    virtual void exitRollMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de60))(this, p0);
    }

    virtual void exitSpiderMode(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7de40))(this, p0);
    }

    virtual void flipGravity(PlayerObject* p0, bool p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(getBase()+0x7cd10))(this, p0, p1, p2);
    }

    virtual void getOtherPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7dcc0))(this, p0);
    }

    virtual void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(getBase()+0x764d0))(this, p0, p1, p2, p3);
    }

    virtual void getParticleKey2(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x767b0))(this, p0);
    }

    virtual void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(getBase()+0x7c2a0))(this, p0, p1, p2, p3);
    }

    virtual void hasItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7cee0))(this, p0);
    }

    virtual void hasUniqueCoin(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77510))(this, p0);
    }

    virtual void init(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b5f0))(this, p0);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x75bf0))(this, p0, p1);
    }

    virtual void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(getBase()+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void loadFromCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7f000))(this, p0);
    }

    virtual void loadSavedObjectsState(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7f3d0))(this, p0);
    }

    virtual void moveCameraToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x7c980))(this, p0);
    }

    virtual void pauseGame(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x802d0))(this, p0);
    }

    virtual void pickupItem(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x7c1d0))(this, p0);
    }

    virtual void playAnimationCommand(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0x75930))(this, p0, p1);
    }

    virtual void playEndAnimationToPos(cocos2d::CCPoint p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(getBase()+0x759a0))(this, p0);
    }

    virtual void playExitDualEffect(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x7d1d0))(this, p0);
    }

    virtual void playFlashEffect(float p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(getBase()+0x75e50))(this, p0, p1, p2);
    }

    virtual void playGravityEffect(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7b5a0))(this, p0);
    }

    virtual void playSpeedParticle(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77030))(this, p0);
    }

    virtual void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(getBase()+0x7b820))(this, p0, p1);
    }

    virtual void recordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x7e190))(this, p0, p1);
    }

    virtual void registerActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77620))(this, p0);
    }

    virtual void registerStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777b0))(this, p0);
    }

    virtual void removeFromGroupOld(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77750))(this, p0);
    }

    virtual void saveRecordAction(bool p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(getBase()+0x78750))(this, p0, p1);
    }

    virtual void scene(GJGameLevel* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(getBase()+0x6b500))(this, p0);
    }

    virtual void setupLevelStart(LevelSettingsObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(getBase()+0x6f560))(this, p0);
    }

    virtual void setupReplay(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x7e1e0))(this, p0);
    }

    virtual void shakeCamera(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x744a0))(this, p0, p1, p2);
    }

    virtual void shouldBlend(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x771b0))(this, p0);
    }

    virtual void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(getBase()+0x74580))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(getBase()+0x76330))(this, p0, p1, p2, p3);
    }

    virtual void storeCheckpoint(CheckpointObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(getBase()+0x7ef10))(this, p0);
    }

    virtual void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(getBase()+0x7baf0))(this, p0, p1, p2, p3);
    }

    virtual void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bc80))(this, p0, p1, p2);
    }

    virtual void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bbe0))(this, p0, p1, p2);
    }

    virtual void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(getBase()+0x7bd20))(this, p0, p1, p2);
    }

    virtual void timeForXPos(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d120))(this, p0);
    }

    virtual void timeForXPos2(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x293eb0))(this, p0, p1);
    }

    virtual void toggleBGEffectVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7fe80))(this, p0);
    }

    virtual void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(getBase()+0x7bf90))(this, p0, p1, p2, p3);
    }

    virtual void toggleFlipped(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x7bdc0))(this, p0, p1);
    }

    virtual void toggleGhostEffect(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x7fe40))(this, p0);
    }

    virtual void toggleGlitter(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x70e00))(this, p0);
    }

    virtual void togglePracticeMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x7f9e0))(this, p0);
    }

    virtual void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(getBase()+0x76e00))(this, p0, p1);
    }

    virtual void unregisterActiveObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x77660))(this, p0);
    }

    virtual void unregisterStateObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x777f0))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x77900))(this, p0);
    }

    virtual void updateCamera(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x6e2b0))(this, p0);
    }

    virtual void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(getBase()+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    virtual void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(getBase()+0x7caa0))(this, p0, p1, p2);
    }

    virtual void updateReplay(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x78b60))(this, p0);
    }

    virtual void updateTimeMod(float p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(getBase()+0x786f0))(this, p0, p1);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x7ffb0))(this, p0, p1);
    }

    virtual void willSwitchToMode(int p0, PlayerObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(getBase()+0x7b9e0))(this, p0, p1);
    }

    virtual void xPosForTime(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x7d140))(this, p0);
    }

    virtual void circleWaveWillBeRemoved(CCCircleWave* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(getBase()+0x7e110))(this, p0);
    }

    virtual void currencyWillExit(CurrencyRewardLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(getBase()+0x7e070))(this, p0);
    }

    virtual void dialogClosed(DialogLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(getBase()+0x7e0b0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($PlayLayer::*)(CCCircleWave*);
        m->registerHook(getBase()+0x7e0f0, extract_virtual(this, tf0{&$PlayLayer::addCircle}));

		using tf1 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x70e50, extract_virtual(this, tf1{&$PlayLayer::addObject}));

		using tf2 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x77680, extract_virtual(this, tf2{&$PlayLayer::addToGroupOld}));

		using tf3 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x7cfc0, extract_virtual(this, tf3{&$PlayLayer::addToSpeedObjects}));

		using tf4 = void($PlayLayer::*)(GameObject*, float, bool);
        m->registerHook(getBase()+0x7d710, extract_virtual(this, tf4{&$PlayLayer::animateInDualGround}));

		using tf5 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x7d9d0, extract_virtual(this, tf5{&$PlayLayer::animateInGround}));

		using tf6 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x6f350, extract_virtual(this, tf6{&$PlayLayer::animateOutGround}));

		using tf7 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x7c310, extract_virtual(this, tf7{&$PlayLayer::applyEnterEffect}));

		using tf8 = void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*);
        m->registerHook(getBase()+0x7aa10, extract_virtual(this, tf8{&$PlayLayer::calculateColorValues}));

		using tf9 = void($PlayLayer::*)(float, float, float);
        m->registerHook(getBase()+0x7cbe0, extract_virtual(this, tf9{&$PlayLayer::cameraMoveX}));

		using tf10 = void($PlayLayer::*)(float, float, float);
        m->registerHook(getBase()+0x7cc60, extract_virtual(this, tf10{&$PlayLayer::cameraMoveY}));

		using tf11 = void($PlayLayer::*)(PlayerObject*, float);
        m->registerHook(getBase()+0x78c90, extract_virtual(this, tf11{&$PlayLayer::checkCollisions}));

		using tf12 = void($PlayLayer::*)(std::string);
        m->registerHook(getBase()+0x76ba0, extract_virtual(this, tf12{&$PlayLayer::claimParticle}));

		using tf13 = void($PlayLayer::*)(int, cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x77810, extract_virtual(this, tf13{&$PlayLayer::colorObject}));

		using tf14 = void($PlayLayer::*)(GJGameLevel*);
        m->registerHook(getBase()+0x6b590, extract_virtual(this, tf14{&$PlayLayer::create}));

		using tf15 = void($PlayLayer::*)(std::string);
        m->registerHook(getBase()+0x6d130, extract_virtual(this, tf15{&$PlayLayer::createObjectsFromSetup}));

		using tf16 = void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType);
        m->registerHook(getBase()+0x76800, extract_virtual(this, tf16{&$PlayLayer::createParticle}));

		using tf17 = void($PlayLayer::*)(PlayerObject*, GameObject*);
        m->registerHook(getBase()+0x7ab80, extract_virtual(this, tf17{&$PlayLayer::destroyPlayer}));

		using tf18 = void($PlayLayer::*)(GameObject*, bool);
        m->registerHook(getBase()+0x7d6a0, extract_virtual(this, tf18{&$PlayLayer::enterDualMode}));

		using tf19 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7dd80, extract_virtual(this, tf19{&$PlayLayer::exitBirdMode}));

		using tf20 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7ddd0, extract_virtual(this, tf20{&$PlayLayer::exitDartMode}));

		using tf21 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7dcf0, extract_virtual(this, tf21{&$PlayLayer::exitFlyMode}));

		using tf22 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7de20, extract_virtual(this, tf22{&$PlayLayer::exitRobotMode}));

		using tf23 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7de60, extract_virtual(this, tf23{&$PlayLayer::exitRollMode}));

		using tf24 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7de40, extract_virtual(this, tf24{&$PlayLayer::exitSpiderMode}));

		using tf25 = void($PlayLayer::*)(PlayerObject*, bool, bool);
        m->registerHook(getBase()+0x7cd10, extract_virtual(this, tf25{&$PlayLayer::flipGravity}));

		using tf26 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7dcc0, extract_virtual(this, tf26{&$PlayLayer::getOtherPlayer}));

		using tf27 = void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType);
        m->registerHook(getBase()+0x764d0, extract_virtual(this, tf27{&$PlayLayer::getParticleKey}));

		using tf28 = void($PlayLayer::*)(std::string);
        m->registerHook(getBase()+0x767b0, extract_virtual(this, tf28{&$PlayLayer::getParticleKey2}));

		using tf29 = void($PlayLayer::*)(cocos2d::CCPoint, float, float, float);
        m->registerHook(getBase()+0x7c2a0, extract_virtual(this, tf29{&$PlayLayer::getRelativeMod}));

		using tf30 = void($PlayLayer::*)(int);
        m->registerHook(getBase()+0x7cee0, extract_virtual(this, tf30{&$PlayLayer::hasItem}));

		using tf31 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x77510, extract_virtual(this, tf31{&$PlayLayer::hasUniqueCoin}));

		using tf32 = void($PlayLayer::*)(GJGameLevel*);
        m->registerHook(getBase()+0x6b5f0, extract_virtual(this, tf32{&$PlayLayer::init}));

		using tf33 = void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x75bf0, extract_virtual(this, tf33{&$PlayLayer::lightningFlash}));

		using tf34 = void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float);
        m->registerHook(getBase()+0x75cc0, extract_virtual(this, tf34{&$PlayLayer::lightningFlash}));

		using tf35 = void($PlayLayer::*)(CheckpointObject*);
        m->registerHook(getBase()+0x7f000, extract_virtual(this, tf35{&$PlayLayer::loadFromCheckpoint}));

		using tf36 = void($PlayLayer::*)(std::string);
        m->registerHook(getBase()+0x7f3d0, extract_virtual(this, tf36{&$PlayLayer::loadSavedObjectsState}));

		using tf37 = void($PlayLayer::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0x7c980, extract_virtual(this, tf37{&$PlayLayer::moveCameraToPos}));

		using tf38 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x802d0, extract_virtual(this, tf38{&$PlayLayer::pauseGame}));

		using tf39 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x7c1d0, extract_virtual(this, tf39{&$PlayLayer::pickupItem}));

		using tf40 = void($PlayLayer::*)(int, int);
        m->registerHook(getBase()+0x75930, extract_virtual(this, tf40{&$PlayLayer::playAnimationCommand}));

		using tf41 = void($PlayLayer::*)(cocos2d::CCPoint);
        m->registerHook(getBase()+0x759a0, extract_virtual(this, tf41{&$PlayLayer::playEndAnimationToPos}));

		using tf42 = void($PlayLayer::*)(PlayerObject*);
        m->registerHook(getBase()+0x7d1d0, extract_virtual(this, tf42{&$PlayLayer::playExitDualEffect}));

		using tf43 = void($PlayLayer::*)(float, int, float);
        m->registerHook(getBase()+0x75e50, extract_virtual(this, tf43{&$PlayLayer::playFlashEffect}));

		using tf44 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x7b5a0, extract_virtual(this, tf44{&$PlayLayer::playGravityEffect}));

		using tf45 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x77030, extract_virtual(this, tf45{&$PlayLayer::playSpeedParticle}));

		using tf46 = void($PlayLayer::*)(PlayerObject*, GameObject*);
        m->registerHook(getBase()+0x7b820, extract_virtual(this, tf46{&$PlayLayer::playerWillSwitchMode}));

		using tf47 = void($PlayLayer::*)(bool, PlayerObject*);
        m->registerHook(getBase()+0x7e190, extract_virtual(this, tf47{&$PlayLayer::recordAction}));

		using tf48 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x77620, extract_virtual(this, tf48{&$PlayLayer::registerActiveObject}));

		using tf49 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x777b0, extract_virtual(this, tf49{&$PlayLayer::registerStateObject}));

		using tf50 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x77750, extract_virtual(this, tf50{&$PlayLayer::removeFromGroupOld}));

		using tf51 = void($PlayLayer::*)(bool, PlayerObject*);
        m->registerHook(getBase()+0x78750, extract_virtual(this, tf51{&$PlayLayer::saveRecordAction}));

		using tf52 = void($PlayLayer::*)(GJGameLevel*);
        m->registerHook(getBase()+0x6b500, extract_virtual(this, tf52{&$PlayLayer::scene}));

		using tf53 = void($PlayLayer::*)(LevelSettingsObject*);
        m->registerHook(getBase()+0x6f560, extract_virtual(this, tf53{&$PlayLayer::setupLevelStart}));

		using tf54 = void($PlayLayer::*)(std::string);
        m->registerHook(getBase()+0x7e1e0, extract_virtual(this, tf54{&$PlayLayer::setupReplay}));

		using tf55 = void($PlayLayer::*)(float, float, float);
        m->registerHook(getBase()+0x744a0, extract_virtual(this, tf55{&$PlayLayer::shakeCamera}));

		using tf56 = void($PlayLayer::*)(int);
        m->registerHook(getBase()+0x771b0, extract_virtual(this, tf56{&$PlayLayer::shouldBlend}));

		using tf57 = void($PlayLayer::*)(bool, int, int, bool, bool, bool);
        m->registerHook(getBase()+0x74580, extract_virtual(this, tf57{&$PlayLayer::showNewBest}));

		using tf58 = void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint);
        m->registerHook(getBase()+0x76330, extract_virtual(this, tf58{&$PlayLayer::spawnParticle}));

		using tf59 = void($PlayLayer::*)(CheckpointObject*);
        m->registerHook(getBase()+0x7ef10, extract_virtual(this, tf59{&$PlayLayer::storeCheckpoint}));

		using tf60 = void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int);
        m->registerHook(getBase()+0x7baf0, extract_virtual(this, tf60{&$PlayLayer::switchToFlyMode}));

		using tf61 = void($PlayLayer::*)(PlayerObject*, GameObject*, bool);
        m->registerHook(getBase()+0x7bc80, extract_virtual(this, tf61{&$PlayLayer::switchToRobotMode}));

		using tf62 = void($PlayLayer::*)(PlayerObject*, GameObject*, bool);
        m->registerHook(getBase()+0x7bbe0, extract_virtual(this, tf62{&$PlayLayer::switchToRollMode}));

		using tf63 = void($PlayLayer::*)(PlayerObject*, GameObject*, bool);
        m->registerHook(getBase()+0x7bd20, extract_virtual(this, tf63{&$PlayLayer::switchToSpiderMode}));

		using tf64 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x7d120, extract_virtual(this, tf64{&$PlayLayer::timeForXPos}));

		using tf65 = void($PlayLayer::*)(float, bool);
        m->registerHook(getBase()+0x293eb0, extract_virtual(this, tf65{&$PlayLayer::timeForXPos2}));

		using tf66 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x7fe80, extract_virtual(this, tf66{&$PlayLayer::toggleBGEffectVisibility}));

		using tf67 = void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool);
        m->registerHook(getBase()+0x7bf90, extract_virtual(this, tf67{&$PlayLayer::toggleDualMode}));

		using tf68 = void($PlayLayer::*)(bool, bool);
        m->registerHook(getBase()+0x7bdc0, extract_virtual(this, tf68{&$PlayLayer::toggleFlipped}));

		using tf69 = void($PlayLayer::*)(int);
        m->registerHook(getBase()+0x7fe40, extract_virtual(this, tf69{&$PlayLayer::toggleGhostEffect}));

		using tf70 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x70e00, extract_virtual(this, tf70{&$PlayLayer::toggleGlitter}));

		using tf71 = void($PlayLayer::*)(bool);
        m->registerHook(getBase()+0x7f9e0, extract_virtual(this, tf71{&$PlayLayer::togglePracticeMode}));

		using tf72 = void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*);
        m->registerHook(getBase()+0x76e00, extract_virtual(this, tf72{&$PlayLayer::unclaimParticle}));

		using tf73 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x77660, extract_virtual(this, tf73{&$PlayLayer::unregisterActiveObject}));

		using tf74 = void($PlayLayer::*)(GameObject*);
        m->registerHook(getBase()+0x777f0, extract_virtual(this, tf74{&$PlayLayer::unregisterStateObject}));

		using tf75 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x77900, extract_virtual(this, tf75{&$PlayLayer::update}));

		using tf76 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x6e2b0, extract_virtual(this, tf76{&$PlayLayer::updateCamera}));

		using tf77 = void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*);
        m->registerHook(getBase()+0x7c7f0, extract_virtual(this, tf77{&$PlayLayer::updateColor}));

		using tf78 = void($PlayLayer::*)(PlayerObject*, int, bool);
        m->registerHook(getBase()+0x7caa0, extract_virtual(this, tf78{&$PlayLayer::updateDualGround}));

		using tf79 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x78b60, extract_virtual(this, tf79{&$PlayLayer::updateReplay}));

		using tf80 = void($PlayLayer::*)(float, bool);
        m->registerHook(getBase()+0x786f0, extract_virtual(this, tf80{&$PlayLayer::updateTimeMod}));

		using tf81 = void($PlayLayer::*)(float, char const*);
        m->registerHook(getBase()+0x7ffb0, extract_virtual(this, tf81{&$PlayLayer::updateTweenAction}));

		using tf82 = void($PlayLayer::*)(int, PlayerObject*);
        m->registerHook(getBase()+0x7b9e0, extract_virtual(this, tf82{&$PlayLayer::willSwitchToMode}));

		using tf83 = void($PlayLayer::*)(float);
        m->registerHook(getBase()+0x7d140, extract_virtual(this, tf83{&$PlayLayer::xPosForTime}));

		using tf84 = void($PlayLayer::*)(CCCircleWave*);
        m->registerHook(getBase()+0x7e110, extract_virtual(this, tf84{&$PlayLayer::circleWaveWillBeRemoved}));

		using tf85 = void($PlayLayer::*)(CurrencyRewardLayer*);
        m->registerHook(getBase()+0x7e070, extract_virtual(this, tf85{&$PlayLayer::currencyWillExit}));

		using tf86 = void($PlayLayer::*)(DialogLayer*);
        m->registerHook(getBase()+0x7e0b0, extract_virtual(this, tf86{&$PlayLayer::dialogClosed}));
    }
};


class $PlayerObject : public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $PlayerObject* __thistype;

    virtual void addToTouchedRings(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22b800))(this, p0);
    }

    virtual void boostPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d6b0))(this, p0);
    }

    virtual void bumpPlayer(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x22d890))(this, p0, p1);
    }

    virtual void buttonDown(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b7e0))(this, p0);
    }

    virtual void checkSnapJumpToObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x2217f0))(this, p0);
    }

    virtual void collidedWithObject(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21d880))(this, p0, p1);
    }

    virtual void collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x21f0b0))(this, p0, p1, p2);
    }

    virtual void collidedWithSlope(float p0, GameObject* p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*, bool)>(m->getOriginal(getBase()+0x21d8d0))(this, p0, p1, p2);
    }

    virtual void convertToClosestRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21c860))(this, p0);
    }

    virtual void copyAttributes(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dc70))(this, p0);
    }

    virtual void create(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x217260))(this, p0, p1, p2);
    }

    virtual void deactivateStreak(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218b30))(this, p0);
    }

    virtual void fadeOutStreak2(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x225890))(this, p0);
    }

    virtual void flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x221c80))(this, p0, p1, p2, p3);
    }

    virtual void flipGravity(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x21c090))(this, p0, p1);
    }

    virtual void getOldPosition(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a830))(this, p0);
    }

    virtual void hitGround(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x220a30))(this, p0);
    }

    virtual void init(int p0, int p1, cocos2d::CCLayer* p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCLayer*)>(m->getOriginal(getBase()+0x2172e0))(this, p0, p1, p2);
    }

    virtual void isBoostValid(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21d650))(this, p0);
    }

    virtual void isSafeFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209f0))(this, p0);
    }

    virtual void isSafeMode(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2209b0))(this, p0);
    }

    virtual void isSafeSpiderFlip(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221be0))(this, p0);
    }

    virtual void loadFromCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e420))(this, p0);
    }

    virtual void playerDestroyed(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2256d0))(this, p0);
    }

    virtual void postCollision(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21cd10))(this, p0);
    }

    virtual void preSlopeCollision(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21ec80))(this, p0, p1);
    }

    virtual void propellPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22d8e0))(this, p0);
    }

    virtual void pushButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22aa00))(this, p0);
    }

    virtual void pushPlayer(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22dbb0))(this, p0);
    }

    virtual void releaseButton(PlayerButton p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerButton)>(m->getOriginal(getBase()+0x22b6f0))(this, p0);
    }

    virtual void ringJump(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22abf0))(this, p0);
    }

    virtual void runBallRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21ca10))(this, p0);
    }

    virtual void runRotateAction(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c570))(this, p0);
    }

    virtual void saveToCheckpoint(PlayerCheckpoint* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerCheckpoint*)>(m->getOriginal(getBase()+0x22e2f0))(this, p0);
    }

    virtual void setFlipX(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e720))(this, p0);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e7b0))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x22c8b0))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e6e0))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e870))(this, p0);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e7f0))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e830))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x219610))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x22e8b0))(this, p0);
    }

    virtual void spawnFromPlayer(PlayerObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(getBase()+0x22dde0))(this, p0);
    }

    virtual void spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float)>(m->getOriginal(getBase()+0x225350))(this, p0, p1);
    }

    virtual void spiderTestJump(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21b160))(this, p0);
    }

    virtual void startDashing(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x221d70))(this, p0);
    }

    virtual void stopRotation(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21c830))(this, p0);
    }

    virtual void storeCollision(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x21cc60))(this, p0, p1);
    }

    virtual void switchedToMode(GameObjectType p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(getBase()+0x22b9a0))(this, p0);
    }

    virtual void testForMoving(float p0, GameObject* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, GameObject*)>(m->getOriginal(getBase()+0x21eb70))(this, p0, p1);
    }

    virtual void toggleBirdMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224070))(this, p0);
    }

    virtual void toggleDartMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2243f0))(this, p0);
    }

    virtual void toggleFlyMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223820))(this, p0);
    }

    virtual void toggleGhostEffect(GhostType p0) {
        return reinterpret_cast<void(*)(decltype(this), GhostType)>(m->getOriginal(getBase()+0x225000))(this, p0);
    }

    virtual void togglePlayerScale(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224bd0))(this, p0);
    }

    virtual void toggleRobotMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223c70))(this, p0);
    }

    virtual void toggleRollMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x223b20))(this, p0);
    }

    virtual void toggleSpiderMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x224830))(this, p0);
    }

    virtual void toggleVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x21abf0))(this, p0);
    }

    virtual void touchedObject(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x22e660))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x218bf0))(this, p0);
    }

    virtual void updateCheckpointMode(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x218980))(this, p0);
    }

    virtual void updateCollide(bool p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, int)>(m->getOriginal(getBase()+0x220f10))(this, p0, p1);
    }

    virtual void updateCollideBottom(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221790))(this, p0, p1);
    }

    virtual void updateCollideTop(float p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), float, int)>(m->getOriginal(getBase()+0x221c20))(this, p0, p1);
    }

    virtual void updateJump(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x219680))(this, p0);
    }

    virtual void updatePlayerBirdFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22bfe0))(this, p0);
    }

    virtual void updatePlayerDartFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c260))(this, p0);
    }

    virtual void updatePlayerFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c470))(this, p0);
    }

    virtual void updatePlayerRobotFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d620))(this, p0);
    }

    virtual void updatePlayerRollFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22c6a0))(this, p0);
    }

    virtual void updatePlayerShipFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22ba40))(this, p0);
    }

    virtual void updatePlayerSpiderFrame(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x22d650))(this, p0);
    }

    virtual void updatePlayerSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218440))(this, p0);
    }

    virtual void updateRotation(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x221230))(this, p0, p1);
    }

    virtual void updateRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2214b0))(this, p0);
    }

    virtual void updateShipRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221310))(this, p0);
    }

    virtual void updateShipSpriteExtra(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x218510))(this, p0);
    }

    virtual void updateSlopeRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x221030))(this, p0);
    }

    virtual void updateSlopeYVelocity(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x22e920))(this, p0);
    }

    virtual void updateSpecial(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x21a790))(this, p0);
    }

    virtual void updateTimeMod(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x2185e0))(this, p0);
    }

    virtual void animationFinished(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x22e9d0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x22cdf0))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x22d400))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($PlayerObject::*)(GameObject*);
        m->registerHook(getBase()+0x22b800, extract_virtual(this, tf0{&$PlayerObject::addToTouchedRings}));

		using tf1 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21d6b0, extract_virtual(this, tf1{&$PlayerObject::boostPlayer}));

		using tf2 = void($PlayerObject::*)(float, int);
        m->registerHook(getBase()+0x22d890, extract_virtual(this, tf2{&$PlayerObject::bumpPlayer}));

		using tf3 = void($PlayerObject::*)(PlayerButton);
        m->registerHook(getBase()+0x22b7e0, extract_virtual(this, tf3{&$PlayerObject::buttonDown}));

		using tf4 = void($PlayerObject::*)(GameObject*);
        m->registerHook(getBase()+0x2217f0, extract_virtual(this, tf4{&$PlayerObject::checkSnapJumpToObject}));

		using tf5 = void($PlayerObject::*)(float, GameObject*);
        m->registerHook(getBase()+0x21d880, extract_virtual(this, tf5{&$PlayerObject::collidedWithObject}));

		using tf6 = void($PlayerObject::*)(float, GameObject*, cocos2d::CCRect);
        m->registerHook(getBase()+0x21f0b0, extract_virtual(this, tf6{&$PlayerObject::collidedWithObject}));

		using tf7 = void($PlayerObject::*)(float, GameObject*, bool);
        m->registerHook(getBase()+0x21d8d0, extract_virtual(this, tf7{&$PlayerObject::collidedWithSlope}));

		using tf8 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21c860, extract_virtual(this, tf8{&$PlayerObject::convertToClosestRotation}));

		using tf9 = void($PlayerObject::*)(PlayerObject*);
        m->registerHook(getBase()+0x22dc70, extract_virtual(this, tf9{&$PlayerObject::copyAttributes}));

		using tf10 = void($PlayerObject::*)(int, int, cocos2d::CCLayer*);
        m->registerHook(getBase()+0x217260, extract_virtual(this, tf10{&$PlayerObject::create}));

		using tf11 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x218b30, extract_virtual(this, tf11{&$PlayerObject::deactivateStreak}));

		using tf12 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x225890, extract_virtual(this, tf12{&$PlayerObject::fadeOutStreak2}));

		using tf13 = void($PlayerObject::*)(float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x221c80, extract_virtual(this, tf13{&$PlayerObject::flashPlayer}));

		using tf14 = void($PlayerObject::*)(bool, bool);
        m->registerHook(getBase()+0x21c090, extract_virtual(this, tf14{&$PlayerObject::flipGravity}));

		using tf15 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21a830, extract_virtual(this, tf15{&$PlayerObject::getOldPosition}));

		using tf16 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x220a30, extract_virtual(this, tf16{&$PlayerObject::hitGround}));

		using tf17 = void($PlayerObject::*)(int, int, cocos2d::CCLayer*);
        m->registerHook(getBase()+0x2172e0, extract_virtual(this, tf17{&$PlayerObject::init}));

		using tf18 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21d650, extract_virtual(this, tf18{&$PlayerObject::isBoostValid}));

		using tf19 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x2209f0, extract_virtual(this, tf19{&$PlayerObject::isSafeFlip}));

		using tf20 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x2209b0, extract_virtual(this, tf20{&$PlayerObject::isSafeMode}));

		using tf21 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x221be0, extract_virtual(this, tf21{&$PlayerObject::isSafeSpiderFlip}));

		using tf22 = void($PlayerObject::*)(PlayerCheckpoint*);
        m->registerHook(getBase()+0x22e420, extract_virtual(this, tf22{&$PlayerObject::loadFromCheckpoint}));

		using tf23 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x2256d0, extract_virtual(this, tf23{&$PlayerObject::playerDestroyed}));

		using tf24 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21cd10, extract_virtual(this, tf24{&$PlayerObject::postCollision}));

		using tf25 = void($PlayerObject::*)(float, GameObject*);
        m->registerHook(getBase()+0x21ec80, extract_virtual(this, tf25{&$PlayerObject::preSlopeCollision}));

		using tf26 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22d8e0, extract_virtual(this, tf26{&$PlayerObject::propellPlayer}));

		using tf27 = void($PlayerObject::*)(PlayerButton);
        m->registerHook(getBase()+0x22aa00, extract_virtual(this, tf27{&$PlayerObject::pushButton}));

		using tf28 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22dbb0, extract_virtual(this, tf28{&$PlayerObject::pushPlayer}));

		using tf29 = void($PlayerObject::*)(PlayerButton);
        m->registerHook(getBase()+0x22b6f0, extract_virtual(this, tf29{&$PlayerObject::releaseButton}));

		using tf30 = void($PlayerObject::*)(GameObject*);
        m->registerHook(getBase()+0x22abf0, extract_virtual(this, tf30{&$PlayerObject::ringJump}));

		using tf31 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21ca10, extract_virtual(this, tf31{&$PlayerObject::runBallRotation}));

		using tf32 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x21c570, extract_virtual(this, tf32{&$PlayerObject::runRotateAction}));

		using tf33 = void($PlayerObject::*)(PlayerCheckpoint*);
        m->registerHook(getBase()+0x22e2f0, extract_virtual(this, tf33{&$PlayerObject::saveToCheckpoint}));

		using tf34 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x22e720, extract_virtual(this, tf34{&$PlayerObject::setFlipX}));

		using tf35 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x22e7b0, extract_virtual(this, tf35{&$PlayerObject::setFlipY}));

		using tf36 = void($PlayerObject::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x22c8b0, extract_virtual(this, tf36{&$PlayerObject::setPosition}));

		using tf37 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22e6e0, extract_virtual(this, tf37{&$PlayerObject::setRotation}));

		using tf38 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22e870, extract_virtual(this, tf38{&$PlayerObject::setScale}));

		using tf39 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22e7f0, extract_virtual(this, tf39{&$PlayerObject::setScaleX}));

		using tf40 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22e830, extract_virtual(this, tf40{&$PlayerObject::setScaleY}));

		using tf41 = void($PlayerObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x219610, extract_virtual(this, tf41{&$PlayerObject::setSecondColor}));

		using tf42 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x22e8b0, extract_virtual(this, tf42{&$PlayerObject::setVisible}));

		using tf43 = void($PlayerObject::*)(PlayerObject*);
        m->registerHook(getBase()+0x22dde0, extract_virtual(this, tf43{&$PlayerObject::spawnFromPlayer}));

		using tf44 = void($PlayerObject::*)(cocos2d::_ccColor3B, float);
        m->registerHook(getBase()+0x225350, extract_virtual(this, tf44{&$PlayerObject::spawnPortalCircle}));

		using tf45 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x21b160, extract_virtual(this, tf45{&$PlayerObject::spiderTestJump}));

		using tf46 = void($PlayerObject::*)(GameObject*);
        m->registerHook(getBase()+0x221d70, extract_virtual(this, tf46{&$PlayerObject::startDashing}));

		using tf47 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x21c830, extract_virtual(this, tf47{&$PlayerObject::stopRotation}));

		using tf48 = void($PlayerObject::*)(bool, int);
        m->registerHook(getBase()+0x21cc60, extract_virtual(this, tf48{&$PlayerObject::storeCollision}));

		using tf49 = void($PlayerObject::*)(GameObjectType);
        m->registerHook(getBase()+0x22b9a0, extract_virtual(this, tf49{&$PlayerObject::switchedToMode}));

		using tf50 = void($PlayerObject::*)(float, GameObject*);
        m->registerHook(getBase()+0x21eb70, extract_virtual(this, tf50{&$PlayerObject::testForMoving}));

		using tf51 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x224070, extract_virtual(this, tf51{&$PlayerObject::toggleBirdMode}));

		using tf52 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x2243f0, extract_virtual(this, tf52{&$PlayerObject::toggleDartMode}));

		using tf53 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x223820, extract_virtual(this, tf53{&$PlayerObject::toggleFlyMode}));

		using tf54 = void($PlayerObject::*)(GhostType);
        m->registerHook(getBase()+0x225000, extract_virtual(this, tf54{&$PlayerObject::toggleGhostEffect}));

		using tf55 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x224bd0, extract_virtual(this, tf55{&$PlayerObject::togglePlayerScale}));

		using tf56 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x223c70, extract_virtual(this, tf56{&$PlayerObject::toggleRobotMode}));

		using tf57 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x223b20, extract_virtual(this, tf57{&$PlayerObject::toggleRollMode}));

		using tf58 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x224830, extract_virtual(this, tf58{&$PlayerObject::toggleSpiderMode}));

		using tf59 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x21abf0, extract_virtual(this, tf59{&$PlayerObject::toggleVisibility}));

		using tf60 = void($PlayerObject::*)(GameObject*);
        m->registerHook(getBase()+0x22e660, extract_virtual(this, tf60{&$PlayerObject::touchedObject}));

		using tf61 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x218bf0, extract_virtual(this, tf61{&$PlayerObject::update}));

		using tf62 = void($PlayerObject::*)(bool);
        m->registerHook(getBase()+0x218980, extract_virtual(this, tf62{&$PlayerObject::updateCheckpointMode}));

		using tf63 = void($PlayerObject::*)(bool, int);
        m->registerHook(getBase()+0x220f10, extract_virtual(this, tf63{&$PlayerObject::updateCollide}));

		using tf64 = void($PlayerObject::*)(float, int);
        m->registerHook(getBase()+0x221790, extract_virtual(this, tf64{&$PlayerObject::updateCollideBottom}));

		using tf65 = void($PlayerObject::*)(float, int);
        m->registerHook(getBase()+0x221c20, extract_virtual(this, tf65{&$PlayerObject::updateCollideTop}));

		using tf66 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x219680, extract_virtual(this, tf66{&$PlayerObject::updateJump}));

		using tf67 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22bfe0, extract_virtual(this, tf67{&$PlayerObject::updatePlayerBirdFrame}));

		using tf68 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22c260, extract_virtual(this, tf68{&$PlayerObject::updatePlayerDartFrame}));

		using tf69 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22c470, extract_virtual(this, tf69{&$PlayerObject::updatePlayerFrame}));

		using tf70 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22d620, extract_virtual(this, tf70{&$PlayerObject::updatePlayerRobotFrame}));

		using tf71 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22c6a0, extract_virtual(this, tf71{&$PlayerObject::updatePlayerRollFrame}));

		using tf72 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22ba40, extract_virtual(this, tf72{&$PlayerObject::updatePlayerShipFrame}));

		using tf73 = void($PlayerObject::*)(int);
        m->registerHook(getBase()+0x22d650, extract_virtual(this, tf73{&$PlayerObject::updatePlayerSpiderFrame}));

		using tf74 = void($PlayerObject::*)(std::string);
        m->registerHook(getBase()+0x218440, extract_virtual(this, tf74{&$PlayerObject::updatePlayerSpriteExtra}));

		using tf75 = void($PlayerObject::*)(float, float);
        m->registerHook(getBase()+0x221230, extract_virtual(this, tf75{&$PlayerObject::updateRotation}));

		using tf76 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x2214b0, extract_virtual(this, tf76{&$PlayerObject::updateRotation}));

		using tf77 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x221310, extract_virtual(this, tf77{&$PlayerObject::updateShipRotation}));

		using tf78 = void($PlayerObject::*)(std::string);
        m->registerHook(getBase()+0x218510, extract_virtual(this, tf78{&$PlayerObject::updateShipSpriteExtra}));

		using tf79 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x221030, extract_virtual(this, tf79{&$PlayerObject::updateSlopeRotation}));

		using tf80 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x22e920, extract_virtual(this, tf80{&$PlayerObject::updateSlopeYVelocity}));

		using tf81 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x21a790, extract_virtual(this, tf81{&$PlayerObject::updateSpecial}));

		using tf82 = void($PlayerObject::*)(float);
        m->registerHook(getBase()+0x2185e0, extract_virtual(this, tf82{&$PlayerObject::updateTimeMod}));

		using tf83 = void($PlayerObject::*)(char const*);
        m->registerHook(getBase()+0x22e9d0, extract_virtual(this, tf83{&$PlayerObject::animationFinished}));

		using tf84 = void($PlayerObject::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x22cdf0, extract_virtual(this, tf84{&$PlayerObject::setColor}));

		using tf85 = void($PlayerObject::*)(unsigned char);
        m->registerHook(getBase()+0x22d400, extract_virtual(this, tf85{&$PlayerObject::setOpacity}));
    }
};


class $PulseEffectAction : public $CacBase {
 public:
    $PulseEffectAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $PulseEffectAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x179e90))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($PulseEffectAction::*)(std::string);
        m->registerHook(getBase()+0x179e90, extract_virtual(this, tf0{&$PulseEffectAction::createFromString}));
    }
};


class $SetIDLayer : public $CacBase {
 public:
    $SetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetIDLayer* __thistype;

    virtual void create(GameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(getBase()+0x168f20))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($SetIDLayer::*)(GameObject*);
        m->registerHook(getBase()+0x168f20, extract_virtual(this, tf0{&$SetIDLayer::create}));
    }
};


class $SetTargetIDLayer : public $CacBase {
 public:
    $SetTargetIDLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetTargetIDLayer* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1, std::string p2) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*, std::string)>(m->getOriginal(getBase()+0x159d20))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($SetTargetIDLayer::*)(EffectGameObject*, cocos2d::CCArray*, std::string);
        m->registerHook(getBase()+0x159d20, extract_virtual(this, tf0{&$SetTargetIDLayer::create}));
    }
};


class $SetupAnimationPopup : public $CacBase {
 public:
    $SetupAnimationPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupAnimationPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x208b70))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupAnimationPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x208b70, extract_virtual(this, tf0{&$SetupAnimationPopup::create}));
    }
};


class $SetupCollisionTriggerPopup : public $CacBase {
 public:
    $SetupCollisionTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupCollisionTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1d6120))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupCollisionTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1d6120, extract_virtual(this, tf0{&$SetupCollisionTriggerPopup::create}));
    }
};


class $SetupCountTriggerPopup : public $CacBase {
 public:
    $SetupCountTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupCountTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x15c6c0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupCountTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x15c6c0, extract_virtual(this, tf0{&$SetupCountTriggerPopup::create}));
    }
};


class $SetupInstantCountPopup : public $CacBase {
 public:
    $SetupInstantCountPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupInstantCountPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x352c10))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupInstantCountPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x352c10, extract_virtual(this, tf0{&$SetupInstantCountPopup::create}));
    }
};


class $SetupOpacityPopup : public $CacBase {
 public:
    $SetupOpacityPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupOpacityPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x32b70))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupOpacityPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x32b70, extract_virtual(this, tf0{&$SetupOpacityPopup::create}));
    }
};


class $SetupPickupTriggerPopup : public $CacBase {
 public:
    $SetupPickupTriggerPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupPickupTriggerPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x35e70))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupPickupTriggerPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x35e70, extract_virtual(this, tf0{&$SetupPickupTriggerPopup::create}));
    }
};


class $SetupPulsePopup : public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupPulsePopup* __thistype;

    virtual void colorValueChanged(cocos2d::_ccColor3B p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(getBase()+0x1ec680))(this, p0);
    }

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e6d40))(this, p0, p1);
    }

    virtual void init(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
    }

    virtual void onSelectPulseMode(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
    }

    virtual void updateFadeOutLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eba20))(this, p0);
    }

    virtual void updateHoldLabel(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1eb8d0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($SetupPulsePopup::*)(cocos2d::_ccColor3B);
        m->registerHook(getBase()+0x1ec680, extract_virtual(this, tf0{&$SetupPulsePopup::colorValueChanged}));

		using tf1 = void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1e6d40, extract_virtual(this, tf1{&$SetupPulsePopup::create}));

		using tf2 = void($SetupPulsePopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1e7010, extract_virtual(this, tf2{&$SetupPulsePopup::init}));

		using tf3 = void($SetupPulsePopup::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x1eb020, extract_virtual(this, tf3{&$SetupPulsePopup::onSelectPulseMode}));

		using tf4 = void($SetupPulsePopup::*)(bool);
        m->registerHook(getBase()+0x1eba20, extract_virtual(this, tf4{&$SetupPulsePopup::updateFadeOutLabel}));

		using tf5 = void($SetupPulsePopup::*)(bool);
        m->registerHook(getBase()+0x1eb8d0, extract_virtual(this, tf5{&$SetupPulsePopup::updateHoldLabel}));
    }
};


class $SetupShakePopup : public $CacBase {
 public:
    $SetupShakePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupShakePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x3adc00))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupShakePopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x3adc00, extract_virtual(this, tf0{&$SetupShakePopup::create}));
    }
};


class $SetupSpawnPopup : public $CacBase {
 public:
    $SetupSpawnPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupSpawnPopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x139790))(this, p0, p1);
    }

    virtual void createToggleButton(std::string p0, Cacao::CC_SEL p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) {
        return reinterpret_cast<void(*)(decltype(this), std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x13b0e0))(this, p0, p1, p2, p3, p4, p5);
    }

void apply_hooks() override {
		using tf0 = void($SetupSpawnPopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x139790, extract_virtual(this, tf0{&$SetupSpawnPopup::create}));

		using tf1 = void($SetupSpawnPopup::*)(std::string, Cacao::CC_SEL, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*);
        m->registerHook(getBase()+0x13b0e0, extract_virtual(this, tf1{&$SetupSpawnPopup::createToggleButton}));
    }
};


class $SetupTouchTogglePopup : public $CacBase {
 public:
    $SetupTouchTogglePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SetupTouchTogglePopup* __thistype;

    virtual void create(EffectGameObject* p0, cocos2d::CCArray* p1) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCArray*)>(m->getOriginal(getBase()+0x1576a0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SetupTouchTogglePopup::*)(EffectGameObject*, cocos2d::CCArray*);
        m->registerHook(getBase()+0x1576a0, extract_virtual(this, tf0{&$SetupTouchTogglePopup::create}));
    }
};


class $SimplePlayer : public $CacBase {
 public:
    $SimplePlayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SimplePlayer* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1b6140))(this, p0);
    }

    virtual void setSecondColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1bace0))(this, p0);
    }

    virtual void updatePlayerFrame(int p0, IconType p1) {
        return reinterpret_cast<void(*)(decltype(this), int, IconType)>(m->getOriginal(getBase()+0x1b62f0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($SimplePlayer::*)(int);
        m->registerHook(getBase()+0x1b6140, extract_virtual(this, tf0{&$SimplePlayer::create}));

		using tf1 = void($SimplePlayer::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x1bace0, extract_virtual(this, tf1{&$SimplePlayer::setSecondColor}));

		using tf2 = void($SimplePlayer::*)(int, IconType);
        m->registerHook(getBase()+0x1b62f0, extract_virtual(this, tf2{&$SimplePlayer::updatePlayerFrame}));
    }
};


class $SpawnTriggerAction : public $CacBase {
 public:
    $SpawnTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SpawnTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x17bf50))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($SpawnTriggerAction::*)(std::string);
        m->registerHook(getBase()+0x17bf50, extract_virtual(this, tf0{&$SpawnTriggerAction::createFromString}));
    }
};


class $SpeedObject : public $CacBase {
 public:
    $SpeedObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $SpeedObject* __thistype;

    virtual void create(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77450))(this, p0, p1, p2);
    }

    virtual void init(GameObject* p0, int p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), GameObject*, int, float)>(m->getOriginal(getBase()+0x77400))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($SpeedObject::*)(GameObject*, int, float);
        m->registerHook(getBase()+0x77450, extract_virtual(this, tf0{&$SpeedObject::create}));

		using tf1 = void($SpeedObject::*)(GameObject*, int, float);
        m->registerHook(getBase()+0x77400, extract_virtual(this, tf1{&$SpeedObject::init}));
    }
};


class $TeleportPortalObject : public $CacBase {
 public:
    $TeleportPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $TeleportPortalObject* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0xdaa50))(this, p0);
    }

    virtual void getTeleportXOff(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0xdac20))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($TeleportPortalObject::*)(char const*);
        m->registerHook(getBase()+0xdaa50, extract_virtual(this, tf0{&$TeleportPortalObject::create}));

		using tf1 = void($TeleportPortalObject::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0xdac20, extract_virtual(this, tf1{&$TeleportPortalObject::getTeleportXOff}));
    }
};


class $TextInputDelegate : public $CacBase {
 public:
    $TextInputDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $TextInputDelegate* __thistype;

    virtual void allowTextInput(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6210))(this, p0);
    }

    virtual void textInputOpened(CCTextInputNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(getBase()+0x6200))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($TextInputDelegate::*)(CCTextInputNode*);
        m->registerHook(getBase()+0x6210, extract_virtual(this, tf0{&$TextInputDelegate::allowTextInput}));

		using tf1 = void($TextInputDelegate::*)(CCTextInputNode*);
        m->registerHook(getBase()+0x6200, extract_virtual(this, tf1{&$TextInputDelegate::textInputOpened}));
    }
};


class $ToggleTriggerAction : public $CacBase {
 public:
    $ToggleTriggerAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ToggleTriggerAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x1765e0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($ToggleTriggerAction::*)(std::string);
        m->registerHook(getBase()+0x1765e0, extract_virtual(this, tf0{&$ToggleTriggerAction::createFromString}));
    }
};


class $TouchToggleAction : public $CacBase {
 public:
    $TouchToggleAction() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $TouchToggleAction* __thistype;

    virtual void createFromString(std::string p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(getBase()+0x177e10))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($TouchToggleAction::*)(std::string);
        m->registerHook(getBase()+0x177e10, extract_virtual(this, tf0{&$TouchToggleAction::createFromString}));
    }
};


class $UILayer : public $CacBase {
 public:
    $UILayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $UILayer* __thistype;

    virtual void pCommand(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x280830))(this, p0);
    }

    virtual void toggleCheckpointsMenu(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x280430))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($UILayer::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0x280830, extract_virtual(this, tf0{&$UILayer::pCommand}));

		using tf1 = void($UILayer::*)(bool);
        m->registerHook(getBase()+0x280430, extract_virtual(this, tf1{&$UILayer::toggleCheckpointsMenu}));
    }
};


class $CCActionTween : public $CacBase {
 public:
    $CCActionTween() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCActionTween* __thistype;

    virtual void create(float p0, char const* p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*, float, float)>(m->getOriginal(getBase()+0x447590))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CCActionTween::*)(float, char const*, float, float);
        m->registerHook(getBase()+0x447590, extract_virtual(this, tf0{&$CCActionTween::create}));
    }
};


class $CCAnimate : public $CacBase {
 public:
    $CCAnimate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCAnimate* __thistype;

    virtual void create(cocos2d::CCAnimation* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAnimation*)>(m->getOriginal(getBase()+0x1f8fc0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCAnimate::*)(cocos2d::CCAnimation*);
        m->registerHook(getBase()+0x1f8fc0, extract_virtual(this, tf0{&$CCAnimate::create}));
    }
};


class $CCAnimation : public $CacBase {
 public:
    $CCAnimation() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCAnimation* __thistype;

    virtual void createWithSpriteFrames(cocos2d::CCArray* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float)>(m->getOriginal(getBase()+0x140df0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCAnimation::*)(cocos2d::CCArray*, float);
        m->registerHook(getBase()+0x140df0, extract_virtual(this, tf0{&$CCAnimation::createWithSpriteFrames}));
    }
};


class $CCArray : public $CacBase {
 public:
    $CCArray() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCArray* __thistype;

    virtual void addObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419f90))(this, p0);
    }

    virtual void addObjectNew(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a450))(this, p0);
    }

    virtual void addObjectsFromArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x41a2d0))(this, p0);
    }

    virtual void createWithObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x419d50))(this, p0);
    }

    virtual void fastRemoveObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x41a520))(this, p0);
    }

    virtual void fastRemoveObjectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a500))(this, p0);
    }

    virtual void fastRemoveObjectAtIndexNew(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a510))(this, p0);
    }

    virtual void objectAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a340))(this, p0);
    }

    virtual void removeLastObject(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x41a470))(this, p0);
    }

    virtual void removeObject(cocos2d::CCObject* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, bool)>(m->getOriginal(getBase()+0x41a490))(this, p0, p1);
    }

    virtual void removeObjectAtIndex(unsigned int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int, bool)>(m->getOriginal(getBase()+0x41a4b0))(this, p0, p1);
    }

    virtual void stringAtIndex(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x41a320))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCArray::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x419f90, extract_virtual(this, tf0{&$CCArray::addObject}));

		using tf1 = void($CCArray::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x41a450, extract_virtual(this, tf1{&$CCArray::addObjectNew}));

		using tf2 = void($CCArray::*)(cocos2d::CCArray*);
        m->registerHook(getBase()+0x41a2d0, extract_virtual(this, tf2{&$CCArray::addObjectsFromArray}));

		using tf3 = void($CCArray::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x419d50, extract_virtual(this, tf3{&$CCArray::createWithObject}));

		using tf4 = void($CCArray::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x41a520, extract_virtual(this, tf4{&$CCArray::fastRemoveObject}));

		using tf5 = void($CCArray::*)(unsigned int);
        m->registerHook(getBase()+0x41a500, extract_virtual(this, tf5{&$CCArray::fastRemoveObjectAtIndex}));

		using tf6 = void($CCArray::*)(unsigned int);
        m->registerHook(getBase()+0x41a510, extract_virtual(this, tf6{&$CCArray::fastRemoveObjectAtIndexNew}));

		using tf7 = void($CCArray::*)(unsigned int);
        m->registerHook(getBase()+0x41a340, extract_virtual(this, tf7{&$CCArray::objectAtIndex}));

		using tf8 = void($CCArray::*)(bool);
        m->registerHook(getBase()+0x41a470, extract_virtual(this, tf8{&$CCArray::removeLastObject}));

		using tf9 = void($CCArray::*)(cocos2d::CCObject*, bool);
        m->registerHook(getBase()+0x41a490, extract_virtual(this, tf9{&$CCArray::removeObject}));

		using tf10 = void($CCArray::*)(unsigned int, bool);
        m->registerHook(getBase()+0x41a4b0, extract_virtual(this, tf10{&$CCArray::removeObjectAtIndex}));

		using tf11 = void($CCArray::*)(unsigned int);
        m->registerHook(getBase()+0x41a320, extract_virtual(this, tf11{&$CCArray::stringAtIndex}));
    }
};


class $CCBezierTo : public $CacBase {
 public:
    $CCBezierTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCBezierTo* __thistype;

    virtual void create(float p0, cocos2d::_ccBezierConfig const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::_ccBezierConfig const&)>(m->getOriginal(getBase()+0x1f6c10))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCBezierTo::*)(float, cocos2d::_ccBezierConfig const&);
        m->registerHook(getBase()+0x1f6c10, extract_virtual(this, tf0{&$CCBezierTo::create}));
    }
};


class $CCCallFunc : public $CacBase {
 public:
    $CCCallFunc() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCCallFunc* __thistype;

    virtual void create(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x454d90))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCCallFunc::*)(int);
        m->registerHook(getBase()+0x454d90, extract_virtual(this, tf0{&$CCCallFunc::create}));
    }
};


class $CCCopying : public $CacBase {
 public:
    $CCCopying() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCCopying* __thistype;

    virtual void copyWithZone(cocos2d::CCZone* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCZone*)>(m->getOriginal(getBase()+0x250c90))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCCopying::*)(cocos2d::CCZone*);
        m->registerHook(getBase()+0x250c90, extract_virtual(this, tf0{&$CCCopying::copyWithZone}));
    }
};


class $CCDelayTime : public $CacBase {
 public:
    $CCDelayTime() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCDelayTime* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f4380))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCDelayTime::*)(float);
        m->registerHook(getBase()+0x1f4380, extract_virtual(this, tf0{&$CCDelayTime::create}));
    }
};


class $CCDictionary : public $CacBase {
 public:
    $CCDictionary() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCDictionary* __thistype;

    virtual void objectForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x190870))(this, p0);
    }

    virtual void objectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190bb0))(this, p0);
    }

    virtual void removeObjectForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x1921d0))(this, p0);
    }

    virtual void setObject(cocos2d::CCObject* p0, std::string const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string const&)>(m->getOriginal(getBase()+0x190dc0))(this, p0, p1);
    }

    virtual void setObject(cocos2d::CCObject* p0, long p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, long)>(m->getOriginal(getBase()+0x191790))(this, p0, p1);
    }

    virtual void valueForKey(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x1907a0))(this, p0);
    }

    virtual void valueForKey(long p0) {
        return reinterpret_cast<void(*)(decltype(this), long)>(m->getOriginal(getBase()+0x190cf0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCDictionary::*)(std::string const&);
        m->registerHook(getBase()+0x190870, extract_virtual(this, tf0{&$CCDictionary::objectForKey}));

		using tf1 = void($CCDictionary::*)(long);
        m->registerHook(getBase()+0x190bb0, extract_virtual(this, tf1{&$CCDictionary::objectForKey}));

		using tf2 = void($CCDictionary::*)(long);
        m->registerHook(getBase()+0x1921d0, extract_virtual(this, tf2{&$CCDictionary::removeObjectForKey}));

		using tf3 = void($CCDictionary::*)(cocos2d::CCObject*, std::string const&);
        m->registerHook(getBase()+0x190dc0, extract_virtual(this, tf3{&$CCDictionary::setObject}));

		using tf4 = void($CCDictionary::*)(cocos2d::CCObject*, long);
        m->registerHook(getBase()+0x191790, extract_virtual(this, tf4{&$CCDictionary::setObject}));

		using tf5 = void($CCDictionary::*)(std::string const&);
        m->registerHook(getBase()+0x1907a0, extract_virtual(this, tf5{&$CCDictionary::valueForKey}));

		using tf6 = void($CCDictionary::*)(long);
        m->registerHook(getBase()+0x190cf0, extract_virtual(this, tf6{&$CCDictionary::valueForKey}));
    }
};


class $CCDrawNode : public $CacBase {
 public:
    $CCDrawNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCDrawNode* __thistype;

    virtual void setBlendFunc(cocos2d::_ccBlendFunc const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc const&)>(m->getOriginal(getBase()+0x379eb0))(this, p0);
    }

    virtual void drawPolygon(cocos2d::CCPoint* p0, unsigned int p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3797f0))(this, p0, p1, p2, p3, p4);
    }

    virtual void drawSegment(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, float p2, cocos2d::_ccColor4F const& p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&)>(m->getOriginal(getBase()+0x3792d0))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CCDrawNode::*)(cocos2d::_ccBlendFunc const&);
        m->registerHook(getBase()+0x379eb0, extract_virtual(this, tf0{&$CCDrawNode::setBlendFunc}));

		using tf1 = void($CCDrawNode::*)(cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&);
        m->registerHook(getBase()+0x3797f0, extract_virtual(this, tf1{&$CCDrawNode::drawPolygon}));

		using tf2 = void($CCDrawNode::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&);
        m->registerHook(getBase()+0x3792d0, extract_virtual(this, tf2{&$CCDrawNode::drawSegment}));
    }
};


class $CCEaseElasticOut : public $CacBase {
 public:
    $CCEaseElasticOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCEaseElasticOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a3080))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCEaseElasticOut::*)(cocos2d::CCActionInterval*, float);
        m->registerHook(getBase()+0x2a3080, extract_virtual(this, tf0{&$CCEaseElasticOut::create}));
    }
};


class $CCEaseIn : public $CacBase {
 public:
    $CCEaseIn() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCEaseIn* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1960))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCEaseIn::*)(cocos2d::CCActionInterval*, float);
        m->registerHook(getBase()+0x2a1960, extract_virtual(this, tf0{&$CCEaseIn::create}));
    }
};


class $CCEaseInOut : public $CacBase {
 public:
    $CCEaseInOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCEaseInOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1d80))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCEaseInOut::*)(cocos2d::CCActionInterval*, float);
        m->registerHook(getBase()+0x2a1d80, extract_virtual(this, tf0{&$CCEaseInOut::create}));
    }
};


class $CCEaseOut : public $CacBase {
 public:
    $CCEaseOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCEaseOut* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*, float)>(m->getOriginal(getBase()+0x2a1b70))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCEaseOut::*)(cocos2d::CCActionInterval*, float);
        m->registerHook(getBase()+0x2a1b70, extract_virtual(this, tf0{&$CCEaseOut::create}));
    }
};


class $CCFadeOut : public $CacBase {
 public:
    $CCFadeOut() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCFadeOut* __thistype;

    virtual void create(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1f7d80))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCFadeOut::*)(float);
        m->registerHook(getBase()+0x1f7d80, extract_virtual(this, tf0{&$CCFadeOut::create}));
    }
};


class $CCFadeTo : public $CacBase {
 public:
    $CCFadeTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCFadeTo* __thistype;

    virtual void create(float p0, unsigned char p1) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char)>(m->getOriginal(getBase()+0x1f7ff0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCFadeTo::*)(float, unsigned char);
        m->registerHook(getBase()+0x1f7ff0, extract_virtual(this, tf0{&$CCFadeTo::create}));
    }
};


class $CCKeyboardDelegate : public $CacBase {
 public:
    $CCKeyboardDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCKeyboardDelegate* __thistype;

    virtual void keyUp(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x61a0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCKeyboardDelegate::*)(cocos2d::enumKeyCodes);
        m->registerHook(getBase()+0x61a0, extract_virtual(this, tf0{&$CCKeyboardDelegate::keyUp}));
    }
};


class $CCLabelBMFont : public $CacBase {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCLabelBMFont* __thistype;

    virtual void create(char const* p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, char const*)>(m->getOriginal(getBase()+0x347660))(this, p0, p1);
    }

    virtual void limitLabelWidth(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x34a6e0))(this, p0, p1, p2);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x34a5d0))(this, p0);
    }

    virtual void setString(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x3489e0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCLabelBMFont::*)(char const*, char const*);
        m->registerHook(getBase()+0x347660, extract_virtual(this, tf0{&$CCLabelBMFont::create}));

		using tf1 = void($CCLabelBMFont::*)(float, float, float);
        m->registerHook(getBase()+0x34a6e0, extract_virtual(this, tf1{&$CCLabelBMFont::limitLabelWidth}));

		using tf2 = void($CCLabelBMFont::*)(float);
        m->registerHook(getBase()+0x34a5d0, extract_virtual(this, tf2{&$CCLabelBMFont::setScale}));

		using tf3 = void($CCLabelBMFont::*)(char const*, bool);
        m->registerHook(getBase()+0x3489e0, extract_virtual(this, tf3{&$CCLabelBMFont::setString}));
    }
};


class $CCLayer : public $CacBase {
 public:
    $CCLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCLayer* __thistype;

    virtual void registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), int, bool, int, bool)>(m->getOriginal(getBase()+0x272bd0))(this, p0, p1, p2, p3);
    }

    virtual void setAccelerometerEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272e30))(this, p0);
    }

    virtual void setAccelerometerInterval(double p0) {
        return reinterpret_cast<void(*)(decltype(this), double)>(m->getOriginal(getBase()+0x272e70))(this, p0);
    }

    virtual void setKeyboardEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x273020))(this, p0);
    }

    virtual void setKeypadEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272f80))(this, p0);
    }

    virtual void setMouseEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x2730a0))(this, p0);
    }

    virtual void setTouchEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x272cf0))(this, p0);
    }

    virtual void setTouchMode(cocos2d::ccTouchesMode p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccTouchesMode)>(m->getOriginal(getBase()+0x272d60))(this, p0);
    }

    virtual void setTouchPriority(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x272db0))(this, p0);
    }

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2734d0))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273650))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2735d0))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273550))(this, p0, p1);
    }

    virtual void ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2736d0))(this, p0, p1);
    }

    virtual void ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273850))(this, p0, p1);
    }

    virtual void ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x2737d0))(this, p0, p1);
    }

    virtual void ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSet*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x273750))(this, p0, p1);
    }

    virtual void didAccelerate(cocos2d::CCAcceleration* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAcceleration*)>(m->getOriginal(getBase()+0x272ea0))(this, p0);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x273280))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCLayer::*)(int, bool, int, bool);
        m->registerHook(getBase()+0x272bd0, extract_virtual(this, tf0{&$CCLayer::registerScriptTouchHandler}));

		using tf1 = void($CCLayer::*)(bool);
        m->registerHook(getBase()+0x272e30, extract_virtual(this, tf1{&$CCLayer::setAccelerometerEnabled}));

		using tf2 = void($CCLayer::*)(double);
        m->registerHook(getBase()+0x272e70, extract_virtual(this, tf2{&$CCLayer::setAccelerometerInterval}));

		using tf3 = void($CCLayer::*)(bool);
        m->registerHook(getBase()+0x273020, extract_virtual(this, tf3{&$CCLayer::setKeyboardEnabled}));

		using tf4 = void($CCLayer::*)(bool);
        m->registerHook(getBase()+0x272f80, extract_virtual(this, tf4{&$CCLayer::setKeypadEnabled}));

		using tf5 = void($CCLayer::*)(bool);
        m->registerHook(getBase()+0x2730a0, extract_virtual(this, tf5{&$CCLayer::setMouseEnabled}));

		using tf6 = void($CCLayer::*)(bool);
        m->registerHook(getBase()+0x272cf0, extract_virtual(this, tf6{&$CCLayer::setTouchEnabled}));

		using tf7 = void($CCLayer::*)(cocos2d::ccTouchesMode);
        m->registerHook(getBase()+0x272d60, extract_virtual(this, tf7{&$CCLayer::setTouchMode}));

		using tf8 = void($CCLayer::*)(int);
        m->registerHook(getBase()+0x272db0, extract_virtual(this, tf8{&$CCLayer::setTouchPriority}));

		using tf9 = void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x2734d0, extract_virtual(this, tf9{&$CCLayer::ccTouchBegan}));

		using tf10 = void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x273650, extract_virtual(this, tf10{&$CCLayer::ccTouchCancelled}));

		using tf11 = void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x2735d0, extract_virtual(this, tf11{&$CCLayer::ccTouchEnded}));

		using tf12 = void($CCLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x273550, extract_virtual(this, tf12{&$CCLayer::ccTouchMoved}));

		using tf13 = void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x2736d0, extract_virtual(this, tf13{&$CCLayer::ccTouchesBegan}));

		using tf14 = void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x273850, extract_virtual(this, tf14{&$CCLayer::ccTouchesCancelled}));

		using tf15 = void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x2737d0, extract_virtual(this, tf15{&$CCLayer::ccTouchesEnded}));

		using tf16 = void($CCLayer::*)(cocos2d::CCSet*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x273750, extract_virtual(this, tf16{&$CCLayer::ccTouchesMoved}));

		using tf17 = void($CCLayer::*)(cocos2d::CCAcceleration*);
        m->registerHook(getBase()+0x272ea0, extract_virtual(this, tf17{&$CCLayer::didAccelerate}));

		using tf18 = void($CCLayer::*)(cocos2d::enumKeyCodes);
        m->registerHook(getBase()+0x273280, extract_virtual(this, tf18{&$CCLayer::keyDown}));
    }
};


class $CCLayerColor : public $CacBase {
 public:
    $CCLayerColor() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCLayerColor* __thistype;

    virtual void initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x274850))(this, p0, p1, p2);
    }

    virtual void initWithColor(cocos2d::_ccColor4B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&)>(m->getOriginal(getBase()+0x2749a0))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2749f0))(this, p0);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x2744a0))(this, p0);
    }

    virtual void setColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x274c20))(this, p0);
    }

    virtual void setOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x274db0))(this, p0);
    }

    virtual void create(cocos2d::_ccColor4B const& p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor4B const&, float, float)>(m->getOriginal(getBase()+0x2745e0))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float);
        m->registerHook(getBase()+0x274850, extract_virtual(this, tf0{&$CCLayerColor::initWithColor}));

		using tf1 = void($CCLayerColor::*)(cocos2d::_ccColor4B const&);
        m->registerHook(getBase()+0x2749a0, extract_virtual(this, tf1{&$CCLayerColor::initWithColor}));

		using tf2 = void($CCLayerColor::*)(cocos2d::CCSize const&);
        m->registerHook(getBase()+0x2749f0, extract_virtual(this, tf2{&$CCLayerColor::setContentSize}));

		using tf3 = void($CCLayerColor::*)(cocos2d::_ccBlendFunc);
        m->registerHook(getBase()+0x2744a0, extract_virtual(this, tf3{&$CCLayerColor::setBlendFunc}));

		using tf4 = void($CCLayerColor::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x274c20, extract_virtual(this, tf4{&$CCLayerColor::setColor}));

		using tf5 = void($CCLayerColor::*)(unsigned char);
        m->registerHook(getBase()+0x274db0, extract_virtual(this, tf5{&$CCLayerColor::setOpacity}));

		using tf6 = void($CCLayerColor::*)(cocos2d::_ccColor4B const&, float, float);
        m->registerHook(getBase()+0x2745e0, extract_virtual(this, tf6{&$CCLayerColor::create}));
    }
};


class $CCMouseDelegate : public $CacBase {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMouseDelegate* __thistype;

    virtual void scrollWheel(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x61d0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCMouseDelegate::*)(float, float);
        m->registerHook(getBase()+0x61d0, extract_virtual(this, tf0{&$CCMouseDelegate::scrollWheel}));
    }
};


class $CCMoveBy : public $CacBase {
 public:
    $CCMoveBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMoveBy* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f50e0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCMoveBy::*)(float, cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x1f50e0, extract_virtual(this, tf0{&$CCMoveBy::create}));
    }
};


class $CCMoveTo : public $CacBase {
 public:
    $CCMoveTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMoveTo* __thistype;

    virtual void create(float p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1f54d0))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCMoveTo::*)(float, cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x1f54d0, extract_virtual(this, tf0{&$CCMoveTo::create}));
    }
};


class $CCNode : public $CacBase {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCNode* __thistype;

    virtual void _setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x122990))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1232a0))(this, p0, p1, p2);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1233b0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x1233d0))(this, p0);
    }

    virtual void addComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a40))(this, p0);
    }

    virtual void convertToNodeSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124750))(this, p0);
    }

    virtual void convertToWorldSpace(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x124790))(this, p0);
    }

    virtual void getActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ee0))(this, p0);
    }

    virtual void getChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123220))(this, p0);
    }

    virtual void getPosition(float* p0, float* p1) {
        return reinterpret_cast<void(*)(decltype(this), float*, float*)>(m->getOriginal(getBase()+0x122b90))(this, p0, p1);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122f00))(this, p0);
    }

    virtual void registerScriptHandler(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123d90))(this, p0);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123620))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x123460))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x123480))(this, p0, p1);
    }

    virtual void removeChildByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1235a0))(this, p0);
    }

    virtual void removeChildByTag(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x1235c0))(this, p0, p1);
    }

    virtual void removeComponent(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x124a60))(this, p0);
    }

    virtual void removeComponent(cocos2d::CCComponent* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCComponent*)>(m->getOriginal(getBase()+0x124a80))(this, p0);
    }

    virtual void removeFromParentAndCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x123410))(this, p0);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x123760))(this, p0, p1);
    }

    virtual void runAction(cocos2d::CCAction* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCAction*)>(m->getOriginal(getBase()+0x123e60))(this, p0);
    }

    virtual void setActionManager(cocos2d::CCActionManager* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionManager*)>(m->getOriginal(getBase()+0x123e00))(this, p0);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122d90))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x122e50))(this, p0);
    }

    virtual void setGLServerState(cocos2d::ccGLServerState p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::ccGLServerState)>(m->getOriginal(getBase()+0x122fa0))(this, p0);
    }

    virtual void setGrid(cocos2d::CCGridBase* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGridBase*)>(m->getOriginal(getBase()+0x122d10))(this, p0);
    }

    virtual void setOrderOfArrival(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0x122f60))(this, p0);
    }

    virtual void setParent(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x122ee0))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x122b70))(this, p0);
    }

    virtual void setPosition(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ba0))(this, p0, p1);
    }

    virtual void setPositionX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c00))(this, p0);
    }

    virtual void setPositionY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122c40))(this, p0);
    }

    virtual void setRotation(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a10))(this, p0);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a60))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122a90))(this, p0);
    }

    virtual void setScale(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122ac0))(this, p0);
    }

    virtual void setScale(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x122ae0))(this, p0, p1);
    }

    virtual void setScaleX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b10))(this, p0);
    }

    virtual void setScaleY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122b40))(this, p0);
    }

    virtual void setScheduler(cocos2d::CCScheduler* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScheduler*)>(m->getOriginal(getBase()+0x123f20))(this, p0);
    }

    virtual void setShaderProgram(cocos2d::CCGLProgram* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCGLProgram*)>(m->getOriginal(getBase()+0x122ff0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122930))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x122960))(this, p0);
    }

    virtual void setUserData(void* p0) {
        return reinterpret_cast<void(*)(decltype(this), void*)>(m->getOriginal(getBase()+0x122f40))(this, p0);
    }

    virtual void setUserObject(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x122fb0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1229f0))(this, p0);
    }

    virtual void setVisible(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x122d60))(this, p0);
    }

    virtual void setZOrder(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1229a0))(this, p0);
    }

    virtual void stopActionByTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x123ec0))(this, p0);
    }

    virtual void update(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1241a0))(this, p0);
    }

    virtual void updateTweenAction(float p0, char const* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(getBase()+0x1249c0))(this, p0, p1);
    }

    virtual void schedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x1240b0))(this, p0);
    }

    virtual void schedule(Cacao::CC_SCHED p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, float)>(m->getOriginal(getBase()+0x124120))(this, p0, p1);
    }

    virtual void unschedule(Cacao::CC_SCHED p0) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED)>(m->getOriginal(getBase()+0x124180))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x122990, extract_virtual(this, tf0{&$CCNode::_setZOrder}));

		using tf1 = void($CCNode::*)(cocos2d::CCNode*, int, int);
        m->registerHook(getBase()+0x1232a0, extract_virtual(this, tf1{&$CCNode::addChild}));

		using tf2 = void($CCNode::*)(cocos2d::CCNode*, int);
        m->registerHook(getBase()+0x1233b0, extract_virtual(this, tf2{&$CCNode::addChild}));

		using tf3 = void($CCNode::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0x1233d0, extract_virtual(this, tf3{&$CCNode::addChild}));

		using tf4 = void($CCNode::*)(cocos2d::CCComponent*);
        m->registerHook(getBase()+0x124a40, extract_virtual(this, tf4{&$CCNode::addComponent}));

		using tf5 = void($CCNode::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x124750, extract_virtual(this, tf5{&$CCNode::convertToNodeSpace}));

		using tf6 = void($CCNode::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x124790, extract_virtual(this, tf6{&$CCNode::convertToWorldSpace}));

		using tf7 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x123ee0, extract_virtual(this, tf7{&$CCNode::getActionByTag}));

		using tf8 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x123220, extract_virtual(this, tf8{&$CCNode::getChildByTag}));

		using tf9 = void($CCNode::*)(float*, float*);
        m->registerHook(getBase()+0x122b90, extract_virtual(this, tf9{&$CCNode::getPosition}));

		using tf10 = void($CCNode::*)(bool);
        m->registerHook(getBase()+0x122f00, extract_virtual(this, tf10{&$CCNode::ignoreAnchorPointForPosition}));

		using tf11 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x123d90, extract_virtual(this, tf11{&$CCNode::registerScriptHandler}));

		using tf12 = void($CCNode::*)(bool);
        m->registerHook(getBase()+0x123620, extract_virtual(this, tf12{&$CCNode::removeAllChildrenWithCleanup}));

		using tf13 = void($CCNode::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0x123460, extract_virtual(this, tf13{&$CCNode::removeChild}));

		using tf14 = void($CCNode::*)(cocos2d::CCNode*, bool);
        m->registerHook(getBase()+0x123480, extract_virtual(this, tf14{&$CCNode::removeChild}));

		using tf15 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x1235a0, extract_virtual(this, tf15{&$CCNode::removeChildByTag}));

		using tf16 = void($CCNode::*)(int, bool);
        m->registerHook(getBase()+0x1235c0, extract_virtual(this, tf16{&$CCNode::removeChildByTag}));

		using tf17 = void($CCNode::*)(char const*);
        m->registerHook(getBase()+0x124a60, extract_virtual(this, tf17{&$CCNode::removeComponent}));

		using tf18 = void($CCNode::*)(cocos2d::CCComponent*);
        m->registerHook(getBase()+0x124a80, extract_virtual(this, tf18{&$CCNode::removeComponent}));

		using tf19 = void($CCNode::*)(bool);
        m->registerHook(getBase()+0x123410, extract_virtual(this, tf19{&$CCNode::removeFromParentAndCleanup}));

		using tf20 = void($CCNode::*)(cocos2d::CCNode*, int);
        m->registerHook(getBase()+0x123760, extract_virtual(this, tf20{&$CCNode::reorderChild}));

		using tf21 = void($CCNode::*)(cocos2d::CCAction*);
        m->registerHook(getBase()+0x123e60, extract_virtual(this, tf21{&$CCNode::runAction}));

		using tf22 = void($CCNode::*)(cocos2d::CCActionManager*);
        m->registerHook(getBase()+0x123e00, extract_virtual(this, tf22{&$CCNode::setActionManager}));

		using tf23 = void($CCNode::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x122d90, extract_virtual(this, tf23{&$CCNode::setAnchorPoint}));

		using tf24 = void($CCNode::*)(cocos2d::CCSize const&);
        m->registerHook(getBase()+0x122e50, extract_virtual(this, tf24{&$CCNode::setContentSize}));

		using tf25 = void($CCNode::*)(cocos2d::ccGLServerState);
        m->registerHook(getBase()+0x122fa0, extract_virtual(this, tf25{&$CCNode::setGLServerState}));

		using tf26 = void($CCNode::*)(cocos2d::CCGridBase*);
        m->registerHook(getBase()+0x122d10, extract_virtual(this, tf26{&$CCNode::setGrid}));

		using tf27 = void($CCNode::*)(unsigned int);
        m->registerHook(getBase()+0x122f60, extract_virtual(this, tf27{&$CCNode::setOrderOfArrival}));

		using tf28 = void($CCNode::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0x122ee0, extract_virtual(this, tf28{&$CCNode::setParent}));

		using tf29 = void($CCNode::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x122b70, extract_virtual(this, tf29{&$CCNode::setPosition}));

		using tf30 = void($CCNode::*)(float, float);
        m->registerHook(getBase()+0x122ba0, extract_virtual(this, tf30{&$CCNode::setPosition}));

		using tf31 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122c00, extract_virtual(this, tf31{&$CCNode::setPositionX}));

		using tf32 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122c40, extract_virtual(this, tf32{&$CCNode::setPositionY}));

		using tf33 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122a10, extract_virtual(this, tf33{&$CCNode::setRotation}));

		using tf34 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122a60, extract_virtual(this, tf34{&$CCNode::setRotationX}));

		using tf35 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122a90, extract_virtual(this, tf35{&$CCNode::setRotationY}));

		using tf36 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122ac0, extract_virtual(this, tf36{&$CCNode::setScale}));

		using tf37 = void($CCNode::*)(float, float);
        m->registerHook(getBase()+0x122ae0, extract_virtual(this, tf37{&$CCNode::setScale}));

		using tf38 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122b10, extract_virtual(this, tf38{&$CCNode::setScaleX}));

		using tf39 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122b40, extract_virtual(this, tf39{&$CCNode::setScaleY}));

		using tf40 = void($CCNode::*)(cocos2d::CCScheduler*);
        m->registerHook(getBase()+0x123f20, extract_virtual(this, tf40{&$CCNode::setScheduler}));

		using tf41 = void($CCNode::*)(cocos2d::CCGLProgram*);
        m->registerHook(getBase()+0x122ff0, extract_virtual(this, tf41{&$CCNode::setShaderProgram}));

		using tf42 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122930, extract_virtual(this, tf42{&$CCNode::setSkewX}));

		using tf43 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x122960, extract_virtual(this, tf43{&$CCNode::setSkewY}));

		using tf44 = void($CCNode::*)(void*);
        m->registerHook(getBase()+0x122f40, extract_virtual(this, tf44{&$CCNode::setUserData}));

		using tf45 = void($CCNode::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x122fb0, extract_virtual(this, tf45{&$CCNode::setUserObject}));

		using tf46 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x1229f0, extract_virtual(this, tf46{&$CCNode::setVertexZ}));

		using tf47 = void($CCNode::*)(bool);
        m->registerHook(getBase()+0x122d60, extract_virtual(this, tf47{&$CCNode::setVisible}));

		using tf48 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x1229a0, extract_virtual(this, tf48{&$CCNode::setZOrder}));

		using tf49 = void($CCNode::*)(int);
        m->registerHook(getBase()+0x123ec0, extract_virtual(this, tf49{&$CCNode::stopActionByTag}));

		using tf50 = void($CCNode::*)(float);
        m->registerHook(getBase()+0x1241a0, extract_virtual(this, tf50{&$CCNode::update}));

		using tf51 = void($CCNode::*)(float, char const*);
        m->registerHook(getBase()+0x1249c0, extract_virtual(this, tf51{&$CCNode::updateTweenAction}));

		using tf52 = void($CCNode::*)(Cacao::CC_SCHED);
        m->registerHook(getBase()+0x1240b0, extract_virtual(this, tf52{&$CCNode::schedule}));

		using tf53 = void($CCNode::*)(Cacao::CC_SCHED, float);
        m->registerHook(getBase()+0x124120, extract_virtual(this, tf53{&$CCNode::schedule}));

		using tf54 = void($CCNode::*)(Cacao::CC_SCHED);
        m->registerHook(getBase()+0x124180, extract_virtual(this, tf54{&$CCNode::unschedule}));
    }
};


class $CCObject : public $CacBase {
 public:
    $CCObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCObject* __thistype;

    virtual void acceptVisitor(cocos2d::CCDataVisitor& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDataVisitor&)>(m->getOriginal(getBase()+0x250f30))(this, p0);
    }

    virtual void encodeWithCoder(DS_Dictionary* p0) {
        return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(getBase()+0x250f70))(this, p0);
    }

    virtual void isEqual(cocos2d::CCObject const* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject const*)>(m->getOriginal(getBase()+0x250f20))(this, p0);
    }

    virtual void setTag(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x250f60))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCObject::*)(cocos2d::CCDataVisitor&);
        m->registerHook(getBase()+0x250f30, extract_virtual(this, tf0{&$CCObject::acceptVisitor}));

		using tf1 = void($CCObject::*)(DS_Dictionary*);
        m->registerHook(getBase()+0x250f70, extract_virtual(this, tf1{&$CCObject::encodeWithCoder}));

		using tf2 = void($CCObject::*)(cocos2d::CCObject const*);
        m->registerHook(getBase()+0x250f20, extract_virtual(this, tf2{&$CCObject::isEqual}));

		using tf3 = void($CCObject::*)(int);
        m->registerHook(getBase()+0x250f60, extract_virtual(this, tf3{&$CCObject::setTag}));
    }
};


class $CCParticleSystemQuad : public $CacBase {
 public:
    $CCParticleSystemQuad() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCParticleSystemQuad* __thistype;

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x36b000))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCParticleSystemQuad::*)(char const*);
        m->registerHook(getBase()+0x36b000, extract_virtual(this, tf0{&$CCParticleSystemQuad::create}));
    }
};


class $CCPoint : public $CacBase {
 public:
    $CCPoint() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCPoint* __thistype;

    virtual void CCPoint(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x137000))(this, p0, p1);
    }

    virtual void CCPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x137090))(this, p0);
    }

    virtual void operator=(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1370c0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCPoint::*)(float, float);
        m->registerHook(getBase()+0x137000, extract_virtual(this, tf0{&$CCPoint::CCPoint}));

		using tf1 = void($CCPoint::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x137090, extract_virtual(this, tf1{&$CCPoint::CCPoint}));

		using tf2 = void($CCPoint::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x1370c0, extract_virtual(this, tf2{&$CCPoint::operator=}));
    }
};


class $CCRect : public $CacBase {
 public:
    $CCRect() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCRect* __thistype;

    virtual void CCRect(float p0, float p1, float p2, float p3) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float, float)>(m->getOriginal(getBase()+0x137020))(this, p0, p1, p2, p3);
    }

    virtual void operator=(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x137670))(this, p0);
    }

    virtual void CCRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x137630))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCRect::*)(float, float, float, float);
        m->registerHook(getBase()+0x137020, extract_virtual(this, tf0{&$CCRect::CCRect}));

		using tf1 = void($CCRect::*)(cocos2d::CCRect const&);
        m->registerHook(getBase()+0x137670, extract_virtual(this, tf1{&$CCRect::operator=}));

		using tf2 = void($CCRect::*)(cocos2d::CCRect const&);
        m->registerHook(getBase()+0x137630, extract_virtual(this, tf2{&$CCRect::CCRect}));
    }
};


class $CCRepeatForever : public $CacBase {
 public:
    $CCRepeatForever() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCRepeatForever* __thistype;

    virtual void create(cocos2d::CCActionInterval* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCActionInterval*)>(m->getOriginal(getBase()+0x1f3920))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCRepeatForever::*)(cocos2d::CCActionInterval*);
        m->registerHook(getBase()+0x1f3920, extract_virtual(this, tf0{&$CCRepeatForever::create}));
    }
};


class $CCRotateBy : public $CacBase {
 public:
    $CCRotateBy() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCRotateBy* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f4c50))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCRotateBy::*)(float, float);
        m->registerHook(getBase()+0x1f4c50, extract_virtual(this, tf0{&$CCRotateBy::create}));
    }
};


class $CCScaleTo : public $CacBase {
 public:
    $CCScaleTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCScaleTo* __thistype;

    virtual void create(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x1f6ff0))(this, p0, p1);
    }

    virtual void create(float p0, float p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(getBase()+0x1f70f0))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($CCScaleTo::*)(float, float);
        m->registerHook(getBase()+0x1f6ff0, extract_virtual(this, tf0{&$CCScaleTo::create}));

		using tf1 = void($CCScaleTo::*)(float, float, float);
        m->registerHook(getBase()+0x1f70f0, extract_virtual(this, tf1{&$CCScaleTo::create}));
    }
};


class $CCSequence : public $CacBase {
 public:
    $CCSequence() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSequence* __thistype;

void apply_hooks() override {    }
};


class $CCSize : public $CacBase {
 public:
    $CCSize() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSize* __thistype;

    virtual void CCSize(float p0, float p1) {
        return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(getBase()+0x137010))(this, p0, p1);
    }

    virtual void CCSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x137400))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCSize::*)(float, float);
        m->registerHook(getBase()+0x137010, extract_virtual(this, tf0{&$CCSize::CCSize}));

		using tf1 = void($CCSize::*)(cocos2d::CCSize const&);
        m->registerHook(getBase()+0x137400, extract_virtual(this, tf1{&$CCSize::CCSize}));
    }
};


class $CCSprite : public $CacBase {
 public:
    $CCSprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSprite* __thistype;

    virtual void addChild(cocos2d::CCNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(getBase()+0x134190))(this, p0);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x1341a0))(this, p0, p1);
    }

    virtual void addChild(cocos2d::CCNode* p0, int p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int, int)>(m->getOriginal(getBase()+0x1341b0))(this, p0, p1, p2);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132a80))(this, p0);
    }

    virtual void createWithSpriteFrameName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x132dc0))(this, p0);
    }

    virtual void ignoreAnchorPointForPosition(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134b60))(this, p0);
    }

    virtual void initWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x133180))(this, p0);
    }

    virtual void initWithFile(char const* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133210))(this, p0, p1);
    }

    virtual void initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x133270))(this, p0);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(getBase()+0x132f10))(this, p0, p1, p2);
    }

    virtual void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1330f0))(this, p0, p1);
    }

    virtual void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x1356d0))(this, p0);
    }

    virtual void removeAllChildrenWithCleanup(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134340))(this, p0);
    }

    virtual void removeChild(cocos2d::CCNode* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(getBase()+0x134300))(this, p0, p1);
    }

    virtual void reorderChild(cocos2d::CCNode* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, int)>(m->getOriginal(getBase()+0x134270))(this, p0, p1);
    }

    virtual void setAnchorPoint(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134af0))(this, p0);
    }

    virtual void setBatchNode(cocos2d::CCSpriteBatchNode* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteBatchNode*)>(m->getOriginal(getBase()+0x135920))(this, p0);
    }

    virtual void setChildOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x134f50))(this, p0);
    }

    virtual void setDirty(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x505c0))(this, p0);
    }

    virtual void setDirtyRecursively(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x1345b0))(this, p0);
    }

    virtual void setDisplayFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x135610))(this, p0);
    }

    virtual void setDisplayFrameWithAnimationName(char const* p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(getBase()+0x135680))(this, p0, p1);
    }

    virtual void setFlipY(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x134c30))(this, p0);
    }

    virtual void setPosition(cocos2d::CCPoint const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x134650))(this, p0);
    }

    virtual void setRotationX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134740))(this, p0);
    }

    virtual void setRotationY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1347b0))(this, p0);
    }

    virtual void setSkewX(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134820))(this, p0);
    }

    virtual void setSkewY(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134890))(this, p0);
    }

    virtual void setTextureCoords(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133910))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x133560))(this, p0);
    }

    virtual void setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&, bool, cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x133580))(this, p0, p1, p2);
    }

    virtual void setVertexRect(cocos2d::CCRect const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect const&)>(m->getOriginal(getBase()+0x1338f0))(this, p0);
    }

    virtual void setVertexZ(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x134a80))(this, p0);
    }

    virtual void setBlendFunc(cocos2d::_ccBlendFunc p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(getBase()+0x50590))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x135200))(this, p0);
    }

    virtual void setTexture(cocos2d::CCTexture2D* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(getBase()+0x135a90))(this, p0);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x135370))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x1354c0))(this, p0);
    }

    virtual void createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(getBase()+0x132cb0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCSprite::*)(cocos2d::CCNode*);
        m->registerHook(getBase()+0x134190, extract_virtual(this, tf0{&$CCSprite::addChild}));

		using tf1 = void($CCSprite::*)(cocos2d::CCNode*, int);
        m->registerHook(getBase()+0x1341a0, extract_virtual(this, tf1{&$CCSprite::addChild}));

		using tf2 = void($CCSprite::*)(cocos2d::CCNode*, int, int);
        m->registerHook(getBase()+0x1341b0, extract_virtual(this, tf2{&$CCSprite::addChild}));

		using tf3 = void($CCSprite::*)(char const*);
        m->registerHook(getBase()+0x132a80, extract_virtual(this, tf3{&$CCSprite::create}));

		using tf4 = void($CCSprite::*)(char const*);
        m->registerHook(getBase()+0x132dc0, extract_virtual(this, tf4{&$CCSprite::createWithSpriteFrameName}));

		using tf5 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x134b60, extract_virtual(this, tf5{&$CCSprite::ignoreAnchorPointForPosition}));

		using tf6 = void($CCSprite::*)(char const*);
        m->registerHook(getBase()+0x133180, extract_virtual(this, tf6{&$CCSprite::initWithFile}));

		using tf7 = void($CCSprite::*)(char const*, cocos2d::CCRect const&);
        m->registerHook(getBase()+0x133210, extract_virtual(this, tf7{&$CCSprite::initWithFile}));

		using tf8 = void($CCSprite::*)(cocos2d::CCSpriteFrame*);
        m->registerHook(getBase()+0x133270, extract_virtual(this, tf8{&$CCSprite::initWithSpriteFrame}));

		using tf9 = void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
        m->registerHook(getBase()+0x132f10, extract_virtual(this, tf9{&$CCSprite::initWithTexture}));

		using tf10 = void($CCSprite::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&);
        m->registerHook(getBase()+0x1330f0, extract_virtual(this, tf10{&$CCSprite::initWithTexture}));

		using tf11 = void($CCSprite::*)(cocos2d::CCSpriteFrame*);
        m->registerHook(getBase()+0x1356d0, extract_virtual(this, tf11{&$CCSprite::isFrameDisplayed}));

		using tf12 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x134340, extract_virtual(this, tf12{&$CCSprite::removeAllChildrenWithCleanup}));

		using tf13 = void($CCSprite::*)(cocos2d::CCNode*, bool);
        m->registerHook(getBase()+0x134300, extract_virtual(this, tf13{&$CCSprite::removeChild}));

		using tf14 = void($CCSprite::*)(cocos2d::CCNode*, int);
        m->registerHook(getBase()+0x134270, extract_virtual(this, tf14{&$CCSprite::reorderChild}));

		using tf15 = void($CCSprite::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x134af0, extract_virtual(this, tf15{&$CCSprite::setAnchorPoint}));

		using tf16 = void($CCSprite::*)(cocos2d::CCSpriteBatchNode*);
        m->registerHook(getBase()+0x135920, extract_virtual(this, tf16{&$CCSprite::setBatchNode}));

		using tf17 = void($CCSprite::*)(unsigned char);
        m->registerHook(getBase()+0x134f50, extract_virtual(this, tf17{&$CCSprite::setChildOpacity}));

		using tf18 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x505c0, extract_virtual(this, tf18{&$CCSprite::setDirty}));

		using tf19 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x1345b0, extract_virtual(this, tf19{&$CCSprite::setDirtyRecursively}));

		using tf20 = void($CCSprite::*)(cocos2d::CCSpriteFrame*);
        m->registerHook(getBase()+0x135610, extract_virtual(this, tf20{&$CCSprite::setDisplayFrame}));

		using tf21 = void($CCSprite::*)(char const*, int);
        m->registerHook(getBase()+0x135680, extract_virtual(this, tf21{&$CCSprite::setDisplayFrameWithAnimationName}));

		using tf22 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x134c30, extract_virtual(this, tf22{&$CCSprite::setFlipY}));

		using tf23 = void($CCSprite::*)(cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x134650, extract_virtual(this, tf23{&$CCSprite::setPosition}));

		using tf24 = void($CCSprite::*)(float);
        m->registerHook(getBase()+0x134740, extract_virtual(this, tf24{&$CCSprite::setRotationX}));

		using tf25 = void($CCSprite::*)(float);
        m->registerHook(getBase()+0x1347b0, extract_virtual(this, tf25{&$CCSprite::setRotationY}));

		using tf26 = void($CCSprite::*)(float);
        m->registerHook(getBase()+0x134820, extract_virtual(this, tf26{&$CCSprite::setSkewX}));

		using tf27 = void($CCSprite::*)(float);
        m->registerHook(getBase()+0x134890, extract_virtual(this, tf27{&$CCSprite::setSkewY}));

		using tf28 = void($CCSprite::*)(cocos2d::CCRect const&);
        m->registerHook(getBase()+0x133910, extract_virtual(this, tf28{&$CCSprite::setTextureCoords}));

		using tf29 = void($CCSprite::*)(cocos2d::CCRect const&);
        m->registerHook(getBase()+0x133560, extract_virtual(this, tf29{&$CCSprite::setTextureRect}));

		using tf30 = void($CCSprite::*)(cocos2d::CCRect const&, bool, cocos2d::CCSize const&);
        m->registerHook(getBase()+0x133580, extract_virtual(this, tf30{&$CCSprite::setTextureRect}));

		using tf31 = void($CCSprite::*)(cocos2d::CCRect const&);
        m->registerHook(getBase()+0x1338f0, extract_virtual(this, tf31{&$CCSprite::setVertexRect}));

		using tf32 = void($CCSprite::*)(float);
        m->registerHook(getBase()+0x134a80, extract_virtual(this, tf32{&$CCSprite::setVertexZ}));

		using tf33 = void($CCSprite::*)(cocos2d::_ccBlendFunc);
        m->registerHook(getBase()+0x50590, extract_virtual(this, tf33{&$CCSprite::setBlendFunc}));

		using tf34 = void($CCSprite::*)(bool);
        m->registerHook(getBase()+0x135200, extract_virtual(this, tf34{&$CCSprite::setOpacityModifyRGB}));

		using tf35 = void($CCSprite::*)(cocos2d::CCTexture2D*);
        m->registerHook(getBase()+0x135a90, extract_virtual(this, tf35{&$CCSprite::setTexture}));

		using tf36 = void($CCSprite::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x135370, extract_virtual(this, tf36{&$CCSprite::updateDisplayedColor}));

		using tf37 = void($CCSprite::*)(unsigned char);
        m->registerHook(getBase()+0x1354c0, extract_virtual(this, tf37{&$CCSprite::updateDisplayedOpacity}));

		using tf38 = void($CCSprite::*)(cocos2d::CCSpriteFrame*);
        m->registerHook(getBase()+0x132cb0, extract_virtual(this, tf38{&$CCSprite::createWithSpriteFrame}));
    }
};


class $CCSpriteBatchNode : public $CacBase {
 public:
    $CCSpriteBatchNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSpriteBatchNode* __thistype;

    virtual void createWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, unsigned int)>(m->getOriginal(getBase()+0xbb310))(this, p0, p1);
    }

    virtual void increaseAtlasCapacity(unsigned int p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned int)>(m->getOriginal(getBase()+0xbc670))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCSpriteBatchNode::*)(cocos2d::CCTexture2D*, unsigned int);
        m->registerHook(getBase()+0xbb310, extract_virtual(this, tf0{&$CCSpriteBatchNode::createWithTexture}));

		using tf1 = void($CCSpriteBatchNode::*)(unsigned int);
        m->registerHook(getBase()+0xbc670, extract_virtual(this, tf1{&$CCSpriteBatchNode::increaseAtlasCapacity}));
    }
};


class $CCSpriteFrameCache : public $CacBase {
 public:
    $CCSpriteFrameCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCSpriteFrameCache* __thistype;

    virtual void spriteFrameByName(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x19a7e0))(this, p0);
    }

    virtual void addSpriteFramesWithFile(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x199a10))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCSpriteFrameCache::*)(char const*);
        m->registerHook(getBase()+0x19a7e0, extract_virtual(this, tf0{&$CCSpriteFrameCache::spriteFrameByName}));

		using tf1 = void($CCSpriteFrameCache::*)(char const*);
        m->registerHook(getBase()+0x199a10, extract_virtual(this, tf1{&$CCSpriteFrameCache::addSpriteFramesWithFile}));
    }
};


class $CCString : public $CacBase {
 public:
    $CCString() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCString* __thistype;

    virtual void CCString(std::string const& p0) {
        return reinterpret_cast<void(*)(decltype(this), std::string const&)>(m->getOriginal(getBase()+0x44c310))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCString::*)(std::string const&);
        m->registerHook(getBase()+0x44c310, extract_virtual(this, tf0{&$CCString::CCString}));
    }
};


class $CCTexture2D : public $CacBase {
 public:
    $CCTexture2D() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTexture2D* __thistype;

    virtual void setTexParameters(cocos2d::_ccTexParams* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccTexParams*)>(m->getOriginal(getBase()+0x247980))(this, p0);
    }

    virtual void initWithImage(cocos2d::CCImage* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCImage*)>(m->getOriginal(getBase()+0x246940))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCTexture2D::*)(cocos2d::_ccTexParams*);
        m->registerHook(getBase()+0x247980, extract_virtual(this, tf0{&$CCTexture2D::setTexParameters}));

		using tf1 = void($CCTexture2D::*)(cocos2d::CCImage*);
        m->registerHook(getBase()+0x246940, extract_virtual(this, tf1{&$CCTexture2D::initWithImage}));
    }
};


class $CCTextureCache : public $CacBase {
 public:
    $CCTextureCache() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTextureCache* __thistype;

    virtual void addImage(char const* p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(getBase()+0x358120))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCTextureCache::*)(char const*, bool);
        m->registerHook(getBase()+0x358120, extract_virtual(this, tf0{&$CCTextureCache::addImage}));
    }
};


class $CCTouchDispatcher : public $CacBase {
 public:
    $CCTouchDispatcher() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTouchDispatcher* __thistype;

    virtual void decrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f70))(this, p0);
    }

    virtual void incrementForcePrio(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x280f60))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCTouchDispatcher::*)(int);
        m->registerHook(getBase()+0x280f70, extract_virtual(this, tf0{&$CCTouchDispatcher::decrementForcePrio}));

		using tf1 = void($CCTouchDispatcher::*)(int);
        m->registerHook(getBase()+0x280f60, extract_virtual(this, tf1{&$CCTouchDispatcher::incrementForcePrio}));
    }
};


class $ZipUtils : public $CacBase {
 public:
    $ZipUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $ZipUtils* __thistype;

    virtual void decompressString(std::string p0, bool p1, int p2) {
        return reinterpret_cast<void(*)(decltype(this), std::string, bool, int)>(m->getOriginal(getBase()+0xea380))(this, p0, p1, p2);
    }

void apply_hooks() override {
		using tf0 = void($ZipUtils::*)(std::string, bool, int);
        m->registerHook(getBase()+0xea380, extract_virtual(this, tf0{&$ZipUtils::decompressString}));
    }
};


class $cocos2d : public $CacBase {
 public:
    $cocos2d() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $cocos2d* __thistype;

    virtual void ccArrayRemoveAllObjects(cocos2d::_ccArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccArray*)>(m->getOriginal(getBase()+0x3b1c80))(this, p0);
    }

    virtual void ccpDistance(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&, cocos2d::CCPoint const&)>(m->getOriginal(getBase()+0x1aaf90))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($cocos2d::*)(cocos2d::_ccArray*);
        m->registerHook(getBase()+0x3b1c80, extract_virtual(this, tf0{&$cocos2d::ccArrayRemoveAllObjects}));

		using tf1 = void($cocos2d::*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&);
        m->registerHook(getBase()+0x1aaf90, extract_virtual(this, tf1{&$cocos2d::ccpDistance}));
    }
};


class $CCControlColourPicker : public $CacBase {
 public:
    $CCControlColourPicker() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCControlColourPicker* __thistype;

    virtual void setColorValue(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x1aac10))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCControlColourPicker::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x1aac10, extract_virtual(this, tf0{&$CCControlColourPicker::setColorValue}));
    }
};


class $CCControlUtils : public $CacBase {
 public:
    $CCControlUtils() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCControlUtils* __thistype;

    virtual void HSVfromRGB(cocos2d::extension::RGBA p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::RGBA)>(m->getOriginal(getBase()+0x1e6750))(this, p0);
    }

    virtual void RGBfromHSV(cocos2d::extension::HSV p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::extension::HSV)>(m->getOriginal(getBase()+0x1e6850))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCControlUtils::*)(cocos2d::extension::RGBA);
        m->registerHook(getBase()+0x1e6750, extract_virtual(this, tf0{&$CCControlUtils::HSVfromRGB}));

		using tf1 = void($CCControlUtils::*)(cocos2d::extension::HSV);
        m->registerHook(getBase()+0x1e6850, extract_virtual(this, tf1{&$CCControlUtils::RGBfromHSV}));
    }
};


class $CCScale9Sprite : public $CacBase {
 public:
    $CCScale9Sprite() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCScale9Sprite* __thistype;

    virtual void create(char const* p0, cocos2d::CCRect p1) {
        return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCRect)>(m->getOriginal(getBase()+0x212ef0))(this, p0, p1);
    }

    virtual void create(char const* p0) {
        return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(getBase()+0x2130d0))(this, p0);
    }

    virtual void setContentSize(cocos2d::CCSize const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSize const&)>(m->getOriginal(getBase()+0x2127c0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCScale9Sprite::*)(char const*, cocos2d::CCRect);
        m->registerHook(getBase()+0x212ef0, extract_virtual(this, tf0{&$CCScale9Sprite::create}));

		using tf1 = void($CCScale9Sprite::*)(char const*);
        m->registerHook(getBase()+0x2130d0, extract_virtual(this, tf1{&$CCScale9Sprite::create}));

		using tf2 = void($CCScale9Sprite::*)(cocos2d::CCSize const&);
        m->registerHook(getBase()+0x2127c0, extract_virtual(this, tf2{&$CCScale9Sprite::setContentSize}));
    }
};


class $FLAlertLayer : public $CacBase {
 public:
    $FLAlertLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $FLAlertLayer* __thistype;

    virtual void ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ee40))(this, p0, p1);
    }

    virtual void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f020))(this, p0, p1);
    }

    virtual void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25ef60))(this, p0, p1);
    }

    virtual void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(getBase()+0x25f0a0))(this, p0, p1);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(getBase()+0x25e0e0))(this, p0, p1, p2, p3, p4, p5);
    }

    virtual void keyDown(cocos2d::enumKeyCodes p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(getBase()+0x25ece0))(this, p0);
    }

    virtual void create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25dec0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        return reinterpret_cast<void(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(getBase()+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

void apply_hooks() override {
		using tf0 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x25ee40, extract_virtual(this, tf0{&$FLAlertLayer::ccTouchBegan}));

		using tf1 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x25f020, extract_virtual(this, tf1{&$FLAlertLayer::ccTouchCancelled}));

		using tf2 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x25ef60, extract_virtual(this, tf2{&$FLAlertLayer::ccTouchEnded}));

		using tf3 = void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*);
        m->registerHook(getBase()+0x25f0a0, extract_virtual(this, tf3{&$FLAlertLayer::ccTouchMoved}));

		using tf4 = void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float);
        m->registerHook(getBase()+0x25e0e0, extract_virtual(this, tf4{&$FLAlertLayer::create}));

		using tf5 = void($FLAlertLayer::*)(cocos2d::enumKeyCodes);
        m->registerHook(getBase()+0x25ece0, extract_virtual(this, tf5{&$FLAlertLayer::keyDown}));

		using tf6 = void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float);
        m->registerHook(getBase()+0x25dec0, extract_virtual(this, tf6{&$FLAlertLayer::create}));

		using tf7 = void($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float);
        m->registerHook(getBase()+0x25e1b0, extract_virtual(this, tf7{&$FLAlertLayer::init}));
    }
};


class $CCLayerRGBA : public $CacBase {
 public:
    $CCLayerRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCLayerRGBA* __thistype;

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274250))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x274210))(this, p0);
    }

    virtual void setOpacityModifyRGB(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x6180))(this, p0);
    }

    virtual void updateDisplayedColor(cocos2d::_ccColor3B const& p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(getBase()+0x2740b0))(this, p0);
    }

    virtual void updateDisplayedOpacity(unsigned char p0) {
        return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(getBase()+0x273f20))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCLayerRGBA::*)(bool);
        m->registerHook(getBase()+0x274250, extract_virtual(this, tf0{&$CCLayerRGBA::setCascadeColorEnabled}));

		using tf1 = void($CCLayerRGBA::*)(bool);
        m->registerHook(getBase()+0x274210, extract_virtual(this, tf1{&$CCLayerRGBA::setCascadeOpacityEnabled}));

		using tf2 = void($CCLayerRGBA::*)(bool);
        m->registerHook(getBase()+0x6180, extract_virtual(this, tf2{&$CCLayerRGBA::setOpacityModifyRGB}));

		using tf3 = void($CCLayerRGBA::*)(cocos2d::_ccColor3B const&);
        m->registerHook(getBase()+0x2740b0, extract_virtual(this, tf3{&$CCLayerRGBA::updateDisplayedColor}));

		using tf4 = void($CCLayerRGBA::*)(unsigned char);
        m->registerHook(getBase()+0x273f20, extract_virtual(this, tf4{&$CCLayerRGBA::updateDisplayedOpacity}));
    }
};


class $CCNodeRGBA : public $CacBase {
 public:
    $CCNodeRGBA() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCNodeRGBA* __thistype;

    virtual void setCascadeColorEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125340))(this, p0);
    }

    virtual void setCascadeOpacityEnabled(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x125000))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCNodeRGBA::*)(bool);
        m->registerHook(getBase()+0x125340, extract_virtual(this, tf0{&$CCNodeRGBA::setCascadeColorEnabled}));

		using tf1 = void($CCNodeRGBA::*)(bool);
        m->registerHook(getBase()+0x125000, extract_virtual(this, tf1{&$CCNodeRGBA::setCascadeOpacityEnabled}));
    }
};


class $CCMenuItemSpriteExtra : public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMenuItemSpriteExtra* __thistype;

    virtual void setSizeMult(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x1255e0))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1253c0))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CCMenuItemSpriteExtra::*)(float);
        m->registerHook(getBase()+0x1255e0, extract_virtual(this, tf0{&$CCMenuItemSpriteExtra::setSizeMult}));

		using tf1 = void($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL);
        m->registerHook(getBase()+0x1253c0, extract_virtual(this, tf1{&$CCMenuItemSpriteExtra::create}));
    }
};


class $EditButtonBar : public $CacBase {
 public:
    $EditButtonBar() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EditButtonBar* __thistype;

    virtual void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(getBase()+0x351010))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool);
        m->registerHook(getBase()+0x351010, extract_virtual(this, tf0{&$EditButtonBar::loadFromItems}));
    }
};


class $EditorPauseLayer : public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $EditorPauseLayer* __thistype;

    virtual void create(LevelEditorLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(getBase()+0x13c680))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($EditorPauseLayer::*)(LevelEditorLayer*);
        m->registerHook(getBase()+0x13c680, extract_virtual(this, tf0{&$EditorPauseLayer::create}));
    }
};


class $GJSearchObject : public $CacBase {
 public:
    $GJSearchObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $GJSearchObject* __thistype;

    virtual void create(SearchType p0, std::string p1, std::string p2, std::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, int p17, int p18) {
        return reinterpret_cast<void(*)(decltype(this), SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int)>(m->getOriginal(getBase()+0x2dee30))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
    }

    virtual void create(SearchType p0) {
        return reinterpret_cast<void(*)(decltype(this), SearchType)>(m->getOriginal(getBase()+0x2df120))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($GJSearchObject::*)(SearchType, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int);
        m->registerHook(getBase()+0x2dee30, extract_virtual(this, tf0{&$GJSearchObject::create}));

		using tf1 = void($GJSearchObject::*)(SearchType);
        m->registerHook(getBase()+0x2df120, extract_virtual(this, tf1{&$GJSearchObject::create}));
    }
};


class $InfoLayer : public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $InfoLayer* __thistype;

    virtual void loadPage(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0x458fb0))(this, p0, p1);
    }

    virtual void onRefreshComments(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x459b60))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($InfoLayer::*)(int, bool);
        m->registerHook(getBase()+0x458fb0, extract_virtual(this, tf0{&$InfoLayer::loadPage}));

		using tf1 = void($InfoLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x459b60, extract_virtual(this, tf1{&$InfoLayer::onRefreshComments}));
    }
};


class $LevelBrowserLayer : public $CacBase {
 public:
    $LevelBrowserLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $LevelBrowserLayer* __thistype;

    virtual void scene(GJSearchObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJSearchObject*)>(m->getOriginal(getBase()+0x2511d0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($LevelBrowserLayer::*)(GJSearchObject*);
        m->registerHook(getBase()+0x2511d0, extract_virtual(this, tf0{&$LevelBrowserLayer::scene}));
    }
};


class $MenuLayer : public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $MenuLayer* __thistype;

    virtual void onQuit(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2b40))(this, p0);
    }

    virtual void onMoreGames(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x1d2ad0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($MenuLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x1d2b40, extract_virtual(this, tf0{&$MenuLayer::onQuit}));

		using tf1 = void($MenuLayer::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x1d2ad0, extract_virtual(this, tf1{&$MenuLayer::onMoreGames}));
    }
};


class $Slider : public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $Slider* __thistype;

    virtual void setBarVisibility(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x18e280))(this, p0);
    }

    virtual void setValue(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x18e170))(this, p0);
    }

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, float p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, float)>(m->getOriginal(getBase()+0x18dc40))(this, p0, p1, p2);
    }

    virtual void create(cocos2d::CCNode* p0, Cacao::CC_SEL p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float)>(m->getOriginal(getBase()+0x18dd80))(this, p0, p1, p2, p3, p4, p5, p6);
    }

void apply_hooks() override {
		using tf0 = void($Slider::*)(bool);
        m->registerHook(getBase()+0x18e280, extract_virtual(this, tf0{&$Slider::setBarVisibility}));

		using tf1 = void($Slider::*)(float);
        m->registerHook(getBase()+0x18e170, extract_virtual(this, tf1{&$Slider::setValue}));

		using tf2 = void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, float);
        m->registerHook(getBase()+0x18dc40, extract_virtual(this, tf2{&$Slider::create}));

		using tf3 = void($Slider::*)(cocos2d::CCNode*, Cacao::CC_SEL, char const*, char const*, char const*, char const*, float);
        m->registerHook(getBase()+0x18dd80, extract_virtual(this, tf3{&$Slider::create}));
    }
};


class $TextArea : public $CacBase {
 public:
    $TextArea() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $TextArea* __thistype;

    virtual void create(std::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) {
        return reinterpret_cast<void(*)(decltype(this), std::string, char const*, float, float, cocos2d::CCPoint, float, bool)>(m->getOriginal(getBase()+0x19eb40))(this, p0, p1, p2, p3, p4, p5, p6);
    }

void apply_hooks() override {
		using tf0 = void($TextArea::*)(std::string, char const*, float, float, cocos2d::CCPoint, float, bool);
        m->registerHook(getBase()+0x19eb40, extract_virtual(this, tf0{&$TextArea::create}));
    }
};


class $CCDirector : public $CacBase {
 public:
    $CCDirector() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCDirector* __thistype;

    virtual void pushScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a620))(this, p0);
    }

    virtual void replaceScene(cocos2d::CCScene* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(getBase()+0x24a6d0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCDirector::*)(cocos2d::CCScene*);
        m->registerHook(getBase()+0x24a620, extract_virtual(this, tf0{&$CCDirector::pushScene}));

		using tf1 = void($CCDirector::*)(cocos2d::CCScene*);
        m->registerHook(getBase()+0x24a6d0, extract_virtual(this, tf1{&$CCDirector::replaceScene}));
    }
};


class $CCImage : public $CacBase {
 public:
    $CCImage() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCImage* __thistype;

    virtual void initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5) {
        return reinterpret_cast<void(*)(decltype(this), void*, int, cocos2d::CCImage::EImageFormat, int, int, int)>(m->getOriginal(getBase()+0x24fcb0))(this, p0, p1, p2, p3, p4, p5);
    }

void apply_hooks() override {
		using tf0 = void($CCImage::*)(void*, int, cocos2d::CCImage::EImageFormat, int, int, int);
        m->registerHook(getBase()+0x24fcb0, extract_virtual(this, tf0{&$CCImage::initWithImageData}));
    }
};


class $CCMenu : public $CacBase {
 public:
    $CCMenu() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCMenu* __thistype;

    virtual void alignItemsHorizontallyWithPadding(float p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0x4393e0))(this, p0);
    }

    virtual void createWithArray(cocos2d::CCArray* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(getBase()+0x4387e0))(this, p0);
    }

    virtual void createWithItem(cocos2d::CCMenuItem* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCMenuItem*)>(m->getOriginal(getBase()+0x438b80))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCMenu::*)(float);
        m->registerHook(getBase()+0x4393e0, extract_virtual(this, tf0{&$CCMenu::alignItemsHorizontallyWithPadding}));

		using tf1 = void($CCMenu::*)(cocos2d::CCArray*);
        m->registerHook(getBase()+0x4387e0, extract_virtual(this, tf1{&$CCMenu::createWithArray}));

		using tf2 = void($CCMenu::*)(cocos2d::CCMenuItem*);
        m->registerHook(getBase()+0x438b80, extract_virtual(this, tf2{&$CCMenu::createWithItem}));
    }
};


class $CCRenderTexture : public $CacBase {
 public:
    $CCRenderTexture() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCRenderTexture* __thistype;

    virtual void create(int p0, int p1, cocos2d::CCTexture2DPixelFormat p2) {
        return reinterpret_cast<void(*)(decltype(this), int, int, cocos2d::CCTexture2DPixelFormat)>(m->getOriginal(getBase()+0x35c720))(this, p0, p1, p2);
    }

    virtual void newCCImage(bool p0) {
        return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(getBase()+0x35d7d0))(this, p0);
    }

void apply_hooks() override {
		using tf0 = void($CCRenderTexture::*)(int, int, cocos2d::CCTexture2DPixelFormat);
        m->registerHook(getBase()+0x35c720, extract_virtual(this, tf0{&$CCRenderTexture::create}));

		using tf1 = void($CCRenderTexture::*)(bool);
        m->registerHook(getBase()+0x35d7d0, extract_virtual(this, tf1{&$CCRenderTexture::newCCImage}));
    }
};


class $CCScheduler : public $CacBase {
 public:
    $CCScheduler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCScheduler* __thistype;

    virtual void scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, int, bool)>(m->getOriginal(getBase()+0x2438d0))(this, p0, p1, p2);
    }

    virtual void unscheduleAllForTarget(cocos2d::CCObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(getBase()+0x243e40))(this, p0);
    }

    virtual void scheduleSelector(Cacao::CC_SCHED p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) {
        return reinterpret_cast<void(*)(decltype(this), Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool)>(m->getOriginal(getBase()+0x242b20))(this, p0, p1, p2, p3, p4, p5);
    }

void apply_hooks() override {
		using tf0 = void($CCScheduler::*)(cocos2d::CCObject*, int, bool);
        m->registerHook(getBase()+0x2438d0, extract_virtual(this, tf0{&$CCScheduler::scheduleUpdateForTarget}));

		using tf1 = void($CCScheduler::*)(cocos2d::CCObject*);
        m->registerHook(getBase()+0x243e40, extract_virtual(this, tf1{&$CCScheduler::unscheduleAllForTarget}));

		using tf2 = void($CCScheduler::*)(Cacao::CC_SCHED, cocos2d::CCObject*, float, unsigned int, float, bool);
        m->registerHook(getBase()+0x242b20, extract_virtual(this, tf2{&$CCScheduler::scheduleSelector}));
    }
};


class $CCTintTo : public $CacBase {
 public:
    $CCTintTo() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTintTo* __thistype;

    virtual void create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) {
        return reinterpret_cast<void(*)(decltype(this), float, unsigned char, unsigned char, unsigned char)>(m->getOriginal(getBase()+0x1f82a0))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CCTintTo::*)(float, unsigned char, unsigned char, unsigned char);
        m->registerHook(getBase()+0x1f82a0, extract_virtual(this, tf0{&$CCTintTo::create}));
    }
};


class $CCTransitionFade : public $CacBase {
 public:
    $CCTransitionFade() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CCTransitionFade* __thistype;

    virtual void create(float p0, cocos2d::CCScene* p1) {
        return reinterpret_cast<void(*)(decltype(this), float, cocos2d::CCScene*)>(m->getOriginal(getBase()+0x8ea30))(this, p0, p1);
    }

void apply_hooks() override {
		using tf0 = void($CCTransitionFade::*)(float, cocos2d::CCScene*);
        m->registerHook(getBase()+0x8ea30, extract_virtual(this, tf0{&$CCTransitionFade::create}));
    }
};


class $CreateMenuItem : public $CacBase {
 public:
    $CreateMenuItem() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef $CreateMenuItem* __thistype;

    virtual void create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, Cacao::CC_SEL p3) {
        return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL)>(m->getOriginal(getBase()+0x1c580))(this, p0, p1, p2, p3);
    }

void apply_hooks() override {
		using tf0 = void($CreateMenuItem::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, Cacao::CC_SEL);
        m->registerHook(getBase()+0x1c580, extract_virtual(this, tf0{&$CreateMenuItem::create}));
    }
};
