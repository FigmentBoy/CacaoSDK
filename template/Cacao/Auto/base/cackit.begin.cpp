//Copyright camden314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#include <stdint.h>

uintptr_t getBase();
volatile uintptr_t base = getBase();

#include <Cacao.hpp>
#include <CackitMacros.hpp>

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

ModContainer* m = new ModContainer(CAC_PROJ_NAME);

typedef char const* c_string;

// deprecated lol
template <class F>
struct GetReturnType;

// deprecated lol
template <class K>
struct RemoveRef;

// deprecated lol
template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

// deprecated lol
template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

// deprecated lol
#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

// "A destructor is used to destroy objects of its class type. The address of a destructor shall not be taken."
// - C++ standard 12.4.2
// Therefore, we shall not take the destructor of the class and replace it with an empty function. ~alk
template <class T>
inline uintptr_t extract_destructor(T instance) {
    return (*reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(instance)+8));
};

// Welcome back we missed you
template <typename F, class T>
inline uintptr_t extract_virtual(T instance, F func) {
    return (*reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(instance)+*reinterpret_cast<uintptr_t*>(&func)-1));
};

template <typename F>
inline uintptr_t extract(F func) {
    return (*reinterpret_cast<uintptr_t*>(&func));
};

class $CacBase {
public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}
