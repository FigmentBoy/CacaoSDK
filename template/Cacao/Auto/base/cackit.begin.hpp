//Copyright camila314 2021. Autogenerated using a python script
//please add meeeeee - alk1m123/altalk23
#ifndef __CACKIT_HPP__
#define __CACKIT_HPP__

#include <stdint.h>

uintptr_t getBase();
volatile uintptr_t const base = getBase();

#include <Cacao.hpp>
#include <CackitMacros.hpp>

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

ModContainer* const m = new ModContainer(CAC_PROJ_NAME);

// "A destructor is used to destroy objects of its class type. The address of a destructor shall not be taken."
// - C++ standard 12.4.2
// Therefore, we shall not take the destructor of the class and replace it with an empty function.  ~alk
//
// 0x18 from 0x10 + 0x8, the vtable pointer is offset by 0x10 and the destructor is at the address vtable + 0x8
template <typename V>
inline uintptr_t extract_destructor(V vtable) {
    return (*reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(vtable)+0x18));
};

// Even more advanced this time
//
// 0xf is from 0x10 - 1, the vtable pointer is offset by 0x10 and -1 comes from the address of a virtual func being 1 off
template <typename F, typename V>
inline uintptr_t extract_virtual(V vtable, F func) { 
    return (*reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(vtable)+*reinterpret_cast<uintptr_t*>(&func)+0xf));
};

// itâ€™s actually kinda sick because you can use the ref cast thingy to convert almost anything to anything else  ~camila
template <typename F>
inline uintptr_t extract(F func) {
    return reinterpret_cast<uintptr_t&>(func);
};

// Just in case if we ever need to add shared implementations
class $CacBase {};
