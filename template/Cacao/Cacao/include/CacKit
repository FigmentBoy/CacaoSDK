//Copyright camden314 2021. Autogenerated using a python script
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif
#define CAC_HOOKS void __cacinj() __attribute__((constructor)); void __cacinj() {
#define END_CAC_HOOKS \
    for(auto& i : __cackit::glob) {i->apply_hooks();};m->enable();}

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};

class $CacBase {
 public:
    virtual void apply_hooks() = 0; 
};

namespace __cackit {
  std::vector<$CacBase*> glob;  
}
 

class $GameObject : public $CacBase {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameObject* __thistype;

    virtual int getGroupID(int  p0) {
        return reinterpret_cast<int(*)(decltype(this),int )>(m->getOriginal(getBase()+0x33ae10))(this,p0);
    }

    virtual void setPosition(CCPoint  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCPoint )>(m->getOriginal(getBase()+0x335850))(this,p0);
    }

    virtual void setStartPos(CCPoint  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCPoint )>(m->getOriginal(getBase()+0x2fa520))(this,p0);
    }

    virtual void selectObject(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x341f90))(this,p0);
    }

    virtual void setupCoinArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
    }

    virtual void destroyObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
    }

    virtual void playShineEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
    }

    virtual void calculateSpawnXPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
    }

    virtual bool init(char const*  p0) {
        return reinterpret_cast<bool(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x2f5520))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x33ae10, extract_virtual(this, &$GameObject::getGroupID));

        m->registerHook(getBase()+0x335850, extract_virtual(this, &$GameObject::setPosition));

        m->registerHook(getBase()+0x2fa520, extract_virtual(this, &$GameObject::setStartPos));

        m->registerHook(getBase()+0x341f90, extract_virtual(this, &$GameObject::selectObject));

        m->registerHook(getBase()+0x337dd0, extract_virtual(this, &$GameObject::setupCoinArt));

        m->registerHook(getBase()+0x336a00, extract_virtual(this, &$GameObject::destroyObject));

        m->registerHook(getBase()+0x2fa9d0, extract_virtual(this, &$GameObject::playShineEffect));

        m->registerHook(getBase()+0x336970, extract_virtual(this, &$GameObject::calculateSpawnXPos));

        m->registerHook(getBase()+0x2f5520, extract_virtual(this, &$GameObject::init));
    }
};


class $GameManager : public $CacBase {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameManager* __thistype;

    virtual _ccColor3B colorForIdx(int  p0) {
        return reinterpret_cast<_ccColor3B(*)(decltype(this),int )>(m->getOriginal(getBase()+0x1cbc80))(this,p0);
    }

    virtual void doQuickSave() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
    }

    virtual void fadeInMusic(char const*  p0) {
        return reinterpret_cast<void(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x1c2ff0))(this,p0);
    }

    virtual void reloadAllStep5() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
    }

    virtual int getGameVariable(char const*  p0) {
        return reinterpret_cast<int(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x1cccd0))(this,p0);
    }

    virtual int setGameVariable(char const*  p0,bool  p1) {
        return reinterpret_cast<int(*)(decltype(this),char const* ,bool )>(m->getOriginal(getBase()+0x1cca80))(this,p0,p1);
    }

    virtual bool accountStatusChanged() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
    }

    virtual void load() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26ee20))(this);
    }

    virtual void loadFont(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x1cc550))(this,p0);
    }

    virtual void reloadAll(bool  p0,bool  p1,bool  p2) {
        return reinterpret_cast<void(*)(decltype(this),bool ,bool ,bool )>(m->getOriginal(getBase()+0x1d08a0))(this,p0,p1,p2);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1cbc80, extract_virtual(this, &$GameManager::colorForIdx));

        m->registerHook(getBase()+0x1d0200, extract_virtual(this, &$GameManager::doQuickSave));

        m->registerHook(getBase()+0x1c2ff0, extract_virtual(this, &$GameManager::fadeInMusic));

        m->registerHook(getBase()+0x1d0b00, extract_virtual(this, &$GameManager::reloadAllStep5));

        m->registerHook(getBase()+0x1cccd0, extract_virtual(this, &$GameManager::getGameVariable));

        m->registerHook(getBase()+0x1cca80, extract_virtual(this, &$GameManager::setGameVariable));

        m->registerHook(getBase()+0x1cdad0, extract_virtual(this, &$GameManager::accountStatusChanged));

        m->registerHook(getBase()+0x26ee20, extract_virtual(this, &$GameManager::load));

        m->registerHook(getBase()+0x1cc550, extract_virtual(this, &$GameManager::loadFont));

        m->registerHook(getBase()+0x1d08a0, extract_virtual(this, &$GameManager::reloadAll));
    }
};


class $PlayerObject : public $CacBase {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayerObject* __thistype;

    virtual void pushButton(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x22aa00))(this,p0);
    }

    virtual void releaseButton(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x22b6f0))(this,p0);
    }

    virtual void flipGravity(bool  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),bool ,bool )>(m->getOriginal(getBase()+0x21c090))(this,p0,p1);
    }

    virtual void setSecondColor(_ccColor3B const&  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B const& )>(m->getOriginal(getBase()+0x219610))(this,p0);
    }

    virtual void addAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
    }

    virtual void setColor(_ccColor3B const&  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B const& )>(m->getOriginal(getBase()+0x22cdf0))(this,p0);
    }

    virtual void update(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x218bf0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x22aa00, extract_virtual(this, &$PlayerObject::pushButton));

        m->registerHook(getBase()+0x22b6f0, extract_virtual(this, &$PlayerObject::releaseButton));

        m->registerHook(getBase()+0x21c090, extract_virtual(this, &$PlayerObject::flipGravity));

        m->registerHook(getBase()+0x219610, extract_virtual(this, &$PlayerObject::setSecondColor));

        m->registerHook(getBase()+0x2189b0, extract_virtual(this, &$PlayerObject::addAllParticles));

        m->registerHook(getBase()+0x22cdf0, extract_virtual(this, &$PlayerObject::setColor));

        m->registerHook(getBase()+0x218bf0, extract_virtual(this, &$PlayerObject::update));
    }
};


class $ObjectToolbox : public $CacBase {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ObjectToolbox* __thistype;

    virtual c_string intKeyToFrame(int  p0) {
        return reinterpret_cast<c_string(*)(decltype(this),int )>(m->getOriginal(getBase()+0x4173b0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x4173b0, extract_virtual(this, &$ObjectToolbox::intKeyToFrame));
    }
};


class $CCTextInputNode : public $CacBase {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCTextInputNode* __thistype;

    virtual void setAllowedChars(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x5d360))(this,p0);
    }

    virtual void setMaxLabelScale(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x5da30))(this,p0);
    }

    virtual void setMaxLabelWidth(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x5da50))(this,p0);
    }

    virtual void setLabelPlaceholderColor(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x5da90))(this,p0);
    }

    virtual std::string getString() {
        return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
    }

    virtual void setString(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x5d3e0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x5d360, extract_virtual(this, &$CCTextInputNode::setAllowedChars));

        m->registerHook(getBase()+0x5da30, extract_virtual(this, &$CCTextInputNode::setMaxLabelScale));

        m->registerHook(getBase()+0x5da50, extract_virtual(this, &$CCTextInputNode::setMaxLabelWidth));

        m->registerHook(getBase()+0x5da90, extract_virtual(this, &$CCTextInputNode::setLabelPlaceholderColor));

        m->registerHook(getBase()+0x5d6f0, extract_virtual(this, &$CCTextInputNode::getString));

        m->registerHook(getBase()+0x5d3e0, extract_virtual(this, &$CCTextInputNode::setString));
    }
};


class $EndPortalObject : public $CacBase {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EndPortalObject* __thistype;

    virtual void updateColors(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x1dacb0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1dacb0, extract_virtual(this, &$EndPortalObject::updateColors));
    }
};


class $GJBaseGameLayer : public $CacBase {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJBaseGameLayer* __thistype;

    virtual void pushButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9920))(this, p0, p1);
    }

    virtual void releaseButton(int p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(getBase()+0xb9a00))(this, p0, p1);
    }

    virtual void spawnGroup(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0xb7050))(this,p0);
    }

    virtual void addToSection(GameObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* )>(m->getOriginal(getBase()+0xb7b70))(this,p0);
    }

    virtual void processMoveActionsStep() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb7ea0))(this);
    }

    virtual void processMoveActions() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb86c0))(this);
    }

    virtual void collectItem(int p0, int p1) {
        return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(getBase()+0xb9e20))(this, p0, p1);
    }

    virtual void createMoveCommand(CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) {
        return reinterpret_cast<void(*)(decltype(this), CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(getBase()+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
    }

    virtual void triggerMoveCommand(EffectGameObject* p0) {
        return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(getBase()+0xb7290))(this, p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0xb9920, extract_virtual(this, &$GJBaseGameLayer::pushButton));

        m->registerHook(getBase()+0xb9a00, extract_virtual(this, &$GJBaseGameLayer::releaseButton));

        m->registerHook(getBase()+0xb7050, extract_virtual(this, &$GJBaseGameLayer::spawnGroup));

        m->registerHook(getBase()+0xb7b70, extract_virtual(this, &$GJBaseGameLayer::addToSection));

        m->registerHook(getBase()+0xb7ea0, extract_virtual(this, &$GJBaseGameLayer::processMoveActionsStep));

        m->registerHook(getBase()+0xb86c0, extract_virtual(this, &$GJBaseGameLayer::processMoveActions));

        m->registerHook(getBase()+0xb9e20, extract_virtual(this, &$GJBaseGameLayer::collectItem));

        m->registerHook(getBase()+0xb73a0, extract_virtual(this, &$GJBaseGameLayer::createMoveCommand));

        m->registerHook(getBase()+0xb7290, extract_virtual(this, &$GJBaseGameLayer::triggerMoveCommand));
    }
};


class $EditorPauseLayer : public $CacBase {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorPauseLayer* __thistype;

    virtual void saveLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x13ebd0, extract_virtual(this, &$EditorPauseLayer::saveLevel));
    }
};


class $GameSoundManager : public $CacBase {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GameSoundManager* __thistype;

    virtual void stopBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x362130, extract_virtual(this, &$GameSoundManager::stopBackgroundMusic));
    }
};


class $LevelEditorLayer : public $CacBase {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef LevelEditorLayer* __thistype;

    virtual void createObject(int  p0,CCPoint  p1,bool  p2) {
        return reinterpret_cast<void(*)(decltype(this),int ,CCPoint ,bool )>(m->getOriginal(getBase()+0x957c0))(this,p0,p1,p2);
    }

    virtual void handleAction(bool  p0,CCArray*  p1) {
        return reinterpret_cast<void(*)(decltype(this),bool ,CCArray* )>(m->getOriginal(getBase()+0x97020))(this,p0,p1);
    }

    virtual void removeObject(GameObject*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* ,bool )>(m->getOriginal(getBase()+0x96890))(this,p0,p1);
    }

    // virtual void redoLastAction() {
    //     return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
    // }

    // virtual void undoLastAction() {
    //     return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
    // }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
    }

    virtual int getNextFreeGroupID(CCArray*  p0) {
        return reinterpret_cast<int(*)(decltype(this),CCArray* )>(m->getOriginal(getBase()+0x9a1b0))(this,p0);
    }

    // virtual GameObject* addObjectFromString(std::string  p0) {
    //     return reinterpret_cast<GameObject*(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x94640))(this,p0);
    // }

    // virtual void createObjectsFromString(std::string  p0) {
    //     return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x94730))(this,p0);
    // }

    virtual void update(float  p0) {
        return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(getBase()+0xa1b70))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x957c0, extract_virtual(this, &$LevelEditorLayer::createObject));

        m->registerHook(getBase()+0x97020, extract_virtual(this, &$LevelEditorLayer::handleAction));

        m->registerHook(getBase()+0x96890, extract_virtual(this, &$LevelEditorLayer::removeObject));

        // m->registerHook(getBase()+0x97750, extract_virtual(this, &$LevelEditorLayer::redoLastAction));

        // m->registerHook(getBase()+0x97770, extract_virtual(this, &$LevelEditorLayer::undoLastAction));

        m->registerHook(getBase()+0x93d80, extract_virtual(this, &$LevelEditorLayer::removeAllObjects));

        m->registerHook(getBase()+0x9a1b0, extract_virtual(this, &$LevelEditorLayer::getNextFreeGroupID));

        // m->registerHook(getBase()+0x94640, extract_virtual(this, &$LevelEditorLayer::addObjectFromString));

        // m->registerHook(getBase()+0x94730, extract_virtual(this, &$LevelEditorLayer::createObjectsFromString));

        m->registerHook(getBase()+0xa1b70, extract_virtual(this, &$LevelEditorLayer::update));
    }
};


class $CCMenuItemToggler : public $CacBase {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemToggler* __thistype;

    virtual void setSizeMult(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x38a40))(this,p0);
    }

    virtual void toggle(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x38950))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x38a40, extract_virtual(this, &$CCMenuItemToggler::setSizeMult));

        m->registerHook(getBase()+0x38950, extract_virtual(this, &$CCMenuItemToggler::toggle));
    }
};


class $CCMenuItemSpriteExtra : public $CacBase {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMenuItemSpriteExtra* __thistype;

    virtual void setSizeMult(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x1255e0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1255e0, extract_virtual(this, &$CCMenuItemSpriteExtra::setSizeMult));
    }
};


class $MoreVideoOptionsLayer : public $CacBase {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MoreVideoOptionsLayer* __thistype;

    virtual bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x444150, extract_virtual(this, &$MoreVideoOptionsLayer::init));
    }
};


class $Slider : public $CacBase {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef Slider* __thistype;

    virtual void setBarVisibility(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x18e280))(this,p0);
    }

    virtual float getValue() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
    }

    virtual void setValue(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x18e170))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x18e280, extract_virtual(this, &$Slider::setBarVisibility));

        m->registerHook(getBase()+0x18e0c0, extract_virtual(this, &$Slider::getValue));

        m->registerHook(getBase()+0x18e170, extract_virtual(this, &$Slider::setValue));
    }
};


class $CCLabelBMFont : public $CacBase {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCLabelBMFont* __thistype;

    virtual void limitLabelWidth(float  p0,float  p1,float  p2) {
        return reinterpret_cast<void(*)(decltype(this),float ,float ,float )>(m->getOriginal(getBase()+0x34a6e0))(this,p0,p1,p2);
    }

    virtual void setScale(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x34a5d0))(this,p0);
    }

    virtual void setString(char const*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),char const* ,bool )>(m->getOriginal(getBase()+0x3489e0))(this,p0,p1);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x34a6e0, extract_virtual(this, &$CCLabelBMFont::limitLabelWidth));

        m->registerHook(getBase()+0x34a5d0, extract_virtual(this, &$CCLabelBMFont::setScale));

        m->registerHook(getBase()+0x3489e0, extract_virtual(this, &$CCLabelBMFont::setString));
    }
};


class $CCMouseDelegate : public $CacBase {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCMouseDelegate* __thistype;

    virtual void rightKeyUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61c0))(this);
    }

    virtual void scrollWheel(float  p0,float  p1) {
        return reinterpret_cast<void(*)(decltype(this),float ,float )>(m->getOriginal(getBase()+0x61d0))(this,p0,p1);
    }

    virtual void rightKeyDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61b0))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x61c0, extract_virtual(this, &$CCMouseDelegate::rightKeyUp));

        m->registerHook(getBase()+0x61d0, extract_virtual(this, &$CCMouseDelegate::scrollWheel));

        m->registerHook(getBase()+0x61b0, extract_virtual(this, &$CCMouseDelegate::rightKeyDown));
    }
};


class $CCNode : public $CacBase {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCNode* __thistype;

    virtual void _setZOrder(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x122990))(this,p0);
    }

    virtual float getVertexZ() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x1229e0))(this);
    }

    virtual void setVertexZ(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x1229f0))(this,p0);
    }

    virtual void setVisible(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x122d60))(this,p0);
    }

    virtual void unschedule(Cacao::CC_SEL  p0) {
        return reinterpret_cast<void(*)(decltype(this),Cacao::CC_SEL )>(m->getOriginal(getBase()+0x124180))(this,p0);
    }

    virtual CCArray* getChildren() {
        return reinterpret_cast<CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x122c80))(this);
    }

    virtual CCPoint getPosition() {
        return reinterpret_cast<CCPoint(*)(decltype(this))>(m->getOriginal(getBase()+0x122b60))(this);
    }

    virtual float getRotation() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a00))(this);
    }

    virtual void* getUserData() {
        return reinterpret_cast<void*(*)(decltype(this))>(m->getOriginal(getBase()+0x122f30))(this);
    }

    virtual void setPosition(float  p0,float  p1) {
        return reinterpret_cast<void(*)(decltype(this),float ,float )>(m->getOriginal(getBase()+0x122ba0))(this,p0,p1);
    }

    virtual void setRotation(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a10))(this,p0);
    }

    virtual void setUserData(void*  p0) {
        return reinterpret_cast<void(*)(decltype(this),void* )>(m->getOriginal(getBase()+0x122f40))(this,p0);
    }

    virtual float getPositionX() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122be0))(this);
    }

    virtual float getPositionY() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122bf0))(this);
    }

    virtual float getRotationX() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a50))(this);
    }

    virtual float getRotationY() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a80))(this);
    }

    virtual float getScheduler() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x123f70))(this);
    }

    virtual void setPositionX(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122c00))(this,p0);
    }

    virtual void setPositionY(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122c40))(this,p0);
    }

    virtual void setRotationX(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a60))(this,p0);
    }

    virtual void setRotationY(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a90))(this,p0);
    }

    virtual CCNode* getChildByTag(int  p0) {
        return reinterpret_cast<CCNode*(*)(decltype(this),int )>(m->getOriginal(getBase()+0x123220))(this,p0);
    }

    virtual CCObject* getUserObject() {
        return reinterpret_cast<CCObject*(*)(decltype(this))>(m->getOriginal(getBase()+0x122f80))(this);
    }

    virtual void setUserObject(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x122fb0))(this,p0);
    }

    virtual void setContentSize(CCSize  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCSize )>(m->getOriginal(getBase()+0x122e50))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x122990, extract_virtual(this, &$CCNode::_setZOrder));

        m->registerHook(getBase()+0x1229e0, extract_virtual(this, &$CCNode::getVertexZ));

        m->registerHook(getBase()+0x1229f0, extract_virtual(this, &$CCNode::setVertexZ));

        m->registerHook(getBase()+0x122d60, extract_virtual(this, &$CCNode::setVisible));

        m->registerHook(getBase()+0x124180, extract_virtual(this, &$CCNode::unschedule));

        m->registerHook(getBase()+0x122c80, extract_virtual(this, &$CCNode::getChildren));

        m->registerHook(getBase()+0x122b60, extract_virtual(this, &$CCNode::getPosition));

        m->registerHook(getBase()+0x122a00, extract_virtual(this, &$CCNode::getRotation));

        m->registerHook(getBase()+0x122f30, extract_virtual(this, &$CCNode::getUserData));

        m->registerHook(getBase()+0x122ba0, extract_virtual(this, &$CCNode::setPosition));

        m->registerHook(getBase()+0x122a10, extract_virtual(this, &$CCNode::setRotation));

        m->registerHook(getBase()+0x122f40, extract_virtual(this, &$CCNode::setUserData));

        m->registerHook(getBase()+0x122be0, extract_virtual(this, &$CCNode::getPositionX));

        m->registerHook(getBase()+0x122bf0, extract_virtual(this, &$CCNode::getPositionY));

        m->registerHook(getBase()+0x122a50, extract_virtual(this, &$CCNode::getRotationX));

        m->registerHook(getBase()+0x122a80, extract_virtual(this, &$CCNode::getRotationY));

        m->registerHook(getBase()+0x123f70, extract_virtual(this, &$CCNode::getScheduler));

        m->registerHook(getBase()+0x122c00, extract_virtual(this, &$CCNode::setPositionX));

        m->registerHook(getBase()+0x122c40, extract_virtual(this, &$CCNode::setPositionY));

        m->registerHook(getBase()+0x122a60, extract_virtual(this, &$CCNode::setRotationX));

        m->registerHook(getBase()+0x122a90, extract_virtual(this, &$CCNode::setRotationY));

        m->registerHook(getBase()+0x123220, extract_virtual(this, &$CCNode::getChildByTag));

        m->registerHook(getBase()+0x122f80, extract_virtual(this, &$CCNode::getUserObject));

        m->registerHook(getBase()+0x122fb0, extract_virtual(this, &$CCNode::setUserObject));

        m->registerHook(getBase()+0x122e50, extract_virtual(this, &$CCNode::setContentSize));
    }
};


class $EditorUI : public $CacBase {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EditorUI* __thistype;

    virtual void deselectAll() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
    }

    // virtual void onDuplicate(CCObject*  p0) {
    //     return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x18ba0))(this,p0);
    // }

    virtual void enableButton(CreateMenuItem*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CreateMenuItem* )>(m->getOriginal(getBase()+0x1bff0))(this,p0);
    }

    virtual CreateMenuItem* getCreateBtn(int  p0,int  p1) {
        return reinterpret_cast<CreateMenuItem*(*)(decltype(this),int ,int )>(m->getOriginal(getBase()+0x1f6c0))(this,p0,p1);
    }

    // virtual void pasteObjects(std::string  p0) {
    //     return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x232d0))(this,p0);
    // }

    virtual void disableButton(CreateMenuItem*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CreateMenuItem* )>(m->getOriginal(getBase()+0x1c0f0))(this,p0);
    }

    virtual void selectObjects(CCArray*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),CCArray* ,bool )>(m->getOriginal(getBase()+0x23940))(this,p0,p1);
    }

    virtual void updateButtons() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
    }

    virtual void redoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8e0))(this);
    }

    virtual void undoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb830))(this);
    }

    // virtual CCArray* getSelectedObjects() {
    //     return reinterpret_cast<CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
    // }

    virtual void scaleObjects(CCArray *p0, float p1, CCPoint p2) {
        return reinterpret_cast<void(*)(decltype(this), CCArray*, float, CCPoint)>(m->getOriginal(getBase()+0x252e0))(this, p0, p1, p2);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1f300, extract_virtual(this, &$EditorUI::deselectAll));

        // m->registerHook(getBase()+0x18ba0, extract_virtual(this, &$EditorUI::onDuplicate));

        m->registerHook(getBase()+0x1bff0, extract_virtual(this, &$EditorUI::enableButton));

        m->registerHook(getBase()+0x1f6c0, extract_virtual(this, &$EditorUI::getCreateBtn));

        // m->registerHook(getBase()+0x232d0, extract_virtual(this, &$EditorUI::pasteObjects));

        m->registerHook(getBase()+0x1c0f0, extract_virtual(this, &$EditorUI::disableButton));

        m->registerHook(getBase()+0x23940, extract_virtual(this, &$EditorUI::selectObjects));

        m->registerHook(getBase()+0x1a300, extract_virtual(this, &$EditorUI::updateButtons));

        m->registerHook(getBase()+0xb8e0, extract_virtual(this, &$EditorUI::redoLastAction));

        m->registerHook(getBase()+0xb830, extract_virtual(this, &$EditorUI::undoLastAction));

        // m->registerHook(getBase()+0x23f30, extract_virtual(this, &$EditorUI::getSelectedObjects));

        m->registerHook(getBase()+0x252e0, extract_virtual(this, &$EditorUI::scaleObjects));
    }
};


class $InfoLayer : public $CacBase {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef InfoLayer* __thistype;

    virtual void onRefreshComments(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x459b60))(this,p0);
    }

    virtual void loadPage(int  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),int ,bool )>(m->getOriginal(getBase()+0x458fb0))(this,p0,p1);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x459b60, extract_virtual(this, &$InfoLayer::onRefreshComments));

        m->registerHook(getBase()+0x458fb0, extract_virtual(this, &$InfoLayer::loadPage));
    }
};


class $MenuLayer : public $CacBase {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef MenuLayer* __thistype;

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3170))(this);
    }

    virtual void onQuit(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x1d2b40))(this,p0);
    }

    virtual void onMoreGames(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x1d2ad0))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1d3170, extract_virtual(this, &$MenuLayer::keyBackClicked));

        m->registerHook(getBase()+0x1d2b40, extract_virtual(this, &$MenuLayer::onQuit));

        m->registerHook(getBase()+0x1d2ad0, extract_virtual(this, &$MenuLayer::onMoreGames));
    }
};


class $CCKeyboardDispatcher : public $CacBase {
 public:
    $CCKeyboardDispatcher() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CCKeyboardDispatcher* __thistype;

    virtual void dispatchKeyboardMSG(int  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),int ,bool )>(m->getOriginal(getBase()+0xe8190))(this,p0,p1);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0xe8190, extract_virtual(this, &$CCKeyboardDispatcher::dispatchKeyboardMSG));
    }
};


class $PlayLayer : public $CacBase {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef PlayLayer* __thistype;

    virtual void resetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
    }

    virtual bool init(GJGameLevel*  p0) {
        return reinterpret_cast<bool(*)(decltype(this),GJGameLevel* )>(m->getOriginal(getBase()+0x6b5f0))(this,p0);
    }

    virtual void switchToScene(GJGameLevel*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GJGameLevel* )>(m->getOriginal(getBase()+0xe5d50))(this,p0);
    }

    virtual void update(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x77900))(this,p0);
    }

    virtual void updateVisibility() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x6fb90))(this);
    }

    virtual void addObject(GameObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* )>(m->getOriginal(getBase()+0x70e50))(this,p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x71c50, extract_virtual(this, &$PlayLayer::resetLevel));

        m->registerHook(getBase()+0x6b5f0, extract_virtual(this, &$PlayLayer::init));

        m->registerHook(getBase()+0xe5d50, extract_virtual(this, &$PlayLayer::switchToScene));

        m->registerHook(getBase()+0x77900, extract_virtual(this, &$PlayLayer::update));

        m->registerHook(getBase()+0x6fb90, extract_virtual(this, &$PlayLayer::updateVisibility));

        m->registerHook(getBase()+0x70e50, extract_virtual(this, &$PlayLayer::addObject));
    }
};


class $CreatorLayer : public $CacBase {
 public:
    $CreatorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef CreatorLayer* __thistype;

    virtual bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x141c10))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x141c10, extract_virtual(this, &$CreatorLayer::init));
    }
};


class $ColorSelectPopup : public $CacBase {
 public:
    $ColorSelectPopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef ColorSelectPopup* __thistype;

    virtual bool init(EffectGameObject *p0, CCArray *p1, ColorAction *p2) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, CCArray*, ColorAction*)>(m->getOriginal(getBase()+0x41ee70))(this, p0, p1, p2);
    }

    virtual void updateCopyColor() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423b70))(this);
    }

    virtual void colorValueChanged() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x423320))(this);
    }

    virtual void dtor() { //idk
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x41e960))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x41ee70, extract_virtual(this, &$ColorSelectPopup::init));
        m->registerHook(getBase()+0x423b70, extract_virtual(this, &$ColorSelectPopup::updateCopyColor));
        m->registerHook(getBase()+0x423320, extract_virtual(this, &$ColorSelectPopup::colorValueChanged));
        m->registerHook(getBase()+0x41e960, extract_virtual(this, &$ColorSelectPopup::dtor));
    }
};

class $SetupPulsePopup : public $CacBase {
 public:
    $SetupPulsePopup() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef SetupPulsePopup* __thistype;

    virtual bool init(EffectGameObject *p0, CCArray *p1) {
        return reinterpret_cast<bool(*)(decltype(this), EffectGameObject*, CCArray*)>(m->getOriginal(getBase()+0x1e7010))(this, p0, p1);
    }

    virtual void onSelectPulseMode(CCObject *p0) {
        return reinterpret_cast<void(*)(decltype(this), CCObject*)>(m->getOriginal(getBase()+0x1eb020))(this, p0);
    }

    virtual void colorValueChanged() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1ec680))(this);
    }

    virtual void dtor() { //idk
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1e6b40))(this);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x1e7010, extract_virtual(this, &$SetupPulsePopup::init));
        m->registerHook(getBase()+0x1eb020, extract_virtual(this, &$SetupPulsePopup::onSelectPulseMode));
        m->registerHook(getBase()+0x1ec680, extract_virtual(this, &$SetupPulsePopup::colorValueChanged));
        m->registerHook(getBase()+0x1e6b40, extract_virtual(this, &$SetupPulsePopup::dtor));
    }
};

class $GJEffectManager : public $CacBase {
 public:
    $GJEffectManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef GJEffectManager* __thistype;

    virtual void countChangedForItem(int p0) {
        return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(getBase()+0x185a40))(this, p0);
    }

    virtual bool isGroupEnabled(int p0) {
        return reinterpret_cast<bool(*)(decltype(this), int)>(m->getOriginal(getBase()+0x1853d0))(this, p0);
    }

    virtual bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x180230))(this);
    }

    virtual void playerButton(bool p0, bool p1) {
        return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(getBase()+0x1855a0))(this, p0, p1);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0x185a40, extract_virtual(this, &$GJEffectManager::countChangedForItem));

        m->registerHook(getBase()+0x1853d0, extract_virtual(this, &$GJEffectManager::isGroupEnabled));

        m->registerHook(getBase()+0x180230, extract_virtual(this, &$GJEffectManager::init));

        m->registerHook(getBase()+0x1855a0, extract_virtual(this, &$GJEffectManager::playerButton));
    }
};

class $EffectGameObject : public $CacBase {
 public:
    $EffectGameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        __cackit::glob.push_back(this);
    }
    typedef EffectGameObject* __thistype;

    virtual void triggerObject(GJBaseGameLayer* p0) {
        return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(getBase()+0xc9870))(this, p0);
    }

    void apply_hooks() override {
        m->registerHook(getBase()+0xc9870, extract_virtual(this, &$EffectGameObject::triggerObject));
    }
};

