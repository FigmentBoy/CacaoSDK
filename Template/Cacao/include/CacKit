//Copyright camila314 & alk1m123 2021. Autogenerated using a python script
#pragma once // but if u want it to be more crossplatform. u need to use c standard.

#ifdef __APPLE__
#include <platform/macos/CacKitUtil.hpp>
#endif

#include <Cacao.hpp>


template<class D>
class $ArtistCell : public ArtistCell, public $CacBase {
public:
    dupable ~$ArtistCell() override {}

    dupable bool init() override {
        if ((bool($ArtistCell::*)()){&$ArtistCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c7c0))(this);
        else return ArtistCell::init();
    }

    dupable void draw() override {
        if ((void($ArtistCell::*)()){&$ArtistCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c980))(this);
        else return ArtistCell::draw();
    }

    dupable $ArtistCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ArtistCell::*)()){&$ArtistCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c7c0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ArtistCell::*)()){&$ArtistCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c980, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ButtonSprite : public ButtonSprite, public $CacBase {
public:
    dupable ~$ButtonSprite() override {}

    dupable static ButtonSprite* create(char const* p0) {
        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*)>(m->getOriginal(base+0x4fa10))(p0);
        else return ButtonSprite::create(p0);
    }

    dupable static ButtonSprite* create(char const* p0, int p1, int p2, float p3, bool p4) {
        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*, int, int, float, bool)>(m->getOriginal(base+0x4fa40))(p0, p1, p2, p3, p4);
        else return ButtonSprite::create(p0, p1, p2, p3, p4);
    }

    dupable void updateBGImage(char const* p0) {
        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x502d0))(this, p0);
        else return ButtonSprite::updateBGImage(p0);
    }

    dupable static ButtonSprite* create(char const* p0, float p1) {
        if ((ButtonSprite*(*)(char const*, float)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, float)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(char const*, float)>(m->getOriginal(base+0x4fa60))(p0, p1);
        else return ButtonSprite::create(p0, p1);
    }

    dupable static ButtonSprite* create(cocos2d::CCSprite* p0, int p1, int p2, float p3, float p4, bool p5, char const* p6, bool p7) {
        if ((ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create})
            return reinterpret_cast<ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)>(m->getOriginal(base+0x4fa90))(p0, p1, p2, p3, p4, p5, p6, p7);
        else return ButtonSprite::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable $ButtonSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((ButtonSprite*(*)(char const*)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*)){&D::create})
            m->registerHook(base+0x4fa10, (ButtonSprite*(*)(char const*)){&D::create});

        if ((ButtonSprite*(*)(char const*, int, int, float, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create})
            m->registerHook(base+0x4fa40, (ButtonSprite*(*)(char const*, int, int, float, bool)){&D::create});

        if ((void($ButtonSprite::*)(char const*)){&$ButtonSprite::updateBGImage} != (void(D::*)(char const*)){&D::updateBGImage})
            m->registerHook(base+0x502d0, extract((void(D::*)(char const*)){&D::updateBGImage}));

        if ((ButtonSprite*(*)(char const*, float)){&$ButtonSprite::create} != (ButtonSprite*(*)(char const*, float)){&D::create})
            m->registerHook(base+0x4fa60, (ButtonSprite*(*)(char const*, float)){&D::create});

        if ((ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&$ButtonSprite::create} != (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create})
            m->registerHook(base+0x4fa90, (ButtonSprite*(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool)){&D::create});
    }
};


template<class D>
class $GJItemIcon : public GJItemIcon, public $CacBase {
public:
    dupable ~$GJItemIcon() override {}

    dupable void setOpacity(unsigned char p0) override {
        if ((void($GJItemIcon::*)(unsigned char)){&$GJItemIcon::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1bd9d0))(this, p0);
        else return GJItemIcon::setOpacity(p0);
    }

    dupable $GJItemIcon() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJItemIcon::*)(unsigned char)){&$GJItemIcon::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1bd9d0, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $GJUserCell : public GJUserCell, public $CacBase {
public:
    dupable ~$GJUserCell() override {}

    dupable bool init() override {
        if ((bool($GJUserCell::*)()){&$GJUserCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11e180))(this);
        else return GJUserCell::init();
    }

    dupable void draw() override {
        if ((void($GJUserCell::*)()){&$GJUserCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11e790))(this);
        else return GJUserCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJUserCell::*)(FLAlertLayer*, bool)){&$GJUserCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11e860))(this, p0, p1);
        else return GJUserCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11eae0))(this, p0, p1);
        else return GJUserCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11ecb0))(this, p0, p1);
        else return GJUserCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($GJUserCell::*)(UploadActionPopup*)){&$GJUserCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x11edb0))(this, p0);
        else return GJUserCell::onClosePopup(p0);
    }

    dupable $GJUserCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserCell::*)()){&$GJUserCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11e180, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJUserCell::*)()){&$GJUserCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11e790, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($GJUserCell::*)(FLAlertLayer*, bool)){&$GJUserCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11e860, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x11eae0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJUserCell::*)(int, int)){&$GJUserCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x11ecb0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJUserCell::*)(UploadActionPopup*)){&$GJUserCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x11edb0, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $CCSpritePlus : public CCSpritePlus, public $CacBase {
public:
    dupable ~$CCSpritePlus() override {}

    dupable void setScaleX(float p0) override {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248950))(this, p0);
        else return CCSpritePlus::setScaleX(p0);
    }

    dupable void setScaleY(float p0) override {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2489d0))(this, p0);
        else return CCSpritePlus::setScaleY(p0);
    }

    dupable void setScale(float p0) override {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248a50))(this, p0);
        else return CCSpritePlus::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($CCSpritePlus::*)(cocos2d::CCPoint const&)){&$CCSpritePlus::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x2486b0))(this, p0);
        else return CCSpritePlus::setPosition(p0);
    }

    dupable void setRotation(float p0) override {
        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248730))(this, p0);
        else return CCSpritePlus::setRotation(p0);
    }

    dupable bool initWithTexture(cocos2d::CCTexture2D* p0) override {
        if ((bool($CCSpritePlus::*)(cocos2d::CCTexture2D*)){&$CCSpritePlus::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x248690))(this, p0);
        else return CCSpritePlus::initWithTexture(p0);
    }

    dupable bool initWithSpriteFrameName(char const* p0) override {
        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(base+0x248670))(this, p0);
        else return CCSpritePlus::initWithSpriteFrameName(p0);
    }

    dupable void setFlipX(bool p0) override {
        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2487b0))(this, p0);
        else return CCSpritePlus::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) override {
        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x248880))(this, p0);
        else return CCSpritePlus::setFlipY(p0);
    }

    dupable $CCSpritePlus() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x248950, extract_virtual(V, (void(D::*)(float)){&D::setScaleX}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x2489d0, extract_virtual(V, (void(D::*)(float)){&D::setScaleY}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x248a50, extract_virtual(V, (void(D::*)(float)){&D::setScale}));

        if ((void($CCSpritePlus::*)(cocos2d::CCPoint const&)){&$CCSpritePlus::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x2486b0, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCSpritePlus::*)(float)){&$CCSpritePlus::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x248730, extract_virtual(V, (void(D::*)(float)){&D::setRotation}));

        if ((bool($CCSpritePlus::*)(cocos2d::CCTexture2D*)){&$CCSpritePlus::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x248690, extract_virtual(V, (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((bool($CCSpritePlus::*)(char const*)){&$CCSpritePlus::initWithSpriteFrameName} != (bool(D::*)(char const*)){&D::initWithSpriteFrameName})
            m->registerHook(base+0x248670, extract_virtual(V, (bool(D::*)(char const*)){&D::initWithSpriteFrameName}));

        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x2487b0, extract_virtual(V, (void(D::*)(bool)){&D::setFlipX}));

        if ((void($CCSpritePlus::*)(bool)){&$CCSpritePlus::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x248880, extract_virtual(V, (void(D::*)(bool)){&D::setFlipY}));
    }
};


template<class D>
class $OBB2D : public OBB2D, public $CacBase {
public:
    dupable ~$OBB2D() override {}

    dupable void calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(base+0x35a9c0))(this, p0, p1, p2, p3);
        else return OBB2D::calculateWithCenter(p0, p1, p2, p3);
    }

    dupable static OBB2D* create(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create})
            return reinterpret_cast<OBB2D*(*)(cocos2d::CCPoint, float, float, float)>(m->getOriginal(base+0x35a890))(p0, p1, p2, p3);
        else return OBB2D::create(p0, p1, p2, p3);
    }

    dupable void getBoundingRect() {
        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35b2b0))(this);
        else return OBB2D::getBoundingRect();
    }

    dupable void overlaps(OBB2D* p0) {
        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps} != (void(D::*)(OBB2D*)){&D::overlaps})
            return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(base+0x35b0a0))(this, p0);
        else return OBB2D::overlaps(p0);
    }

    dupable void overlaps1Way(OBB2D* p0) {
        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D*)){&D::overlaps1Way})
            return reinterpret_cast<void(*)(decltype(this), OBB2D*)>(m->getOriginal(base+0x35b0d0))(this, p0);
        else return OBB2D::overlaps1Way(p0);
    }

    dupable $OBB2D() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($OBB2D::*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::calculateWithCenter} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter})
            m->registerHook(base+0x35a9c0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::calculateWithCenter}));

        if ((OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&$OBB2D::create} != (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create})
            m->registerHook(base+0x35a890, (OBB2D*(*)(cocos2d::CCPoint, float, float, float)){&D::create});

        if ((void($OBB2D::*)()){&$OBB2D::getBoundingRect} != (void(D::*)()){&D::getBoundingRect})
            m->registerHook(base+0x35b2b0, extract((void(D::*)()){&D::getBoundingRect}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps} != (void(D::*)(OBB2D*)){&D::overlaps})
            m->registerHook(base+0x35b0a0, extract((void(D::*)(OBB2D*)){&D::overlaps}));

        if ((void($OBB2D::*)(OBB2D*)){&$OBB2D::overlaps1Way} != (void(D::*)(OBB2D*)){&D::overlaps1Way})
            m->registerHook(base+0x35b0d0, extract((void(D::*)(OBB2D*)){&D::overlaps1Way}));
    }
};


template<class D>
class $GameObject : public GameObject, public $CacBase {
public:
    dupable ~$GameObject() override {}

    dupable void update(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2fbb90))(this, p0);
        else return GameObject::update(p0);
    }

    dupable void setScaleX(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335b00))(this, p0);
        else return GameObject::setScaleX(p0);
    }

    dupable void setScaleY(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335b90))(this, p0);
        else return GameObject::setScaleY(p0);
    }

    dupable void setScale(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335c20))(this, p0);
        else return GameObject::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x335850))(this, p0);
        else return GameObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x336280))(this, p0);
        else return GameObject::setVisible(p0);
    }

    dupable void setRotation(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335970))(this, p0);
        else return GameObject::setRotation(p0);
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($GameObject::*)(unsigned char)){&$GameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x335f10))(this, p0);
        else return GameObject::setOpacity(p0);
    }

    dupable bool initWithTexture(cocos2d::CCTexture2D* p0) override {
        if ((bool($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x2f56a0))(this, p0);
        else return GameObject::initWithTexture(p0);
    }

    dupable void setChildColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341f20))(this, p0);
        else return GameObject::setChildColor(p0);
    }

    dupable void setFlipX(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x335a60))(this, p0);
        else return GameObject::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x335ab0))(this, p0);
        else return GameObject::setFlipY(p0);
    }

    dupable void customSetup() override {
        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fbba0))(this);
        else return GameObject::customSetup();
    }

    dupable void setupCustomSprites() override {
        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x307f60))(this);
        else return GameObject::setupCustomSprites();
    }

    dupable void addMainSpriteToParent(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x33a5b0))(this, p0);
        else return GameObject::addMainSpriteToParent(p0);
    }

    dupable void resetObject() override {
        if ((void($GameObject::*)()){&$GameObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fa620))(this);
        else return GameObject::resetObject();
    }

    dupable void triggerObject(GJBaseGameLayer* p0) override {
        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0x2fa8f0))(this, p0);
        else return GameObject::triggerObject(p0);
    }

    dupable void activateObject() override {
        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2faf60))(this);
        else return GameObject::activateObject();
    }

    dupable void deactivateObject(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2fb8f0))(this, p0);
        else return GameObject::deactivateObject(p0);
    }

    dupable void getObjectRect() override {
        if ((void($GameObject::*)()){&$GameObject::getObjectRect} != (void(D::*)()){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3352b0))(this);
        else return GameObject::getObjectRect();
    }

    dupable void getObjectRect(float p0, float p1) override {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x3352d0))(this, p0, p1);
        else return GameObject::getObjectRect(p0, p1);
    }

    dupable void getObjectRect2(float p0, float p1) override {
        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x3354e0))(this, p0, p1);
        else return GameObject::getObjectRect2(p0, p1);
    }

    dupable void getObjectTextureRect() override {
        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3355b0))(this);
        else return GameObject::getObjectTextureRect();
    }

    dupable void getRealPosition() override {
        if ((void($GameObject::*)()){&$GameObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335750))(this);
        else return GameObject::getRealPosition();
    }

    dupable void setStartPos(cocos2d::CCPoint p0) override {
        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x2fa520))(this, p0);
        else return GameObject::setStartPos(p0);
    }

    dupable void updateStartValues() override {
        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2fa800))(this);
        else return GameObject::updateStartValues();
    }

    dupable void getSaveString() override {
        if ((void($GameObject::*)()){&$GameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x33d3d0))(this);
        else return GameObject::getSaveString();
    }

    dupable void isFlipX() override {
        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335a40))(this);
        else return GameObject::isFlipX();
    }

    dupable void isFlipY() override {
        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335a50))(this);
        else return GameObject::isFlipY();
    }

    dupable void setRScaleX(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335cb0))(this, p0);
        else return GameObject::setRScaleX(p0);
    }

    dupable void setRScaleY(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335d60))(this, p0);
        else return GameObject::setRScaleY(p0);
    }

    dupable void setRScale(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x335e10))(this, p0);
        else return GameObject::setRScale(p0);
    }

    dupable void getRScaleX() override {
        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335e50))(this);
        else return GameObject::getRScaleX();
    }

    dupable void getRScaleY() override {
        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x335e80))(this);
        else return GameObject::getRScaleY();
    }

    dupable void calculateSpawnXPos() override {
        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x336970))(this);
        else return GameObject::calculateSpawnXPos();
    }

    dupable void triggerActivated(float p0) override {
        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x336990))(this, p0);
        else return GameObject::triggerActivated(p0);
    }

    dupable void powerOnObject() override {
        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3369a0))(this);
        else return GameObject::powerOnObject();
    }

    dupable void powerOffObject() override {
        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3369c0))(this);
        else return GameObject::powerOffObject();
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341c90))(this, p0);
        else return GameObject::setObjectColor(p0);
    }

    dupable void setGlowColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x341ed0))(this, p0);
        else return GameObject::setGlowColor(p0);
    }

    dupable void getOrientedBox() override {
        if ((void($GameObject::*)()){&$GameObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x342ad0))(this);
        else return GameObject::getOrientedBox();
    }

    dupable void addToGroup(int p0) override {
        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x33ad00))(this, p0);
        else return GameObject::addToGroup(p0);
    }

    dupable void removeFromGroup(int p0) override {
        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x33ada0))(this, p0);
        else return GameObject::removeFromGroup(p0);
    }

    dupable void spawnXPosition() override {
        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1b0))(this);
        else return GameObject::spawnXPosition();
    }

    dupable void getObjectRectDirty() override {
        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1d0))(this);
        else return GameObject::getObjectRectDirty();
    }

    dupable void setObjectRectDirty(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdc1e0))(this, p0);
        else return GameObject::setObjectRectDirty(p0);
    }

    dupable void getOrientedRectDirty() override {
        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc1f0))(this);
        else return GameObject::getOrientedRectDirty();
    }

    dupable void setOrientedRectDirty(bool p0) override {
        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdc200))(this, p0);
        else return GameObject::setOrientedRectDirty(p0);
    }

    dupable void getType() override {
        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc210))(this);
        else return GameObject::getType();
    }

    dupable void setType(GameObjectType p0) override {
        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            return reinterpret_cast<void(*)(decltype(this), GameObjectType)>(m->getOriginal(base+0xdc220))(this, p0);
        else return GameObject::setType(p0);
    }

    dupable void getStartPos() override {
        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdc230))(this);
        else return GameObject::getStartPos();
    }

    dupable int getGroupID(int p0) {
        if ((int($GameObject::*)(int)){&$GameObject::getGroupID} != (int(D::*)(int)){&D::getGroupID})
            return reinterpret_cast<int(*)(decltype(this), int)>(m->getOriginal(base+0x33ae10))(this, p0);
        else return GameObject::getGroupID(p0);
    }

    dupable $GameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GameObject::*)(float)){&$GameObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x2fbb90, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((void($GameObject::*)(float)){&$GameObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x335b00, extract_virtual(V, (void(D::*)(float)){&D::setScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x335b90, extract_virtual(V, (void(D::*)(float)){&D::setScaleY}));

        if ((void($GameObject::*)(float)){&$GameObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x335c20, extract_virtual(V, (void(D::*)(float)){&D::setScale}));

        if ((void($GameObject::*)(cocos2d::CCPoint const&)){&$GameObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x335850, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($GameObject::*)(bool)){&$GameObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x336280, extract_virtual(V, (void(D::*)(bool)){&D::setVisible}));

        if ((void($GameObject::*)(float)){&$GameObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x335970, extract_virtual(V, (void(D::*)(float)){&D::setRotation}));

        if ((void($GameObject::*)(unsigned char)){&$GameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x335f10, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((bool($GameObject::*)(cocos2d::CCTexture2D*)){&$GameObject::initWithTexture} != (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x2f56a0, extract_virtual(V, (bool(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setChildColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor})
            m->registerHook(base+0x341f20, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setChildColor}));

        if ((void($GameObject::*)(bool)){&$GameObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x335a60, extract_virtual(V, (void(D::*)(bool)){&D::setFlipX}));

        if ((void($GameObject::*)(bool)){&$GameObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x335ab0, extract_virtual(V, (void(D::*)(bool)){&D::setFlipY}));

        if ((void($GameObject::*)()){&$GameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x2fbba0, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($GameObject::*)()){&$GameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(base+0x307f60, extract_virtual(V, (void(D::*)()){&D::setupCustomSprites}));

        if ((void($GameObject::*)(bool)){&$GameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(base+0x33a5b0, extract_virtual(V, (void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($GameObject::*)()){&$GameObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0x2fa620, extract_virtual(V, (void(D::*)()){&D::resetObject}));

        if ((void($GameObject::*)(GJBaseGameLayer*)){&$GameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0x2fa8f0, extract_virtual(V, (void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($GameObject::*)()){&$GameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(base+0x2faf60, extract_virtual(V, (void(D::*)()){&D::activateObject}));

        if ((void($GameObject::*)(bool)){&$GameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(base+0x2fb8f0, extract_virtual(V, (void(D::*)(bool)){&D::deactivateObject}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRect} != (void(D::*)()){&D::getObjectRect})
            m->registerHook(base+0x3352b0, extract_virtual(V, (void(D::*)()){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect} != (void(D::*)(float, float)){&D::getObjectRect})
            m->registerHook(base+0x3352d0, extract_virtual(V, (void(D::*)(float, float)){&D::getObjectRect}));

        if ((void($GameObject::*)(float, float)){&$GameObject::getObjectRect2} != (void(D::*)(float, float)){&D::getObjectRect2})
            m->registerHook(base+0x3354e0, extract_virtual(V, (void(D::*)(float, float)){&D::getObjectRect2}));

        if ((void($GameObject::*)()){&$GameObject::getObjectTextureRect} != (void(D::*)()){&D::getObjectTextureRect})
            m->registerHook(base+0x3355b0, extract_virtual(V, (void(D::*)()){&D::getObjectTextureRect}));

        if ((void($GameObject::*)()){&$GameObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(base+0x335750, extract_virtual(V, (void(D::*)()){&D::getRealPosition}));

        if ((void($GameObject::*)(cocos2d::CCPoint)){&$GameObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(base+0x2fa520, extract_virtual(V, (void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($GameObject::*)()){&$GameObject::updateStartValues} != (void(D::*)()){&D::updateStartValues})
            m->registerHook(base+0x2fa800, extract_virtual(V, (void(D::*)()){&D::updateStartValues}));

        if ((void($GameObject::*)()){&$GameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0x33d3d0, extract_virtual(V, (void(D::*)()){&D::getSaveString}));

        if ((void($GameObject::*)()){&$GameObject::isFlipX} != (void(D::*)()){&D::isFlipX})
            m->registerHook(base+0x335a40, extract_virtual(V, (void(D::*)()){&D::isFlipX}));

        if ((void($GameObject::*)()){&$GameObject::isFlipY} != (void(D::*)()){&D::isFlipY})
            m->registerHook(base+0x335a50, extract_virtual(V, (void(D::*)()){&D::isFlipY}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleX} != (void(D::*)(float)){&D::setRScaleX})
            m->registerHook(base+0x335cb0, extract_virtual(V, (void(D::*)(float)){&D::setRScaleX}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScaleY} != (void(D::*)(float)){&D::setRScaleY})
            m->registerHook(base+0x335d60, extract_virtual(V, (void(D::*)(float)){&D::setRScaleY}));

        if ((void($GameObject::*)(float)){&$GameObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(base+0x335e10, extract_virtual(V, (void(D::*)(float)){&D::setRScale}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleX} != (void(D::*)()){&D::getRScaleX})
            m->registerHook(base+0x335e50, extract_virtual(V, (void(D::*)()){&D::getRScaleX}));

        if ((void($GameObject::*)()){&$GameObject::getRScaleY} != (void(D::*)()){&D::getRScaleY})
            m->registerHook(base+0x335e80, extract_virtual(V, (void(D::*)()){&D::getRScaleY}));

        if ((void($GameObject::*)()){&$GameObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(base+0x336970, extract_virtual(V, (void(D::*)()){&D::calculateSpawnXPos}));

        if ((void($GameObject::*)(float)){&$GameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0x336990, extract_virtual(V, (void(D::*)(float)){&D::triggerActivated}));

        if ((void($GameObject::*)()){&$GameObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(base+0x3369a0, extract_virtual(V, (void(D::*)()){&D::powerOnObject}));

        if ((void($GameObject::*)()){&$GameObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(base+0x3369c0, extract_virtual(V, (void(D::*)()){&D::powerOffObject}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0x341c90, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($GameObject::*)(cocos2d::_ccColor3B const&)){&$GameObject::setGlowColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor})
            m->registerHook(base+0x341ed0, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setGlowColor}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(base+0x342ad0, extract_virtual(V, (void(D::*)()){&D::getOrientedBox}));

        if ((void($GameObject::*)(int)){&$GameObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(base+0x33ad00, extract_virtual(V, (void(D::*)(int)){&D::addToGroup}));

        if ((void($GameObject::*)(int)){&$GameObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(base+0x33ada0, extract_virtual(V, (void(D::*)(int)){&D::removeFromGroup}));

        if ((void($GameObject::*)()){&$GameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(base+0xdc1b0, extract_virtual(V, (void(D::*)()){&D::spawnXPosition}));

        if ((void($GameObject::*)()){&$GameObject::getObjectRectDirty} != (void(D::*)()){&D::getObjectRectDirty})
            m->registerHook(base+0xdc1d0, extract_virtual(V, (void(D::*)()){&D::getObjectRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setObjectRectDirty} != (void(D::*)(bool)){&D::setObjectRectDirty})
            m->registerHook(base+0xdc1e0, extract_virtual(V, (void(D::*)(bool)){&D::setObjectRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getOrientedRectDirty} != (void(D::*)()){&D::getOrientedRectDirty})
            m->registerHook(base+0xdc1f0, extract_virtual(V, (void(D::*)()){&D::getOrientedRectDirty}));

        if ((void($GameObject::*)(bool)){&$GameObject::setOrientedRectDirty} != (void(D::*)(bool)){&D::setOrientedRectDirty})
            m->registerHook(base+0xdc200, extract_virtual(V, (void(D::*)(bool)){&D::setOrientedRectDirty}));

        if ((void($GameObject::*)()){&$GameObject::getType} != (void(D::*)()){&D::getType})
            m->registerHook(base+0xdc210, extract_virtual(V, (void(D::*)()){&D::getType}));

        if ((void($GameObject::*)(GameObjectType)){&$GameObject::setType} != (void(D::*)(GameObjectType)){&D::setType})
            m->registerHook(base+0xdc220, extract_virtual(V, (void(D::*)(GameObjectType)){&D::setType}));

        if ((void($GameObject::*)()){&$GameObject::getStartPos} != (void(D::*)()){&D::getStartPos})
            m->registerHook(base+0xdc230, extract_virtual(V, (void(D::*)()){&D::getStartPos}));

        if ((int($GameObject::*)(int)){&$GameObject::getGroupID} != (int(D::*)(int)){&D::getGroupID})
            m->registerHook(base+0x33ae10, extract((int(D::*)(int)){&D::getGroupID}));
    }
};


template<class D>
class $GaragePage : public GaragePage, public $CacBase {
public:
    dupable ~$GaragePage() override {}

    dupable void listButtonBarSwitchedPage(ListButtonBar* p0, int p1) override {
        if ((void($GaragePage::*)(ListButtonBar*, int)){&$GaragePage::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            return reinterpret_cast<void(*)(decltype(this), ListButtonBar*, int)>(m->getOriginal(base+0x1bc2f0))(this, p0, p1);
        else return GaragePage::listButtonBarSwitchedPage(p0, p1);
    }

    dupable $GaragePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GaragePage::*)(ListButtonBar*, int)){&$GaragePage::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            m->registerHook(base+0x1bc2f0, extract_virtual(V, (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage}));
    }
};


template<class D>
class $HardStreak : public HardStreak, public $CacBase {
public:
    dupable ~$HardStreak() override {}

    dupable bool init() override {
        if ((bool($HardStreak::*)()){&$HardStreak::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x5c090))(this);
        else return HardStreak::init();
    }

    dupable $HardStreak() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($HardStreak::*)()){&$HardStreak::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x5c090, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $PauseLayer : public PauseLayer, public $CacBase {
public:
    dupable ~$PauseLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($PauseLayer::*)()){&$PauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20cd80))(this);
        else return PauseLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x20cc80))(this, p0);
        else return PauseLayer::keyDown(p0);
    }

    dupable void customSetup() override {
        if ((void($PauseLayer::*)()){&$PauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20b300))(this);
        else return PauseLayer::customSetup();
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) override {
        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x20cd60))(this, p0);
        else return PauseLayer::keyUp(p0);
    }

    dupable $PauseLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PauseLayer::*)()){&$PauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20cd80, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x20cc80, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($PauseLayer::*)()){&$PauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x20b300, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($PauseLayer::*)(cocos2d::enumKeyCodes)){&$PauseLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x20cd60, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $RingObject : public RingObject, public $CacBase {
public:
    dupable ~$RingObject() override {}

    dupable void setScale(float p0) override {
        if ((void($RingObject::*)(float)){&$RingObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6fb0))(this, p0);
        else return RingObject::setScale(p0);
    }

    dupable void setRotation(float p0) override {
        if ((void($RingObject::*)(float)){&$RingObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc7010))(this, p0);
        else return RingObject::setRotation(p0);
    }

    dupable void resetObject() override {
        if ((void($RingObject::*)()){&$RingObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6f90))(this);
        else return RingObject::resetObject();
    }

    dupable void getSaveString() override {
        if ((void($RingObject::*)()){&$RingObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc73a0))(this);
        else return RingObject::getSaveString();
    }

    dupable void setRScale(float p0) override {
        if ((void($RingObject::*)(float)){&$RingObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6fe0))(this, p0);
        else return RingObject::setRScale(p0);
    }

    dupable void triggerActivated(float p0) override {
        if ((void($RingObject::*)(float)){&$RingObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xc6e10))(this, p0);
        else return RingObject::triggerActivated(p0);
    }

    dupable void powerOnObject() override {
        if ((void($RingObject::*)()){&$RingObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6e20))(this);
        else return RingObject::powerOnObject();
    }

    dupable void powerOffObject() override {
        if ((void($RingObject::*)()){&$RingObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc6f70))(this);
        else return RingObject::powerOffObject();
    }

    dupable $RingObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RingObject::*)(float)){&$RingObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0xc6fb0, extract_virtual(V, (void(D::*)(float)){&D::setScale}));

        if ((void($RingObject::*)(float)){&$RingObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0xc7010, extract_virtual(V, (void(D::*)(float)){&D::setRotation}));

        if ((void($RingObject::*)()){&$RingObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0xc6f90, extract_virtual(V, (void(D::*)()){&D::resetObject}));

        if ((void($RingObject::*)()){&$RingObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xc73a0, extract_virtual(V, (void(D::*)()){&D::getSaveString}));

        if ((void($RingObject::*)(float)){&$RingObject::setRScale} != (void(D::*)(float)){&D::setRScale})
            m->registerHook(base+0xc6fe0, extract_virtual(V, (void(D::*)(float)){&D::setRScale}));

        if ((void($RingObject::*)(float)){&$RingObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0xc6e10, extract_virtual(V, (void(D::*)(float)){&D::triggerActivated}));

        if ((void($RingObject::*)()){&$RingObject::powerOnObject} != (void(D::*)()){&D::powerOnObject})
            m->registerHook(base+0xc6e20, extract_virtual(V, (void(D::*)()){&D::powerOnObject}));

        if ((void($RingObject::*)()){&$RingObject::powerOffObject} != (void(D::*)()){&D::powerOffObject})
            m->registerHook(base+0xc6f70, extract_virtual(V, (void(D::*)()){&D::powerOffObject}));
    }
};


template<class D>
class $SetIDLayer : public SetIDLayer, public $CacBase {
public:
    dupable ~$SetIDLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SetIDLayer::*)()){&$SetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169670))(this);
        else return SetIDLayer::keyBackClicked();
    }

    dupable $SetIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetIDLayer::*)()){&$SetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x169670, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetIDPopup : public SetIDPopup, public $CacBase {
public:
    dupable ~$SetIDPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x155310))(this);
        else return SetIDPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1552c0))(this);
        else return SetIDPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x155140))(this, p0);
        else return SetIDPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x155180))(this, p0);
        else return SetIDPopup::textChanged(p0);
    }

    dupable void valueChanged() override {
        if ((void($SetIDPopup::*)()){&$SetIDPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1552b0))(this);
        else return SetIDPopup::valueChanged();
    }

    dupable $SetIDPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetIDPopup::*)()){&$SetIDPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x155310, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetIDPopup::*)()){&$SetIDPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1552c0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x155140, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetIDPopup::*)(CCTextInputNode*)){&$SetIDPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x155180, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetIDPopup::*)()){&$SetIDPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            m->registerHook(base+0x1552b0, extract_virtual(V, (void(D::*)()){&D::valueChanged}));
    }
};


template<class D>
class $ShardsPage : public ShardsPage, public $CacBase {
public:
    dupable ~$ShardsPage() override {}

    dupable bool init() override {
        if ((bool($ShardsPage::*)()){&$ShardsPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x27d610))(this);
        else return ShardsPage::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($ShardsPage::*)()){&$ShardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fc40))(this);
        else return ShardsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($ShardsPage::*)()){&$ShardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fbd0))(this);
        else return ShardsPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($ShardsPage::*)()){&$ShardsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x27fa30))(this);
        else return ShardsPage::show();
    }

    dupable $ShardsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ShardsPage::*)()){&$ShardsPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x27d610, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ShardsPage::*)()){&$ShardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x27fc40, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ShardsPage::*)()){&$ShardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x27fbd0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ShardsPage::*)()){&$ShardsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x27fa30, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $SongsLayer : public SongsLayer, public $CacBase {
public:
    dupable ~$SongsLayer() override {}

    dupable void customSetup() override {
        if ((void($SongsLayer::*)()){&$SongsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29ec80))(this);
        else return SongsLayer::customSetup();
    }

    dupable $SongsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongsLayer::*)()){&$SongsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x29ec80, extract_virtual(V, (void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $StatsLayer : public StatsLayer, public $CacBase {
public:
    dupable ~$StatsLayer() override {}

    dupable void customSetup() override {
        if ((void($StatsLayer::*)()){&$StatsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x59df0))(this);
        else return StatsLayer::customSetup();
    }

    dupable $StatsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($StatsLayer::*)()){&$StatsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x59df0, extract_virtual(V, (void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $UndoObject : public UndoObject, public $CacBase {
public:
    dupable ~$UndoObject() override {}

    dupable $UndoObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $AppDelegate : public AppDelegate, public $CacBase {
public:
    dupable ~$AppDelegate() override {}

    dupable void applicationDidFinishLaunching() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (void(D::*)()){&D::applicationDidFinishLaunching})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa900))(this);
        else return AppDelegate::applicationDidFinishLaunching();
    }

    dupable void applicationDidEnterBackground() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aabe0))(this);
        else return AppDelegate::applicationDidEnterBackground();
    }

    dupable void applicationWillEnterForeground() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aac80))(this);
        else return AppDelegate::applicationWillEnterForeground();
    }

    dupable void applicationWillBecomeActive() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (void(D::*)()){&D::applicationWillBecomeActive})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aab30))(this);
        else return AppDelegate::applicationWillBecomeActive();
    }

    dupable void applicationWillResignActive() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (void(D::*)()){&D::applicationWillResignActive})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aab50))(this);
        else return AppDelegate::applicationWillResignActive();
    }

    dupable void trySaveGame() override {
        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aaf10))(this);
        else return AppDelegate::trySaveGame();
    }

    dupable void willSwitchToScene(cocos2d::CCScene* p0) override {
        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(base+0x3aaf40))(this, p0);
        else return AppDelegate::willSwitchToScene(p0);
    }

    dupable void bgScale() {
        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aaab0))(this);
        else return AppDelegate::bgScale();
    }

    dupable static AppDelegate* get() {
        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            return reinterpret_cast<AppDelegate*(*)()>(m->getOriginal(base+0x3aab10))();
        else return AppDelegate::get();
    }

    dupable $AppDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidFinishLaunching} != (void(D::*)()){&D::applicationDidFinishLaunching})
            m->registerHook(base+0x3aa900, extract_virtual(V, (void(D::*)()){&D::applicationDidFinishLaunching}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationDidEnterBackground} != (void(D::*)()){&D::applicationDidEnterBackground})
            m->registerHook(base+0x3aabe0, extract_virtual(V, (void(D::*)()){&D::applicationDidEnterBackground}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillEnterForeground} != (void(D::*)()){&D::applicationWillEnterForeground})
            m->registerHook(base+0x3aac80, extract_virtual(V, (void(D::*)()){&D::applicationWillEnterForeground}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillBecomeActive} != (void(D::*)()){&D::applicationWillBecomeActive})
            m->registerHook(base+0x3aab30, extract_virtual(V, (void(D::*)()){&D::applicationWillBecomeActive}));

        if ((void($AppDelegate::*)()){&$AppDelegate::applicationWillResignActive} != (void(D::*)()){&D::applicationWillResignActive})
            m->registerHook(base+0x3aab50, extract_virtual(V, (void(D::*)()){&D::applicationWillResignActive}));

        if ((void($AppDelegate::*)()){&$AppDelegate::trySaveGame} != (void(D::*)()){&D::trySaveGame})
            m->registerHook(base+0x3aaf10, extract_virtual(V, (void(D::*)()){&D::trySaveGame}));

        if ((void($AppDelegate::*)(cocos2d::CCScene*)){&$AppDelegate::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            m->registerHook(base+0x3aaf40, extract_virtual(V, (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene}));

        if ((void($AppDelegate::*)()){&$AppDelegate::bgScale} != (void(D::*)()){&D::bgScale})
            m->registerHook(base+0x3aaab0, extract((void(D::*)()){&D::bgScale}));

        if ((AppDelegate*(*)()){&$AppDelegate::get} != (AppDelegate*(*)()){&D::get})
            m->registerHook(base+0x3aab10, (AppDelegate*(*)()){&D::get});
    }
};


template<class D>
class $CCCountdown : public CCCountdown, public $CacBase {
public:
    dupable ~$CCCountdown() override {}

    dupable bool init() override {
        if ((bool($CCCountdown::*)()){&$CCCountdown::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x468870))(this);
        else return CCCountdown::init();
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($CCCountdown::*)(unsigned char)){&$CCCountdown::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x468c70))(this, p0);
        else return CCCountdown::setOpacity(p0);
    }

    dupable $CCCountdown() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCCountdown::*)()){&$CCCountdown::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x468870, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CCCountdown::*)(unsigned char)){&$CCCountdown::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x468c70, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $CCMoveCNode : public CCMoveCNode, public $CacBase {
public:
    dupable ~$CCMoveCNode() override {}

    dupable bool init() override {
        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18b3d0))(this);
        else return CCMoveCNode::init();
    }

    dupable $CCMoveCNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCMoveCNode::*)()){&$CCMoveCNode::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18b3d0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CommentCell : public CommentCell, public $CacBase {
public:
    dupable ~$CommentCell() override {}

    dupable bool init() override {
        if ((bool($CommentCell::*)()){&$CommentCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11ce80))(this);
        else return CommentCell::init();
    }

    dupable void draw() override {
        if ((void($CommentCell::*)()){&$CommentCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11d1f0))(this);
        else return CommentCell::draw();
    }

    dupable void likedItem(LikeItemType p0, int p1, bool p2) override {
        if ((void($CommentCell::*)(LikeItemType, int, bool)){&$CommentCell::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            return reinterpret_cast<void(*)(decltype(this), LikeItemType, int, bool)>(m->getOriginal(base+0x11d2c0))(this, p0, p1, p2);
        else return CommentCell::likedItem(p0, p1, p2);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($CommentCell::*)(FLAlertLayer*, bool)){&$CommentCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11d4b0))(this, p0, p1);
        else return CommentCell::FLAlert_Clicked(p0, p1);
    }

    dupable $CommentCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CommentCell::*)()){&$CommentCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11ce80, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CommentCell::*)()){&$CommentCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11d1f0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($CommentCell::*)(LikeItemType, int, bool)){&$CommentCell::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            m->registerHook(base+0x11d2c0, extract_virtual(V, (void(D::*)(LikeItemType, int, bool)){&D::likedItem}));

        if ((void($CommentCell::*)(FLAlertLayer*, bool)){&$CommentCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11d4b0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $DialogLayer : public DialogLayer, public $CacBase {
public:
    dupable ~$DialogLayer() override {}

    dupable void onEnter() override {
        if ((void($DialogLayer::*)()){&$DialogLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x205900))(this);
        else return DialogLayer::onEnter();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205790))(this, p0, p1);
        else return DialogLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205820))(this, p0, p1);
        else return DialogLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2057e0))(this, p0, p1);
        else return DialogLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x205840))(this, p0, p1);
        else return DialogLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($DialogLayer::*)()){&$DialogLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x205890))(this);
        else return DialogLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($DialogLayer::*)()){&$DialogLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2056a0))(this);
        else return DialogLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($DialogLayer::*)(cocos2d::enumKeyCodes)){&$DialogLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x205ce0))(this, p0);
        else return DialogLayer::keyDown(p0);
    }

    dupable void fadeInTextFinished(TextArea* p0) override {
        if ((void($DialogLayer::*)(TextArea*)){&$DialogLayer::fadeInTextFinished} != (void(D::*)(TextArea*)){&D::fadeInTextFinished})
            return reinterpret_cast<void(*)(decltype(this), TextArea*)>(m->getOriginal(base+0x205930))(this, p0);
        else return DialogLayer::fadeInTextFinished(p0);
    }

    dupable $DialogLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DialogLayer::*)()){&$DialogLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x205900, extract_virtual(V, (void(D::*)()){&D::onEnter}));

        if ((bool($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x205790, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x205820, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2057e0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($DialogLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$DialogLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x205840, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($DialogLayer::*)()){&$DialogLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x205890, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($DialogLayer::*)()){&$DialogLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2056a0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($DialogLayer::*)(cocos2d::enumKeyCodes)){&$DialogLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x205ce0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($DialogLayer::*)(TextArea*)){&$DialogLayer::fadeInTextFinished} != (void(D::*)(TextArea*)){&D::fadeInTextFinished})
            m->registerHook(base+0x205930, extract_virtual(V, (void(D::*)(TextArea*)){&D::fadeInTextFinished}));
    }
};


template<class D>
class $GJGameLevel : public GJGameLevel, public $CacBase {
public:
    dupable ~$GJGameLevel() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) override {
        if ((void($GJGameLevel::*)(DS_Dictionary*)){&$GJGameLevel::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x2dd1c0))(this, p0);
        else return GJGameLevel::encodeWithCoder(p0);
    }

    dupable bool canEncode() override {
        if ((bool($GJGameLevel::*)()){&$GJGameLevel::canEncode} != (bool(D::*)()){&D::canEncode})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2ddae0))(this);
        else return GJGameLevel::canEncode();
    }

    dupable bool init() override {
        if ((bool($GJGameLevel::*)()){&$GJGameLevel::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2db310))(this);
        else return GJGameLevel::init();
    }

    dupable $GJGameLevel() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJGameLevel::*)(DS_Dictionary*)){&$GJGameLevel::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x2dd1c0, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((bool($GJGameLevel::*)()){&$GJGameLevel::canEncode} != (bool(D::*)()){&D::canEncode})
            m->registerHook(base+0x2ddae0, extract_virtual(V, (bool(D::*)()){&D::canEncode}));

        if ((bool($GJGameLevel::*)()){&$GJGameLevel::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2db310, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJListLayer : public GJListLayer, public $CacBase {
public:
    dupable ~$GJListLayer() override {}

    dupable $GJListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJScoreCell : public GJScoreCell, public $CacBase {
public:
    dupable ~$GJScoreCell() override {}

    dupable bool init() override {
        if ((bool($GJScoreCell::*)()){&$GJScoreCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11d710))(this);
        else return GJScoreCell::init();
    }

    dupable void draw() override {
        if ((void($GJScoreCell::*)()){&$GJScoreCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11d9b0))(this);
        else return GJScoreCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJScoreCell::*)(FLAlertLayer*, bool)){&$GJScoreCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11d8e0))(this, p0, p1);
        else return GJScoreCell::FLAlert_Clicked(p0, p1);
    }

    dupable $GJScoreCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJScoreCell::*)()){&$GJScoreCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11d710, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJScoreCell::*)()){&$GJScoreCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11d9b0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($GJScoreCell::*)(FLAlertLayer*, bool)){&$GJScoreCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11d8e0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJShopLayer : public GJShopLayer, public $CacBase {
public:
    dupable ~$GJShopLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJShopLayer::*)()){&$GJShopLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1a2370))(this);
        else return GJShopLayer::keyBackClicked();
    }

    dupable void didPurchaseItem(GJStoreItem* p0) override {
        if ((void($GJShopLayer::*)(GJStoreItem*)){&$GJShopLayer::didPurchaseItem} != (void(D::*)(GJStoreItem*)){&D::didPurchaseItem})
            return reinterpret_cast<void(*)(decltype(this), GJStoreItem*)>(m->getOriginal(base+0x1a1ae0))(this, p0);
        else return GJShopLayer::didPurchaseItem(p0);
    }

    dupable $GJShopLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJShopLayer::*)()){&$GJShopLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1a2370, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJShopLayer::*)(GJStoreItem*)){&$GJShopLayer::didPurchaseItem} != (void(D::*)(GJStoreItem*)){&D::didPurchaseItem})
            m->registerHook(base+0x1a1ae0, extract_virtual(V, (void(D::*)(GJStoreItem*)){&D::didPurchaseItem}));
    }
};


template<class D>
class $GJUserScore : public GJUserScore, public $CacBase {
public:
    dupable ~$GJUserScore() override {}

    dupable bool init() override {
        if ((bool($GJUserScore::*)()){&$GJUserScore::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2de5a0))(this);
        else return GJUserScore::init();
    }

    dupable $GJUserScore() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserScore::*)()){&$GJUserScore::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2de5a0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJWorldNode : public GJWorldNode, public $CacBase {
public:
    dupable ~$GJWorldNode() override {}

    dupable $GJWorldNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GameManager : public GameManager, public $CacBase {
public:
    dupable ~$GameManager() override {}

    dupable void update(float p0) override {
        if ((void($GameManager::*)(float)){&$GameManager::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1d0270))(this, p0);
        else return GameManager::update(p0);
    }

    dupable bool init() override {
        if ((bool($GameManager::*)()){&$GameManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1c2ec0))(this);
        else return GameManager::init();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) override {
        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x1cfd90))(this, p0);
        else return GameManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) override {
        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x1ce7f0))(this, p0);
        else return GameManager::dataLoaded(p0);
    }

    dupable void firstLoad() override {
        if ((void($GameManager::*)()){&$GameManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1cf6a0))(this);
        else return GameManager::firstLoad();
    }

    dupable void accountStatusChanged() {
        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1cdad0))(this);
        else return GameManager::accountStatusChanged();
    }

    dupable const cocos2d::_ccColor3B& colorForIdx(int p0) {
        if ((const cocos2d::_ccColor3B&($GameManager::*)(int)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx})
            return reinterpret_cast<const cocos2d::_ccColor3B&(*)(decltype(this), int)>(m->getOriginal(base+0x1cbc80))(this, p0);
        else return GameManager::colorForIdx(p0);
    }

    dupable void didExitPlayscene() {
        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d0230))(this);
        else return GameManager::didExitPlayscene();
    }

    dupable void doQuickSave() {
        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d0200))(this);
        else return GameManager::doQuickSave();
    }

    dupable void fadeInMusic(char const* p0) {
        if ((void($GameManager::*)(char const*)){&$GameManager::fadeInMusic} != (void(D::*)(char const*)){&D::fadeInMusic})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1c2ff0))(this, p0);
        else return GameManager::fadeInMusic(p0);
    }

    dupable void getBGTexture(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::getBGTexture} != (void(D::*)(int)){&D::getBGTexture})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1cca00))(this, p0);
        else return GameManager::getBGTexture(p0);
    }

    dupable void getFontFile(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::getFontFile} != (void(D::*)(int)){&D::getFontFile})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1cc5f0))(this, p0);
        else return GameManager::getFontFile(p0);
    }

    dupable bool getGameVariable(char const* p0) {
        if ((bool($GameManager::*)(char const*)){&$GameManager::getGameVariable} != (bool(D::*)(char const*)){&D::getGameVariable})
            return reinterpret_cast<bool(*)(decltype(this), char const*)>(m->getOriginal(base+0x1cccd0))(this, p0);
        else return GameManager::getGameVariable(p0);
    }

    dupable int getIntGameVariable(char const* p0) {
        if ((int($GameManager::*)(char const*)){&$GameManager::getIntGameVariable} != (int(D::*)(char const*)){&D::getIntGameVariable})
            return reinterpret_cast<int(*)(decltype(this), char const*)>(m->getOriginal(base+0x1cd1d0))(this, p0);
        else return GameManager::getIntGameVariable(p0);
    }

    dupable void getUGV(char const* p0) {
        if ((void($GameManager::*)(char const*)){&$GameManager::getUGV} != (void(D::*)(char const*)){&D::getUGV})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1ccfa0))(this, p0);
        else return GameManager::getUGV(p0);
    }

    dupable void loadDeathEffect(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::loadDeathEffect} != (void(D::*)(int)){&D::loadDeathEffect})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1cc690))(this, p0);
        else return GameManager::loadDeathEffect(p0);
    }

    dupable void loadFont(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::loadFont} != (void(D::*)(int)){&D::loadFont})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1cc550))(this, p0);
        else return GameManager::loadFont(p0);
    }

    dupable void reloadAll(bool p0, bool p1, bool p2) {
        if ((void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll} != (void(D::*)(bool, bool, bool)){&D::reloadAll})
            return reinterpret_cast<void(*)(decltype(this), bool, bool, bool)>(m->getOriginal(base+0x1d08a0))(this, p0, p1, p2);
        else return GameManager::reloadAll(p0, p1, p2);
    }

    dupable void reloadAllStep5() {
        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d0b00))(this);
        else return GameManager::reloadAllStep5();
    }

    dupable void reportPercentageForLevel(int p0, int p1, bool p2) {
        if ((void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel} != (void(D::*)(int, int, bool)){&D::reportPercentageForLevel})
            return reinterpret_cast<void(*)(decltype(this), int, int, bool)>(m->getOriginal(base+0x1c5b00))(this, p0, p1, p2);
        else return GameManager::reportPercentageForLevel(p0, p1, p2);
    }

    dupable void setGameVariable(char const* p0, bool p1) {
        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable} != (void(D::*)(char const*, bool)){&D::setGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(base+0x1cca80))(this, p0, p1);
        else return GameManager::setGameVariable(p0, p1);
    }

    dupable void setIntGameVariable(char const* p0, int p1) {
        if ((void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable} != (void(D::*)(char const*, int)){&D::setIntGameVariable})
            return reinterpret_cast<void(*)(decltype(this), char const*, int)>(m->getOriginal(base+0x1cd0e0))(this, p0, p1);
        else return GameManager::setIntGameVariable(p0, p1);
    }

    dupable void setUGV(char const* p0, bool p1) {
        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setUGV} != (void(D::*)(char const*, bool)){&D::setUGV})
            return reinterpret_cast<void(*)(decltype(this), char const*, bool)>(m->getOriginal(base+0x1cce50))(this, p0, p1);
        else return GameManager::setUGV(p0, p1);
    }

    dupable static GameManager* sharedState() {
        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            return reinterpret_cast<GameManager*(*)()>(m->getOriginal(base+0x1c2b30))();
        else return GameManager::sharedState();
    }

    dupable void getGTexture(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::getGTexture} != (void(D::*)(int)){&D::getGTexture})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1cca40))(this, p0);
        else return GameManager::getGTexture(p0);
    }

    dupable void reportAchievementWithID(char const* p0, int p1, bool p2) {
        if ((void($GameManager::*)(char const*, int, bool)){&$GameManager::reportAchievementWithID} != (void(D::*)(char const*, int, bool)){&D::reportAchievementWithID})
            return reinterpret_cast<void(*)(decltype(this), char const*, int, bool)>(m->getOriginal(base+0x1c6460))(this, p0, p1, p2);
        else return GameManager::reportAchievementWithID(p0, p1, p2);
    }

    dupable void resolutionForKey(int p0) {
        if ((void($GameManager::*)(int)){&$GameManager::resolutionForKey} != (void(D::*)(int)){&D::resolutionForKey})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1d0b40))(this, p0);
        else return GameManager::resolutionForKey(p0);
    }

    dupable $GameManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GameManager::*)(float)){&$GameManager::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x1d0270, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((bool($GameManager::*)()){&$GameManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1c2ec0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x1cfd90, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($GameManager::*)(DS_Dictionary*)){&$GameManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x1ce7f0, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($GameManager::*)()){&$GameManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x1cf6a0, extract_virtual(V, (void(D::*)()){&D::firstLoad}));

        if ((void($GameManager::*)()){&$GameManager::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(base+0x1cdad0, extract((void(D::*)()){&D::accountStatusChanged}));

        if ((const cocos2d::_ccColor3B&($GameManager::*)(int)){&$GameManager::colorForIdx} != (const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx})
            m->registerHook(base+0x1cbc80, extract((const cocos2d::_ccColor3B&(D::*)(int)){&D::colorForIdx}));

        if ((void($GameManager::*)()){&$GameManager::didExitPlayscene} != (void(D::*)()){&D::didExitPlayscene})
            m->registerHook(base+0x1d0230, extract((void(D::*)()){&D::didExitPlayscene}));

        if ((void($GameManager::*)()){&$GameManager::doQuickSave} != (void(D::*)()){&D::doQuickSave})
            m->registerHook(base+0x1d0200, extract((void(D::*)()){&D::doQuickSave}));

        if ((void($GameManager::*)(char const*)){&$GameManager::fadeInMusic} != (void(D::*)(char const*)){&D::fadeInMusic})
            m->registerHook(base+0x1c2ff0, extract((void(D::*)(char const*)){&D::fadeInMusic}));

        if ((void($GameManager::*)(int)){&$GameManager::getBGTexture} != (void(D::*)(int)){&D::getBGTexture})
            m->registerHook(base+0x1cca00, extract((void(D::*)(int)){&D::getBGTexture}));

        if ((void($GameManager::*)(int)){&$GameManager::getFontFile} != (void(D::*)(int)){&D::getFontFile})
            m->registerHook(base+0x1cc5f0, extract((void(D::*)(int)){&D::getFontFile}));

        if ((bool($GameManager::*)(char const*)){&$GameManager::getGameVariable} != (bool(D::*)(char const*)){&D::getGameVariable})
            m->registerHook(base+0x1cccd0, extract((bool(D::*)(char const*)){&D::getGameVariable}));

        if ((int($GameManager::*)(char const*)){&$GameManager::getIntGameVariable} != (int(D::*)(char const*)){&D::getIntGameVariable})
            m->registerHook(base+0x1cd1d0, extract((int(D::*)(char const*)){&D::getIntGameVariable}));

        if ((void($GameManager::*)(char const*)){&$GameManager::getUGV} != (void(D::*)(char const*)){&D::getUGV})
            m->registerHook(base+0x1ccfa0, extract((void(D::*)(char const*)){&D::getUGV}));

        if ((void($GameManager::*)(int)){&$GameManager::loadDeathEffect} != (void(D::*)(int)){&D::loadDeathEffect})
            m->registerHook(base+0x1cc690, extract((void(D::*)(int)){&D::loadDeathEffect}));

        if ((void($GameManager::*)(int)){&$GameManager::loadFont} != (void(D::*)(int)){&D::loadFont})
            m->registerHook(base+0x1cc550, extract((void(D::*)(int)){&D::loadFont}));

        if ((void($GameManager::*)(bool, bool, bool)){&$GameManager::reloadAll} != (void(D::*)(bool, bool, bool)){&D::reloadAll})
            m->registerHook(base+0x1d08a0, extract((void(D::*)(bool, bool, bool)){&D::reloadAll}));

        if ((void($GameManager::*)()){&$GameManager::reloadAllStep5} != (void(D::*)()){&D::reloadAllStep5})
            m->registerHook(base+0x1d0b00, extract((void(D::*)()){&D::reloadAllStep5}));

        if ((void($GameManager::*)(int, int, bool)){&$GameManager::reportPercentageForLevel} != (void(D::*)(int, int, bool)){&D::reportPercentageForLevel})
            m->registerHook(base+0x1c5b00, extract((void(D::*)(int, int, bool)){&D::reportPercentageForLevel}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setGameVariable} != (void(D::*)(char const*, bool)){&D::setGameVariable})
            m->registerHook(base+0x1cca80, extract((void(D::*)(char const*, bool)){&D::setGameVariable}));

        if ((void($GameManager::*)(char const*, int)){&$GameManager::setIntGameVariable} != (void(D::*)(char const*, int)){&D::setIntGameVariable})
            m->registerHook(base+0x1cd0e0, extract((void(D::*)(char const*, int)){&D::setIntGameVariable}));

        if ((void($GameManager::*)(char const*, bool)){&$GameManager::setUGV} != (void(D::*)(char const*, bool)){&D::setUGV})
            m->registerHook(base+0x1cce50, extract((void(D::*)(char const*, bool)){&D::setUGV}));

        if ((GameManager*(*)()){&$GameManager::sharedState} != (GameManager*(*)()){&D::sharedState})
            m->registerHook(base+0x1c2b30, (GameManager*(*)()){&D::sharedState});

        if ((void($GameManager::*)(int)){&$GameManager::getGTexture} != (void(D::*)(int)){&D::getGTexture})
            m->registerHook(base+0x1cca40, extract((void(D::*)(int)){&D::getGTexture}));

        if ((void($GameManager::*)(char const*, int, bool)){&$GameManager::reportAchievementWithID} != (void(D::*)(char const*, int, bool)){&D::reportAchievementWithID})
            m->registerHook(base+0x1c6460, extract((void(D::*)(char const*, int, bool)){&D::reportAchievementWithID}));

        if ((void($GameManager::*)(int)){&$GameManager::resolutionForKey} != (void(D::*)(int)){&D::resolutionForKey})
            m->registerHook(base+0x1d0b40, extract((void(D::*)(int)){&D::resolutionForKey}));
    }
};


template<class D>
class $MapPackCell : public MapPackCell, public $CacBase {
public:
    dupable ~$MapPackCell() override {}

    dupable bool init() override {
        if ((bool($MapPackCell::*)()){&$MapPackCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11a9c0))(this);
        else return MapPackCell::init();
    }

    dupable void draw() override {
        if ((void($MapPackCell::*)()){&$MapPackCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11ae80))(this);
        else return MapPackCell::draw();
    }

    dupable $MapPackCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MapPackCell::*)()){&$MapPackCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11a9c0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MapPackCell::*)()){&$MapPackCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11ae80, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ProfilePage : public ProfilePage, public $CacBase {
public:
    dupable ~$ProfilePage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($ProfilePage::*)()){&$ProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x464a60))(this);
        else return ProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($ProfilePage::*)()){&$ProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4637e0))(this);
        else return ProfilePage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($ProfilePage::*)()){&$ProfilePage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4639c0))(this);
        else return ProfilePage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($ProfilePage::*)(FLAlertLayer*, bool)){&$ProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x463340))(this, p0, p1);
        else return ProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void updateUserScoreFinished() override {
        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x463850))(this);
        else return ProfilePage::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() override {
        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x463920))(this);
        else return ProfilePage::updateUserScoreFailed();
    }

    dupable void getUserInfoFinished(GJUserScore* p0) override {
        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::getUserInfoFinished} != (void(D::*)(GJUserScore*)){&D::getUserInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), GJUserScore*)>(m->getOriginal(base+0x463cd0))(this, p0);
        else return ProfilePage::getUserInfoFinished(p0);
    }

    dupable void getUserInfoFailed(int p0) override {
        if ((void($ProfilePage::*)(int)){&$ProfilePage::getUserInfoFailed} != (void(D::*)(int)){&D::getUserInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x463fb0))(this, p0);
        else return ProfilePage::getUserInfoFailed(p0);
    }

    dupable void userInfoChanged(GJUserScore* p0) override {
        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::userInfoChanged} != (void(D::*)(GJUserScore*)){&D::userInfoChanged})
            return reinterpret_cast<void(*)(decltype(this), GJUserScore*)>(m->getOriginal(base+0x464070))(this, p0);
        else return ProfilePage::userInfoChanged(p0);
    }

    dupable void loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($ProfilePage::*)(cocos2d::CCArray*, char const*)){&$ProfilePage::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x464250))(this, p0, p1);
        else return ProfilePage::loadCommentsFinished(p0, p1);
    }

    dupable void loadCommentsFailed(char const* p0) override {
        if ((void($ProfilePage::*)(char const*)){&$ProfilePage::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x464340))(this, p0);
        else return ProfilePage::loadCommentsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($ProfilePage::*)(std::string, char const*)){&$ProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x464410))(this, p0, p1);
        else return ProfilePage::setupPageInfo(p0, p1);
    }

    dupable void commentUploadFinished(int p0) override {
        if ((void($ProfilePage::*)(int)){&$ProfilePage::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x464770))(this, p0);
        else return ProfilePage::commentUploadFinished(p0);
    }

    dupable void commentUploadFailed(int p0, CommentError p1) override {
        if ((void($ProfilePage::*)(int, CommentError)){&$ProfilePage::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), int, CommentError)>(m->getOriginal(base+0x464800))(this, p0, p1);
        else return ProfilePage::commentUploadFailed(p0, p1);
    }

    dupable void commentDeleteFailed(int p0, int p1) override {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::commentDeleteFailed} != (void(D::*)(int, int)){&D::commentDeleteFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x4648e0))(this, p0, p1);
        else return ProfilePage::commentDeleteFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($ProfilePage::*)(UploadActionPopup*)){&$ProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x463510))(this, p0);
        else return ProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x463570))(this, p0, p1);
        else return ProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x463710))(this, p0, p1);
        else return ProfilePage::uploadActionFailed(p0, p1);
    }

    dupable $ProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ProfilePage::*)()){&$ProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x464a60, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ProfilePage::*)()){&$ProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4637e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ProfilePage::*)()){&$ProfilePage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x4639c0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($ProfilePage::*)(FLAlertLayer*, bool)){&$ProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x463340, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x463850, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($ProfilePage::*)()){&$ProfilePage::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x463920, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFailed}));

        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::getUserInfoFinished} != (void(D::*)(GJUserScore*)){&D::getUserInfoFinished})
            m->registerHook(base+0x463cd0, extract_virtual(V, (void(D::*)(GJUserScore*)){&D::getUserInfoFinished}));

        if ((void($ProfilePage::*)(int)){&$ProfilePage::getUserInfoFailed} != (void(D::*)(int)){&D::getUserInfoFailed})
            m->registerHook(base+0x463fb0, extract_virtual(V, (void(D::*)(int)){&D::getUserInfoFailed}));

        if ((void($ProfilePage::*)(GJUserScore*)){&$ProfilePage::userInfoChanged} != (void(D::*)(GJUserScore*)){&D::userInfoChanged})
            m->registerHook(base+0x464070, extract_virtual(V, (void(D::*)(GJUserScore*)){&D::userInfoChanged}));

        if ((void($ProfilePage::*)(cocos2d::CCArray*, char const*)){&$ProfilePage::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            m->registerHook(base+0x464250, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished}));

        if ((void($ProfilePage::*)(char const*)){&$ProfilePage::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            m->registerHook(base+0x464340, extract_virtual(V, (void(D::*)(char const*)){&D::loadCommentsFailed}));

        if ((void($ProfilePage::*)(std::string, char const*)){&$ProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x464410, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($ProfilePage::*)(int)){&$ProfilePage::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            m->registerHook(base+0x464770, extract_virtual(V, (void(D::*)(int)){&D::commentUploadFinished}));

        if ((void($ProfilePage::*)(int, CommentError)){&$ProfilePage::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            m->registerHook(base+0x464800, extract_virtual(V, (void(D::*)(int, CommentError)){&D::commentUploadFailed}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::commentDeleteFailed} != (void(D::*)(int, int)){&D::commentDeleteFailed})
            m->registerHook(base+0x4648e0, extract_virtual(V, (void(D::*)(int, int)){&D::commentDeleteFailed}));

        if ((void($ProfilePage::*)(UploadActionPopup*)){&$ProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x463510, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x463570, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($ProfilePage::*)(int, int)){&$ProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x463710, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));
    }
};


template<class D>
class $RewardsPage : public RewardsPage, public $CacBase {
public:
    dupable ~$RewardsPage() override {}

    dupable bool init() override {
        if ((bool($RewardsPage::*)()){&$RewardsPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xf3800))(this);
        else return RewardsPage::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($RewardsPage::*)()){&$RewardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf5040))(this);
        else return RewardsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($RewardsPage::*)()){&$RewardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4fd0))(this);
        else return RewardsPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($RewardsPage::*)()){&$RewardsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4e70))(this);
        else return RewardsPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($RewardsPage::*)(FLAlertLayer*, bool)){&$RewardsPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xf4fb0))(this, p0, p1);
        else return RewardsPage::FLAlert_Clicked(p0, p1);
    }

    dupable void rewardsStatusFinished(int p0) override {
        if ((void($RewardsPage::*)(int)){&$RewardsPage::rewardsStatusFinished} != (void(D::*)(int)){&D::rewardsStatusFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xf4ae0))(this, p0);
        else return RewardsPage::rewardsStatusFinished(p0);
    }

    dupable void rewardsStatusFailed() override {
        if ((void($RewardsPage::*)()){&$RewardsPage::rewardsStatusFailed} != (void(D::*)()){&D::rewardsStatusFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf4d70))(this);
        else return RewardsPage::rewardsStatusFailed();
    }

    dupable $RewardsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($RewardsPage::*)()){&$RewardsPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xf3800, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($RewardsPage::*)()){&$RewardsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0xf5040, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($RewardsPage::*)()){&$RewardsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf4fd0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($RewardsPage::*)()){&$RewardsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0xf4e70, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($RewardsPage::*)(FLAlertLayer*, bool)){&$RewardsPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xf4fb0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($RewardsPage::*)(int)){&$RewardsPage::rewardsStatusFinished} != (void(D::*)(int)){&D::rewardsStatusFinished})
            m->registerHook(base+0xf4ae0, extract_virtual(V, (void(D::*)(int)){&D::rewardsStatusFinished}));

        if ((void($RewardsPage::*)()){&$RewardsPage::rewardsStatusFailed} != (void(D::*)()){&D::rewardsStatusFailed})
            m->registerHook(base+0xf4d70, extract_virtual(V, (void(D::*)()){&D::rewardsStatusFailed}));
    }
};


template<class D>
class $SecretLayer : public SecretLayer, public $CacBase {
public:
    dupable ~$SecretLayer() override {}

    dupable bool init() override {
        if ((bool($SecretLayer::*)()){&$SecretLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x363340))(this);
        else return SecretLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($SecretLayer::*)()){&$SecretLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x368450))(this);
        else return SecretLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x366d30))(this, p0);
        else return SecretLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x366f30))(this, p0);
        else return SecretLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x367050))(this, p0);
        else return SecretLayer::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($SecretLayer::*)(FLAlertLayer*, bool)){&$SecretLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x366d10))(this, p0, p1);
        else return SecretLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $SecretLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer::*)()){&$SecretLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x363340, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SecretLayer::*)()){&$SecretLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x368450, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x366d30, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x366f30, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer::*)(CCTextInputNode*)){&$SecretLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x367050, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer::*)(FLAlertLayer*, bool)){&$SecretLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x366d10, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $SpeedObject : public SpeedObject, public $CacBase {
public:
    dupable ~$SpeedObject() override {}

    dupable $SpeedObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $UploadPopup : public UploadPopup, public $CacBase {
public:
    dupable ~$UploadPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($UploadPopup::*)()){&$UploadPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12c600))(this);
        else return UploadPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($UploadPopup::*)()){&$UploadPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12c5a0))(this);
        else return UploadPopup::show();
    }

    dupable void levelUploadFinished(GJGameLevel* p0) override {
        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFinished} != (void(D::*)(GJGameLevel*)){&D::levelUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x12c080))(this, p0);
        else return UploadPopup::levelUploadFinished(p0);
    }

    dupable void levelUploadFailed(GJGameLevel* p0) override {
        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFailed} != (void(D::*)(GJGameLevel*)){&D::levelUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x12c340))(this, p0);
        else return UploadPopup::levelUploadFailed(p0);
    }

    dupable $UploadPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadPopup::*)()){&$UploadPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12c600, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($UploadPopup::*)()){&$UploadPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x12c5a0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFinished} != (void(D::*)(GJGameLevel*)){&D::levelUploadFinished})
            m->registerHook(base+0x12c080, extract_virtual(V, (void(D::*)(GJGameLevel*)){&D::levelUploadFinished}));

        if ((void($UploadPopup::*)(GJGameLevel*)){&$UploadPopup::levelUploadFailed} != (void(D::*)(GJGameLevel*)){&D::levelUploadFailed})
            m->registerHook(base+0x12c340, extract_virtual(V, (void(D::*)(GJGameLevel*)){&D::levelUploadFailed}));
    }
};


template<class D>
class $AccountLayer : public AccountLayer, public $CacBase {
public:
    dupable ~$AccountLayer() override {}

    dupable void customSetup() override {
        if ((void($AccountLayer::*)()){&$AccountLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x81c20))(this);
        else return AccountLayer::customSetup();
    }

    dupable void layerHidden() override {
        if ((void($AccountLayer::*)()){&$AccountLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83950))(this);
        else return AccountLayer::layerHidden();
    }

    dupable void backupAccountFinished() override {
        if ((void($AccountLayer::*)()){&$AccountLayer::backupAccountFinished} != (void(D::*)()){&D::backupAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x830e0))(this);
        else return AccountLayer::backupAccountFinished();
    }

    dupable void backupAccountFailed(BackupAccountError p0) override {
        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::backupAccountFailed} != (void(D::*)(BackupAccountError)){&D::backupAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), BackupAccountError)>(m->getOriginal(base+0x832d0))(this, p0);
        else return AccountLayer::backupAccountFailed(p0);
    }

    dupable void syncAccountFinished() override {
        if ((void($AccountLayer::*)()){&$AccountLayer::syncAccountFinished} != (void(D::*)()){&D::syncAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83490))(this);
        else return AccountLayer::syncAccountFinished();
    }

    dupable void syncAccountFailed(BackupAccountError p0) override {
        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::syncAccountFailed} != (void(D::*)(BackupAccountError)){&D::syncAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), BackupAccountError)>(m->getOriginal(base+0x83630))(this, p0);
        else return AccountLayer::syncAccountFailed(p0);
    }

    dupable void accountStatusChanged() override {
        if ((void($AccountLayer::*)()){&$AccountLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x830b0))(this);
        else return AccountLayer::accountStatusChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($AccountLayer::*)(FLAlertLayer*, bool)){&$AccountLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x83830))(this, p0, p1);
        else return AccountLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $AccountLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountLayer::*)()){&$AccountLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x81c20, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($AccountLayer::*)()){&$AccountLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x83950, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($AccountLayer::*)()){&$AccountLayer::backupAccountFinished} != (void(D::*)()){&D::backupAccountFinished})
            m->registerHook(base+0x830e0, extract_virtual(V, (void(D::*)()){&D::backupAccountFinished}));

        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::backupAccountFailed} != (void(D::*)(BackupAccountError)){&D::backupAccountFailed})
            m->registerHook(base+0x832d0, extract_virtual(V, (void(D::*)(BackupAccountError)){&D::backupAccountFailed}));

        if ((void($AccountLayer::*)()){&$AccountLayer::syncAccountFinished} != (void(D::*)()){&D::syncAccountFinished})
            m->registerHook(base+0x83490, extract_virtual(V, (void(D::*)()){&D::syncAccountFinished}));

        if ((void($AccountLayer::*)(BackupAccountError)){&$AccountLayer::syncAccountFailed} != (void(D::*)(BackupAccountError)){&D::syncAccountFailed})
            m->registerHook(base+0x83630, extract_virtual(V, (void(D::*)(BackupAccountError)){&D::syncAccountFailed}));

        if ((void($AccountLayer::*)()){&$AccountLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(base+0x830b0, extract_virtual(V, (void(D::*)()){&D::accountStatusChanged}));

        if ((void($AccountLayer::*)(FLAlertLayer*, bool)){&$AccountLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x83830, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $TableViewDataSource : public TableViewDataSource, public $CacBase {
public:
    dupable ~$TableViewDataSource() override {}

    dupable $TableViewDataSource() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TableViewDelegate : public TableViewDelegate, public $CacBase {
public:
    dupable ~$TableViewDelegate() override {}

    dupable $TableViewDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $BoomListView : public BoomListView, public $CacBase {
public:
    dupable ~$BoomListView() override {}

    dupable void draw() override {
        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18f790))(this);
        else return BoomListView::draw();
    }

    dupable void setupList() override {
        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18ef90))(this);
        else return BoomListView::setupList();
    }

    dupable void TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) override {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f030))(this, p0, p1, p2);
        else return BoomListView::TableViewWillDisplayCellForRowAtIndexPath(p0, p1, p2);
    }

    dupable void cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) override {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f070))(this, p0, p1);
        else return BoomListView::cellHeightForRowAtIndexPath(p0, p1);
    }

    dupable void didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) override {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f090))(this, p0, p1);
        else return BoomListView::didSelectRowAtIndexPath(p0, p1);
    }

    dupable int numberOfRowsInSection(unsigned int p0, TableView* p1) override {
        if ((int($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            return reinterpret_cast<int(*)(decltype(this), unsigned int, TableView*)>(m->getOriginal(base+0x18f0b0))(this, p0, p1);
        else return BoomListView::numberOfRowsInSection(p0, p1);
    }

    dupable void numberOfSectionsInTableView(TableView* p0) override {
        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            return reinterpret_cast<void(*)(decltype(this), TableView*)>(m->getOriginal(base+0x18f0e0))(this, p0);
        else return BoomListView::numberOfSectionsInTableView(p0);
    }

    dupable void cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) override {
        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableView*)>(m->getOriginal(base+0x18f100))(this, p0, p1);
        else return BoomListView::cellForRowAtIndexPath(p0, p1);
    }

    dupable void TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) override {
        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), TableView*, TableViewCellEditingStyle, CCIndexPath&)>(m->getOriginal(base+0x18f770))(this, p0, p1, p2);
        else return BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2);
    }

    dupable void TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) override {
        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            return reinterpret_cast<void(*)(decltype(this), CCIndexPath&, TableViewCell*, TableView*)>(m->getOriginal(base+0x18f050))(this, p0, p1, p2);
        else return BoomListView::TableViewWillReloadCellForRowAtIndexPath(p0, p1, p2);
    }

    dupable TableViewCell* getListCell(char const* p0) override {
        if ((TableViewCell*($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (TableViewCell*(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<TableViewCell*(*)(decltype(this), char const*)>(m->getOriginal(base+0x18f200))(this, p0);
        else return BoomListView::getListCell(p0);
    }

    dupable void loadCell(TableViewCell* p0, int p1) override {
        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x18f4a0))(this, p0, p1);
        else return BoomListView::loadCell(p0, p1);
    }

    dupable static BoomListView* create(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::create} != (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            return reinterpret_cast<BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)>(m->getOriginal(base+0x18ecb0))(p0, p1, p2, p3, p4);
        else return BoomListView::create(p0, p1, p2, p3, p4);
    }

    dupable bool init(cocos2d::CCArray* p0, float p1, float p2, int p3, BoomListType p4) {
        if ((bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::init} != (bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCArray*, float, float, int, BoomListType)>(m->getOriginal(base+0x18ee00))(this, p0, p1, p2, p3, p4);
        else return BoomListView::init(p0, p1, p2, p3, p4);
    }

    dupable $BoomListView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomListView::*)()){&$BoomListView::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18f790, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($BoomListView::*)()){&$BoomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x18ef90, extract_virtual(V, (void(D::*)()){&D::setupList}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillDisplayCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath})
            m->registerHook(base+0x18f030, extract_virtual(V, (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillDisplayCellForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellHeightForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath})
            m->registerHook(base+0x18f070, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::cellHeightForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::didSelectRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath})
            m->registerHook(base+0x18f090, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::didSelectRowAtIndexPath}));

        if ((int($BoomListView::*)(unsigned int, TableView*)){&$BoomListView::numberOfRowsInSection} != (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection})
            m->registerHook(base+0x18f0b0, extract_virtual(V, (int(D::*)(unsigned int, TableView*)){&D::numberOfRowsInSection}));

        if ((void($BoomListView::*)(TableView*)){&$BoomListView::numberOfSectionsInTableView} != (void(D::*)(TableView*)){&D::numberOfSectionsInTableView})
            m->registerHook(base+0x18f0e0, extract_virtual(V, (void(D::*)(TableView*)){&D::numberOfSectionsInTableView}));

        if ((void($BoomListView::*)(CCIndexPath&, TableView*)){&$BoomListView::cellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath})
            m->registerHook(base+0x18f100, extract_virtual(V, (void(D::*)(CCIndexPath&, TableView*)){&D::cellForRowAtIndexPath}));

        if ((void($BoomListView::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&$BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath} != (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath})
            m->registerHook(base+0x18f770, extract_virtual(V, (void(D::*)(TableView*, TableViewCellEditingStyle, CCIndexPath&)){&D::TableViewCommitCellEditingStyleForRowAtIndexPath}));

        if ((void($BoomListView::*)(CCIndexPath&, TableViewCell*, TableView*)){&$BoomListView::TableViewWillReloadCellForRowAtIndexPath} != (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath})
            m->registerHook(base+0x18f050, extract_virtual(V, (void(D::*)(CCIndexPath&, TableViewCell*, TableView*)){&D::TableViewWillReloadCellForRowAtIndexPath}));

        if ((TableViewCell*($BoomListView::*)(char const*)){&$BoomListView::getListCell} != (TableViewCell*(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x18f200, extract_virtual(V, (TableViewCell*(D::*)(char const*)){&D::getListCell}));

        if ((void($BoomListView::*)(TableViewCell*, int)){&$BoomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x18f4a0, extract_virtual(V, (void(D::*)(TableViewCell*, int)){&D::loadCell}));

        if ((BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::create} != (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create})
            m->registerHook(base+0x18ecb0, (BoomListView*(*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::create});

        if ((bool($BoomListView::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&$BoomListView::init} != (bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init})
            m->registerHook(base+0x18ee00, extract((bool(D::*)(cocos2d::CCArray*, float, float, int, BoomListType)){&D::init}));
    }
};


template<class D>
class $CCBlockLayer : public CCBlockLayer, public $CacBase {
public:
    dupable ~$CCBlockLayer() override {}

    dupable bool init() override {
        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2a59c0))(this);
        else return CCBlockLayer::init();
    }

    dupable void draw() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5c20))(this);
        else return CCBlockLayer::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c50))(this, p0, p1);
        else return CCBlockLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5cb0))(this, p0, p1);
        else return CCBlockLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c70))(this, p0, p1);
        else return CCBlockLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2a5c90))(this, p0, p1);
        else return CCBlockLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5ad0))(this);
        else return CCBlockLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5b10))(this);
        else return CCBlockLayer::keyBackClicked();
    }

    dupable void customSetup() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a70))(this);
        else return CCBlockLayer::customSetup();
    }

    dupable void enterLayer() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5aa0))(this);
        else return CCBlockLayer::enterLayer();
    }

    dupable void exitLayer() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5b40))(this);
        else return CCBlockLayer::exitLayer();
    }

    dupable void showLayer(bool p0) override {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5b90))(this, p0);
        else return CCBlockLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) override {
        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x2a5ba0))(this, p0);
        else return CCBlockLayer::hideLayer(p0);
    }

    dupable void layerVisible() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bc0))(this);
        else return CCBlockLayer::layerVisible();
    }

    dupable void layerHidden() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5be0))(this);
        else return CCBlockLayer::layerHidden();
    }

    dupable void enterAnimFinished() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5bb0))(this);
        else return CCBlockLayer::enterAnimFinished();
    }

    dupable void disableUI() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a80))(this);
        else return CCBlockLayer::disableUI();
    }

    dupable void enableUI() override {
        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a5a90))(this);
        else return CCBlockLayer::enableUI();
    }

    dupable $CCBlockLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCBlockLayer::*)()){&$CCBlockLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2a59c0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2a5c20, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2a5c50, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2a5cb0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2a5c70, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCBlockLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCBlockLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2a5c90, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2a5ad0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2a5b10, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x2a5a70, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x2a5aa0, extract_virtual(V, (void(D::*)()){&D::enterLayer}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::exitLayer} != (void(D::*)()){&D::exitLayer})
            m->registerHook(base+0x2a5b40, extract_virtual(V, (void(D::*)()){&D::exitLayer}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x2a5b90, extract_virtual(V, (void(D::*)(bool)){&D::showLayer}));

        if ((void($CCBlockLayer::*)(bool)){&$CCBlockLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x2a5ba0, extract_virtual(V, (void(D::*)(bool)){&D::hideLayer}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x2a5bc0, extract_virtual(V, (void(D::*)()){&D::layerVisible}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x2a5be0, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x2a5bb0, extract_virtual(V, (void(D::*)()){&D::enterAnimFinished}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x2a5a80, extract_virtual(V, (void(D::*)()){&D::disableUI}));

        if ((void($CCBlockLayer::*)()){&$CCBlockLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x2a5a90, extract_virtual(V, (void(D::*)()){&D::enableUI}));
    }
};


template<class D>
class $CCCircleWave : public CCCircleWave, public $CacBase {
public:
    dupable ~$CCCircleWave() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($CCCircleWave::*)(cocos2d::CCPoint const&)){&$CCCircleWave::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0xbd600))(this, p0);
        else return CCCircleWave::setPosition(p0);
    }

    dupable void removeMeAndCleanup() override {
        if ((void($CCCircleWave::*)()){&$CCCircleWave::removeMeAndCleanup} != (void(D::*)()){&D::removeMeAndCleanup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbdac0))(this);
        else return CCCircleWave::removeMeAndCleanup();
    }

    dupable void draw() override {
        if ((void($CCCircleWave::*)()){&$CCCircleWave::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbd960))(this);
        else return CCCircleWave::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) override {
        if ((void($CCCircleWave::*)(float, char const*)){&$CCCircleWave::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0xbd710))(this, p0, p1);
        else return CCCircleWave::updateTweenAction(p0, p1);
    }

    dupable static CCCircleWave* create(float p0, float p1, float p2, bool p3) {
        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool)>(m->getOriginal(base+0xbd270))(p0, p1, p2, p3);
        else return CCCircleWave::create(p0, p1, p2, p3);
    }

    dupable static CCCircleWave* create(float p0, float p1, float p2, bool p3, bool p4) {
        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            return reinterpret_cast<CCCircleWave*(*)(float, float, float, bool, bool)>(m->getOriginal(base+0xbd290))(p0, p1, p2, p3, p4);
        else return CCCircleWave::create(p0, p1, p2, p3, p4);
    }

    dupable bool init(float p0, float p1, float p2, bool p3, bool p4) {
        if ((bool($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::init} != (bool(D::*)(float, float, float, bool, bool)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), float, float, float, bool, bool)>(m->getOriginal(base+0xbd380))(this, p0, p1, p2, p3, p4);
        else return CCCircleWave::init(p0, p1, p2, p3, p4);
    }

    dupable void followObject(cocos2d::CCNode* p0, bool p1) {
        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*, bool)>(m->getOriginal(base+0xbd670))(this, p0, p1);
        else return CCCircleWave::followObject(p0, p1);
    }

    dupable void updatePosition(float p0) {
        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xbd630))(this, p0);
        else return CCCircleWave::updatePosition(p0);
    }

    dupable $CCCircleWave() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCCircleWave::*)(cocos2d::CCPoint const&)){&$CCCircleWave::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0xbd600, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($CCCircleWave::*)()){&$CCCircleWave::removeMeAndCleanup} != (void(D::*)()){&D::removeMeAndCleanup})
            m->registerHook(base+0xbdac0, extract_virtual(V, (void(D::*)()){&D::removeMeAndCleanup}));

        if ((void($CCCircleWave::*)()){&$CCCircleWave::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xbd960, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($CCCircleWave::*)(float, char const*)){&$CCCircleWave::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0xbd710, extract_virtual(V, (void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((CCCircleWave*(*)(float, float, float, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool)){&D::create})
            m->registerHook(base+0xbd270, (CCCircleWave*(*)(float, float, float, bool)){&D::create});

        if ((CCCircleWave*(*)(float, float, float, bool, bool)){&$CCCircleWave::create} != (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create})
            m->registerHook(base+0xbd290, (CCCircleWave*(*)(float, float, float, bool, bool)){&D::create});

        if ((bool($CCCircleWave::*)(float, float, float, bool, bool)){&$CCCircleWave::init} != (bool(D::*)(float, float, float, bool, bool)){&D::init})
            m->registerHook(base+0xbd380, extract((bool(D::*)(float, float, float, bool, bool)){&D::init}));

        if ((void($CCCircleWave::*)(cocos2d::CCNode*, bool)){&$CCCircleWave::followObject} != (void(D::*)(cocos2d::CCNode*, bool)){&D::followObject})
            m->registerHook(base+0xbd670, extract((void(D::*)(cocos2d::CCNode*, bool)){&D::followObject}));

        if ((void($CCCircleWave::*)(float)){&$CCCircleWave::updatePosition} != (void(D::*)(float)){&D::updatePosition})
            m->registerHook(base+0xbd630, extract((void(D::*)(float)){&D::updatePosition}));
    }
};


template<class D>
class $CCCircleWaveDelegate : public CCCircleWaveDelegate, public $CacBase {
public:
    dupable ~$CCCircleWaveDelegate() override {}

    dupable $CCCircleWaveDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CCLightFlash : public CCLightFlash, public $CacBase {
public:
    dupable ~$CCLightFlash() override {}

    dupable bool init() override {
        if ((bool($CCLightFlash::*)()){&$CCLightFlash::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2958f0))(this);
        else return CCLightFlash::init();
    }

    dupable $CCLightFlash() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCLightFlash::*)()){&$CCLightFlash::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2958f0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $CCLightStrip : public CCLightStrip, public $CacBase {
public:
    dupable ~$CCLightStrip() override {}

    dupable void draw() override {
        if ((void($CCLightStrip::*)()){&$CCLightStrip::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x296410))(this);
        else return CCLightStrip::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) override {
        if ((void($CCLightStrip::*)(float, char const*)){&$CCLightStrip::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x2965a0))(this, p0, p1);
        else return CCLightStrip::updateTweenAction(p0, p1);
    }

    dupable $CCLightStrip() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCLightStrip::*)()){&$CCLightStrip::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x296410, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($CCLightStrip::*)(float, char const*)){&$CCLightStrip::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x2965a0, extract_virtual(V, (void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $CreatorLayer : public CreatorLayer, public $CacBase {
public:
    dupable ~$CreatorLayer() override {}

    dupable bool init() override {
        if ((bool($CreatorLayer::*)()){&$CreatorLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x141c10))(this);
        else return CreatorLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($CreatorLayer::*)()){&$CreatorLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x143950))(this);
        else return CreatorLayer::keyBackClicked();
    }

    dupable void sceneWillResume() override {
        if ((void($CreatorLayer::*)()){&$CreatorLayer::sceneWillResume} != (void(D::*)()){&D::sceneWillResume})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1438f0))(this);
        else return CreatorLayer::sceneWillResume();
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($CreatorLayer::*)(DialogLayer*)){&$CreatorLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x143830))(this, p0);
        else return CreatorLayer::dialogClosed(p0);
    }

    dupable $CreatorLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CreatorLayer::*)()){&$CreatorLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x141c10, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CreatorLayer::*)()){&$CreatorLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x143950, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CreatorLayer::*)()){&$CreatorLayer::sceneWillResume} != (void(D::*)()){&D::sceneWillResume})
            m->registerHook(base+0x1438f0, extract_virtual(V, (void(D::*)()){&D::sceneWillResume}));

        if ((void($CreatorLayer::*)(DialogLayer*)){&$CreatorLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x143830, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $FLAlertLayerProtocol : public FLAlertLayerProtocol, public $CacBase {
public:
    dupable ~$FLAlertLayerProtocol() override {}

    dupable $FLAlertLayerProtocol() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $FLAlertLayer : public FLAlertLayer, public $CacBase {
public:
    dupable ~$FLAlertLayer() override {}

    dupable void onEnter() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f350))(this);
        else return FLAlertLayer::onEnter();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ee40))(this, p0, p1);
        else return FLAlertLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f0a0))(this, p0, p1);
        else return FLAlertLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25ef60))(this, p0, p1);
        else return FLAlertLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x25f020))(this, p0, p1);
        else return FLAlertLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f2e0))(this);
        else return FLAlertLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25ed90))(this);
        else return FLAlertLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x25ece0))(this, p0);
        else return FLAlertLayer::keyDown(p0);
    }

    dupable void show() override {
        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25f120))(this);
        else return FLAlertLayer::show();
    }

    dupable bool init(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(base+0x25e1b0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::init(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)>(m->getOriginal(base+0x25e0e0))(p0, p1, p2, p3, p4, p5);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5);
    }

    dupable static FLAlertLayer* create(FLAlertLayerProtocol* p0, char const* p1, std::string p2, char const* p3, char const* p4, float p5, bool p6, float p7) {
        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create})
            return reinterpret_cast<FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)>(m->getOriginal(base+0x25dec0))(p0, p1, p2, p3, p4, p5, p6, p7);
        else return FLAlertLayer::create(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable $FLAlertLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x25f350, extract_virtual(V, (void(D::*)()){&D::onEnter}));

        if ((bool($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x25ee40, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x25f0a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x25ef60, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($FLAlertLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$FLAlertLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x25f020, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25f2e0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25ed90, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FLAlertLayer::*)(cocos2d::enumKeyCodes)){&$FLAlertLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x25ece0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($FLAlertLayer::*)()){&$FLAlertLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x25f120, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((bool($FLAlertLayer::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::init} != (bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init})
            m->registerHook(base+0x25e1b0, extract((bool(D::*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::init}));

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create})
            m->registerHook(base+0x25e0e0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float)){&D::create});

        if ((FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&$FLAlertLayer::create} != (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create})
            m->registerHook(base+0x25dec0, (FLAlertLayer*(*)(FLAlertLayerProtocol*, char const*, std::string, char const*, char const*, float, bool, float)){&D::create});
    }
};


template<class D>
class $GJHttpResult : public GJHttpResult, public $CacBase {
public:
    dupable ~$GJHttpResult() override {}

    dupable $GJHttpResult() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJRewardItem : public GJRewardItem, public $CacBase {
public:
    dupable ~$GJRewardItem() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) override {
        if ((void($GJRewardItem::*)(DS_Dictionary*)){&$GJRewardItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4d7f0))(this, p0);
        else return GJRewardItem::encodeWithCoder(p0);
    }

    dupable bool canEncode() override {
        if ((bool($GJRewardItem::*)()){&$GJRewardItem::canEncode} != (bool(D::*)()){&D::canEncode})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x4d850))(this);
        else return GJRewardItem::canEncode();
    }

    dupable $GJRewardItem() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRewardItem::*)(DS_Dictionary*)){&$GJRewardItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4d7f0, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((bool($GJRewardItem::*)()){&$GJRewardItem::canEncode} != (bool(D::*)()){&D::canEncode})
            m->registerHook(base+0x4d850, extract_virtual(V, (bool(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GauntletNode : public GauntletNode, public $CacBase {
public:
    dupable ~$GauntletNode() override {}

    dupable $GauntletNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $LoadingLayer : public LoadingLayer, public $CacBase {
public:
    dupable ~$LoadingLayer() override {}

    dupable $LoadingLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $OptionsLayer : public OptionsLayer, public $CacBase {
public:
    dupable ~$OptionsLayer() override {}

    dupable void customSetup() override {
        if ((void($OptionsLayer::*)()){&$OptionsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43dc70))(this);
        else return OptionsLayer::customSetup();
    }

    dupable void layerHidden() override {
        if ((void($OptionsLayer::*)()){&$OptionsLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43f200))(this);
        else return OptionsLayer::layerHidden();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($OptionsLayer::*)(FLAlertLayer*, bool)){&$OptionsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x43f270))(this, p0, p1);
        else return OptionsLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $OptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($OptionsLayer::*)()){&$OptionsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x43dc70, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($OptionsLayer::*)()){&$OptionsLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x43f200, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($OptionsLayer::*)(FLAlertLayer*, bool)){&$OptionsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x43f270, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $PlayerObject : public PlayerObject, public $CacBase {
public:
    dupable ~$PlayerObject() override {}

    dupable void update(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x218bf0))(this, p0);
        else return PlayerObject::update(p0);
    }

    dupable void setScaleX(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e7f0))(this, p0);
        else return PlayerObject::setScaleX(p0);
    }

    dupable void setScaleY(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e830))(this, p0);
        else return PlayerObject::setScaleY(p0);
    }

    dupable void setScale(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e870))(this, p0);
        else return PlayerObject::setScale(p0);
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x22c8b0))(this, p0);
        else return PlayerObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e8b0))(this, p0);
        else return PlayerObject::setVisible(p0);
    }

    dupable void setRotation(float p0) override {
        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x22e6e0))(this, p0);
        else return PlayerObject::setRotation(p0);
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x22d400))(this, p0);
        else return PlayerObject::setOpacity(p0);
    }

    dupable void setColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x22cdf0))(this, p0);
        else return PlayerObject::setColor(p0);
    }

    dupable void setFlipX(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e720))(this, p0);
        else return PlayerObject::setFlipX(p0);
    }

    dupable void setFlipY(bool p0) override {
        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x22e7b0))(this, p0);
        else return PlayerObject::setFlipY(p0);
    }

    dupable void resetObject() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x223170))(this);
        else return PlayerObject::resetObject();
    }

    dupable void getRealPosition() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x22d5f0))(this);
        else return PlayerObject::getRealPosition();
    }

    dupable void getOrientedBox() override {
        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x22dee0))(this);
        else return PlayerObject::getOrientedBox();
    }

    dupable void animationFinished(char const* p0) override {
        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x22e9d0))(this, p0);
        else return PlayerObject::animationFinished(p0);
    }

    dupable $PlayerObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlayerObject::*)(float)){&$PlayerObject::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x218bf0, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x22e7f0, extract_virtual(V, (void(D::*)(float)){&D::setScaleX}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x22e830, extract_virtual(V, (void(D::*)(float)){&D::setScaleY}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x22e870, extract_virtual(V, (void(D::*)(float)){&D::setScale}));

        if ((void($PlayerObject::*)(cocos2d::CCPoint const&)){&$PlayerObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x22c8b0, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x22e8b0, extract_virtual(V, (void(D::*)(bool)){&D::setVisible}));

        if ((void($PlayerObject::*)(float)){&$PlayerObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0x22e6e0, extract_virtual(V, (void(D::*)(float)){&D::setRotation}));

        if ((void($PlayerObject::*)(unsigned char)){&$PlayerObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x22d400, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($PlayerObject::*)(cocos2d::_ccColor3B const&)){&$PlayerObject::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0x22cdf0, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipX} != (void(D::*)(bool)){&D::setFlipX})
            m->registerHook(base+0x22e720, extract_virtual(V, (void(D::*)(bool)){&D::setFlipX}));

        if ((void($PlayerObject::*)(bool)){&$PlayerObject::setFlipY} != (void(D::*)(bool)){&D::setFlipY})
            m->registerHook(base+0x22e7b0, extract_virtual(V, (void(D::*)(bool)){&D::setFlipY}));

        if ((void($PlayerObject::*)()){&$PlayerObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0x223170, extract_virtual(V, (void(D::*)()){&D::resetObject}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getRealPosition} != (void(D::*)()){&D::getRealPosition})
            m->registerHook(base+0x22d5f0, extract_virtual(V, (void(D::*)()){&D::getRealPosition}));

        if ((void($PlayerObject::*)()){&$PlayerObject::getOrientedBox} != (void(D::*)()){&D::getOrientedBox})
            m->registerHook(base+0x22dee0, extract_virtual(V, (void(D::*)()){&D::getOrientedBox}));

        if ((void($PlayerObject::*)(char const*)){&$PlayerObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x22e9d0, extract_virtual(V, (void(D::*)(char const*)){&D::animationFinished}));
    }
};


template<class D>
class $SecretLayer2 : public SecretLayer2, public $CacBase {
public:
    dupable ~$SecretLayer2() override {}

    dupable bool init() override {
        if ((bool($SecretLayer2::*)()){&$SecretLayer2::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x25fe70))(this);
        else return SecretLayer2::init();
    }

    dupable void onExit() override {
        if ((void($SecretLayer2::*)()){&$SecretLayer2::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x266b30))(this);
        else return SecretLayer2::onExit();
    }

    dupable void keyBackClicked() override {
        if ((void($SecretLayer2::*)()){&$SecretLayer2::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x266a30))(this);
        else return SecretLayer2::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265880))(this, p0);
        else return SecretLayer2::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265a80))(this, p0);
        else return SecretLayer2::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x265ba0))(this, p0);
        else return SecretLayer2::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($SecretLayer2::*)(FLAlertLayer*, bool)){&$SecretLayer2::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x265860))(this, p0, p1);
        else return SecretLayer2::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($SecretLayer2::*)(DialogLayer*)){&$SecretLayer2::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x264880))(this, p0);
        else return SecretLayer2::dialogClosed(p0);
    }

    dupable $SecretLayer2() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer2::*)()){&$SecretLayer2::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x25fe70, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SecretLayer2::*)()){&$SecretLayer2::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x266b30, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($SecretLayer2::*)()){&$SecretLayer2::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x266a30, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x265880, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x265a80, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer2::*)(CCTextInputNode*)){&$SecretLayer2::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x265ba0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer2::*)(FLAlertLayer*, bool)){&$SecretLayer2::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x265860, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($SecretLayer2::*)(DialogLayer*)){&$SecretLayer2::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x264880, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SecretLayer3 : public SecretLayer3, public $CacBase {
public:
    dupable ~$SecretLayer3() override {}

    dupable bool init() override {
        if ((bool($SecretLayer3::*)()){&$SecretLayer3::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x267040))(this);
        else return SecretLayer3::init();
    }

    dupable void onExit() override {
        if ((void($SecretLayer3::*)()){&$SecretLayer3::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c270))(this);
        else return SecretLayer3::onExit();
    }

    dupable void keyBackClicked() override {
        if ((void($SecretLayer3::*)()){&$SecretLayer3::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c240))(this);
        else return SecretLayer3::keyBackClicked();
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($SecretLayer3::*)(DialogLayer*)){&$SecretLayer3::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x26bf10))(this, p0);
        else return SecretLayer3::dialogClosed(p0);
    }

    dupable $SecretLayer3() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer3::*)()){&$SecretLayer3::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x267040, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SecretLayer3::*)()){&$SecretLayer3::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x26c270, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($SecretLayer3::*)()){&$SecretLayer3::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x26c240, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer3::*)(DialogLayer*)){&$SecretLayer3::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x26bf10, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SecretLayer4 : public SecretLayer4, public $CacBase {
public:
    dupable ~$SecretLayer4() override {}

    dupable bool init() override {
        if ((bool($SecretLayer4::*)()){&$SecretLayer4::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1ed640))(this);
        else return SecretLayer4::init();
    }

    dupable void onExit() override {
        if ((void($SecretLayer4::*)()){&$SecretLayer4::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1f2220))(this);
        else return SecretLayer4::onExit();
    }

    dupable void keyBackClicked() override {
        if ((void($SecretLayer4::*)()){&$SecretLayer4::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1f2120))(this);
        else return SecretLayer4::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f0ff0))(this, p0);
        else return SecretLayer4::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f11f0))(this, p0);
        else return SecretLayer4::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1f1310))(this, p0);
        else return SecretLayer4::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($SecretLayer4::*)(FLAlertLayer*, bool)){&$SecretLayer4::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1f0fd0))(this, p0, p1);
        else return SecretLayer4::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($SecretLayer4::*)(DialogLayer*)){&$SecretLayer4::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x1f0a90))(this, p0);
        else return SecretLayer4::dialogClosed(p0);
    }

    dupable $SecretLayer4() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretLayer4::*)()){&$SecretLayer4::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1ed640, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SecretLayer4::*)()){&$SecretLayer4::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x1f2220, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($SecretLayer4::*)()){&$SecretLayer4::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1f2120, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1f0ff0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1f11f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SecretLayer4::*)(CCTextInputNode*)){&$SecretLayer4::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1f1310, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SecretLayer4::*)(FLAlertLayer*, bool)){&$SecretLayer4::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1f0fd0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($SecretLayer4::*)(DialogLayer*)){&$SecretLayer4::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x1f0a90, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $SetTextPopup : public SetTextPopup, public $CacBase {
public:
    dupable ~$SetTextPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetTextPopup::*)()){&$SetTextPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x157050))(this);
        else return SetTextPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetTextPopup::*)()){&$SetTextPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x157000))(this);
        else return SetTextPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x156ef0))(this, p0);
        else return SetTextPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x156f30))(this, p0);
        else return SetTextPopup::textChanged(p0);
    }

    dupable $SetTextPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetTextPopup::*)()){&$SetTextPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x157050, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetTextPopup::*)()){&$SetTextPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x157000, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x156ef0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetTextPopup::*)(CCTextInputNode*)){&$SetTextPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x156f30, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $SimplePlayer : public SimplePlayer, public $CacBase {
public:
    dupable ~$SimplePlayer() override {}

    dupable void setOpacity(unsigned char p0) override {
        if ((void($SimplePlayer::*)(unsigned char)){&$SimplePlayer::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1bcc40))(this, p0);
        else return SimplePlayer::setOpacity(p0);
    }

    dupable void setColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0x1bc9b0))(this, p0);
        else return SimplePlayer::setColor(p0);
    }

    dupable $SimplePlayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SimplePlayer::*)(unsigned char)){&$SimplePlayer::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1bcc40, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($SimplePlayer::*)(cocos2d::_ccColor3B const&)){&$SimplePlayer::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0x1bc9b0, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));
    }
};


template<class D>
class $SlideInLayer : public SlideInLayer, public $CacBase {
public:
    dupable ~$SlideInLayer() override {}

    dupable bool init() override {
        if ((bool($SlideInLayer::*)()){&$SlideInLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x138cf0))(this);
        else return SlideInLayer::init();
    }

    dupable void draw() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1394a0))(this);
        else return SlideInLayer::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1394d0))(this, p0, p1);
        else return SlideInLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x139530))(this, p0, p1);
        else return SlideInLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1394f0))(this, p0, p1);
        else return SlideInLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x139510))(this, p0, p1);
        else return SlideInLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139190))(this);
        else return SlideInLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1391d0))(this);
        else return SlideInLayer::keyBackClicked();
    }

    dupable void customSetup() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139110))(this);
        else return SlideInLayer::customSetup();
    }

    dupable void enterLayer() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139160))(this);
        else return SlideInLayer::enterLayer();
    }

    dupable void exitLayer(cocos2d::CCObject* p0) override {
        if ((void($SlideInLayer::*)(cocos2d::CCObject*)){&$SlideInLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x139210))(this, p0);
        else return SlideInLayer::exitLayer(p0);
    }

    dupable void showLayer(bool p0) override {
        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x139270))(this, p0);
        else return SlideInLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) override {
        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x139360))(this, p0);
        else return SlideInLayer::hideLayer(p0);
    }

    dupable void layerVisible() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139440))(this);
        else return SlideInLayer::layerVisible();
    }

    dupable void layerHidden() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139460))(this);
        else return SlideInLayer::layerHidden();
    }

    dupable void enterAnimFinished() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139430))(this);
        else return SlideInLayer::enterAnimFinished();
    }

    dupable void disableUI() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139120))(this);
        else return SlideInLayer::disableUI();
    }

    dupable void enableUI() override {
        if ((void($SlideInLayer::*)()){&$SlideInLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x139140))(this);
        else return SlideInLayer::enableUI();
    }

    dupable $SlideInLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SlideInLayer::*)()){&$SlideInLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x138cf0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x1394a0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x1394d0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x139530, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x1394f0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($SlideInLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SlideInLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x139510, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x139190, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1391d0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x139110, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x139160, extract_virtual(V, (void(D::*)()){&D::enterLayer}));

        if ((void($SlideInLayer::*)(cocos2d::CCObject*)){&$SlideInLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(base+0x139210, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x139270, extract_virtual(V, (void(D::*)(bool)){&D::showLayer}));

        if ((void($SlideInLayer::*)(bool)){&$SlideInLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x139360, extract_virtual(V, (void(D::*)(bool)){&D::hideLayer}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x139440, extract_virtual(V, (void(D::*)()){&D::layerVisible}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x139460, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x139430, extract_virtual(V, (void(D::*)()){&D::enterAnimFinished}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x139120, extract_virtual(V, (void(D::*)()){&D::disableUI}));

        if ((void($SlideInLayer::*)()){&$SlideInLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x139140, extract_virtual(V, (void(D::*)()){&D::enableUI}));
    }
};


template<class D>
class $SupportLayer : public SupportLayer, public $CacBase {
public:
    dupable ~$SupportLayer() override {}

    dupable void customSetup() override {
        if ((void($SupportLayer::*)()){&$SupportLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d90b0))(this);
        else return SupportLayer::customSetup();
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x1d9de0))(this, p0, p1);
        else return SupportLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x1d9f00))(this, p0, p1);
        else return SupportLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($SupportLayer::*)(UploadActionPopup*)){&$SupportLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x1d9d90))(this, p0);
        else return SupportLayer::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($SupportLayer::*)(FLAlertLayer*, bool)){&$SupportLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1da170))(this, p0, p1);
        else return SupportLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $SupportLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SupportLayer::*)()){&$SupportLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x1d90b0, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x1d9de0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($SupportLayer::*)(int, int)){&$SupportLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x1d9f00, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($SupportLayer::*)(UploadActionPopup*)){&$SupportLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x1d9d90, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($SupportLayer::*)(FLAlertLayer*, bool)){&$SupportLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1da170, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $CreateMenuItem : public CreateMenuItem, public $CacBase {
public:
    dupable ~$CreateMenuItem() override {}

    dupable $CreateMenuItem() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $BoomListLayer : public BoomListLayer, public $CacBase {
public:
    dupable ~$BoomListLayer() override {}

    dupable $BoomListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CCAlertCircle : public CCAlertCircle, public $CacBase {
public:
    dupable ~$CCAlertCircle() override {}

    dupable bool init() override {
        if ((bool($CCAlertCircle::*)()){&$CCAlertCircle::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xbdea0))(this);
        else return CCAlertCircle::init();
    }

    dupable void draw() override {
        if ((void($CCAlertCircle::*)()){&$CCAlertCircle::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xbdf40))(this);
        else return CCAlertCircle::draw();
    }

    dupable $CCAlertCircle() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCAlertCircle::*)()){&$CCAlertCircle::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xbdea0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CCAlertCircle::*)()){&$CCAlertCircle::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xbdf40, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ChallengeNode : public ChallengeNode, public $CacBase {
public:
    dupable ~$ChallengeNode() override {}

    dupable $ChallengeNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $DrawGridLayer : public DrawGridLayer, public $CacBase {
public:
    dupable ~$DrawGridLayer() override {}

    dupable void update(float p0) override {
        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xa3b30))(this, p0);
        else return DrawGridLayer::update(p0);
    }

    dupable $DrawGridLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DrawGridLayer::*)(float)){&$DrawGridLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0xa3b30, extract_virtual(V, (void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $EditButtonBar : public EditButtonBar, public $CacBase {
public:
    dupable ~$EditButtonBar() override {}

    dupable void loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) {
        if ((void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, int, int, bool)>(m->getOriginal(base+0x351010))(this, p0, p1, p2, p3);
        else return EditButtonBar::loadFromItems(p0, p1, p2, p3);
    }

    dupable $EditButtonBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditButtonBar::*)(cocos2d::CCArray*, int, int, bool)){&$EditButtonBar::loadFromItems} != (void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems})
            m->registerHook(base+0x351010, extract((void(D::*)(cocos2d::CCArray*, int, int, bool)){&D::loadFromItems}));
    }
};


template<class D>
class $ExtendedLayer : public ExtendedLayer, public $CacBase {
public:
    dupable ~$ExtendedLayer() override {}

    dupable bool init() override {
        if ((bool($ExtendedLayer::*)()){&$ExtendedLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1e41e0))(this);
        else return ExtendedLayer::init();
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($ExtendedLayer::*)(cocos2d::CCPoint const&)){&$ExtendedLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x1e41f0))(this, p0);
        else return ExtendedLayer::setPosition(p0);
    }

    dupable $ExtendedLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ExtendedLayer::*)()){&$ExtendedLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1e41e0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ExtendedLayer::*)(cocos2d::CCPoint const&)){&$ExtendedLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x1e41f0, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));
    }
};


template<class D>
class $GJChestSprite : public GJChestSprite, public $CacBase {
public:
    dupable ~$GJChestSprite() override {}

    dupable void setColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($GJChestSprite::*)(cocos2d::_ccColor3B const&)){&$GJChestSprite::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xf8270))(this, p0);
        else return GJChestSprite::setColor(p0);
    }

    dupable $GJChestSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJChestSprite::*)(cocos2d::_ccColor3B const&)){&$GJChestSprite::setColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor})
            m->registerHook(base+0xf8270, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setColor}));
    }
};


template<class D>
class $GJGarageLayer : public GJGarageLayer, public $CacBase {
public:
    dupable ~$GJGarageLayer() override {}

    dupable bool init() override {
        if ((bool($GJGarageLayer::*)()){&$GJGarageLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1b4980))(this);
        else return GJGarageLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bb630))(this);
        else return GJGarageLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b7dc0))(this, p0);
        else return GJGarageLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b8040))(this, p0);
        else return GJGarageLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b82c0))(this, p0);
        else return GJGarageLayer::textChanged(p0);
    }

    dupable void listButtonBarSwitchedPage(ListButtonBar* p0, int p1) override {
        if ((void($GJGarageLayer::*)(ListButtonBar*, int)){&$GJGarageLayer::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            return reinterpret_cast<void(*)(decltype(this), ListButtonBar*, int)>(m->getOriginal(base+0x1bad10))(this, p0, p1);
        else return GJGarageLayer::listButtonBarSwitchedPage(p0, p1);
    }

    dupable void updateRate() override {
        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::updateRate} != (void(D::*)()){&D::updateRate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bb420))(this);
        else return GJGarageLayer::updateRate();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJGarageLayer::*)(FLAlertLayer*, bool)){&$GJGarageLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1bb050))(this, p0, p1);
        else return GJGarageLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($GJGarageLayer::*)(DialogLayer*)){&$GJGarageLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x1bb160))(this, p0);
        else return GJGarageLayer::dialogClosed(p0);
    }

    dupable $GJGarageLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJGarageLayer::*)()){&$GJGarageLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1b4980, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1bb630, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1b7dc0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1b8040, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJGarageLayer::*)(CCTextInputNode*)){&$GJGarageLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1b82c0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJGarageLayer::*)(ListButtonBar*, int)){&$GJGarageLayer::listButtonBarSwitchedPage} != (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage})
            m->registerHook(base+0x1bad10, extract_virtual(V, (void(D::*)(ListButtonBar*, int)){&D::listButtonBarSwitchedPage}));

        if ((void($GJGarageLayer::*)()){&$GJGarageLayer::updateRate} != (void(D::*)()){&D::updateRate})
            m->registerHook(base+0x1bb420, extract_virtual(V, (void(D::*)()){&D::updateRate}));

        if ((void($GJGarageLayer::*)(FLAlertLayer*, bool)){&$GJGarageLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1bb050, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJGarageLayer::*)(DialogLayer*)){&$GJGarageLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x1bb160, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $GJGroundLayer : public GJGroundLayer, public $CacBase {
public:
    dupable ~$GJGroundLayer() override {}

    dupable void draw() override {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x356a60))(this);
        else return GJGroundLayer::draw();
    }

    dupable void showGround() override {
        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::showGround} != (void(D::*)()){&D::showGround})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x356920))(this);
        else return GJGroundLayer::showGround();
    }

    dupable void fadeInGround(float p0) override {
        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeInGround} != (void(D::*)(float)){&D::fadeInGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x356930))(this, p0);
        else return GJGroundLayer::fadeInGround(p0);
    }

    dupable void fadeOutGround(float p0) override {
        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeOutGround} != (void(D::*)(float)){&D::fadeOutGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x356a30))(this, p0);
        else return GJGroundLayer::fadeOutGround(p0);
    }

    dupable $GJGroundLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x356a60, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($GJGroundLayer::*)()){&$GJGroundLayer::showGround} != (void(D::*)()){&D::showGround})
            m->registerHook(base+0x356920, extract_virtual(V, (void(D::*)()){&D::showGround}));

        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeInGround} != (void(D::*)(float)){&D::fadeInGround})
            m->registerHook(base+0x356930, extract_virtual(V, (void(D::*)(float)){&D::fadeInGround}));

        if ((void($GJGroundLayer::*)(float)){&$GJGroundLayer::fadeOutGround} != (void(D::*)(float)){&D::fadeOutGround})
            m->registerHook(base+0x356a30, extract_virtual(V, (void(D::*)(float)){&D::fadeOutGround}));
    }
};


template<class D>
class $GJMessageCell : public GJMessageCell, public $CacBase {
public:
    dupable ~$GJMessageCell() override {}

    dupable bool init() override {
        if ((bool($GJMessageCell::*)()){&$GJMessageCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11fc00))(this);
        else return GJMessageCell::init();
    }

    dupable void draw() override {
        if ((void($GJMessageCell::*)()){&$GJMessageCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11fef0))(this);
        else return GJMessageCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJMessageCell::*)(FLAlertLayer*, bool)){&$GJMessageCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11ffc0))(this, p0, p1);
        else return GJMessageCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x120180))(this, p0, p1);
        else return GJMessageCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x120310))(this, p0, p1);
        else return GJMessageCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($GJMessageCell::*)(UploadActionPopup*)){&$GJMessageCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x120410))(this, p0);
        else return GJMessageCell::onClosePopup(p0);
    }

    dupable $GJMessageCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJMessageCell::*)()){&$GJMessageCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11fc00, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJMessageCell::*)()){&$GJMessageCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11fef0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($GJMessageCell::*)(FLAlertLayer*, bool)){&$GJMessageCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11ffc0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x120180, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJMessageCell::*)(int, int)){&$GJMessageCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x120310, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJMessageCell::*)(UploadActionPopup*)){&$GJMessageCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x120410, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJRequestCell : public GJRequestCell, public $CacBase {
public:
    dupable ~$GJRequestCell() override {}

    dupable bool init() override {
        if ((bool($GJRequestCell::*)()){&$GJRequestCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11f080))(this);
        else return GJRequestCell::init();
    }

    dupable void draw() override {
        if ((void($GJRequestCell::*)()){&$GJRequestCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11f390))(this);
        else return GJRequestCell::draw();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJRequestCell::*)(FLAlertLayer*, bool)){&$GJRequestCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x11f460))(this, p0, p1);
        else return GJRequestCell::FLAlert_Clicked(p0, p1);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11f640))(this, p0, p1);
        else return GJRequestCell::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x11f800))(this, p0, p1);
        else return GJRequestCell::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($GJRequestCell::*)(UploadActionPopup*)){&$GJRequestCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x11f930))(this, p0);
        else return GJRequestCell::onClosePopup(p0);
    }

    dupable $GJRequestCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRequestCell::*)()){&$GJRequestCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11f080, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJRequestCell::*)()){&$GJRequestCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11f390, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($GJRequestCell::*)(FLAlertLayer*, bool)){&$GJRequestCell::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x11f460, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x11f640, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJRequestCell::*)(int, int)){&$GJRequestCell::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x11f800, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJRequestCell::*)(UploadActionPopup*)){&$GJRequestCell::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x11f930, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJRobotSprite : public GJRobotSprite, public $CacBase {
public:
    dupable ~$GJRobotSprite() override {}

    dupable bool init() override {
        if ((bool($GJRobotSprite::*)()){&$GJRobotSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x34ad50))(this);
        else return GJRobotSprite::init();
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($GJRobotSprite::*)(unsigned char)){&$GJRobotSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x34bcc0))(this, p0);
        else return GJRobotSprite::setOpacity(p0);
    }

    dupable void hideSecondary() override {
        if ((void($GJRobotSprite::*)()){&$GJRobotSprite::hideSecondary} != (void(D::*)()){&D::hideSecondary})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34c3b0))(this);
        else return GJRobotSprite::hideSecondary();
    }

    dupable $GJRobotSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRobotSprite::*)()){&$GJRobotSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x34ad50, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJRobotSprite::*)(unsigned char)){&$GJRobotSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x34bcc0, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($GJRobotSprite::*)()){&$GJRobotSprite::hideSecondary} != (void(D::*)()){&D::hideSecondary})
            m->registerHook(base+0x34c3b0, extract_virtual(V, (void(D::*)()){&D::hideSecondary}));
    }
};


template<class D>
class $GJSongBrowser : public GJSongBrowser, public $CacBase {
public:
    dupable ~$GJSongBrowser() override {}

    dupable void customSetup() override {
        if ((void($GJSongBrowser::*)()){&$GJSongBrowser::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x368ab0))(this);
        else return GJSongBrowser::customSetup();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJSongBrowser::*)(FLAlertLayer*, bool)){&$GJSongBrowser::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x3690a0))(this, p0, p1);
        else return GJSongBrowser::FLAlert_Clicked(p0, p1);
    }

    dupable $GJSongBrowser() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJSongBrowser::*)()){&$GJSongBrowser::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x368ab0, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($GJSongBrowser::*)(FLAlertLayer*, bool)){&$GJSongBrowser::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x3690a0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJSpriteColor : public GJSpriteColor, public $CacBase {
public:
    dupable ~$GJSpriteColor() override {}

    dupable bool init() override {
        if ((bool($GJSpriteColor::*)()){&$GJSpriteColor::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x343c90))(this);
        else return GJSpriteColor::init();
    }

    dupable $GJSpriteColor() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJSpriteColor::*)()){&$GJSpriteColor::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x343c90, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJUserMessage : public GJUserMessage, public $CacBase {
public:
    dupable ~$GJUserMessage() override {}

    dupable bool init() override {
        if ((bool($GJUserMessage::*)()){&$GJUserMessage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2debf0))(this);
        else return GJUserMessage::init();
    }

    dupable $GJUserMessage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJUserMessage::*)()){&$GJUserMessage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2debf0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GauntletLayer : public GauntletLayer, public $CacBase {
public:
    dupable ~$GauntletLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GauntletLayer::*)()){&$GauntletLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d5e20))(this);
        else return GauntletLayer::keyBackClicked();
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($GauntletLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x1d5410))(this, p0, p1);
        else return GauntletLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) override {
        if ((void($GauntletLayer::*)(char const*)){&$GauntletLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1d55d0))(this, p0);
        else return GauntletLayer::loadLevelsFailed(p0);
    }

    dupable $GauntletLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GauntletLayer::*)()){&$GauntletLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d5e20, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GauntletLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x1d5410, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($GauntletLayer::*)(char const*)){&$GauntletLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x1d55d0, extract_virtual(V, (void(D::*)(char const*)){&D::loadLevelsFailed}));
    }
};


template<class D>
class $LikeItemLayer : public LikeItemLayer, public $CacBase {
public:
    dupable ~$LikeItemLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($LikeItemLayer::*)()){&$LikeItemLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35ff20))(this);
        else return LikeItemLayer::keyBackClicked();
    }

    dupable $LikeItemLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LikeItemLayer::*)()){&$LikeItemLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x35ff20, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $ListButtonBar : public ListButtonBar, public $CacBase {
public:
    dupable ~$ListButtonBar() override {}

    dupable $ListButtonBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $LoadingCircle : public LoadingCircle, public $CacBase {
public:
    dupable ~$LoadingCircle() override {}

    dupable bool init() override {
        if ((bool($LoadingCircle::*)()){&$LoadingCircle::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x277f00))(this);
        else return LoadingCircle::init();
    }

    dupable void draw() override {
        if ((void($LoadingCircle::*)()){&$LoadingCircle::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x278170))(this);
        else return LoadingCircle::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781d0))(this, p0, p1);
        else return LoadingCircle::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781e0))(this, p0, p1);
        else return LoadingCircle::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2781f0))(this, p0, p1);
        else return LoadingCircle::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x278200))(this, p0, p1);
        else return LoadingCircle::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($LoadingCircle::*)()){&$LoadingCircle::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x278190))(this);
        else return LoadingCircle::registerWithTouchDispatcher();
    }

    dupable $LoadingCircle() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LoadingCircle::*)()){&$LoadingCircle::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x277f00, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($LoadingCircle::*)()){&$LoadingCircle::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x278170, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2781d0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2781e0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2781f0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($LoadingCircle::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LoadingCircle::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x278200, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($LoadingCircle::*)()){&$LoadingCircle::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x278190, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $MenuGameLayer : public MenuGameLayer, public $CacBase {
public:
    dupable ~$MenuGameLayer() override {}

    dupable void update(float p0) override {
        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x28fa70))(this, p0);
        else return MenuGameLayer::update(p0);
    }

    dupable bool init() override {
        if ((bool($MenuGameLayer::*)()){&$MenuGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x28f150))(this);
        else return MenuGameLayer::init();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290650))(this, p0, p1);
        else return MenuGameLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290770))(this, p0, p1);
        else return MenuGameLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x290790))(this, p0, p1);
        else return MenuGameLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2907b0))(this, p0, p1);
        else return MenuGameLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2907f0))(this);
        else return MenuGameLayer::registerWithTouchDispatcher();
    }

    dupable $MenuGameLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MenuGameLayer::*)(float)){&$MenuGameLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x28fa70, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((bool($MenuGameLayer::*)()){&$MenuGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x28f150, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((bool($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x290650, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x290770, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x290790, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($MenuGameLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$MenuGameLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2907b0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($MenuGameLayer::*)()){&$MenuGameLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x2907f0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $MyLevelsLayer : public MyLevelsLayer, public $CacBase {
public:
    dupable ~$MyLevelsLayer() override {}

    dupable bool init() override {
        if ((bool($MyLevelsLayer::*)()){&$MyLevelsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x35470))(this);
        else return MyLevelsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($MyLevelsLayer::*)()){&$MyLevelsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35b90))(this);
        else return MyLevelsLayer::keyBackClicked();
    }

    dupable $MyLevelsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MyLevelsLayer::*)()){&$MyLevelsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x35470, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MyLevelsLayer::*)()){&$MyLevelsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x35b90, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $ObjectDecoder : public ObjectDecoder, public $CacBase {
public:
    dupable ~$ObjectDecoder() override {}

    dupable bool init() override {
        if ((bool($ObjectDecoder::*)()){&$ObjectDecoder::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x437f80))(this);
        else return ObjectDecoder::init();
    }

    dupable $ObjectDecoder() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectDecoder::*)()){&$ObjectDecoder::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x437f80, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ObjectManager : public ObjectManager, public $CacBase {
public:
    dupable ~$ObjectManager() override {}

    dupable bool init() override {
        if ((bool($ObjectManager::*)()){&$ObjectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x43b280))(this);
        else return ObjectManager::init();
    }

    dupable $ObjectManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectManager::*)()){&$ObjectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x43b280, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ObjectToolbox : public ObjectToolbox, public $CacBase {
public:
    dupable ~$ObjectToolbox() override {}

    dupable bool init() override {
        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3b2d80))(this);
        else return ObjectToolbox::init();
    }

    dupable char const* intKeyToFrame(int p0) {
        if ((char const*($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame} != (char const*(D::*)(int)){&D::intKeyToFrame})
            return reinterpret_cast<char const*(*)(decltype(this), int)>(m->getOriginal(base+0x4173b0))(this, p0);
        else return ObjectToolbox::intKeyToFrame(p0);
    }

    dupable static ObjectToolbox* sharedState() {
        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            return reinterpret_cast<ObjectToolbox*(*)()>(m->getOriginal(base+0x3b2bc0))();
        else return ObjectToolbox::sharedState();
    }

    dupable $ObjectToolbox() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ObjectToolbox::*)()){&$ObjectToolbox::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3b2d80, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((char const*($ObjectToolbox::*)(int)){&$ObjectToolbox::intKeyToFrame} != (char const*(D::*)(int)){&D::intKeyToFrame})
            m->registerHook(base+0x4173b0, extract((char const*(D::*)(int)){&D::intKeyToFrame}));

        if ((ObjectToolbox*(*)()){&$ObjectToolbox::sharedState} != (ObjectToolbox*(*)()){&D::sharedState})
            m->registerHook(base+0x3b2bc0, (ObjectToolbox*(*)()){&D::sharedState});
    }
};


template<class D>
class $SongInfoLayer : public SongInfoLayer, public $CacBase {
public:
    dupable ~$SongInfoLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SongInfoLayer::*)()){&$SongInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x36a980))(this);
        else return SongInfoLayer::keyBackClicked();
    }

    dupable $SongInfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongInfoLayer::*)()){&$SongInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x36a980, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TableViewCell : public TableViewCell, public $CacBase {
public:
    dupable ~$TableViewCell() override {}

    dupable $TableViewCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TutorialLayer : public TutorialLayer, public $CacBase {
public:
    dupable ~$TutorialLayer() override {}

    dupable bool init() override {
        if ((bool($TutorialLayer::*)()){&$TutorialLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x286e00))(this);
        else return TutorialLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($TutorialLayer::*)()){&$TutorialLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2878d0))(this);
        else return TutorialLayer::keyBackClicked();
    }

    dupable $TutorialLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($TutorialLayer::*)()){&$TutorialLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x286e00, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($TutorialLayer::*)()){&$TutorialLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2878d0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TutorialPopup : public TutorialPopup, public $CacBase {
public:
    dupable ~$TutorialPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($TutorialPopup::*)()){&$TutorialPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x344ae0))(this);
        else return TutorialPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($TutorialPopup::*)()){&$TutorialPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x344bb0))(this);
        else return TutorialPopup::show();
    }

    dupable $TutorialPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TutorialPopup::*)()){&$TutorialPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x344ae0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($TutorialPopup::*)()){&$TutorialPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x344bb0, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $AchievementBar : public AchievementBar, public $CacBase {
public:
    dupable ~$AchievementBar() override {}

    dupable void setOpacity(unsigned char p0) override {
        if ((void($AchievementBar::*)(unsigned char)){&$AchievementBar::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x37b9b0))(this, p0);
        else return AchievementBar::setOpacity(p0);
    }

    dupable $AchievementBar() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AchievementBar::*)(unsigned char)){&$AchievementBar::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x37b9b0, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $CCContentLayer : public CCContentLayer, public $CacBase {
public:
    dupable ~$CCContentLayer() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($CCContentLayer::*)(cocos2d::CCPoint const&)){&$CCContentLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x464c60))(this, p0);
        else return CCContentLayer::setPosition(p0);
    }

    dupable $CCContentLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCContentLayer::*)(cocos2d::CCPoint const&)){&$CCContentLayer::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x464c60, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));
    }
};


template<class D>
class $CCCounterLabel : public CCCounterLabel, public $CacBase {
public:
    dupable ~$CCCounterLabel() override {}

    dupable $CCCounterLabel() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $ChallengesPage : public ChallengesPage, public $CacBase {
public:
    dupable ~$ChallengesPage() override {}

    dupable bool init() override {
        if ((bool($ChallengesPage::*)()){&$ChallengesPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1db520))(this);
        else return ChallengesPage::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dcc50))(this);
        else return ChallengesPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dcbc0))(this);
        else return ChallengesPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dca10))(this);
        else return ChallengesPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($ChallengesPage::*)(FLAlertLayer*, bool)){&$ChallengesPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1dcba0))(this, p0, p1);
        else return ChallengesPage::FLAlert_Clicked(p0, p1);
    }

    dupable void challengeStatusFinished() override {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFinished} != (void(D::*)()){&D::challengeStatusFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dc520))(this);
        else return ChallengesPage::challengeStatusFinished();
    }

    dupable void challengeStatusFailed() override {
        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFailed} != (void(D::*)()){&D::challengeStatusFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dc830))(this);
        else return ChallengesPage::challengeStatusFailed();
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) override {
        if ((void($ChallengesPage::*)(CurrencyRewardLayer*)){&$ChallengesPage::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0x1dcdb0))(this, p0);
        else return ChallengesPage::currencyWillExit(p0);
    }

    dupable $ChallengesPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ChallengesPage::*)()){&$ChallengesPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1db520, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1dcc50, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1dcbc0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1dca10, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($ChallengesPage::*)(FLAlertLayer*, bool)){&$ChallengesPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1dcba0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFinished} != (void(D::*)()){&D::challengeStatusFinished})
            m->registerHook(base+0x1dc520, extract_virtual(V, (void(D::*)()){&D::challengeStatusFinished}));

        if ((void($ChallengesPage::*)()){&$ChallengesPage::challengeStatusFailed} != (void(D::*)()){&D::challengeStatusFailed})
            m->registerHook(base+0x1dc830, extract_virtual(V, (void(D::*)()){&D::challengeStatusFailed}));

        if ((void($ChallengesPage::*)(CurrencyRewardLayer*)){&$ChallengesPage::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0x1dcdb0, extract_virtual(V, (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));
    }
};


template<class D>
class $CurrencySprite : public CurrencySprite, public $CacBase {
public:
    dupable ~$CurrencySprite() override {}

    dupable $CurrencySprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CustomListView : public CustomListView, public $CacBase {
public:
    dupable ~$CustomListView() override {}

    dupable void setupList() override {
        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x116e70))(this);
        else return CustomListView::setupList();
    }

    dupable void getListCell(char const* p0) override {
        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x10d560))(this, p0);
        else return CustomListView::getListCell(p0);
    }

    dupable void loadCell(TableViewCell* p0, int p1) override {
        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            return reinterpret_cast<void(*)(decltype(this), TableViewCell*, int)>(m->getOriginal(base+0x10e610))(this, p0, p1);
        else return CustomListView::loadCell(p0, p1);
    }

    dupable $CustomListView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomListView::*)()){&$CustomListView::setupList} != (void(D::*)()){&D::setupList})
            m->registerHook(base+0x116e70, extract_virtual(V, (void(D::*)()){&D::setupList}));

        if ((void($CustomListView::*)(char const*)){&$CustomListView::getListCell} != (void(D::*)(char const*)){&D::getListCell})
            m->registerHook(base+0x10d560, extract_virtual(V, (void(D::*)(char const*)){&D::getListCell}));

        if ((void($CustomListView::*)(TableViewCell*, int)){&$CustomListView::loadCell} != (void(D::*)(TableViewCell*, int)){&D::loadCell})
            m->registerHook(base+0x10e610, extract_virtual(V, (void(D::*)(TableViewCell*, int)){&D::loadCell}));
    }
};


template<class D>
class $CustomSongCell : public CustomSongCell, public $CacBase {
public:
    dupable ~$CustomSongCell() override {}

    dupable bool init() override {
        if ((bool($CustomSongCell::*)()){&$CustomSongCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c440))(this);
        else return CustomSongCell::init();
    }

    dupable void draw() override {
        if ((void($CustomSongCell::*)()){&$CustomSongCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c5c0))(this);
        else return CustomSongCell::draw();
    }

    dupable $CustomSongCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CustomSongCell::*)()){&$CustomSongCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c440, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CustomSongCell::*)()){&$CustomSongCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c5c0, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $DailyLevelNode : public DailyLevelNode, public $CacBase {
public:
    dupable ~$DailyLevelNode() override {}

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($DailyLevelNode::*)(FLAlertLayer*, bool)){&$DailyLevelNode::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x10b750))(this, p0, p1);
        else return DailyLevelNode::FLAlert_Clicked(p0, p1);
    }

    dupable $DailyLevelNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DailyLevelNode::*)(FLAlertLayer*, bool)){&$DailyLevelNode::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x10b750, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $DailyLevelPage : public DailyLevelPage, public $CacBase {
public:
    dupable ~$DailyLevelPage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a6f0))(this);
        else return DailyLevelPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a660))(this);
        else return DailyLevelPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x10a4b0))(this);
        else return DailyLevelPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($DailyLevelPage::*)(FLAlertLayer*, bool)){&$DailyLevelPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x10a640))(this, p0, p1);
        else return DailyLevelPage::FLAlert_Clicked(p0, p1);
    }

    dupable void dailyStatusFinished(bool p0) override {
        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFinished} != (void(D::*)(bool)){&D::dailyStatusFinished})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x109be0))(this, p0);
        else return DailyLevelPage::dailyStatusFinished(p0);
    }

    dupable void dailyStatusFailed(bool p0) override {
        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFailed} != (void(D::*)(bool)){&D::dailyStatusFailed})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x10a090))(this, p0);
        else return DailyLevelPage::dailyStatusFailed(p0);
    }

    dupable void levelDownloadFinished(GJGameLevel* p0) override {
        if ((void($DailyLevelPage::*)(GJGameLevel*)){&$DailyLevelPage::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x10a1b0))(this, p0);
        else return DailyLevelPage::levelDownloadFinished(p0);
    }

    dupable void levelDownloadFailed(int p0) override {
        if ((void($DailyLevelPage::*)(int)){&$DailyLevelPage::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x10a280))(this, p0);
        else return DailyLevelPage::levelDownloadFailed(p0);
    }

    dupable $DailyLevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x10a6f0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x10a660, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($DailyLevelPage::*)()){&$DailyLevelPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x10a4b0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($DailyLevelPage::*)(FLAlertLayer*, bool)){&$DailyLevelPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x10a640, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFinished} != (void(D::*)(bool)){&D::dailyStatusFinished})
            m->registerHook(base+0x109be0, extract_virtual(V, (void(D::*)(bool)){&D::dailyStatusFinished}));

        if ((void($DailyLevelPage::*)(bool)){&$DailyLevelPage::dailyStatusFailed} != (void(D::*)(bool)){&D::dailyStatusFailed})
            m->registerHook(base+0x10a090, extract_virtual(V, (void(D::*)(bool)){&D::dailyStatusFailed}));

        if ((void($DailyLevelPage::*)(GJGameLevel*)){&$DailyLevelPage::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            m->registerHook(base+0x10a1b0, extract_virtual(V, (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished}));

        if ((void($DailyLevelPage::*)(int)){&$DailyLevelPage::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            m->registerHook(base+0x10a280, extract_virtual(V, (void(D::*)(int)){&D::levelDownloadFailed}));
    }
};


template<class D>
class $EditLevelLayer : public EditLevelLayer, public $CacBase {
public:
    dupable ~$EditLevelLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($EditLevelLayer::*)()){&$EditLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xe6670))(this);
        else return EditLevelLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($EditLevelLayer::*)(cocos2d::enumKeyCodes)){&$EditLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0xe66a0))(this, p0);
        else return EditLevelLayer::keyDown(p0);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) override {
        if ((void($EditLevelLayer::*)(SetIDPopup*, int)){&$EditLevelLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0xe6560))(this, p0, p1);
        else return EditLevelLayer::setIDPopupClosed(p0, p1);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($EditLevelLayer::*)(FLAlertLayer*, bool)){&$EditLevelLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xe5e70))(this, p0, p1);
        else return EditLevelLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe5540))(this, p0);
        else return EditLevelLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe51e0))(this, p0);
        else return EditLevelLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe57a0))(this, p0);
        else return EditLevelLayer::textChanged(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xe6740))(this, p0, p1);
        else return EditLevelLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xe68c0))(this, p0, p1);
        else return EditLevelLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($EditLevelLayer::*)(UploadActionPopup*)){&$EditLevelLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0xe66f0))(this, p0);
        else return EditLevelLayer::onClosePopup(p0);
    }

    dupable $EditLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditLevelLayer::*)()){&$EditLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xe6670, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($EditLevelLayer::*)(cocos2d::enumKeyCodes)){&$EditLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0xe66a0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditLevelLayer::*)(SetIDPopup*, int)){&$EditLevelLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0xe6560, extract_virtual(V, (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));

        if ((void($EditLevelLayer::*)(FLAlertLayer*, bool)){&$EditLevelLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xe5e70, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xe5540, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xe51e0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($EditLevelLayer::*)(CCTextInputNode*)){&$EditLevelLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xe57a0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0xe6740, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($EditLevelLayer::*)(int, int)){&$EditLevelLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0xe68c0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($EditLevelLayer::*)(UploadActionPopup*)){&$EditLevelLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0xe66f0, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $GJMessagePopup : public GJMessagePopup, public $CacBase {
public:
    dupable ~$GJMessagePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($GJMessagePopup::*)()){&$GJMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1504a0))(this);
        else return GJMessagePopup::keyBackClicked();
    }

    dupable void downloadMessageFinished(GJUserMessage* p0) override {
        if ((void($GJMessagePopup::*)(GJUserMessage*)){&$GJMessagePopup::downloadMessageFinished} != (void(D::*)(GJUserMessage*)){&D::downloadMessageFinished})
            return reinterpret_cast<void(*)(decltype(this), GJUserMessage*)>(m->getOriginal(base+0x150510))(this, p0);
        else return GJMessagePopup::downloadMessageFinished(p0);
    }

    dupable void downloadMessageFailed(int p0) override {
        if ((void($GJMessagePopup::*)(int)){&$GJMessagePopup::downloadMessageFailed} != (void(D::*)(int)){&D::downloadMessageFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1505e0))(this, p0);
        else return GJMessagePopup::downloadMessageFailed(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x150680))(this, p0, p1);
        else return GJMessagePopup::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x150820))(this, p0, p1);
        else return GJMessagePopup::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($GJMessagePopup::*)(UploadActionPopup*)){&$GJMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x150900))(this, p0);
        else return GJMessagePopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJMessagePopup::*)(FLAlertLayer*, bool)){&$GJMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x150a00))(this, p0, p1);
        else return GJMessagePopup::FLAlert_Clicked(p0, p1);
    }

    dupable $GJMessagePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMessagePopup::*)()){&$GJMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1504a0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMessagePopup::*)(GJUserMessage*)){&$GJMessagePopup::downloadMessageFinished} != (void(D::*)(GJUserMessage*)){&D::downloadMessageFinished})
            m->registerHook(base+0x150510, extract_virtual(V, (void(D::*)(GJUserMessage*)){&D::downloadMessageFinished}));

        if ((void($GJMessagePopup::*)(int)){&$GJMessagePopup::downloadMessageFailed} != (void(D::*)(int)){&D::downloadMessageFailed})
            m->registerHook(base+0x1505e0, extract_virtual(V, (void(D::*)(int)){&D::downloadMessageFailed}));

        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x150680, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($GJMessagePopup::*)(int, int)){&$GJMessagePopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x150820, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($GJMessagePopup::*)(UploadActionPopup*)){&$GJMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x150900, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($GJMessagePopup::*)(FLAlertLayer*, bool)){&$GJMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x150a00, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $GJOptionsLayer : public GJOptionsLayer, public $CacBase {
public:
    dupable ~$GJOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($GJOptionsLayer::*)()){&$GJOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x145c60))(this);
        else return GJOptionsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x147190))(this);
        else return GJOptionsLayer::keyBackClicked();
    }

    dupable void setupOptions() override {
        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1464d0))(this);
        else return GJOptionsLayer::setupOptions();
    }

    dupable void onClose(cocos2d::CCObject* p0) override {
        if ((void($GJOptionsLayer::*)(cocos2d::CCObject*)){&$GJOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x147160))(this, p0);
        else return GJOptionsLayer::onClose(p0);
    }

    dupable $GJOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJOptionsLayer::*)()){&$GJOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x145c60, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x147190, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJOptionsLayer::*)()){&$GJOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            m->registerHook(base+0x1464d0, extract_virtual(V, (void(D::*)()){&D::setupOptions}));

        if ((void($GJOptionsLayer::*)(cocos2d::CCObject*)){&$GJOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            m->registerHook(base+0x147160, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::onClose}));
    }
};


template<class D>
class $GJRewardObject : public GJRewardObject, public $CacBase {
public:
    dupable ~$GJRewardObject() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) override {
        if ((void($GJRewardObject::*)(DS_Dictionary*)){&$GJRewardObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4d170))(this, p0);
        else return GJRewardObject::encodeWithCoder(p0);
    }

    dupable bool canEncode() override {
        if ((bool($GJRewardObject::*)()){&$GJRewardObject::canEncode} != (bool(D::*)()){&D::canEncode})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x4d1f0))(this);
        else return GJRewardObject::canEncode();
    }

    dupable $GJRewardObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRewardObject::*)(DS_Dictionary*)){&$GJRewardObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4d170, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((bool($GJRewardObject::*)()){&$GJRewardObject::canEncode} != (bool(D::*)()){&D::canEncode})
            m->registerHook(base+0x4d1f0, extract_virtual(V, (bool(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GJScaleControl : public GJScaleControl, public $CacBase {
public:
    dupable ~$GJScaleControl() override {}

    dupable bool init() override {
        if ((bool($GJScaleControl::*)()){&$GJScaleControl::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x31b30))(this);
        else return GJScaleControl::init();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31d30))(this, p0, p1);
        else return GJScaleControl::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31e60))(this, p0, p1);
        else return GJScaleControl::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31fb0))(this, p0, p1);
        else return GJScaleControl::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x32060))(this, p0, p1);
        else return GJScaleControl::ccTouchCancelled(p0, p1);
    }

    dupable $GJScaleControl() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJScaleControl::*)()){&$GJScaleControl::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x31b30, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((bool($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x31d30, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x31e60, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x31fb0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJScaleControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJScaleControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x32060, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $GJSearchObject : public GJSearchObject, public $CacBase {
public:
    dupable ~$GJSearchObject() override {}

    dupable $GJSearchObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJSpiderSprite : public GJSpiderSprite, public $CacBase {
public:
    dupable ~$GJSpiderSprite() override {}

    dupable bool init() override {
        if ((bool($GJSpiderSprite::*)()){&$GJSpiderSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x34c700))(this);
        else return GJSpiderSprite::init();
    }

    dupable $GJSpiderSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJSpiderSprite::*)()){&$GJSpiderSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x34c700, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameObjectCopy : public GameObjectCopy, public $CacBase {
public:
    dupable ~$GameObjectCopy() override {}

    dupable $GameObjectCopy() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $HSVWidgetPopup : public HSVWidgetPopup, public $CacBase {
public:
    dupable ~$HSVWidgetPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($HSVWidgetPopup::*)()){&$HSVWidgetPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2371e0))(this);
        else return HSVWidgetPopup::keyBackClicked();
    }

    dupable $HSVWidgetPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($HSVWidgetPopup::*)()){&$HSVWidgetPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2371e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LevelInfoLayer : public LevelInfoLayer, public $CacBase {
public:
    dupable ~$LevelInfoLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x166160))(this);
        else return LevelInfoLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($LevelInfoLayer::*)(cocos2d::enumKeyCodes)){&$LevelInfoLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x166190))(this, p0);
        else return LevelInfoLayer::keyDown(p0);
    }

    dupable void numberInputClosed(NumberInputLayer* p0) override {
        if ((void($LevelInfoLayer::*)(NumberInputLayer*)){&$LevelInfoLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            return reinterpret_cast<void(*)(decltype(this), NumberInputLayer*)>(m->getOriginal(base+0x1657a0))(this, p0);
        else return LevelInfoLayer::numberInputClosed(p0);
    }

    dupable void levelDownloadFinished(GJGameLevel* p0) override {
        if ((void($LevelInfoLayer::*)(GJGameLevel*)){&$LevelInfoLayer::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x164c00))(this, p0);
        else return LevelInfoLayer::levelDownloadFinished(p0);
    }

    dupable void levelDownloadFailed(int p0) override {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x164d50))(this, p0);
        else return LevelInfoLayer::levelDownloadFailed(p0);
    }

    dupable void levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) override {
        if ((void($LevelInfoLayer::*)(GJGameLevel*, UpdateResponse)){&$LevelInfoLayer::levelUpdateFinished} != (void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*, UpdateResponse)>(m->getOriginal(base+0x164e60))(this, p0, p1);
        else return LevelInfoLayer::levelUpdateFinished(p0, p1);
    }

    dupable void levelUpdateFailed(int p0) override {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelUpdateFailed} != (void(D::*)(int)){&D::levelUpdateFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165010))(this, p0);
        else return LevelInfoLayer::levelUpdateFailed(p0);
    }

    dupable void levelDeleteFinished(int p0) override {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFinished} != (void(D::*)(int)){&D::levelDeleteFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165120))(this, p0);
        else return LevelInfoLayer::levelDeleteFinished(p0);
    }

    dupable void levelDeleteFailed(int p0) override {
        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFailed} != (void(D::*)(int)){&D::levelDeleteFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x165230))(this, p0);
        else return LevelInfoLayer::levelDeleteFailed(p0);
    }

    dupable void rateLevelClosed() override {
        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::rateLevelClosed} != (void(D::*)()){&D::rateLevelClosed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x165e60))(this);
        else return LevelInfoLayer::rateLevelClosed();
    }

    dupable void likedItem(LikeItemType p0, int p1, bool p2) override {
        if ((void($LevelInfoLayer::*)(LikeItemType, int, bool)){&$LevelInfoLayer::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            return reinterpret_cast<void(*)(decltype(this), LikeItemType, int, bool)>(m->getOriginal(base+0x165e90))(this, p0, p1, p2);
        else return LevelInfoLayer::likedItem(p0, p1, p2);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($LevelInfoLayer::*)(FLAlertLayer*, bool)){&$LevelInfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x165f90))(this, p0, p1);
        else return LevelInfoLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) override {
        if ((void($LevelInfoLayer::*)(SetIDPopup*, int)){&$LevelInfoLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0x163e60))(this, p0, p1);
        else return LevelInfoLayer::setIDPopupClosed(p0, p1);
    }

    dupable $LevelInfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x166160, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelInfoLayer::*)(cocos2d::enumKeyCodes)){&$LevelInfoLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x166190, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelInfoLayer::*)(NumberInputLayer*)){&$LevelInfoLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            m->registerHook(base+0x1657a0, extract_virtual(V, (void(D::*)(NumberInputLayer*)){&D::numberInputClosed}));

        if ((void($LevelInfoLayer::*)(GJGameLevel*)){&$LevelInfoLayer::levelDownloadFinished} != (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished})
            m->registerHook(base+0x164c00, extract_virtual(V, (void(D::*)(GJGameLevel*)){&D::levelDownloadFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDownloadFailed} != (void(D::*)(int)){&D::levelDownloadFailed})
            m->registerHook(base+0x164d50, extract_virtual(V, (void(D::*)(int)){&D::levelDownloadFailed}));

        if ((void($LevelInfoLayer::*)(GJGameLevel*, UpdateResponse)){&$LevelInfoLayer::levelUpdateFinished} != (void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished})
            m->registerHook(base+0x164e60, extract_virtual(V, (void(D::*)(GJGameLevel*, UpdateResponse)){&D::levelUpdateFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelUpdateFailed} != (void(D::*)(int)){&D::levelUpdateFailed})
            m->registerHook(base+0x165010, extract_virtual(V, (void(D::*)(int)){&D::levelUpdateFailed}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFinished} != (void(D::*)(int)){&D::levelDeleteFinished})
            m->registerHook(base+0x165120, extract_virtual(V, (void(D::*)(int)){&D::levelDeleteFinished}));

        if ((void($LevelInfoLayer::*)(int)){&$LevelInfoLayer::levelDeleteFailed} != (void(D::*)(int)){&D::levelDeleteFailed})
            m->registerHook(base+0x165230, extract_virtual(V, (void(D::*)(int)){&D::levelDeleteFailed}));

        if ((void($LevelInfoLayer::*)()){&$LevelInfoLayer::rateLevelClosed} != (void(D::*)()){&D::rateLevelClosed})
            m->registerHook(base+0x165e60, extract_virtual(V, (void(D::*)()){&D::rateLevelClosed}));

        if ((void($LevelInfoLayer::*)(LikeItemType, int, bool)){&$LevelInfoLayer::likedItem} != (void(D::*)(LikeItemType, int, bool)){&D::likedItem})
            m->registerHook(base+0x165e90, extract_virtual(V, (void(D::*)(LikeItemType, int, bool)){&D::likedItem}));

        if ((void($LevelInfoLayer::*)(FLAlertLayer*, bool)){&$LevelInfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x165f90, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelInfoLayer::*)(SetIDPopup*, int)){&$LevelInfoLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0x163e60, extract_virtual(V, (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $RateDemonLayer : public RateDemonLayer, public $CacBase {
public:
    dupable ~$RateDemonLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($RateDemonLayer::*)()){&$RateDemonLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12ec20))(this);
        else return RateDemonLayer::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x12e960))(this, p0, p1);
        else return RateDemonLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x12ea40))(this, p0, p1);
        else return RateDemonLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($RateDemonLayer::*)(UploadActionPopup*)){&$RateDemonLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x12eb40))(this, p0);
        else return RateDemonLayer::onClosePopup(p0);
    }

    dupable $RateDemonLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateDemonLayer::*)()){&$RateDemonLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12ec20, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x12e960, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($RateDemonLayer::*)(int, int)){&$RateDemonLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x12ea40, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($RateDemonLayer::*)(UploadActionPopup*)){&$RateDemonLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x12eb40, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $RateLevelLayer : public RateLevelLayer, public $CacBase {
public:
    dupable ~$RateLevelLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($RateLevelLayer::*)()){&$RateLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e2250))(this);
        else return RateLevelLayer::keyBackClicked();
    }

    dupable $RateLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateLevelLayer::*)()){&$RateLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2e2250, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $RateStarsLayer : public RateStarsLayer, public $CacBase {
public:
    dupable ~$RateStarsLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($RateStarsLayer::*)()){&$RateStarsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x136ec0))(this);
        else return RateStarsLayer::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x136c10))(this, p0, p1);
        else return RateStarsLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x136cf0))(this, p0, p1);
        else return RateStarsLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($RateStarsLayer::*)(UploadActionPopup*)){&$RateStarsLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x136de0))(this, p0);
        else return RateStarsLayer::onClosePopup(p0);
    }

    dupable $RateStarsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RateStarsLayer::*)()){&$RateStarsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x136ec0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x136c10, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($RateStarsLayer::*)(int, int)){&$RateStarsLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x136cf0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($RateStarsLayer::*)(UploadActionPopup*)){&$RateStarsLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x136de0, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $ScrollingLayer : public ScrollingLayer, public $CacBase {
public:
    dupable ~$ScrollingLayer() override {}

    dupable void draw() override {
        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x41abc0))(this);
        else return ScrollingLayer::draw();
    }

    dupable void visit() override {
        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x41acb0))(this);
        else return ScrollingLayer::visit();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41ae10))(this, p0, p1);
        else return ScrollingLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41afb0))(this, p0, p1);
        else return ScrollingLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41b0d0))(this, p0, p1);
        else return ScrollingLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x41b110))(this, p0, p1);
        else return ScrollingLayer::ccTouchCancelled(p0, p1);
    }

    dupable $ScrollingLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x41abc0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($ScrollingLayer::*)()){&$ScrollingLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x41acb0, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x41ae10, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x41afb0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x41b0d0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($ScrollingLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$ScrollingLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x41b110, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $SelectArtLayer : public SelectArtLayer, public $CacBase {
public:
    dupable ~$SelectArtLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SelectArtLayer::*)()){&$SelectArtLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xad440))(this);
        else return SelectArtLayer::keyBackClicked();
    }

    dupable $SelectArtLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SelectArtLayer::*)()){&$SelectArtLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xad440, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetFolderPopup : public SetFolderPopup, public $CacBase {
public:
    dupable ~$SetFolderPopup() override {}

    dupable void valueChanged() override {
        if ((void($SetFolderPopup::*)()){&$SetFolderPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x155d40))(this);
        else return SetFolderPopup::valueChanged();
    }

    dupable void setTextPopupClosed(SetTextPopup* p0, std::string p1) override {
        if ((void($SetFolderPopup::*)(SetTextPopup*, std::string)){&$SetFolderPopup::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetTextPopup*, std::string)>(m->getOriginal(base+0x1561b0))(this, p0, p1);
        else return SetFolderPopup::setTextPopupClosed(p0, p1);
    }

    dupable $SetFolderPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetFolderPopup::*)()){&$SetFolderPopup::valueChanged} != (void(D::*)()){&D::valueChanged})
            m->registerHook(base+0x155d40, extract_virtual(V, (void(D::*)()){&D::valueChanged}));

        if ((void($SetFolderPopup::*)(SetTextPopup*, std::string)){&$SetFolderPopup::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            m->registerHook(base+0x1561b0, extract_virtual(V, (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed}));
    }
};


template<class D>
class $SetItemIDLayer : public SetItemIDLayer, public $CacBase {
public:
    dupable ~$SetItemIDLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5bb90))(this);
        else return SetItemIDLayer::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5bb40))(this);
        else return SetItemIDLayer::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5b9e0))(this, p0);
        else return SetItemIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5ba20))(this, p0);
        else return SetItemIDLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*, float)){&$SetItemIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x5bca0))(this, p0, p1);
        else return SetItemIDLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5bd60))(this, p0);
        else return SetItemIDLayer::textInputReturn(p0);
    }

    dupable $SetItemIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x5bb90, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetItemIDLayer::*)()){&$SetItemIDLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x5bb40, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x5b9e0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x5ba20, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*, float)){&$SetItemIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x5bca0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetItemIDLayer::*)(CCTextInputNode*)){&$SetItemIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x5bd60, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SongInfoObject : public SongInfoObject, public $CacBase {
public:
    dupable ~$SongInfoObject() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) override {
        if ((void($SongInfoObject::*)(DS_Dictionary*)){&$SongInfoObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x2f2c70))(this, p0);
        else return SongInfoObject::encodeWithCoder(p0);
    }

    dupable bool canEncode() override {
        if ((bool($SongInfoObject::*)()){&$SongInfoObject::canEncode} != (bool(D::*)()){&D::canEncode})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2f2da0))(this);
        else return SongInfoObject::canEncode();
    }

    dupable $SongInfoObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongInfoObject::*)(DS_Dictionary*)){&$SongInfoObject::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x2f2c70, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((bool($SongInfoObject::*)()){&$SongInfoObject::canEncode} != (bool(D::*)()){&D::canEncode})
            m->registerHook(base+0x2f2da0, extract_virtual(V, (bool(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $StartPosObject : public StartPosObject, public $CacBase {
public:
    dupable ~$StartPosObject() override {}

    dupable bool init() override {
        if ((bool($StartPosObject::*)()){&$StartPosObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xda8a0))(this);
        else return StartPosObject::init();
    }

    dupable void getSaveString() override {
        if ((void($StartPosObject::*)()){&$StartPosObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xda960))(this);
        else return StartPosObject::getSaveString();
    }

    dupable $StartPosObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($StartPosObject::*)()){&$StartPosObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xda8a0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($StartPosObject::*)()){&$StartPosObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xda960, extract_virtual(V, (void(D::*)()){&D::getSaveString}));
    }
};


template<class D>
class $WorldLevelPage : public WorldLevelPage, public $CacBase {
public:
    dupable ~$WorldLevelPage() override {}

    dupable void keyBackClicked() override {
        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x204300))(this);
        else return WorldLevelPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2041c0))(this);
        else return WorldLevelPage::show();
    }

    dupable $WorldLevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x204300, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($WorldLevelPage::*)()){&$WorldLevelPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2041c0, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $AchievementCell : public AchievementCell, public $CacBase {
public:
    dupable ~$AchievementCell() override {}

    dupable bool init() override {
        if ((bool($AchievementCell::*)()){&$AchievementCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x117730))(this);
        else return AchievementCell::init();
    }

    dupable void draw() override {
        if ((void($AchievementCell::*)()){&$AchievementCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x117740))(this);
        else return AchievementCell::draw();
    }

    dupable void loadFromDict(cocos2d::CCDictionary* p0) {
        if ((void($AchievementCell::*)(cocos2d::CCDictionary*)){&$AchievementCell::loadFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::loadFromDict})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCDictionary*)>(m->getOriginal(base+0x10eaa0))(this, p0);
        else return AchievementCell::loadFromDict(p0);
    }

    dupable $AchievementCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementCell::*)()){&$AchievementCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x117730, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($AchievementCell::*)()){&$AchievementCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x117740, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($AchievementCell::*)(cocos2d::CCDictionary*)){&$AchievementCell::loadFromDict} != (void(D::*)(cocos2d::CCDictionary*)){&D::loadFromDict})
            m->registerHook(base+0x10eaa0, extract((void(D::*)(cocos2d::CCDictionary*)){&D::loadFromDict}));
    }
};


template<class D>
class $BoomScrollLayer : public BoomScrollLayer, public $CacBase {
public:
    dupable ~$BoomScrollLayer() override {}

    dupable void visit() override {
        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1e2f80))(this);
        else return BoomScrollLayer::visit();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3c40))(this, p0, p1);
        else return BoomScrollLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3d90))(this, p0, p1);
        else return BoomScrollLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3ff0))(this, p0, p1);
        else return BoomScrollLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x1e3b40))(this, p0, p1);
        else return BoomScrollLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1e3970))(this);
        else return BoomScrollLayer::registerWithTouchDispatcher();
    }

    dupable $BoomScrollLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x1e2f80, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x1e3c40, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x1e3d90, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x1e3ff0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($BoomScrollLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$BoomScrollLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x1e3b40, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($BoomScrollLayer::*)()){&$BoomScrollLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1e3970, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $CCNodeContainer : public CCNodeContainer, public $CacBase {
public:
    dupable ~$CCNodeContainer() override {}

    dupable bool init() override {
        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xba950))(this);
        else return CCNodeContainer::init();
    }

    dupable void visit() override {
        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xba960))(this);
        else return CCNodeContainer::visit();
    }

    dupable $CCNodeContainer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CCNodeContainer::*)()){&$CCNodeContainer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xba950, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($CCNodeContainer::*)()){&$CCNodeContainer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0xba960, extract_virtual(V, (void(D::*)()){&D::visit}));
    }
};


template<class D>
class $CCSpriteWithHue : public CCSpriteWithHue, public $CacBase {
public:
    dupable ~$CCSpriteWithHue() override {}

    dupable void draw() override {
        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35a400))(this);
        else return CCSpriteWithHue::draw();
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0) override {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*)>(m->getOriginal(base+0x359d10))(this, p0);
        else return CCSpriteWithHue::initWithTexture(p0);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) override {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&)>(m->getOriginal(base+0x359d80))(this, p0, p1);
        else return CCSpriteWithHue::initWithTexture(p0, p1);
    }

    dupable void initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) override {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)>(m->getOriginal(base+0x359b80))(this, p0, p1, p2);
        else return CCSpriteWithHue::initWithTexture(p0, p1, p2);
    }

    dupable void initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) override {
        if ((void($CCSpriteWithHue::*)(cocos2d::CCSpriteFrame*)){&$CCSpriteWithHue::initWithSpriteFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x359da0))(this, p0);
        else return CCSpriteWithHue::initWithSpriteFrame(p0);
    }

    dupable void updateColor() override {
        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::updateColor} != (void(D::*)()){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x359f70))(this);
        else return CCSpriteWithHue::updateColor();
    }

    dupable $CCSpriteWithHue() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x35a400, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture})
            m->registerHook(base+0x359d10, extract_virtual(V, (void(D::*)(cocos2d::CCTexture2D*)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture})
            m->registerHook(base+0x359d80, extract_virtual(V, (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&$CCSpriteWithHue::initWithTexture} != (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture})
            m->registerHook(base+0x359b80, extract_virtual(V, (void(D::*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool)){&D::initWithTexture}));

        if ((void($CCSpriteWithHue::*)(cocos2d::CCSpriteFrame*)){&$CCSpriteWithHue::initWithSpriteFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame})
            m->registerHook(base+0x359da0, extract_virtual(V, (void(D::*)(cocos2d::CCSpriteFrame*)){&D::initWithSpriteFrame}));

        if ((void($CCSpriteWithHue::*)()){&$CCSpriteWithHue::updateColor} != (void(D::*)()){&D::updateColor})
            m->registerHook(base+0x359f70, extract_virtual(V, (void(D::*)()){&D::updateColor}));
    }
};


template<class D>
class $CCTextInputNode : public CCTextInputNode, public $CacBase {
public:
    dupable ~$CCTextInputNode() override {}

    dupable void visit() override {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5d380))(this);
        else return CCTextInputNode::visit();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ec80))(this, p0, p1);
        else return CCTextInputNode::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5eea0))(this, p0, p1);
        else return CCTextInputNode::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee60))(this, p0, p1);
        else return CCTextInputNode::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x5ee80))(this, p0, p1);
        else return CCTextInputNode::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5eec0))(this);
        else return CCTextInputNode::registerWithTouchDispatcher();
    }

    dupable void textChanged() override {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5dd70))(this);
        else return CCTextInputNode::textChanged();
    }

    dupable void onClickTrackNode(bool p0) override {
        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x5dd40))(this, p0);
        else return CCTextInputNode::onClickTrackNode(p0);
    }

    dupable void keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) override {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dad0))(this, p0);
        else return CCTextInputNode::keyboardWillShow(p0);
    }

    dupable void keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) override {
        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCIMEKeyboardNotificationInfo&)>(m->getOriginal(base+0x5dc20))(this, p0);
        else return CCTextInputNode::keyboardWillHide(p0);
    }

    dupable bool onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2) override {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*, char const*, int)>(m->getOriginal(base+0x5de50))(this, p0, p1, p2);
        else return CCTextInputNode::onTextFieldInsertText(p0, p1, p2);
    }

    dupable bool onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) override {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e2c0))(this, p0);
        else return CCTextInputNode::onTextFieldAttachWithIME(p0);
    }

    dupable bool onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) override {
        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTextFieldTTF*)>(m->getOriginal(base+0x5e610))(this, p0);
        else return CCTextInputNode::onTextFieldDetachWithIME(p0);
    }

    dupable static CCTextInputNode* create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) {
        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            return reinterpret_cast<CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)>(m->getOriginal(base+0x5cfb0))(p0, p1, p2, p3, p4, p5);
        else return CCTextInputNode::create(p0, p1, p2, p3, p4, p5);
    }

    dupable std::string getString() {
        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(base+0x5d6f0))(this);
        else return CCTextInputNode::getString();
    }

    dupable void refreshLabel() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5d730))(this);
        else return CCTextInputNode::refreshLabel();
    }

    dupable void setAllowedChars(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::string)){&D::setAllowedChars})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x5d360))(this, p0);
        else return CCTextInputNode::setAllowedChars(p0);
    }

    dupable void setLabelNormalColor(cocos2d::_ccColor3B p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelNormalColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x5dab0))(this, p0);
        else return CCTextInputNode::setLabelNormalColor(p0);
    }

    dupable void setLabelPlaceholderColor(cocos2d::_ccColor3B p0) {
        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x5da90))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderColor(p0);
    }

    dupable void setLabelPlaceholderScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da70))(this, p0);
        else return CCTextInputNode::setLabelPlaceholderScale(p0);
    }

    dupable void setMaxLabelScale(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da30))(this, p0);
        else return CCTextInputNode::setMaxLabelScale(p0);
    }

    dupable void setMaxLabelWidth(float p0) {
        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x5da50))(this, p0);
        else return CCTextInputNode::setMaxLabelWidth(p0);
    }

    dupable void setString(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString} != (void(D::*)(std::string)){&D::setString})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x5d3e0))(this, p0);
        else return CCTextInputNode::setString(p0);
    }

    dupable void updateLabel(std::string p0) {
        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::string)){&D::updateLabel})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x5d4a0))(this, p0);
        else return CCTextInputNode::updateLabel(p0);
    }

    dupable void forceOffset() {
        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::forceOffset} != (void(D::*)()){&D::forceOffset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5ec70))(this);
        else return CCTextInputNode::forceOffset();
    }

    dupable $CCTextInputNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x5d380, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x5ec80, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x5eea0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x5ee60, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCTextInputNode::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCTextInputNode::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x5ee80, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x5eec0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::textChanged} != (void(D::*)()){&D::textChanged})
            m->registerHook(base+0x5dd70, extract_virtual(V, (void(D::*)()){&D::textChanged}));

        if ((void($CCTextInputNode::*)(bool)){&$CCTextInputNode::onClickTrackNode} != (void(D::*)(bool)){&D::onClickTrackNode})
            m->registerHook(base+0x5dd40, extract_virtual(V, (void(D::*)(bool)){&D::onClickTrackNode}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillShow} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow})
            m->registerHook(base+0x5dad0, extract_virtual(V, (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillShow}));

        if ((void($CCTextInputNode::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&$CCTextInputNode::keyboardWillHide} != (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide})
            m->registerHook(base+0x5dc20, extract_virtual(V, (void(D::*)(cocos2d::CCIMEKeyboardNotificationInfo&)){&D::keyboardWillHide}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&$CCTextInputNode::onTextFieldInsertText} != (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText})
            m->registerHook(base+0x5de50, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*, char const*, int)){&D::onTextFieldInsertText}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldAttachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME})
            m->registerHook(base+0x5e2c0, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldAttachWithIME}));

        if ((bool($CCTextInputNode::*)(cocos2d::CCTextFieldTTF*)){&$CCTextInputNode::onTextFieldDetachWithIME} != (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME})
            m->registerHook(base+0x5e610, extract_virtual(V, (bool(D::*)(cocos2d::CCTextFieldTTF*)){&D::onTextFieldDetachWithIME}));

        if ((CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&$CCTextInputNode::create} != (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create})
            m->registerHook(base+0x5cfb0, (CCTextInputNode*(*)(float, float, char const*, char const*, int, char const*)){&D::create});

        if ((std::string($CCTextInputNode::*)()){&$CCTextInputNode::getString} != (std::string(D::*)()){&D::getString})
            m->registerHook(base+0x5d6f0, extract((std::string(D::*)()){&D::getString}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::refreshLabel} != (void(D::*)()){&D::refreshLabel})
            m->registerHook(base+0x5d730, extract((void(D::*)()){&D::refreshLabel}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setAllowedChars} != (void(D::*)(std::string)){&D::setAllowedChars})
            m->registerHook(base+0x5d360, extract((void(D::*)(std::string)){&D::setAllowedChars}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelNormalColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor})
            m->registerHook(base+0x5dab0, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelNormalColor}));

        if ((void($CCTextInputNode::*)(cocos2d::_ccColor3B)){&$CCTextInputNode::setLabelPlaceholderColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor})
            m->registerHook(base+0x5da90, extract((void(D::*)(cocos2d::_ccColor3B)){&D::setLabelPlaceholderColor}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setLabelPlaceholderScale} != (void(D::*)(float)){&D::setLabelPlaceholderScale})
            m->registerHook(base+0x5da70, extract((void(D::*)(float)){&D::setLabelPlaceholderScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelScale} != (void(D::*)(float)){&D::setMaxLabelScale})
            m->registerHook(base+0x5da30, extract((void(D::*)(float)){&D::setMaxLabelScale}));

        if ((void($CCTextInputNode::*)(float)){&$CCTextInputNode::setMaxLabelWidth} != (void(D::*)(float)){&D::setMaxLabelWidth})
            m->registerHook(base+0x5da50, extract((void(D::*)(float)){&D::setMaxLabelWidth}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::setString} != (void(D::*)(std::string)){&D::setString})
            m->registerHook(base+0x5d3e0, extract((void(D::*)(std::string)){&D::setString}));

        if ((void($CCTextInputNode::*)(std::string)){&$CCTextInputNode::updateLabel} != (void(D::*)(std::string)){&D::updateLabel})
            m->registerHook(base+0x5d4a0, extract((void(D::*)(std::string)){&D::updateLabel}));

        if ((void($CCTextInputNode::*)()){&$CCTextInputNode::forceOffset} != (void(D::*)()){&D::forceOffset})
            m->registerHook(base+0x5ec70, extract((void(D::*)()){&D::forceOffset}));
    }
};


template<class D>
class $CustomSongLayer : public CustomSongLayer, public $CacBase {
public:
    dupable ~$CustomSongLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf21c0))(this);
        else return CustomSongLayer::keyBackClicked();
    }

    dupable void show() override {
        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf22a0))(this);
        else return CustomSongLayer::show();
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1fb0))(this, p0);
        else return CustomSongLayer::textChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1f10))(this, p0);
        else return CustomSongLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf1e70))(this, p0);
        else return CustomSongLayer::textInputClosed(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($CustomSongLayer::*)(CCTextInputNode*, float)){&$CustomSongLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0xf1fd0))(this, p0, p1);
        else return CustomSongLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xf2090))(this, p0);
        else return CustomSongLayer::textInputReturn(p0);
    }

    dupable void dropDownLayerWillClose(GJDropDownLayer* p0) override {
        if ((void($CustomSongLayer::*)(GJDropDownLayer*)){&$CustomSongLayer::dropDownLayerWillClose} != (void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose})
            return reinterpret_cast<void(*)(decltype(this), GJDropDownLayer*)>(m->getOriginal(base+0xf2140))(this, p0);
        else return CustomSongLayer::dropDownLayerWillClose(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($CustomSongLayer::*)(FLAlertLayer*, bool)){&$CustomSongLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xf1be0))(this, p0, p1);
        else return CustomSongLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $CustomSongLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf21c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CustomSongLayer::*)()){&$CustomSongLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0xf22a0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xf1fb0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xf1f10, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xf1e70, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*, float)){&$CustomSongLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0xf1fd0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($CustomSongLayer::*)(CCTextInputNode*)){&$CustomSongLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0xf2090, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($CustomSongLayer::*)(GJDropDownLayer*)){&$CustomSongLayer::dropDownLayerWillClose} != (void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose})
            m->registerHook(base+0xf2140, extract_virtual(V, (void(D::*)(GJDropDownLayer*)){&D::dropDownLayerWillClose}));

        if ((void($CustomSongLayer::*)(FLAlertLayer*, bool)){&$CustomSongLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xf1be0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EndPortalObject : public EndPortalObject, public $CacBase {
public:
    dupable ~$EndPortalObject() override {}

    dupable bool init() override {
        if ((bool($EndPortalObject::*)()){&$EndPortalObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1da980))(this);
        else return EndPortalObject::init();
    }

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($EndPortalObject::*)(cocos2d::CCPoint const&)){&$EndPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0x1dae70))(this, p0);
        else return EndPortalObject::setPosition(p0);
    }

    dupable void setVisible(bool p0) override {
        if ((void($EndPortalObject::*)(bool)){&$EndPortalObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1daf30))(this, p0);
        else return EndPortalObject::setVisible(p0);
    }

    dupable void triggerObject(GJBaseGameLayer* p0) override {
        if ((void($EndPortalObject::*)(GJBaseGameLayer*)){&$EndPortalObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0x1dadc0))(this, p0);
        else return EndPortalObject::triggerObject(p0);
    }

    dupable void calculateSpawnXPos() override {
        if ((void($EndPortalObject::*)()){&$EndPortalObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1dae50))(this);
        else return EndPortalObject::calculateSpawnXPos();
    }

    dupable $EndPortalObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($EndPortalObject::*)()){&$EndPortalObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1da980, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($EndPortalObject::*)(cocos2d::CCPoint const&)){&$EndPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0x1dae70, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($EndPortalObject::*)(bool)){&$EndPortalObject::setVisible} != (void(D::*)(bool)){&D::setVisible})
            m->registerHook(base+0x1daf30, extract_virtual(V, (void(D::*)(bool)){&D::setVisible}));

        if ((void($EndPortalObject::*)(GJBaseGameLayer*)){&$EndPortalObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0x1dadc0, extract_virtual(V, (void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($EndPortalObject::*)()){&$EndPortalObject::calculateSpawnXPos} != (void(D::*)()){&D::calculateSpawnXPos})
            m->registerHook(base+0x1dae50, extract_virtual(V, (void(D::*)()){&D::calculateSpawnXPos}));
    }
};


template<class D>
class $FileSaveManager : public FileSaveManager, public $CacBase {
public:
    dupable ~$FileSaveManager() override {}

    dupable bool init() override {
        if ((bool($FileSaveManager::*)()){&$FileSaveManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x6360))(this);
        else return FileSaveManager::init();
    }

    dupable void firstLoad() override {
        if ((void($FileSaveManager::*)()){&$FileSaveManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6390))(this);
        else return FileSaveManager::firstLoad();
    }

    dupable $FileSaveManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($FileSaveManager::*)()){&$FileSaveManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x6360, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($FileSaveManager::*)()){&$FileSaveManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x6390, extract_virtual(V, (void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $GJBaseGameLayer : public GJBaseGameLayer, public $CacBase {
public:
    dupable ~$GJBaseGameLayer() override {}

    dupable bool init() override {
        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xafc90))(this);
        else return GJBaseGameLayer::init();
    }

    dupable void objectsCollided(int p0, int p1) override {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xb6d90))(this, p0, p1);
        else return GJBaseGameLayer::objectsCollided(p0, p1);
    }

    dupable void createMoveCommand(cocos2d::CCPoint p0, int p1, float p2, int p3, float p4, bool p5, bool p6, int p7) override {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, int, float, int, float, bool, bool, int)>(m->getOriginal(base+0xb73a0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return GJBaseGameLayer::createMoveCommand(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) override {
        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0xb7420))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return GJBaseGameLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) override {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0xba990))(this, p0, p1, p2);
        else return GJBaseGameLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0xba9a0))(this, p0, p1, p2, p3, p4, p5);
        else return GJBaseGameLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void toggleGroupTriggered(int p0, bool p1) override {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0xb75a0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroupTriggered(p0, p1);
    }

    dupable void spawnGroup(int p0) override {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb7050))(this, p0);
        else return GJBaseGameLayer::spawnGroup(p0);
    }

    dupable void addToSection(GameObject* p0) override {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb7b70))(this, p0);
        else return GJBaseGameLayer::addToSection(p0);
    }

    dupable void addToGroup(GameObject* p0, int p1, bool p2) override {
        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(base+0xb77f0))(this, p0, p1, p2);
        else return GJBaseGameLayer::addToGroup(p0, p1, p2);
    }

    dupable void removeFromGroup(GameObject* p0, int p1) override {
        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(base+0xb7a60))(this, p0, p1);
        else return GJBaseGameLayer::removeFromGroup(p0, p1);
    }

    dupable void addObjectCounter(LabelGameObject* p0, int p1) {
        if ((void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject*, int)){&D::addObjectCounter})
            return reinterpret_cast<void(*)(decltype(this), LabelGameObject*, int)>(m->getOriginal(base+0xb9eb0))(this, p0, p1);
        else return GJBaseGameLayer::addObjectCounter(p0, p1);
    }

    dupable void addToGroups(GameObject* p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject*, bool)){&D::addToGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(base+0xb7780))(this, p0, p1);
        else return GJBaseGameLayer::addToGroups(p0, p1);
    }

    dupable void atlasValue(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(int)){&D::atlasValue})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb21e0))(this, p0);
        else return GJBaseGameLayer::atlasValue(p0);
    }

    dupable void bumpPlayer(PlayerObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(base+0xb6860))(this, p0, p1);
        else return GJBaseGameLayer::bumpPlayer(p0, p1);
    }

    dupable void calculateOpacityValues(EffectGameObject* p0, EffectGameObject* p1, float p2, GJEffectManager* p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, float, GJEffectManager*)>(m->getOriginal(base+0xb5be0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::calculateOpacityValues(p0, p1, p2, p3);
    }

    dupable void checkSpawnObjects() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb6f90))(this);
        else return GJBaseGameLayer::checkSpawnObjects();
    }

    dupable void collectItem(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem} != (void(D::*)(int, int)){&D::collectItem})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xb9e20))(this, p0, p1);
        else return GJBaseGameLayer::collectItem(p0, p1);
    }

    dupable void collectedObject(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject*)){&D::collectedObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(base+0xb9b60))(this, p0);
        else return GJBaseGameLayer::collectedObject(p0);
    }

    dupable void createTextLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb5260))(this);
        else return GJBaseGameLayer::createTextLayers();
    }

    dupable void damagingObjectsInRect(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0xb6140))(this, p0);
        else return GJBaseGameLayer::damagingObjectsInRect(p0);
    }

    dupable void enableHighCapacityMode() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb11e0))(this);
        else return GJBaseGameLayer::enableHighCapacityMode();
    }

    dupable void getCapacityString() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb2210))(this);
        else return GJBaseGameLayer::getCapacityString();
    }

    dupable void getGroundHeightForMode(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(int)){&D::getGroundHeightForMode})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb6630))(this, p0);
        else return GJBaseGameLayer::getGroundHeightForMode(p0);
    }

    dupable void getGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup} != (void(D::*)(int)){&D::getGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb6f20))(this, p0);
        else return GJBaseGameLayer::getGroup(p0);
    }

    dupable void getMoveDeltaForObjects(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(int, int)){&D::getMoveDeltaForObjects})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xb6db0))(this, p0, p1);
        else return GJBaseGameLayer::getMoveDeltaForObjects(p0, p1);
    }

    dupable void getOptimizedGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(int)){&D::getOptimizedGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb7940))(this, p0);
        else return GJBaseGameLayer::getOptimizedGroup(p0);
    }

    dupable void getStaticGroup(int p0) {
        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(int)){&D::getStaticGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xb79a0))(this, p0);
        else return GJBaseGameLayer::getStaticGroup(p0);
    }

    dupable void isGroupDisabledForObject(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject*)){&D::isGroupDisabledForObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb5cc0))(this, p0);
        else return GJBaseGameLayer::isGroupDisabledForObject(p0);
    }

    dupable void isGroupDisabledForObjectFull(GameObject* p0, cocos2d::CCArray* p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCArray*)>(m->getOriginal(base+0xb5de0))(this, p0, p1);
        else return GJBaseGameLayer::isGroupDisabledForObjectFull(p0, p1);
    }

    dupable void loadUpToPosition(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(float)){&D::loadUpToPosition})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xba680))(this, p0);
        else return GJBaseGameLayer::loadUpToPosition(p0);
    }

    dupable void objectIntersectsCircle(GameObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, GameObject*)>(m->getOriginal(base+0xb66e0))(this, p0, p1);
        else return GJBaseGameLayer::objectIntersectsCircle(p0, p1);
    }

    dupable void objectTriggered(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject*)){&D::objectTriggered})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(base+0xb71b0))(this, p0);
        else return GJBaseGameLayer::objectTriggered(p0);
    }

    dupable void optimizeMoveGroups() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb96c0))(this);
        else return GJBaseGameLayer::optimizeMoveGroups();
    }

    dupable void parentForZLayer(int p0, bool p1, int p2) {
        if ((void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(int, bool, int)){&D::parentForZLayer})
            return reinterpret_cast<void(*)(decltype(this), int, bool, int)>(m->getOriginal(base+0xb55d0))(this, p0, p1, p2);
        else return GJBaseGameLayer::parentForZLayer(p0, p1, p2);
    }

    dupable void playerTouchedRing(PlayerObject* p0, GameObject* p1) {
        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(base+0xb69e0))(this, p0, p1);
        else return GJBaseGameLayer::playerTouchedRing(p0, p1);
    }

    dupable void processColorObject(EffectGameObject* p0, int p1, cocos2d::CCDictionary* p2, float p3, GJEffectManager* p4) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(base+0xb5a90))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::processColorObject(p0, p1, p2, p3, p4);
    }

    dupable void processFollowActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb8fd0))(this);
        else return GJBaseGameLayer::processFollowActions();
    }

    dupable void processMoveActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb86c0))(this);
        else return GJBaseGameLayer::processMoveActions();
    }

    dupable void processMoveActionsStep(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(float)){&D::processMoveActionsStep})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xb7ea0))(this, p0);
        else return GJBaseGameLayer::processMoveActionsStep(p0);
    }

    dupable void processOpacityObject(EffectGameObject* p0, cocos2d::CCDictionary* p1, float p2, GJEffectManager* p3) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)>(m->getOriginal(base+0xb5ae0))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::processOpacityObject(p0, p1, p2, p3);
    }

    dupable void processPlayerFollowActions(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(float)){&D::processPlayerFollowActions})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xb8b50))(this, p0);
        else return GJBaseGameLayer::processPlayerFollowActions(p0);
    }

    dupable void processRotationActions() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb7fd0))(this);
        else return GJBaseGameLayer::processRotationActions();
    }

    dupable void pushButton(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton} != (void(D::*)(int, bool)){&D::pushButton})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0xb9920))(this, p0, p1);
        else return GJBaseGameLayer::pushButton(p0, p1);
    }

    dupable void rectIntersectsCircle(cocos2d::CCRect p0, cocos2d::CCPoint p1, float p2) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, cocos2d::CCPoint, float)>(m->getOriginal(base+0xb6470))(this, p0, p1, p2);
        else return GJBaseGameLayer::rectIntersectsCircle(p0, p1, p2);
    }

    dupable void refreshCounterLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb9fc0))(this);
        else return GJBaseGameLayer::refreshCounterLabels();
    }

    dupable void releaseButton(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(int, bool)){&D::releaseButton})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0xb9a00))(this, p0, p1);
        else return GJBaseGameLayer::releaseButton(p0, p1);
    }

    dupable void removeFromGroups(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject*)){&D::removeFromGroups})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb7a00))(this, p0);
        else return GJBaseGameLayer::removeFromGroups(p0);
    }

    dupable void removeObjectFromSection(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject*)){&D::removeObjectFromSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb7e00))(this, p0);
        else return GJBaseGameLayer::removeObjectFromSection(p0);
    }

    dupable void reorderObjectSection(GameObject* p0) {
        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject*)){&D::reorderObjectSection})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0xb7cb0))(this, p0);
        else return GJBaseGameLayer::reorderObjectSection(p0);
    }

    dupable void resetGroupCounters(bool p0) {
        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(bool)){&D::resetGroupCounters})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xba300))(this, p0);
        else return GJBaseGameLayer::resetGroupCounters(p0);
    }

    dupable void resetMoveOptimizedValue() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb9670))(this);
        else return GJBaseGameLayer::resetMoveOptimizedValue();
    }

    dupable void sectionForPos(float p0) {
        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(float)){&D::sectionForPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xb6120))(this, p0);
        else return GJBaseGameLayer::sectionForPos(p0);
    }

    dupable void setupLayers() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xaffe0))(this);
        else return GJBaseGameLayer::setupLayers();
    }

    dupable void shouldExitHackedLevel() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb1100))(this);
        else return GJBaseGameLayer::shouldExitHackedLevel();
    }

    dupable void spawnGroupTriggered(int p0, float p1, int p2) {
        if ((void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(int, float, int)){&D::spawnGroupTriggered})
            return reinterpret_cast<void(*)(decltype(this), int, float, int)>(m->getOriginal(base+0xb7020))(this, p0, p1, p2);
        else return GJBaseGameLayer::spawnGroupTriggered(p0, p1, p2);
    }

    dupable void staticObjectsInRect(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0xb5f90))(this, p0);
        else return GJBaseGameLayer::staticObjectsInRect(p0);
    }

    dupable void testInstantCountTrigger(int p0, int p1, int p2, bool p3, int p4) {
        if ((void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger})
            return reinterpret_cast<void(*)(decltype(this), int, int, int, bool, int)>(m->getOriginal(base+0xb9ae0))(this, p0, p1, p2, p3, p4);
        else return GJBaseGameLayer::testInstantCountTrigger(p0, p1, p2, p3, p4);
    }

    dupable void toggleGroup(int p0, bool p1) {
        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0xb75f0))(this, p0, p1);
        else return GJBaseGameLayer::toggleGroup(p0, p1);
    }

    dupable void togglePlayerVisibility(bool p0) {
        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(bool)){&D::togglePlayerVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xba910))(this, p0);
        else return GJBaseGameLayer::togglePlayerVisibility(p0);
    }

    dupable void triggerMoveCommand(EffectGameObject* p0) {
        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject*)){&D::triggerMoveCommand})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*)>(m->getOriginal(base+0xb7290))(this, p0);
        else return GJBaseGameLayer::triggerMoveCommand(p0);
    }

    dupable void updateCollisionBlocks() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb6a30))(this);
        else return GJBaseGameLayer::updateCollisionBlocks();
    }

    dupable void updateCounters(int p0, int p1) {
        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(int, int)){&D::updateCounters})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0xb9bc0))(this, p0, p1);
        else return GJBaseGameLayer::updateCounters(p0, p1);
    }

    dupable void updateDisabledObjectsLastPos(cocos2d::CCArray* p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(base+0xb95b0))(this, p0);
        else return GJBaseGameLayer::updateDisabledObjectsLastPos(p0);
    }

    dupable void updateLayerCapacity(std::string p0) {
        if ((void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::string)){&D::updateLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0xb1680))(this, p0);
        else return GJBaseGameLayer::updateLayerCapacity(p0);
    }

    dupable void updateLegacyLayerCapacity(int p0, int p1, int p2, int p3) {
        if ((void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity})
            return reinterpret_cast<void(*)(decltype(this), int, int, int, int)>(m->getOriginal(base+0xb1590))(this, p0, p1, p2, p3);
        else return GJBaseGameLayer::updateLegacyLayerCapacity(p0, p1, p2, p3);
    }

    dupable void updateOBB2(cocos2d::CCRect p0) {
        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRect)){&D::updateOBB2})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0xb63f0))(this, p0);
        else return GJBaseGameLayer::updateOBB2(p0);
    }

    dupable void updateQueuedLabels() {
        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xb9f30))(this);
        else return GJBaseGameLayer::updateQueuedLabels();
    }

    dupable $GJBaseGameLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJBaseGameLayer::*)()){&$GJBaseGameLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xafc90, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::objectsCollided} != (void(D::*)(int, int)){&D::objectsCollided})
            m->registerHook(base+0xb6d90, extract_virtual(V, (void(D::*)(int, int)){&D::objectsCollided}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&$GJBaseGameLayer::createMoveCommand} != (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand})
            m->registerHook(base+0xb73a0, extract_virtual(V, (void(D::*)(cocos2d::CCPoint, int, float, int, float, bool, bool, int)){&D::createMoveCommand}));

        if ((void($GJBaseGameLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$GJBaseGameLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0xb7420, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, bool, bool)){&$GJBaseGameLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0xba990, extract_virtual(V, (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$GJBaseGameLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0xba9a0, extract_virtual(V, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroupTriggered} != (void(D::*)(int, bool)){&D::toggleGroupTriggered})
            m->registerHook(base+0xb75a0, extract_virtual(V, (void(D::*)(int, bool)){&D::toggleGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::spawnGroup} != (void(D::*)(int)){&D::spawnGroup})
            m->registerHook(base+0xb7050, extract_virtual(V, (void(D::*)(int)){&D::spawnGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::addToSection} != (void(D::*)(GameObject*)){&D::addToSection})
            m->registerHook(base+0xb7b70, extract_virtual(V, (void(D::*)(GameObject*)){&D::addToSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int, bool)){&$GJBaseGameLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(base+0xb77f0, extract_virtual(V, (void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*, int)){&$GJBaseGameLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(base+0xb7a60, extract_virtual(V, (void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($GJBaseGameLayer::*)(LabelGameObject*, int)){&$GJBaseGameLayer::addObjectCounter} != (void(D::*)(LabelGameObject*, int)){&D::addObjectCounter})
            m->registerHook(base+0xb9eb0, extract((void(D::*)(LabelGameObject*, int)){&D::addObjectCounter}));

        if ((void($GJBaseGameLayer::*)(GameObject*, bool)){&$GJBaseGameLayer::addToGroups} != (void(D::*)(GameObject*, bool)){&D::addToGroups})
            m->registerHook(base+0xb7780, extract((void(D::*)(GameObject*, bool)){&D::addToGroups}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::atlasValue} != (void(D::*)(int)){&D::atlasValue})
            m->registerHook(base+0xb21e0, extract((void(D::*)(int)){&D::atlasValue}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::bumpPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer})
            m->registerHook(base+0xb6860, extract((void(D::*)(PlayerObject*, GameObject*)){&D::bumpPlayer}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&$GJBaseGameLayer::calculateOpacityValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues})
            m->registerHook(base+0xb5be0, extract((void(D::*)(EffectGameObject*, EffectGameObject*, float, GJEffectManager*)){&D::calculateOpacityValues}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::checkSpawnObjects} != (void(D::*)()){&D::checkSpawnObjects})
            m->registerHook(base+0xb6f90, extract((void(D::*)()){&D::checkSpawnObjects}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::collectItem} != (void(D::*)(int, int)){&D::collectItem})
            m->registerHook(base+0xb9e20, extract((void(D::*)(int, int)){&D::collectItem}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::collectedObject} != (void(D::*)(EffectGameObject*)){&D::collectedObject})
            m->registerHook(base+0xb9b60, extract((void(D::*)(EffectGameObject*)){&D::collectedObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::createTextLayers} != (void(D::*)()){&D::createTextLayers})
            m->registerHook(base+0xb5260, extract((void(D::*)()){&D::createTextLayers}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::damagingObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect})
            m->registerHook(base+0xb6140, extract((void(D::*)(cocos2d::CCRect)){&D::damagingObjectsInRect}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::enableHighCapacityMode} != (void(D::*)()){&D::enableHighCapacityMode})
            m->registerHook(base+0xb11e0, extract((void(D::*)()){&D::enableHighCapacityMode}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::getCapacityString} != (void(D::*)()){&D::getCapacityString})
            m->registerHook(base+0xb2210, extract((void(D::*)()){&D::getCapacityString}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroundHeightForMode} != (void(D::*)(int)){&D::getGroundHeightForMode})
            m->registerHook(base+0xb6630, extract((void(D::*)(int)){&D::getGroundHeightForMode}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getGroup} != (void(D::*)(int)){&D::getGroup})
            m->registerHook(base+0xb6f20, extract((void(D::*)(int)){&D::getGroup}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::getMoveDeltaForObjects} != (void(D::*)(int, int)){&D::getMoveDeltaForObjects})
            m->registerHook(base+0xb6db0, extract((void(D::*)(int, int)){&D::getMoveDeltaForObjects}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getOptimizedGroup} != (void(D::*)(int)){&D::getOptimizedGroup})
            m->registerHook(base+0xb7940, extract((void(D::*)(int)){&D::getOptimizedGroup}));

        if ((void($GJBaseGameLayer::*)(int)){&$GJBaseGameLayer::getStaticGroup} != (void(D::*)(int)){&D::getStaticGroup})
            m->registerHook(base+0xb79a0, extract((void(D::*)(int)){&D::getStaticGroup}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::isGroupDisabledForObject} != (void(D::*)(GameObject*)){&D::isGroupDisabledForObject})
            m->registerHook(base+0xb5cc0, extract((void(D::*)(GameObject*)){&D::isGroupDisabledForObject}));

        if ((void($GJBaseGameLayer::*)(GameObject*, cocos2d::CCArray*)){&$GJBaseGameLayer::isGroupDisabledForObjectFull} != (void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull})
            m->registerHook(base+0xb5de0, extract((void(D::*)(GameObject*, cocos2d::CCArray*)){&D::isGroupDisabledForObjectFull}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::loadUpToPosition} != (void(D::*)(float)){&D::loadUpToPosition})
            m->registerHook(base+0xba680, extract((void(D::*)(float)){&D::loadUpToPosition}));

        if ((void($GJBaseGameLayer::*)(GameObject*, GameObject*)){&$GJBaseGameLayer::objectIntersectsCircle} != (void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle})
            m->registerHook(base+0xb66e0, extract((void(D::*)(GameObject*, GameObject*)){&D::objectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::objectTriggered} != (void(D::*)(EffectGameObject*)){&D::objectTriggered})
            m->registerHook(base+0xb71b0, extract((void(D::*)(EffectGameObject*)){&D::objectTriggered}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::optimizeMoveGroups} != (void(D::*)()){&D::optimizeMoveGroups})
            m->registerHook(base+0xb96c0, extract((void(D::*)()){&D::optimizeMoveGroups}));

        if ((void($GJBaseGameLayer::*)(int, bool, int)){&$GJBaseGameLayer::parentForZLayer} != (void(D::*)(int, bool, int)){&D::parentForZLayer})
            m->registerHook(base+0xb55d0, extract((void(D::*)(int, bool, int)){&D::parentForZLayer}));

        if ((void($GJBaseGameLayer::*)(PlayerObject*, GameObject*)){&$GJBaseGameLayer::playerTouchedRing} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing})
            m->registerHook(base+0xb69e0, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerTouchedRing}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processColorObject} != (void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject})
            m->registerHook(base+0xb5a90, extract((void(D::*)(EffectGameObject*, int, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processColorObject}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processFollowActions} != (void(D::*)()){&D::processFollowActions})
            m->registerHook(base+0xb8fd0, extract((void(D::*)()){&D::processFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processMoveActions} != (void(D::*)()){&D::processMoveActions})
            m->registerHook(base+0xb86c0, extract((void(D::*)()){&D::processMoveActions}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processMoveActionsStep} != (void(D::*)(float)){&D::processMoveActionsStep})
            m->registerHook(base+0xb7ea0, extract((void(D::*)(float)){&D::processMoveActionsStep}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&$GJBaseGameLayer::processOpacityObject} != (void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject})
            m->registerHook(base+0xb5ae0, extract((void(D::*)(EffectGameObject*, cocos2d::CCDictionary*, float, GJEffectManager*)){&D::processOpacityObject}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::processPlayerFollowActions} != (void(D::*)(float)){&D::processPlayerFollowActions})
            m->registerHook(base+0xb8b50, extract((void(D::*)(float)){&D::processPlayerFollowActions}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::processRotationActions} != (void(D::*)()){&D::processRotationActions})
            m->registerHook(base+0xb7fd0, extract((void(D::*)()){&D::processRotationActions}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::pushButton} != (void(D::*)(int, bool)){&D::pushButton})
            m->registerHook(base+0xb9920, extract((void(D::*)(int, bool)){&D::pushButton}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&$GJBaseGameLayer::rectIntersectsCircle} != (void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle})
            m->registerHook(base+0xb6470, extract((void(D::*)(cocos2d::CCRect, cocos2d::CCPoint, float)){&D::rectIntersectsCircle}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::refreshCounterLabels} != (void(D::*)()){&D::refreshCounterLabels})
            m->registerHook(base+0xb9fc0, extract((void(D::*)()){&D::refreshCounterLabels}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::releaseButton} != (void(D::*)(int, bool)){&D::releaseButton})
            m->registerHook(base+0xb9a00, extract((void(D::*)(int, bool)){&D::releaseButton}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeFromGroups} != (void(D::*)(GameObject*)){&D::removeFromGroups})
            m->registerHook(base+0xb7a00, extract((void(D::*)(GameObject*)){&D::removeFromGroups}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::removeObjectFromSection} != (void(D::*)(GameObject*)){&D::removeObjectFromSection})
            m->registerHook(base+0xb7e00, extract((void(D::*)(GameObject*)){&D::removeObjectFromSection}));

        if ((void($GJBaseGameLayer::*)(GameObject*)){&$GJBaseGameLayer::reorderObjectSection} != (void(D::*)(GameObject*)){&D::reorderObjectSection})
            m->registerHook(base+0xb7cb0, extract((void(D::*)(GameObject*)){&D::reorderObjectSection}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::resetGroupCounters} != (void(D::*)(bool)){&D::resetGroupCounters})
            m->registerHook(base+0xba300, extract((void(D::*)(bool)){&D::resetGroupCounters}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::resetMoveOptimizedValue} != (void(D::*)()){&D::resetMoveOptimizedValue})
            m->registerHook(base+0xb9670, extract((void(D::*)()){&D::resetMoveOptimizedValue}));

        if ((void($GJBaseGameLayer::*)(float)){&$GJBaseGameLayer::sectionForPos} != (void(D::*)(float)){&D::sectionForPos})
            m->registerHook(base+0xb6120, extract((void(D::*)(float)){&D::sectionForPos}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::setupLayers} != (void(D::*)()){&D::setupLayers})
            m->registerHook(base+0xaffe0, extract((void(D::*)()){&D::setupLayers}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::shouldExitHackedLevel} != (void(D::*)()){&D::shouldExitHackedLevel})
            m->registerHook(base+0xb1100, extract((void(D::*)()){&D::shouldExitHackedLevel}));

        if ((void($GJBaseGameLayer::*)(int, float, int)){&$GJBaseGameLayer::spawnGroupTriggered} != (void(D::*)(int, float, int)){&D::spawnGroupTriggered})
            m->registerHook(base+0xb7020, extract((void(D::*)(int, float, int)){&D::spawnGroupTriggered}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::staticObjectsInRect} != (void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect})
            m->registerHook(base+0xb5f90, extract((void(D::*)(cocos2d::CCRect)){&D::staticObjectsInRect}));

        if ((void($GJBaseGameLayer::*)(int, int, int, bool, int)){&$GJBaseGameLayer::testInstantCountTrigger} != (void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger})
            m->registerHook(base+0xb9ae0, extract((void(D::*)(int, int, int, bool, int)){&D::testInstantCountTrigger}));

        if ((void($GJBaseGameLayer::*)(int, bool)){&$GJBaseGameLayer::toggleGroup} != (void(D::*)(int, bool)){&D::toggleGroup})
            m->registerHook(base+0xb75f0, extract((void(D::*)(int, bool)){&D::toggleGroup}));

        if ((void($GJBaseGameLayer::*)(bool)){&$GJBaseGameLayer::togglePlayerVisibility} != (void(D::*)(bool)){&D::togglePlayerVisibility})
            m->registerHook(base+0xba910, extract((void(D::*)(bool)){&D::togglePlayerVisibility}));

        if ((void($GJBaseGameLayer::*)(EffectGameObject*)){&$GJBaseGameLayer::triggerMoveCommand} != (void(D::*)(EffectGameObject*)){&D::triggerMoveCommand})
            m->registerHook(base+0xb7290, extract((void(D::*)(EffectGameObject*)){&D::triggerMoveCommand}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateCollisionBlocks} != (void(D::*)()){&D::updateCollisionBlocks})
            m->registerHook(base+0xb6a30, extract((void(D::*)()){&D::updateCollisionBlocks}));

        if ((void($GJBaseGameLayer::*)(int, int)){&$GJBaseGameLayer::updateCounters} != (void(D::*)(int, int)){&D::updateCounters})
            m->registerHook(base+0xb9bc0, extract((void(D::*)(int, int)){&D::updateCounters}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCArray*)){&$GJBaseGameLayer::updateDisabledObjectsLastPos} != (void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos})
            m->registerHook(base+0xb95b0, extract((void(D::*)(cocos2d::CCArray*)){&D::updateDisabledObjectsLastPos}));

        if ((void($GJBaseGameLayer::*)(std::string)){&$GJBaseGameLayer::updateLayerCapacity} != (void(D::*)(std::string)){&D::updateLayerCapacity})
            m->registerHook(base+0xb1680, extract((void(D::*)(std::string)){&D::updateLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(int, int, int, int)){&$GJBaseGameLayer::updateLegacyLayerCapacity} != (void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity})
            m->registerHook(base+0xb1590, extract((void(D::*)(int, int, int, int)){&D::updateLegacyLayerCapacity}));

        if ((void($GJBaseGameLayer::*)(cocos2d::CCRect)){&$GJBaseGameLayer::updateOBB2} != (void(D::*)(cocos2d::CCRect)){&D::updateOBB2})
            m->registerHook(base+0xb63f0, extract((void(D::*)(cocos2d::CCRect)){&D::updateOBB2}));

        if ((void($GJBaseGameLayer::*)()){&$GJBaseGameLayer::updateQueuedLabels} != (void(D::*)()){&D::updateQueuedLabels})
            m->registerHook(base+0xb9f30, extract((void(D::*)()){&D::updateQueuedLabels}));
    }
};


template<class D>
class $GJChallengeItem : public GJChallengeItem, public $CacBase {
public:
    dupable ~$GJChallengeItem() override {}

    dupable void encodeWithCoder(DS_Dictionary* p0) override {
        if ((void($GJChallengeItem::*)(DS_Dictionary*)){&$GJChallengeItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x4df60))(this, p0);
        else return GJChallengeItem::encodeWithCoder(p0);
    }

    dupable bool canEncode() override {
        if ((bool($GJChallengeItem::*)()){&$GJChallengeItem::canEncode} != (bool(D::*)()){&D::canEncode})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x4e020))(this);
        else return GJChallengeItem::canEncode();
    }

    dupable $GJChallengeItem() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJChallengeItem::*)(DS_Dictionary*)){&$GJChallengeItem::encodeWithCoder} != (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder})
            m->registerHook(base+0x4df60, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeWithCoder}));

        if ((bool($GJChallengeItem::*)()){&$GJChallengeItem::canEncode} != (bool(D::*)()){&D::canEncode})
            m->registerHook(base+0x4e020, extract_virtual(V, (bool(D::*)()){&D::canEncode}));
    }
};


template<class D>
class $GJDropDownLayer : public GJDropDownLayer, public $CacBase {
public:
    dupable ~$GJDropDownLayer() override {}

    dupable void draw() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352910))(this);
        else return GJDropDownLayer::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352940))(this, p0, p1);
        else return GJDropDownLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x3529a0))(this, p0, p1);
        else return GJDropDownLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352960))(this, p0, p1);
        else return GJDropDownLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x352980))(this, p0, p1);
        else return GJDropDownLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525f0))(this);
        else return GJDropDownLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352630))(this);
        else return GJDropDownLayer::keyBackClicked();
    }

    dupable void customSetup() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352570))(this);
        else return GJDropDownLayer::customSetup();
    }

    dupable void enterLayer() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525c0))(this);
        else return GJDropDownLayer::enterLayer();
    }

    dupable void exitLayer(cocos2d::CCObject* p0) override {
        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x352670))(this, p0);
        else return GJDropDownLayer::exitLayer(p0);
    }

    dupable void showLayer(bool p0) override {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x3526c0))(this, p0);
        else return GJDropDownLayer::showLayer(p0);
    }

    dupable void hideLayer(bool p0) override {
        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x3527b0))(this, p0);
        else return GJDropDownLayer::hideLayer(p0);
    }

    dupable void layerVisible() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528b0))(this);
        else return GJDropDownLayer::layerVisible();
    }

    dupable void layerHidden() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528d0))(this);
        else return GJDropDownLayer::layerHidden();
    }

    dupable void enterAnimFinished() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3528a0))(this);
        else return GJDropDownLayer::enterAnimFinished();
    }

    dupable void disableUI() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x352580))(this);
        else return GJDropDownLayer::disableUI();
    }

    dupable void enableUI() override {
        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3525a0))(this);
        else return GJDropDownLayer::enableUI();
    }

    dupable static GJDropDownLayer* create(char const* p0, float p1) {
        if ((GJDropDownLayer*(*)(char const*, float)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const*, float)){&D::create})
            return reinterpret_cast<GJDropDownLayer*(*)(char const*, float)>(m->getOriginal(base+0x352530))(p0, p1);
        else return GJDropDownLayer::create(p0, p1);
    }

    dupable bool init(char const* p0, float p1) {
        if ((bool($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init} != (bool(D::*)(char const*, float)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), char const*, float)>(m->getOriginal(base+0x352100))(this, p0, p1);
        else return GJDropDownLayer::init(p0, p1);
    }

    dupable $GJDropDownLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x352910, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x352940, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x3529a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x352960, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJDropDownLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x352980, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x3525f0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x352630, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x352570, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterLayer} != (void(D::*)()){&D::enterLayer})
            m->registerHook(base+0x3525c0, extract_virtual(V, (void(D::*)()){&D::enterLayer}));

        if ((void($GJDropDownLayer::*)(cocos2d::CCObject*)){&$GJDropDownLayer::exitLayer} != (void(D::*)(cocos2d::CCObject*)){&D::exitLayer})
            m->registerHook(base+0x352670, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::exitLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x3526c0, extract_virtual(V, (void(D::*)(bool)){&D::showLayer}));

        if ((void($GJDropDownLayer::*)(bool)){&$GJDropDownLayer::hideLayer} != (void(D::*)(bool)){&D::hideLayer})
            m->registerHook(base+0x3527b0, extract_virtual(V, (void(D::*)(bool)){&D::hideLayer}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerVisible} != (void(D::*)()){&D::layerVisible})
            m->registerHook(base+0x3528b0, extract_virtual(V, (void(D::*)()){&D::layerVisible}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x3528d0, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x3528a0, extract_virtual(V, (void(D::*)()){&D::enterAnimFinished}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::disableUI} != (void(D::*)()){&D::disableUI})
            m->registerHook(base+0x352580, extract_virtual(V, (void(D::*)()){&D::disableUI}));

        if ((void($GJDropDownLayer::*)()){&$GJDropDownLayer::enableUI} != (void(D::*)()){&D::enableUI})
            m->registerHook(base+0x3525a0, extract_virtual(V, (void(D::*)()){&D::enableUI}));

        if ((GJDropDownLayer*(*)(char const*, float)){&$GJDropDownLayer::create} != (GJDropDownLayer*(*)(char const*, float)){&D::create})
            m->registerHook(base+0x352530, (GJDropDownLayer*(*)(char const*, float)){&D::create});

        if ((bool($GJDropDownLayer::*)(char const*, float)){&$GJDropDownLayer::init} != (bool(D::*)(char const*, float)){&D::init})
            m->registerHook(base+0x352100, extract((bool(D::*)(char const*, float)){&D::init}));
    }
};


template<class D>
class $GJEffectManager : public GJEffectManager, public $CacBase {
public:
    dupable ~$GJEffectManager() override {}

    dupable bool init() override {
        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x180230))(this);
        else return GJEffectManager::init();
    }

    dupable $GJEffectManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJEffectManager::*)()){&$GJEffectManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x180230, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJFriendRequest : public GJFriendRequest, public $CacBase {
public:
    dupable ~$GJFriendRequest() override {}

    dupable bool init() override {
        if ((bool($GJFriendRequest::*)()){&$GJFriendRequest::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2dea00))(this);
        else return GJFriendRequest::init();
    }

    dupable $GJFriendRequest() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJFriendRequest::*)()){&$GJFriendRequest::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2dea00, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJObjectDecoder : public GJObjectDecoder, public $CacBase {
public:
    dupable ~$GJObjectDecoder() override {}

    dupable bool init() override {
        if ((bool($GJObjectDecoder::*)()){&$GJObjectDecoder::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x41e780))(this);
        else return GJObjectDecoder::init();
    }

    dupable void getDecodedObject(int p0, DS_Dictionary* p1) override {
        if ((void($GJObjectDecoder::*)(int, DS_Dictionary*)){&$GJObjectDecoder::getDecodedObject} != (void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject})
            return reinterpret_cast<void(*)(decltype(this), int, DS_Dictionary*)>(m->getOriginal(base+0x41e790))(this, p0, p1);
        else return GJObjectDecoder::getDecodedObject(p0, p1);
    }

    dupable $GJObjectDecoder() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJObjectDecoder::*)()){&$GJObjectDecoder::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x41e780, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJObjectDecoder::*)(int, DS_Dictionary*)){&$GJObjectDecoder::getDecodedObject} != (void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject})
            m->registerHook(base+0x41e790, extract_virtual(V, (void(D::*)(int, DS_Dictionary*)){&D::getDecodedObject}));
    }
};


template<class D>
class $InfoAlertButton : public InfoAlertButton, public $CacBase {
public:
    dupable ~$InfoAlertButton() override {}

    dupable void activate() override {
        if ((void($InfoAlertButton::*)()){&$InfoAlertButton::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2ecd70))(this);
        else return InfoAlertButton::activate();
    }

    dupable $InfoAlertButton() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($InfoAlertButton::*)()){&$InfoAlertButton::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x2ecd70, extract_virtual(V, (void(D::*)()){&D::activate}));
    }
};


template<class D>
class $LabelGameObject : public LabelGameObject, public $CacBase {
public:
    dupable ~$LabelGameObject() override {}

    dupable bool init() override {
        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xdb990))(this);
        else return LabelGameObject::init();
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($LabelGameObject::*)(unsigned char)){&$LabelGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0xdba40))(this, p0);
        else return LabelGameObject::setOpacity(p0);
    }

    dupable void setupCustomSprites() override {
        if ((void($LabelGameObject::*)()){&$LabelGameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdb9b0))(this);
        else return LabelGameObject::setupCustomSprites();
    }

    dupable void addMainSpriteToParent(bool p0) override {
        if ((void($LabelGameObject::*)(bool)){&$LabelGameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xdbce0))(this, p0);
        else return LabelGameObject::addMainSpriteToParent(p0);
    }

    dupable void getSaveString() override {
        if ((void($LabelGameObject::*)()){&$LabelGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdbd50))(this);
        else return LabelGameObject::getSaveString();
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xdbca0))(this, p0);
        else return LabelGameObject::setObjectColor(p0);
    }

    dupable $LabelGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LabelGameObject::*)()){&$LabelGameObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xdb990, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($LabelGameObject::*)(unsigned char)){&$LabelGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0xdba40, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($LabelGameObject::*)()){&$LabelGameObject::setupCustomSprites} != (void(D::*)()){&D::setupCustomSprites})
            m->registerHook(base+0xdb9b0, extract_virtual(V, (void(D::*)()){&D::setupCustomSprites}));

        if ((void($LabelGameObject::*)(bool)){&$LabelGameObject::addMainSpriteToParent} != (void(D::*)(bool)){&D::addMainSpriteToParent})
            m->registerHook(base+0xdbce0, extract_virtual(V, (void(D::*)(bool)){&D::addMainSpriteToParent}));

        if ((void($LabelGameObject::*)()){&$LabelGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xdbd50, extract_virtual(V, (void(D::*)()){&D::getSaveString}));

        if ((void($LabelGameObject::*)(cocos2d::_ccColor3B const&)){&$LabelGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0xdbca0, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));
    }
};


template<class D>
class $MoreSearchLayer : public MoreSearchLayer, public $CacBase {
public:
    dupable ~$MoreSearchLayer() override {}

    dupable bool init() override {
        if ((bool($MoreSearchLayer::*)()){&$MoreSearchLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3896b0))(this);
        else return MoreSearchLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($MoreSearchLayer::*)()){&$MoreSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38b820))(this);
        else return MoreSearchLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($MoreSearchLayer::*)(CCTextInputNode*, float)){&$MoreSearchLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x38b6b0))(this, p0, p1);
        else return MoreSearchLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($MoreSearchLayer::*)(CCTextInputNode*)){&$MoreSearchLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x38b770))(this, p0);
        else return MoreSearchLayer::textInputReturn(p0);
    }

    dupable $MoreSearchLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreSearchLayer::*)()){&$MoreSearchLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3896b0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MoreSearchLayer::*)()){&$MoreSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x38b820, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MoreSearchLayer::*)(CCTextInputNode*, float)){&$MoreSearchLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x38b6b0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($MoreSearchLayer::*)(CCTextInputNode*)){&$MoreSearchLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x38b770, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $RetryLevelLayer : public RetryLevelLayer, public $CacBase {
public:
    dupable ~$RetryLevelLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28ed10))(this);
        else return RetryLevelLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x28ec30))(this, p0);
        else return RetryLevelLayer::keyDown(p0);
    }

    dupable void customSetup() override {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28de80))(this);
        else return RetryLevelLayer::customSetup();
    }

    dupable void showLayer(bool p0) override {
        if ((void($RetryLevelLayer::*)(bool)){&$RetryLevelLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x28eaf0))(this, p0);
        else return RetryLevelLayer::showLayer(p0);
    }

    dupable void enterAnimFinished() override {
        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28ebf0))(this);
        else return RetryLevelLayer::enterAnimFinished();
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) override {
        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x28ecf0))(this, p0);
        else return RetryLevelLayer::keyUp(p0);
    }

    dupable $RetryLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x28ed10, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x28ec30, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x28de80, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($RetryLevelLayer::*)(bool)){&$RetryLevelLayer::showLayer} != (void(D::*)(bool)){&D::showLayer})
            m->registerHook(base+0x28eaf0, extract_virtual(V, (void(D::*)(bool)){&D::showLayer}));

        if ((void($RetryLevelLayer::*)()){&$RetryLevelLayer::enterAnimFinished} != (void(D::*)()){&D::enterAnimFinished})
            m->registerHook(base+0x28ebf0, extract_virtual(V, (void(D::*)()){&D::enterAnimFinished}));

        if ((void($RetryLevelLayer::*)(cocos2d::enumKeyCodes)){&$RetryLevelLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x28ecf0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $SelectFontLayer : public SelectFontLayer, public $CacBase {
public:
    dupable ~$SelectFontLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SelectFontLayer::*)()){&$SelectFontLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1445f0))(this);
        else return SelectFontLayer::keyBackClicked();
    }

    dupable $SelectFontLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SelectFontLayer::*)()){&$SelectFontLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1445f0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $SetGroupIDLayer : public SetGroupIDLayer, public $CacBase {
public:
    dupable ~$SetGroupIDLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x198050))(this);
        else return SetGroupIDLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x197ab0))(this, p0);
        else return SetGroupIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x197af0))(this, p0);
        else return SetGroupIDLayer::textChanged(p0);
    }

    dupable $SetGroupIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetGroupIDLayer::*)()){&$SetGroupIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x198050, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x197ab0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetGroupIDLayer::*)(CCTextInputNode*)){&$SetGroupIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x197af0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $SetupPulsePopup : public SetupPulsePopup, public $CacBase {
public:
    dupable ~$SetupPulsePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1ec840))(this);
        else return SetupPulsePopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1ec870))(this);
        else return SetupPulsePopup::show();
    }

    dupable void colorValueChanged(cocos2d::_ccColor3B p0) override {
        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x1ec680))(this, p0);
        else return SetupPulsePopup::colorValueChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec900))(this, p0);
        else return SetupPulsePopup::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec920))(this, p0);
        else return SetupPulsePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ec960))(this, p0);
        else return SetupPulsePopup::textChanged(p0);
    }

    dupable void colorSelectClosed(GJSpecialColorSelect* p0, int p1) override {
        if ((void($SetupPulsePopup::*)(GJSpecialColorSelect*, int)){&$SetupPulsePopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), GJSpecialColorSelect*, int)>(m->getOriginal(base+0x1ebf20))(this, p0, p1);
        else return SetupPulsePopup::colorSelectClosed(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*, float)){&$SetupPulsePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1ecf20))(this, p0, p1);
        else return SetupPulsePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1ecfe0))(this, p0);
        else return SetupPulsePopup::textInputReturn(p0);
    }

    dupable $SetupPulsePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1ec840, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupPulsePopup::*)()){&$SetupPulsePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1ec870, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupPulsePopup::*)(cocos2d::_ccColor3B)){&$SetupPulsePopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(base+0x1ec680, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x1ec900, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1ec920, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1ec960, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPulsePopup::*)(GJSpecialColorSelect*, int)){&$SetupPulsePopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            m->registerHook(base+0x1ebf20, extract_virtual(V, (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*, float)){&$SetupPulsePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1ecf20, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupPulsePopup::*)(CCTextInputNode*)){&$SetupPulsePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1ecfe0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupShakePopup : public SetupShakePopup, public $CacBase {
public:
    dupable ~$SetupShakePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3b00d0))(this);
        else return SetupShakePopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3b0080))(this);
        else return SetupShakePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3afc80))(this, p0);
        else return SetupShakePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3afcc0))(this, p0);
        else return SetupShakePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupShakePopup::*)(CCTextInputNode*, float)){&$SetupShakePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x3b0260))(this, p0, p1);
        else return SetupShakePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3b0320))(this, p0);
        else return SetupShakePopup::textInputReturn(p0);
    }

    dupable $SetupShakePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3b00d0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupShakePopup::*)()){&$SetupShakePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x3b0080, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3afc80, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x3afcc0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*, float)){&$SetupShakePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x3b0260, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupShakePopup::*)(CCTextInputNode*)){&$SetupShakePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x3b0320, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupSpawnPopup : public SetupSpawnPopup, public $CacBase {
public:
    dupable ~$SetupSpawnPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13bc50))(this);
        else return SetupSpawnPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13bc00))(this);
        else return SetupSpawnPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13b950))(this, p0);
        else return SetupSpawnPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13b990))(this, p0);
        else return SetupSpawnPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*, float)){&$SetupSpawnPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x13bda0))(this, p0, p1);
        else return SetupSpawnPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x13be60))(this, p0);
        else return SetupSpawnPopup::textInputReturn(p0);
    }

    dupable $SetupSpawnPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x13bc50, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupSpawnPopup::*)()){&$SetupSpawnPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x13bc00, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x13b950, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x13b990, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*, float)){&$SetupSpawnPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x13bda0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupSpawnPopup::*)(CCTextInputNode*)){&$SetupSpawnPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x13be60, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareLevelLayer : public ShareLevelLayer, public $CacBase {
public:
    dupable ~$ShareLevelLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($ShareLevelLayer::*)()){&$ShareLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12b830))(this);
        else return ShareLevelLayer::keyBackClicked();
    }

    dupable $ShareLevelLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareLevelLayer::*)()){&$ShareLevelLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12b830, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TopArtistsLayer : public TopArtistsLayer, public $CacBase {
public:
    dupable ~$TopArtistsLayer() override {}

    dupable bool init() override {
        if ((bool($TopArtistsLayer::*)()){&$TopArtistsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x192c30))(this);
        else return TopArtistsLayer::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1935b0))(this);
        else return TopArtistsLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x193540))(this);
        else return TopArtistsLayer::keyBackClicked();
    }

    dupable void show() override {
        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x193e40))(this);
        else return TopArtistsLayer::show();
    }

    dupable void loadListFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($TopArtistsLayer::*)(cocos2d::CCArray*, char const*)){&$TopArtistsLayer::loadListFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x193600))(this, p0, p1);
        else return TopArtistsLayer::loadListFinished(p0, p1);
    }

    dupable void loadListFailed(char const* p0) override {
        if ((void($TopArtistsLayer::*)(char const*)){&$TopArtistsLayer::loadListFailed} != (void(D::*)(char const*)){&D::loadListFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1936f0))(this, p0);
        else return TopArtistsLayer::loadListFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($TopArtistsLayer::*)(std::string, char const*)){&$TopArtistsLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x193730))(this, p0, p1);
        else return TopArtistsLayer::setupPageInfo(p0, p1);
    }

    dupable $TopArtistsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($TopArtistsLayer::*)()){&$TopArtistsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x192c30, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1935b0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x193540, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($TopArtistsLayer::*)()){&$TopArtistsLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x193e40, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($TopArtistsLayer::*)(cocos2d::CCArray*, char const*)){&$TopArtistsLayer::loadListFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished})
            m->registerHook(base+0x193600, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadListFinished}));

        if ((void($TopArtistsLayer::*)(char const*)){&$TopArtistsLayer::loadListFailed} != (void(D::*)(char const*)){&D::loadListFailed})
            m->registerHook(base+0x1936f0, extract_virtual(V, (void(D::*)(char const*)){&D::loadListFailed}));

        if ((void($TopArtistsLayer::*)(std::string, char const*)){&$TopArtistsLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x193730, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));
    }
};


template<class D>
class $AccountHelpLayer : public AccountHelpLayer, public $CacBase {
public:
    dupable ~$AccountHelpLayer() override {}

    dupable void customSetup() override {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x83e80))(this);
        else return AccountHelpLayer::customSetup();
    }

    dupable void layerHidden() override {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x84b60))(this);
        else return AccountHelpLayer::layerHidden();
    }

    dupable void accountStatusChanged() override {
        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x84a20))(this);
        else return AccountHelpLayer::accountStatusChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($AccountHelpLayer::*)(FLAlertLayer*, bool)){&$AccountHelpLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x84a50))(this, p0, p1);
        else return AccountHelpLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $AccountHelpLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x83e80, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::layerHidden} != (void(D::*)()){&D::layerHidden})
            m->registerHook(base+0x84b60, extract_virtual(V, (void(D::*)()){&D::layerHidden}));

        if ((void($AccountHelpLayer::*)()){&$AccountHelpLayer::accountStatusChanged} != (void(D::*)()){&D::accountStatusChanged})
            m->registerHook(base+0x84a20, extract_virtual(V, (void(D::*)()){&D::accountStatusChanged}));

        if ((void($AccountHelpLayer::*)(FLAlertLayer*, bool)){&$AccountHelpLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x84a50, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $CCAnimatedSprite : public CCAnimatedSprite, public $CacBase {
public:
    dupable ~$CCAnimatedSprite() override {}

    dupable void setOpacity(unsigned char p0) override {
        if ((void($CCAnimatedSprite::*)(unsigned char)){&$CCAnimatedSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1a6af0))(this, p0);
        else return CCAnimatedSprite::setOpacity(p0);
    }

    dupable void animationFinished(char const* p0) override {
        if ((void($CCAnimatedSprite::*)(char const*)){&$CCAnimatedSprite::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1a6ad0))(this, p0);
        else return CCAnimatedSprite::animationFinished(p0);
    }

    dupable void animationFinishedO(cocos2d::CCObject* p0) override {
        if ((void($CCAnimatedSprite::*)(cocos2d::CCObject*)){&$CCAnimatedSprite::animationFinishedO} != (void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1a6aa0))(this, p0);
        else return CCAnimatedSprite::animationFinishedO(p0);
    }

    dupable $CCAnimatedSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCAnimatedSprite::*)(unsigned char)){&$CCAnimatedSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1a6af0, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($CCAnimatedSprite::*)(char const*)){&$CCAnimatedSprite::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x1a6ad0, extract_virtual(V, (void(D::*)(char const*)){&D::animationFinished}));

        if ((void($CCAnimatedSprite::*)(cocos2d::CCObject*)){&$CCAnimatedSprite::animationFinishedO} != (void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO})
            m->registerHook(base+0x1a6aa0, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::animationFinishedO}));
    }
};


template<class D>
class $CCContentManager : public CCContentManager, public $CacBase {
public:
    dupable ~$CCContentManager() override {}

    dupable $CCContentManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CCPartAnimSprite : public CCPartAnimSprite, public $CacBase {
public:
    dupable ~$CCPartAnimSprite() override {}

    dupable void setScaleX(float p0) override {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff50))(this, p0);
        else return CCPartAnimSprite::setScaleX(p0);
    }

    dupable void setScaleY(float p0) override {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff70))(this, p0);
        else return CCPartAnimSprite::setScaleY(p0);
    }

    dupable void setScale(float p0) override {
        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScale} != (void(D::*)(float)){&D::setScale})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1bff30))(this, p0);
        else return CCPartAnimSprite::setScale(p0);
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($CCPartAnimSprite::*)(unsigned char)){&$CCPartAnimSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x1c01d0))(this, p0);
        else return CCPartAnimSprite::setOpacity(p0);
    }

    dupable void setBlendFunc(cocos2d::_ccBlendFunc p0) override {
        if ((void($CCPartAnimSprite::*)(cocos2d::_ccBlendFunc)){&$CCPartAnimSprite::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccBlendFunc)>(m->getOriginal(base+0x1bff90))(this, p0);
        else return CCPartAnimSprite::setBlendFunc(p0);
    }

    dupable void setDisplayFrame(cocos2d::CCSpriteFrame* p0) override {
        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::setDisplayFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x1bfa40))(this, p0);
        else return CCPartAnimSprite::setDisplayFrame(p0);
    }

    dupable void isFrameDisplayed(cocos2d::CCSpriteFrame* p0) override {
        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::isFrameDisplayed} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCSpriteFrame*)>(m->getOriginal(base+0x1bfc20))(this, p0);
        else return CCPartAnimSprite::isFrameDisplayed(p0);
    }

    dupable void displayFrame() override {
        if ((void($CCPartAnimSprite::*)()){&$CCPartAnimSprite::displayFrame} != (void(D::*)()){&D::displayFrame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bfc40))(this);
        else return CCPartAnimSprite::displayFrame();
    }

    dupable $CCPartAnimSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleX} != (void(D::*)(float)){&D::setScaleX})
            m->registerHook(base+0x1bff50, extract_virtual(V, (void(D::*)(float)){&D::setScaleX}));

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScaleY} != (void(D::*)(float)){&D::setScaleY})
            m->registerHook(base+0x1bff70, extract_virtual(V, (void(D::*)(float)){&D::setScaleY}));

        if ((void($CCPartAnimSprite::*)(float)){&$CCPartAnimSprite::setScale} != (void(D::*)(float)){&D::setScale})
            m->registerHook(base+0x1bff30, extract_virtual(V, (void(D::*)(float)){&D::setScale}));

        if ((void($CCPartAnimSprite::*)(unsigned char)){&$CCPartAnimSprite::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x1c01d0, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($CCPartAnimSprite::*)(cocos2d::_ccBlendFunc)){&$CCPartAnimSprite::setBlendFunc} != (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc})
            m->registerHook(base+0x1bff90, extract_virtual(V, (void(D::*)(cocos2d::_ccBlendFunc)){&D::setBlendFunc}));

        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::setDisplayFrame} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame})
            m->registerHook(base+0x1bfa40, extract_virtual(V, (void(D::*)(cocos2d::CCSpriteFrame*)){&D::setDisplayFrame}));

        if ((void($CCPartAnimSprite::*)(cocos2d::CCSpriteFrame*)){&$CCPartAnimSprite::isFrameDisplayed} != (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed})
            m->registerHook(base+0x1bfc20, extract_virtual(V, (void(D::*)(cocos2d::CCSpriteFrame*)){&D::isFrameDisplayed}));

        if ((void($CCPartAnimSprite::*)()){&$CCPartAnimSprite::displayFrame} != (void(D::*)()){&D::displayFrame})
            m->registerHook(base+0x1bfc40, extract_virtual(V, (void(D::*)()){&D::displayFrame}));
    }
};


template<class D>
class $CCScrollLayerExt : public CCScrollLayerExt, public $CacBase {
public:
    dupable ~$CCScrollLayerExt() override {}

    dupable void visit() override {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236550))(this);
        else return CCScrollLayerExt::visit();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x235ef0))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236300))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x236020))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2362a0))(this, p0, p1);
        else return CCScrollLayerExt::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x235eb0))(this);
        else return CCScrollLayerExt::registerWithTouchDispatcher();
    }

    dupable void preVisitWithClippingRect(cocos2d::CCRect p0) override {
        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect)>(m->getOriginal(base+0x2366a0))(this, p0);
        else return CCScrollLayerExt::preVisitWithClippingRect(p0);
    }

    dupable void postVisit() override {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x236720))(this);
        else return CCScrollLayerExt::postVisit();
    }

    dupable void moveToTop() {
        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::moveToTop} != (void(D::*)()){&D::moveToTop})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x235870))(this);
        else return CCScrollLayerExt::moveToTop();
    }

    dupable void moveToTopWithOffset(float p0) {
        if ((void($CCScrollLayerExt::*)(float)){&$CCScrollLayerExt::moveToTopWithOffset} != (void(D::*)(float)){&D::moveToTopWithOffset})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2357d0))(this, p0);
        else return CCScrollLayerExt::moveToTopWithOffset(p0);
    }

    dupable $CCScrollLayerExt() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x236550, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((bool($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x235ef0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x236300, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x236020, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CCScrollLayerExt::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x2362a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x235eb0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CCScrollLayerExt::*)(cocos2d::CCRect)){&$CCScrollLayerExt::preVisitWithClippingRect} != (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect})
            m->registerHook(base+0x2366a0, extract_virtual(V, (void(D::*)(cocos2d::CCRect)){&D::preVisitWithClippingRect}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::postVisit} != (void(D::*)()){&D::postVisit})
            m->registerHook(base+0x236720, extract_virtual(V, (void(D::*)()){&D::postVisit}));

        if ((void($CCScrollLayerExt::*)()){&$CCScrollLayerExt::moveToTop} != (void(D::*)()){&D::moveToTop})
            m->registerHook(base+0x235870, extract((void(D::*)()){&D::moveToTop}));

        if ((void($CCScrollLayerExt::*)(float)){&$CCScrollLayerExt::moveToTopWithOffset} != (void(D::*)(float)){&D::moveToTopWithOffset})
            m->registerHook(base+0x2357d0, extract((void(D::*)(float)){&D::moveToTopWithOffset}));
    }
};


template<class D>
class $CheckpointObject : public CheckpointObject, public $CacBase {
public:
    dupable ~$CheckpointObject() override {}

    dupable bool init() override {
        if ((bool($CheckpointObject::*)()){&$CheckpointObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x80920))(this);
        else return CheckpointObject::init();
    }

    dupable $CheckpointObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($CheckpointObject::*)()){&$CheckpointObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x80920, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ColorSelectPopup : public ColorSelectPopup, public $CacBase {
public:
    dupable ~$ColorSelectPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x423540))(this);
        else return ColorSelectPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x423570))(this);
        else return ColorSelectPopup::show();
    }

    dupable void colorValueChanged(cocos2d::_ccColor3B p0) override {
        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0x423320))(this, p0);
        else return ColorSelectPopup::colorValueChanged(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x423820))(this, p0);
        else return ColorSelectPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x423860))(this, p0);
        else return ColorSelectPopup::textChanged(p0);
    }

    dupable void colorSelectClosed(GJSpecialColorSelect* p0, int p1) override {
        if ((void($ColorSelectPopup::*)(GJSpecialColorSelect*, int)){&$ColorSelectPopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), GJSpecialColorSelect*, int)>(m->getOriginal(base+0x423c80))(this, p0, p1);
        else return ColorSelectPopup::colorSelectClosed(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*, float)){&$ColorSelectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x423fa0))(this, p0, p1);
        else return ColorSelectPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x424060))(this, p0);
        else return ColorSelectPopup::textInputReturn(p0);
    }

    dupable $ColorSelectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x423540, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ColorSelectPopup::*)()){&$ColorSelectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x423570, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($ColorSelectPopup::*)(cocos2d::_ccColor3B)){&$ColorSelectPopup::colorValueChanged} != (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged})
            m->registerHook(base+0x423320, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B)){&D::colorValueChanged}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x423820, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x423860, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($ColorSelectPopup::*)(GJSpecialColorSelect*, int)){&$ColorSelectPopup::colorSelectClosed} != (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed})
            m->registerHook(base+0x423c80, extract_virtual(V, (void(D::*)(GJSpecialColorSelect*, int)){&D::colorSelectClosed}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*, float)){&$ColorSelectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x423fa0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($ColorSelectPopup::*)(CCTextInputNode*)){&$ColorSelectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x424060, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $CustomSongWidget : public CustomSongWidget, public $CacBase {
public:
    dupable ~$CustomSongWidget() override {}

    dupable void loadSongInfoFinished(SongInfoObject* p0) override {
        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x37e400))(this, p0);
        else return CustomSongWidget::loadSongInfoFinished(p0);
    }

    dupable void loadSongInfoFailed(int p0, GJSongError p1) override {
        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x37e5a0))(this, p0, p1);
        else return CustomSongWidget::loadSongInfoFailed(p0, p1);
    }

    dupable void downloadSongFinished(SongInfoObject* p0) override {
        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x37e7b0))(this, p0);
        else return CustomSongWidget::downloadSongFinished(p0);
    }

    dupable void downloadSongFailed(int p0, GJSongError p1) override {
        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x37e8c0))(this, p0, p1);
        else return CustomSongWidget::downloadSongFailed(p0, p1);
    }

    dupable void songStateChanged() override {
        if ((void($CustomSongWidget::*)()){&$CustomSongWidget::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37e390))(this);
        else return CustomSongWidget::songStateChanged();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($CustomSongWidget::*)(FLAlertLayer*, bool)){&$CustomSongWidget::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x37ea00))(this, p0, p1);
        else return CustomSongWidget::FLAlert_Clicked(p0, p1);
    }

    dupable $CustomSongWidget() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            m->registerHook(base+0x37e400, extract_virtual(V, (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished}));

        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            m->registerHook(base+0x37e5a0, extract_virtual(V, (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed}));

        if ((void($CustomSongWidget::*)(SongInfoObject*)){&$CustomSongWidget::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            m->registerHook(base+0x37e7b0, extract_virtual(V, (void(D::*)(SongInfoObject*)){&D::downloadSongFinished}));

        if ((void($CustomSongWidget::*)(int, GJSongError)){&$CustomSongWidget::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            m->registerHook(base+0x37e8c0, extract_virtual(V, (void(D::*)(int, GJSongError)){&D::downloadSongFailed}));

        if ((void($CustomSongWidget::*)()){&$CustomSongWidget::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            m->registerHook(base+0x37e390, extract_virtual(V, (void(D::*)()){&D::songStateChanged}));

        if ((void($CustomSongWidget::*)(FLAlertLayer*, bool)){&$CustomSongWidget::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x37ea00, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EditorPauseLayer : public EditorPauseLayer, public $CacBase {
public:
    dupable ~$EditorPauseLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13f320))(this);
        else return EditorPauseLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($EditorPauseLayer::*)(cocos2d::enumKeyCodes)){&$EditorPauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x13f3a0))(this, p0);
        else return EditorPauseLayer::keyDown(p0);
    }

    dupable void customSetup() override {
        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x13cc00))(this);
        else return EditorPauseLayer::customSetup();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($EditorPauseLayer::*)(FLAlertLayer*, bool)){&$EditorPauseLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x13f1b0))(this, p0, p1);
        else return EditorPauseLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $EditorPauseLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x13f320, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($EditorPauseLayer::*)(cocos2d::enumKeyCodes)){&$EditorPauseLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x13f3a0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorPauseLayer::*)()){&$EditorPauseLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x13cc00, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($EditorPauseLayer::*)(FLAlertLayer*, bool)){&$EditorPauseLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x13f1b0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $EffectGameObject : public EffectGameObject, public $CacBase {
public:
    dupable ~$EffectGameObject() override {}

    dupable void customSetup() override {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xca370))(this);
        else return EffectGameObject::customSetup();
    }

    dupable void triggerObject(GJBaseGameLayer* p0) override {
        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            return reinterpret_cast<void(*)(decltype(this), GJBaseGameLayer*)>(m->getOriginal(base+0xc9870))(this, p0);
        else return EffectGameObject::triggerObject(p0);
    }

    dupable void getSaveString() override {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xcd7e0))(this);
        else return EffectGameObject::getSaveString();
    }

    dupable void triggerActivated(float p0) override {
        if ((void($EffectGameObject::*)(float)){&$EffectGameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xca310))(this, p0);
        else return EffectGameObject::triggerActivated(p0);
    }

    dupable void spawnXPosition() override {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xca2d0))(this);
        else return EffectGameObject::spawnXPosition();
    }

    dupable static EffectGameObject* create(char const* p0) {
        if ((EffectGameObject*(*)(char const*)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const*)){&D::create})
            return reinterpret_cast<EffectGameObject*(*)(char const*)>(m->getOriginal(base+0xc9790))(p0);
        else return EffectGameObject::create(p0);
    }

    dupable void getTargetColorIndex() {
        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xca1f0))(this);
        else return EffectGameObject::getTargetColorIndex();
    }

    dupable $EffectGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0xca370, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($EffectGameObject::*)(GJBaseGameLayer*)){&$EffectGameObject::triggerObject} != (void(D::*)(GJBaseGameLayer*)){&D::triggerObject})
            m->registerHook(base+0xc9870, extract_virtual(V, (void(D::*)(GJBaseGameLayer*)){&D::triggerObject}));

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xcd7e0, extract_virtual(V, (void(D::*)()){&D::getSaveString}));

        if ((void($EffectGameObject::*)(float)){&$EffectGameObject::triggerActivated} != (void(D::*)(float)){&D::triggerActivated})
            m->registerHook(base+0xca310, extract_virtual(V, (void(D::*)(float)){&D::triggerActivated}));

        if ((void($EffectGameObject::*)()){&$EffectGameObject::spawnXPosition} != (void(D::*)()){&D::spawnXPosition})
            m->registerHook(base+0xca2d0, extract_virtual(V, (void(D::*)()){&D::spawnXPosition}));

        if ((EffectGameObject*(*)(char const*)){&$EffectGameObject::create} != (EffectGameObject*(*)(char const*)){&D::create})
            m->registerHook(base+0xc9790, (EffectGameObject*(*)(char const*)){&D::create});

        if ((void($EffectGameObject::*)()){&$EffectGameObject::getTargetColorIndex} != (void(D::*)()){&D::getTargetColorIndex})
            m->registerHook(base+0xca1f0, extract((void(D::*)()){&D::getTargetColorIndex}));
    }
};


template<class D>
class $FollowRewardPage : public FollowRewardPage, public $CacBase {
public:
    dupable ~$FollowRewardPage() override {}

    dupable bool init() override {
        if ((bool($FollowRewardPage::*)()){&$FollowRewardPage::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x22f4a0))(this);
        else return FollowRewardPage::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230eb0))(this);
        else return FollowRewardPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230e40))(this);
        else return FollowRewardPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230c10))(this);
        else return FollowRewardPage::show();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($FollowRewardPage::*)(FLAlertLayer*, bool)){&$FollowRewardPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x230da0))(this, p0, p1);
        else return FollowRewardPage::FLAlert_Clicked(p0, p1);
    }

    dupable void updateRate() override {
        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::updateRate} != (void(D::*)()){&D::updateRate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x230950))(this);
        else return FollowRewardPage::updateRate();
    }

    dupable $FollowRewardPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($FollowRewardPage::*)()){&$FollowRewardPage::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x22f4a0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x230eb0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x230e40, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x230c10, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($FollowRewardPage::*)(FLAlertLayer*, bool)){&$FollowRewardPage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x230da0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($FollowRewardPage::*)()){&$FollowRewardPage::updateRate} != (void(D::*)()){&D::updateRate})
            m->registerHook(base+0x230950, extract_virtual(V, (void(D::*)()){&D::updateRate}));
    }
};


template<class D>
class $GJAccountManager : public GJAccountManager, public $CacBase {
public:
    dupable ~$GJAccountManager() override {}

    dupable bool init() override {
        if ((bool($GJAccountManager::*)()){&$GJAccountManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x879d0))(this);
        else return GJAccountManager::init();
    }

    dupable $GJAccountManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJAccountManager::*)()){&$GJAccountManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x879d0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJFlyGroundLayer : public GJFlyGroundLayer, public $CacBase {
public:
    dupable ~$GJFlyGroundLayer() override {}

    dupable bool init() override {
        if ((bool($GJFlyGroundLayer::*)()){&$GJFlyGroundLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x356c00))(this);
        else return GJFlyGroundLayer::init();
    }

    dupable $GJFlyGroundLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJFlyGroundLayer::*)()){&$GJFlyGroundLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x356c00, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJLevelScoreCell : public GJLevelScoreCell, public $CacBase {
public:
    dupable ~$GJLevelScoreCell() override {}

    dupable bool init() override {
        if ((bool($GJLevelScoreCell::*)()){&$GJLevelScoreCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11dbb0))(this);
        else return GJLevelScoreCell::init();
    }

    dupable void draw() override {
        if ((void($GJLevelScoreCell::*)()){&$GJLevelScoreCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11dc00))(this);
        else return GJLevelScoreCell::draw();
    }

    dupable $GJLevelScoreCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJLevelScoreCell::*)()){&$GJLevelScoreCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11dbb0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJLevelScoreCell::*)()){&$GJLevelScoreCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11dc00, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $GJMoreGamesLayer : public GJMoreGamesLayer, public $CacBase {
public:
    dupable ~$GJMoreGamesLayer() override {}

    dupable void customSetup() override {
        if ((void($GJMoreGamesLayer::*)()){&$GJMoreGamesLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x43ae60))(this);
        else return GJMoreGamesLayer::customSetup();
    }

    dupable $GJMoreGamesLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMoreGamesLayer::*)()){&$GJMoreGamesLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x43ae60, extract_virtual(V, (void(D::*)()){&D::customSetup}));
    }
};


template<class D>
class $GameLevelManager : public GameLevelManager, public $CacBase {
public:
    dupable ~$GameLevelManager() override {}

    dupable bool init() override {
        if ((bool($GameLevelManager::*)()){&$GameLevelManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2b7ba0))(this);
        else return GameLevelManager::init();
    }

    dupable $GameLevelManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameLevelManager::*)()){&$GameLevelManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2b7ba0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameSoundManager : public GameSoundManager, public $CacBase {
public:
    dupable ~$GameSoundManager() override {}

    dupable bool init() override {
        if ((bool($GameSoundManager::*)()){&$GameSoundManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x3611d0))(this);
        else return GameSoundManager::init();
    }

    dupable $GameSoundManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameSoundManager::*)()){&$GameSoundManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x3611d0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GameStatsManager : public GameStatsManager, public $CacBase {
public:
    dupable ~$GameStatsManager() override {}

    dupable bool init() override {
        if ((bool($GameStatsManager::*)()){&$GameStatsManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x39330))(this);
        else return GameStatsManager::init();
    }

    dupable $GameStatsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameStatsManager::*)()){&$GameStatsManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x39330, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GhostTrailEffect : public GhostTrailEffect, public $CacBase {
public:
    dupable ~$GhostTrailEffect() override {}

    dupable bool init() override {
        if ((bool($GhostTrailEffect::*)()){&$GhostTrailEffect::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x360730))(this);
        else return GhostTrailEffect::init();
    }

    dupable void draw() override {
        if ((void($GhostTrailEffect::*)()){&$GhostTrailEffect::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x360d20))(this);
        else return GhostTrailEffect::draw();
    }

    dupable $GhostTrailEffect() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GhostTrailEffect::*)()){&$GhostTrailEffect::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x360730, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GhostTrailEffect::*)()){&$GhostTrailEffect::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x360d20, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $KeybindingsLayer : public KeybindingsLayer, public $CacBase {
public:
    dupable ~$KeybindingsLayer() override {}

    dupable bool init() override {
        if ((bool($KeybindingsLayer::*)()){&$KeybindingsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x375890))(this);
        else return KeybindingsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($KeybindingsLayer::*)()){&$KeybindingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x376f30))(this);
        else return KeybindingsLayer::keyBackClicked();
    }

    dupable $KeybindingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeybindingsLayer::*)()){&$KeybindingsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x375890, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($KeybindingsLayer::*)()){&$KeybindingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x376f30, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LevelEditorLayer : public LevelEditorLayer, public $CacBase {
public:
    dupable ~$LevelEditorLayer() override {}

    dupable void update(float p0) override {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xa1b70))(this, p0);
        else return LevelEditorLayer::update(p0);
    }

    dupable void draw() override {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xa2a70))(this);
        else return LevelEditorLayer::draw();
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) override {
        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0x9c200))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return LevelEditorLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) override {
        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0xa04e0))(this, p0, p1, p2);
        else return LevelEditorLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0x9c590))(this, p0, p1, p2, p3, p4, p5);
        else return LevelEditorLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void addToGroup(GameObject* p0, int p1, bool p2) override {
        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, bool)>(m->getOriginal(base+0x9dab0))(this, p0, p1, p2);
        else return LevelEditorLayer::addToGroup(p0, p1, p2);
    }

    dupable void removeFromGroup(GameObject* p0, int p1) override {
        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int)>(m->getOriginal(base+0x9db60))(this, p0, p1);
        else return LevelEditorLayer::removeFromGroup(p0, p1);
    }

    dupable void timeForXPos(float p0) override {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x9c7d0))(this, p0);
        else return LevelEditorLayer::timeForXPos(p0);
    }

    dupable void xPosForTime(float p0) override {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x9c800))(this, p0);
        else return LevelEditorLayer::xPosForTime(p0);
    }

    dupable void levelSettingsUpdated() override {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x93f30))(this);
        else return LevelEditorLayer::levelSettingsUpdated();
    }

    dupable void activateTriggerEffect(EffectGameObject* p0, float p1, float p2, float p3) {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, float, float, float)>(m->getOriginal(base+0x9b520))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::activateTriggerEffect(p0, p1, p2, p3);
    }

    dupable GameObject* addObjectFromString(std::string p0) {
        if ((GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::string)){&D::addObjectFromString})
            return reinterpret_cast<GameObject*(*)(decltype(this), std::string)>(m->getOriginal(base+0x94640))(this, p0);
        else return LevelEditorLayer::addObjectFromString(p0);
    }

    dupable void addSpecial(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject*)){&D::addSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x94f30))(this, p0);
        else return LevelEditorLayer::addSpecial(p0);
    }

    dupable void addToRedoList(UndoObject* p0) {
        if ((void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject*)){&D::addToRedoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject*)>(m->getOriginal(base+0x96f80))(this, p0);
        else return LevelEditorLayer::addToRedoList(p0);
    }

    dupable void addToUndoList(UndoObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject*, bool)){&D::addToUndoList})
            return reinterpret_cast<void(*)(decltype(this), UndoObject*, bool)>(m->getOriginal(base+0x94e20))(this, p0, p1);
        else return LevelEditorLayer::addToUndoList(p0, p1);
    }

    dupable void animateInDualGround(GameObject* p0, float p1, bool p2) {
        if ((void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(base+0xa2780))(this, p0, p1, p2);
        else return LevelEditorLayer::animateInDualGround(p0, p1, p2);
    }

    dupable void checkCollisions(PlayerObject* p0, float p1) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(base+0x9e620))(this, p0, p1);
        else return LevelEditorLayer::checkCollisions(p0, p1);
    }

    dupable static LevelEditorLayer* create(GJGameLevel* p0) {
        if ((LevelEditorLayer*(*)(GJGameLevel*)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel*)){&D::create})
            return reinterpret_cast<LevelEditorLayer*(*)(GJGameLevel*)>(m->getOriginal(base+0x90fb0))(p0);
        else return LevelEditorLayer::create(p0);
    }

    dupable void createBackground() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x929f0))(this);
        else return LevelEditorLayer::createBackground();
    }

    dupable void createGroundLayer() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x92840))(this);
        else return LevelEditorLayer::createGroundLayer();
    }

    dupable GameObject* createObject(int p0, cocos2d::CCPoint p1, bool p2) {
        if ((GameObject*($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject})
            return reinterpret_cast<GameObject*(*)(decltype(this), int, cocos2d::CCPoint, bool)>(m->getOriginal(base+0x957c0))(this, p0, p1, p2);
        else return LevelEditorLayer::createObject(p0, p1, p2);
    }

    dupable void createObjectsFromSetup(std::string p0) {
        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x92230))(this, p0);
        else return LevelEditorLayer::createObjectsFromSetup(p0);
    }

    dupable void createObjectsFromString(std::string p0, bool p1) {
        if ((void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::string, bool)){&D::createObjectsFromString})
            return reinterpret_cast<void(*)(decltype(this), std::string, bool)>(m->getOriginal(base+0x94730))(this, p0, p1);
        else return LevelEditorLayer::createObjectsFromString(p0, p1);
    }

    dupable void getLastObjectX() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9c860))(this);
        else return LevelEditorLayer::getLastObjectX();
    }

    dupable void getLevelString() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x97790))(this);
        else return LevelEditorLayer::getLevelString();
    }

    dupable void getNextColorChannel() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9a610))(this);
        else return LevelEditorLayer::getNextColorChannel();
    }

    dupable void getNextFreeBlockID(cocos2d::CCArray* p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(base+0x9a4e0))(this, p0);
        else return LevelEditorLayer::getNextFreeBlockID(p0);
    }

    dupable int getNextFreeGroupID(cocos2d::CCArray* p0) {
        if ((int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID})
            return reinterpret_cast<int(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(base+0x9a1b0))(this, p0);
        else return LevelEditorLayer::getNextFreeGroupID(p0);
    }

    dupable void getNextFreeItemID(cocos2d::CCArray* p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*)>(m->getOriginal(base+0x9a390))(this, p0);
        else return LevelEditorLayer::getNextFreeItemID(p0);
    }

    dupable void getObjectRect(GameObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject*, bool)){&D::getObjectRect})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(base+0x96240))(this, p0, p1);
        else return LevelEditorLayer::getObjectRect(p0, p1);
    }

    dupable void getRelativeOffset(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject*)){&D::getRelativeOffset})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x96840))(this, p0);
        else return LevelEditorLayer::getRelativeOffset(p0);
    }

    dupable void handleAction(bool p0, cocos2d::CCArray* p1) {
        if ((void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction} != (void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction})
            return reinterpret_cast<void(*)(decltype(this), bool, cocos2d::CCArray*)>(m->getOriginal(base+0x97020))(this, p0, p1);
        else return LevelEditorLayer::handleAction(p0, p1);
    }

    dupable bool init(GJGameLevel* p0) {
        if ((bool($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x91010))(this, p0);
        else return LevelEditorLayer::init(p0);
    }

    dupable void objectAtPosition(cocos2d::CCPoint p0) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x960c0))(this, p0);
        else return LevelEditorLayer::objectAtPosition(p0);
    }

    dupable void objectMoved(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject*)){&D::objectMoved})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x999f0))(this, p0);
        else return LevelEditorLayer::objectMoved(p0);
    }

    dupable void objectsInRect(cocos2d::CCRect p0, bool p1) {
        if ((void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCRect, bool)>(m->getOriginal(base+0x95e60))(this, p0, p1);
        else return LevelEditorLayer::objectsInRect(p0, p1);
    }

    dupable void onPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xa06b0))(this);
        else return LevelEditorLayer::onPlaytest();
    }

    dupable void onStopPlaytest() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xa1780))(this);
        else return LevelEditorLayer::onStopPlaytest();
    }

    dupable void playMusic() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xa13c0))(this);
        else return LevelEditorLayer::playMusic();
    }

    dupable void recreateGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9dbf0))(this);
        else return LevelEditorLayer::recreateGroups();
    }

    dupable void redoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x97750))(this);
        else return LevelEditorLayer::redoLastAction();
    }

    dupable void removeAllObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x93d80))(this);
        else return LevelEditorLayer::removeAllObjects();
    }

    dupable void removeAllObjectsOfType(int p0) {
        if ((void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(int)){&D::removeAllObjectsOfType})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x96d40))(this, p0);
        else return LevelEditorLayer::removeAllObjectsOfType(p0);
    }

    dupable void removeObject(GameObject* p0, bool p1) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject*, bool)){&D::removeObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(base+0x96890))(this, p0, p1);
        else return LevelEditorLayer::removeObject(p0, p1);
    }

    dupable void removeSpecial(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject*)){&D::removeSpecial})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x969c0))(this, p0);
        else return LevelEditorLayer::removeSpecial(p0);
    }

    dupable void resetMovingObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9ddc0))(this);
        else return LevelEditorLayer::resetMovingObjects();
    }

    dupable void resetObjectVector() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9c4b0))(this);
        else return LevelEditorLayer::resetObjectVector();
    }

    dupable void resetToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9aa70))(this);
        else return LevelEditorLayer::resetToggledGroups();
    }

    dupable void resetToggledGroupsAndObjects() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9c3c0))(this);
        else return LevelEditorLayer::resetToggledGroupsAndObjects();
    }

    dupable void resetUnusedColorChannels() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9a870))(this);
        else return LevelEditorLayer::resetUnusedColorChannels();
    }

    dupable void rotationForSlopeNearObject(GameObject* p0) {
        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject*)){&D::rotationForSlopeNearObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x95cd0))(this, p0);
        else return LevelEditorLayer::rotationForSlopeNearObject(p0);
    }

    dupable void runColorEffect(EffectGameObject* p0, int p1, float p2, float p3, bool p4) {
        if ((void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, int, float, float, bool)>(m->getOriginal(base+0x9bd30))(this, p0, p1, p2, p3, p4);
        else return LevelEditorLayer::runColorEffect(p0, p1, p2, p3, p4);
    }

    dupable void scene(GJGameLevel* p0) {
        if ((void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x90f20))(this, p0);
        else return LevelEditorLayer::scene(p0);
    }

    dupable void setupLevelStart(LevelSettingsObject* p0) {
        if ((void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(base+0xa0ca0))(this, p0);
        else return LevelEditorLayer::setupLevelStart(p0);
    }

    dupable void sortStickyGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x92b10))(this);
        else return LevelEditorLayer::sortStickyGroups();
    }

    dupable void stopTriggersInGroup(int p0, float p1) {
        if ((void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(int, float)){&D::stopTriggersInGroup})
            return reinterpret_cast<void(*)(decltype(this), int, float)>(m->getOriginal(base+0x9c030))(this, p0, p1);
        else return LevelEditorLayer::stopTriggersInGroup(p0, p1);
    }

    dupable void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        if ((void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(base+0xa0200))(this, p0, p1, p2, p3);
        else return LevelEditorLayer::toggleDualMode(p0, p1, p2, p3);
    }

    dupable void toggleGroupPreview(int p0, bool p1) {
        if ((void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(int, bool)){&D::toggleGroupPreview})
            return reinterpret_cast<void(*)(decltype(this), int, bool)>(m->getOriginal(base+0x9bea0))(this, p0, p1);
        else return LevelEditorLayer::toggleGroupPreview(p0, p1);
    }

    dupable void transferDefaultColors(GJEffectManager* p0, GJEffectManager* p1) {
        if ((void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors})
            return reinterpret_cast<void(*)(decltype(this), GJEffectManager*, GJEffectManager*)>(m->getOriginal(base+0x9ab50))(this, p0, p1);
        else return LevelEditorLayer::transferDefaultColors(p0, p1);
    }

    dupable void undoLastAction() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x97770))(this);
        else return LevelEditorLayer::undoLastAction();
    }

    dupable void updateBGAndGColors() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9b9b0))(this);
        else return LevelEditorLayer::updateBGAndGColors();
    }

    dupable void updateBlendValues() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9bc60))(this);
        else return LevelEditorLayer::updateBlendValues();
    }

    dupable void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        if ((void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(base+0xa1a60))(this, p0, p1, p2);
        else return LevelEditorLayer::updateDualGround(p0, p1, p2);
    }

    dupable void updateEditorMode() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x93b50))(this);
        else return LevelEditorLayer::updateEditorMode();
    }

    dupable void updateGameObjectsNew() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9adc0))(this);
        else return LevelEditorLayer::updateGameObjectsNew();
    }

    dupable void updateGround(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround} != (void(D::*)(float)){&D::updateGround})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x93a60))(this, p0);
        else return LevelEditorLayer::updateGround(p0);
    }

    dupable void updateGroundWidth() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x92af0))(this);
        else return LevelEditorLayer::updateGroundWidth();
    }

    dupable void updateOptions() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x91ed0))(this);
        else return LevelEditorLayer::updateOptions();
    }

    dupable void updateToggledGroups() {
        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x9bb10))(this);
        else return LevelEditorLayer::updateToggledGroups();
    }

    dupable void updateVisibility(float p0) {
        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(float)){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x92c70))(this, p0);
        else return LevelEditorLayer::updateVisibility(p0);
    }

    dupable $LevelEditorLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0xa1b70, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0xa2a70, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($LevelEditorLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$LevelEditorLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0x9c200, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, bool, bool)){&$LevelEditorLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0xa04e0, extract_virtual(V, (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$LevelEditorLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0x9c590, extract_virtual(V, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($LevelEditorLayer::*)(GameObject*, int, bool)){&$LevelEditorLayer::addToGroup} != (void(D::*)(GameObject*, int, bool)){&D::addToGroup})
            m->registerHook(base+0x9dab0, extract_virtual(V, (void(D::*)(GameObject*, int, bool)){&D::addToGroup}));

        if ((void($LevelEditorLayer::*)(GameObject*, int)){&$LevelEditorLayer::removeFromGroup} != (void(D::*)(GameObject*, int)){&D::removeFromGroup})
            m->registerHook(base+0x9db60, extract_virtual(V, (void(D::*)(GameObject*, int)){&D::removeFromGroup}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(base+0x9c7d0, extract_virtual(V, (void(D::*)(float)){&D::timeForXPos}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(base+0x9c800, extract_virtual(V, (void(D::*)(float)){&D::xPosForTime}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::levelSettingsUpdated} != (void(D::*)()){&D::levelSettingsUpdated})
            m->registerHook(base+0x93f30, extract_virtual(V, (void(D::*)()){&D::levelSettingsUpdated}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, float, float, float)){&$LevelEditorLayer::activateTriggerEffect} != (void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect})
            m->registerHook(base+0x9b520, extract((void(D::*)(EffectGameObject*, float, float, float)){&D::activateTriggerEffect}));

        if ((GameObject*($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::addObjectFromString} != (GameObject*(D::*)(std::string)){&D::addObjectFromString})
            m->registerHook(base+0x94640, extract((GameObject*(D::*)(std::string)){&D::addObjectFromString}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::addSpecial} != (void(D::*)(GameObject*)){&D::addSpecial})
            m->registerHook(base+0x94f30, extract((void(D::*)(GameObject*)){&D::addSpecial}));

        if ((void($LevelEditorLayer::*)(UndoObject*)){&$LevelEditorLayer::addToRedoList} != (void(D::*)(UndoObject*)){&D::addToRedoList})
            m->registerHook(base+0x96f80, extract((void(D::*)(UndoObject*)){&D::addToRedoList}));

        if ((void($LevelEditorLayer::*)(UndoObject*, bool)){&$LevelEditorLayer::addToUndoList} != (void(D::*)(UndoObject*, bool)){&D::addToUndoList})
            m->registerHook(base+0x94e20, extract((void(D::*)(UndoObject*, bool)){&D::addToUndoList}));

        if ((void($LevelEditorLayer::*)(GameObject*, float, bool)){&$LevelEditorLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(base+0xa2780, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, float)){&$LevelEditorLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(base+0x9e620, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((LevelEditorLayer*(*)(GJGameLevel*)){&$LevelEditorLayer::create} != (LevelEditorLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(base+0x90fb0, (LevelEditorLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createBackground} != (void(D::*)()){&D::createBackground})
            m->registerHook(base+0x929f0, extract((void(D::*)()){&D::createBackground}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::createGroundLayer} != (void(D::*)()){&D::createGroundLayer})
            m->registerHook(base+0x92840, extract((void(D::*)()){&D::createGroundLayer}));

        if ((GameObject*($LevelEditorLayer::*)(int, cocos2d::CCPoint, bool)){&$LevelEditorLayer::createObject} != (GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject})
            m->registerHook(base+0x957c0, extract((GameObject*(D::*)(int, cocos2d::CCPoint, bool)){&D::createObject}));

        if ((void($LevelEditorLayer::*)(std::string)){&$LevelEditorLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(base+0x92230, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($LevelEditorLayer::*)(std::string, bool)){&$LevelEditorLayer::createObjectsFromString} != (void(D::*)(std::string, bool)){&D::createObjectsFromString})
            m->registerHook(base+0x94730, extract((void(D::*)(std::string, bool)){&D::createObjectsFromString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLastObjectX} != (void(D::*)()){&D::getLastObjectX})
            m->registerHook(base+0x9c860, extract((void(D::*)()){&D::getLastObjectX}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getLevelString} != (void(D::*)()){&D::getLevelString})
            m->registerHook(base+0x97790, extract((void(D::*)()){&D::getLevelString}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::getNextColorChannel} != (void(D::*)()){&D::getNextColorChannel})
            m->registerHook(base+0x9a610, extract((void(D::*)()){&D::getNextColorChannel}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeBlockID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID})
            m->registerHook(base+0x9a4e0, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeBlockID}));

        if ((int($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeGroupID} != (int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID})
            m->registerHook(base+0x9a1b0, extract((int(D::*)(cocos2d::CCArray*)){&D::getNextFreeGroupID}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCArray*)){&$LevelEditorLayer::getNextFreeItemID} != (void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID})
            m->registerHook(base+0x9a390, extract((void(D::*)(cocos2d::CCArray*)){&D::getNextFreeItemID}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::getObjectRect} != (void(D::*)(GameObject*, bool)){&D::getObjectRect})
            m->registerHook(base+0x96240, extract((void(D::*)(GameObject*, bool)){&D::getObjectRect}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::getRelativeOffset} != (void(D::*)(GameObject*)){&D::getRelativeOffset})
            m->registerHook(base+0x96840, extract((void(D::*)(GameObject*)){&D::getRelativeOffset}));

        if ((void($LevelEditorLayer::*)(bool, cocos2d::CCArray*)){&$LevelEditorLayer::handleAction} != (void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction})
            m->registerHook(base+0x97020, extract((void(D::*)(bool, cocos2d::CCArray*)){&D::handleAction}));

        if ((bool($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(base+0x91010, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCPoint)){&$LevelEditorLayer::objectAtPosition} != (void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition})
            m->registerHook(base+0x960c0, extract((void(D::*)(cocos2d::CCPoint)){&D::objectAtPosition}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::objectMoved} != (void(D::*)(GameObject*)){&D::objectMoved})
            m->registerHook(base+0x999f0, extract((void(D::*)(GameObject*)){&D::objectMoved}));

        if ((void($LevelEditorLayer::*)(cocos2d::CCRect, bool)){&$LevelEditorLayer::objectsInRect} != (void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect})
            m->registerHook(base+0x95e60, extract((void(D::*)(cocos2d::CCRect, bool)){&D::objectsInRect}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onPlaytest} != (void(D::*)()){&D::onPlaytest})
            m->registerHook(base+0xa06b0, extract((void(D::*)()){&D::onPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::onStopPlaytest} != (void(D::*)()){&D::onStopPlaytest})
            m->registerHook(base+0xa1780, extract((void(D::*)()){&D::onStopPlaytest}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::playMusic} != (void(D::*)()){&D::playMusic})
            m->registerHook(base+0xa13c0, extract((void(D::*)()){&D::playMusic}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::recreateGroups} != (void(D::*)()){&D::recreateGroups})
            m->registerHook(base+0x9dbf0, extract((void(D::*)()){&D::recreateGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::redoLastAction} != (void(D::*)()){&D::redoLastAction})
            m->registerHook(base+0x97750, extract((void(D::*)()){&D::redoLastAction}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(base+0x93d80, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($LevelEditorLayer::*)(int)){&$LevelEditorLayer::removeAllObjectsOfType} != (void(D::*)(int)){&D::removeAllObjectsOfType})
            m->registerHook(base+0x96d40, extract((void(D::*)(int)){&D::removeAllObjectsOfType}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool)){&$LevelEditorLayer::removeObject} != (void(D::*)(GameObject*, bool)){&D::removeObject})
            m->registerHook(base+0x96890, extract((void(D::*)(GameObject*, bool)){&D::removeObject}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::removeSpecial} != (void(D::*)(GameObject*)){&D::removeSpecial})
            m->registerHook(base+0x969c0, extract((void(D::*)(GameObject*)){&D::removeSpecial}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetMovingObjects} != (void(D::*)()){&D::resetMovingObjects})
            m->registerHook(base+0x9ddc0, extract((void(D::*)()){&D::resetMovingObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetObjectVector} != (void(D::*)()){&D::resetObjectVector})
            m->registerHook(base+0x9c4b0, extract((void(D::*)()){&D::resetObjectVector}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroups} != (void(D::*)()){&D::resetToggledGroups})
            m->registerHook(base+0x9aa70, extract((void(D::*)()){&D::resetToggledGroups}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetToggledGroupsAndObjects} != (void(D::*)()){&D::resetToggledGroupsAndObjects})
            m->registerHook(base+0x9c3c0, extract((void(D::*)()){&D::resetToggledGroupsAndObjects}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::resetUnusedColorChannels} != (void(D::*)()){&D::resetUnusedColorChannels})
            m->registerHook(base+0x9a870, extract((void(D::*)()){&D::resetUnusedColorChannels}));

        if ((void($LevelEditorLayer::*)(GameObject*)){&$LevelEditorLayer::rotationForSlopeNearObject} != (void(D::*)(GameObject*)){&D::rotationForSlopeNearObject})
            m->registerHook(base+0x95cd0, extract((void(D::*)(GameObject*)){&D::rotationForSlopeNearObject}));

        if ((void($LevelEditorLayer::*)(EffectGameObject*, int, float, float, bool)){&$LevelEditorLayer::runColorEffect} != (void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect})
            m->registerHook(base+0x9bd30, extract((void(D::*)(EffectGameObject*, int, float, float, bool)){&D::runColorEffect}));

        if ((void($LevelEditorLayer::*)(GJGameLevel*)){&$LevelEditorLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(base+0x90f20, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($LevelEditorLayer::*)(LevelSettingsObject*)){&$LevelEditorLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(base+0xa0ca0, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::sortStickyGroups} != (void(D::*)()){&D::sortStickyGroups})
            m->registerHook(base+0x92b10, extract((void(D::*)()){&D::sortStickyGroups}));

        if ((void($LevelEditorLayer::*)(int, float)){&$LevelEditorLayer::stopTriggersInGroup} != (void(D::*)(int, float)){&D::stopTriggersInGroup})
            m->registerHook(base+0x9c030, extract((void(D::*)(int, float)){&D::stopTriggersInGroup}));

        if ((void($LevelEditorLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$LevelEditorLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(base+0xa0200, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($LevelEditorLayer::*)(int, bool)){&$LevelEditorLayer::toggleGroupPreview} != (void(D::*)(int, bool)){&D::toggleGroupPreview})
            m->registerHook(base+0x9bea0, extract((void(D::*)(int, bool)){&D::toggleGroupPreview}));

        if ((void($LevelEditorLayer::*)(GJEffectManager*, GJEffectManager*)){&$LevelEditorLayer::transferDefaultColors} != (void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors})
            m->registerHook(base+0x9ab50, extract((void(D::*)(GJEffectManager*, GJEffectManager*)){&D::transferDefaultColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::undoLastAction} != (void(D::*)()){&D::undoLastAction})
            m->registerHook(base+0x97770, extract((void(D::*)()){&D::undoLastAction}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBGAndGColors} != (void(D::*)()){&D::updateBGAndGColors})
            m->registerHook(base+0x9b9b0, extract((void(D::*)()){&D::updateBGAndGColors}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateBlendValues} != (void(D::*)()){&D::updateBlendValues})
            m->registerHook(base+0x9bc60, extract((void(D::*)()){&D::updateBlendValues}));

        if ((void($LevelEditorLayer::*)(PlayerObject*, int, bool)){&$LevelEditorLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(base+0xa1a60, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateEditorMode} != (void(D::*)()){&D::updateEditorMode})
            m->registerHook(base+0x93b50, extract((void(D::*)()){&D::updateEditorMode}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGameObjectsNew} != (void(D::*)()){&D::updateGameObjectsNew})
            m->registerHook(base+0x9adc0, extract((void(D::*)()){&D::updateGameObjectsNew}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateGround} != (void(D::*)(float)){&D::updateGround})
            m->registerHook(base+0x93a60, extract((void(D::*)(float)){&D::updateGround}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateGroundWidth} != (void(D::*)()){&D::updateGroundWidth})
            m->registerHook(base+0x92af0, extract((void(D::*)()){&D::updateGroundWidth}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateOptions} != (void(D::*)()){&D::updateOptions})
            m->registerHook(base+0x91ed0, extract((void(D::*)()){&D::updateOptions}));

        if ((void($LevelEditorLayer::*)()){&$LevelEditorLayer::updateToggledGroups} != (void(D::*)()){&D::updateToggledGroups})
            m->registerHook(base+0x9bb10, extract((void(D::*)()){&D::updateToggledGroups}));

        if ((void($LevelEditorLayer::*)(float)){&$LevelEditorLayer::updateVisibility} != (void(D::*)(float)){&D::updateVisibility})
            m->registerHook(base+0x92c70, extract((void(D::*)(float)){&D::updateVisibility}));
    }
};


template<class D>
class $LevelLeaderboard : public LevelLeaderboard, public $CacBase {
public:
    dupable ~$LevelLeaderboard() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e7a0))(this);
        else return LevelLeaderboard::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e730))(this);
        else return LevelLeaderboard::keyBackClicked();
    }

    dupable void show() override {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ec40))(this);
        else return LevelLeaderboard::show();
    }

    dupable void loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($LevelLeaderboard::*)(cocos2d::CCArray*, char const*)){&$LevelLeaderboard::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x20e980))(this, p0, p1);
        else return LevelLeaderboard::loadLeaderboardFinished(p0, p1);
    }

    dupable void loadLeaderboardFailed(char const* p0) override {
        if ((void($LevelLeaderboard::*)(char const*)){&$LevelLeaderboard::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x20ead0))(this, p0);
        else return LevelLeaderboard::loadLeaderboardFailed(p0);
    }

    dupable void updateUserScoreFinished() override {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e660))(this);
        else return LevelLeaderboard::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() override {
        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20e690))(this);
        else return LevelLeaderboard::updateUserScoreFailed();
    }

    dupable $LevelLeaderboard() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x20e7a0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20e730, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x20ec40, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($LevelLeaderboard::*)(cocos2d::CCArray*, char const*)){&$LevelLeaderboard::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            m->registerHook(base+0x20e980, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished}));

        if ((void($LevelLeaderboard::*)(char const*)){&$LevelLeaderboard::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            m->registerHook(base+0x20ead0, extract_virtual(V, (void(D::*)(char const*)){&D::loadLeaderboardFailed}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x20e660, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($LevelLeaderboard::*)()){&$LevelLeaderboard::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x20e690, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFailed}));
    }
};


template<class D>
class $LevelSearchLayer : public LevelSearchLayer, public $CacBase {
public:
    dupable ~$LevelSearchLayer() override {}

    dupable bool init() override {
        if ((bool($LevelSearchLayer::*)()){&$LevelSearchLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x384770))(this);
        else return LevelSearchLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($LevelSearchLayer::*)()){&$LevelSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3891f0))(this);
        else return LevelSearchLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3885f0))(this, p0);
        else return LevelSearchLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3887f0))(this, p0);
        else return LevelSearchLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x388910))(this, p0);
        else return LevelSearchLayer::textChanged(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($LevelSearchLayer::*)(FLAlertLayer*, bool)){&$LevelSearchLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x388580))(this, p0, p1);
        else return LevelSearchLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void demonFilterSelectClosed(int p0) override {
        if ((void($LevelSearchLayer::*)(int)){&$LevelSearchLayer::demonFilterSelectClosed} != (void(D::*)(int)){&D::demonFilterSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x388040))(this, p0);
        else return LevelSearchLayer::demonFilterSelectClosed(p0);
    }

    dupable $LevelSearchLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelSearchLayer::*)()){&$LevelSearchLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x384770, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($LevelSearchLayer::*)()){&$LevelSearchLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3891f0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x3885f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3887f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($LevelSearchLayer::*)(CCTextInputNode*)){&$LevelSearchLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x388910, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($LevelSearchLayer::*)(FLAlertLayer*, bool)){&$LevelSearchLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x388580, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelSearchLayer::*)(int)){&$LevelSearchLayer::demonFilterSelectClosed} != (void(D::*)(int)){&D::demonFilterSelectClosed})
            m->registerHook(base+0x388040, extract_virtual(V, (void(D::*)(int)){&D::demonFilterSelectClosed}));
    }
};


template<class D>
class $LevelSelectLayer : public LevelSelectLayer, public $CacBase {
public:
    dupable ~$LevelSelectLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($LevelSelectLayer::*)()){&$LevelSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x23a5e0))(this);
        else return LevelSelectLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($LevelSelectLayer::*)(cocos2d::enumKeyCodes)){&$LevelSelectLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x23a680))(this, p0);
        else return LevelSelectLayer::keyDown(p0);
    }

    dupable void updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) override {
        if ((void($LevelSelectLayer::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&$LevelSelectLayer::updatePageWithObject} != (void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, cocos2d::CCObject*)>(m->getOriginal(base+0x2390a0))(this, p0, p1);
        else return LevelSelectLayer::updatePageWithObject(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) override {
        if ((void($LevelSelectLayer::*)(cocos2d::CCPoint)){&$LevelSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x23a100))(this, p0);
        else return LevelSelectLayer::scrollLayerMoved(p0);
    }

    dupable $LevelSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelSelectLayer::*)()){&$LevelSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x23a5e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSelectLayer::*)(cocos2d::enumKeyCodes)){&$LevelSelectLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x23a680, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelSelectLayer::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&$LevelSelectLayer::updatePageWithObject} != (void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject})
            m->registerHook(base+0x2390a0, extract_virtual(V, (void(D::*)(cocos2d::CCObject*, cocos2d::CCObject*)){&D::updatePageWithObject}));

        if ((void($LevelSelectLayer::*)(cocos2d::CCPoint)){&$LevelSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x23a100, extract_virtual(V, (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));
    }
};


template<class D>
class $MoreOptionsLayer : public MoreOptionsLayer, public $CacBase {
public:
    dupable ~$MoreOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($MoreOptionsLayer::*)()){&$MoreOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x43f470))(this);
        else return MoreOptionsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x441f50))(this);
        else return MoreOptionsLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($MoreOptionsLayer::*)(CCTextInputNode*, float)){&$MoreOptionsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x4420a0))(this, p0, p1);
        else return MoreOptionsLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($MoreOptionsLayer::*)(CCTextInputNode*)){&$MoreOptionsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x442160))(this, p0);
        else return MoreOptionsLayer::textInputReturn(p0);
    }

    dupable void googlePlaySignedIn() override {
        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x442210))(this);
        else return MoreOptionsLayer::googlePlaySignedIn();
    }

    dupable $MoreOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreOptionsLayer::*)()){&$MoreOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x43f470, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x441f50, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MoreOptionsLayer::*)(CCTextInputNode*, float)){&$MoreOptionsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x4420a0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($MoreOptionsLayer::*)(CCTextInputNode*)){&$MoreOptionsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x442160, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($MoreOptionsLayer::*)()){&$MoreOptionsLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            m->registerHook(base+0x442210, extract_virtual(V, (void(D::*)()){&D::googlePlaySignedIn}));
    }
};


template<class D>
class $NumberInputLayer : public NumberInputLayer, public $CacBase {
public:
    dupable ~$NumberInputLayer() override {}

    dupable bool init() override {
        if ((bool($NumberInputLayer::*)()){&$NumberInputLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x255ff0))(this);
        else return NumberInputLayer::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x256a70))(this);
        else return NumberInputLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2569c0))(this);
        else return NumberInputLayer::keyBackClicked();
    }

    dupable $NumberInputLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($NumberInputLayer::*)()){&$NumberInputLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x255ff0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x256a70, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($NumberInputLayer::*)()){&$NumberInputLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2569c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $PlayerCheckpoint : public PlayerCheckpoint, public $CacBase {
public:
    dupable ~$PlayerCheckpoint() override {}

    dupable bool init() override {
        if ((bool($PlayerCheckpoint::*)()){&$PlayerCheckpoint::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x807a0))(this);
        else return PlayerCheckpoint::init();
    }

    dupable $PlayerCheckpoint() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($PlayerCheckpoint::*)()){&$PlayerCheckpoint::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x807a0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $SetTargetIDLayer : public SetTargetIDLayer, public $CacBase {
public:
    dupable ~$SetTargetIDLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15b990))(this);
        else return SetTargetIDLayer::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15b940))(this);
        else return SetTargetIDLayer::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15b680))(this, p0);
        else return SetTargetIDLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15b6c0))(this, p0);
        else return SetTargetIDLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*, float)){&$SetTargetIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x15baa0))(this, p0, p1);
        else return SetTargetIDLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15bb60))(this, p0);
        else return SetTargetIDLayer::textInputReturn(p0);
    }

    dupable $SetTargetIDLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x15b990, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetTargetIDLayer::*)()){&$SetTargetIDLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x15b940, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x15b680, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x15b6c0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*, float)){&$SetTargetIDLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x15baa0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetTargetIDLayer::*)(CCTextInputNode*)){&$SetTargetIDLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x15bb60, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupRotatePopup : public SetupRotatePopup, public $CacBase {
public:
    dupable ~$SetupRotatePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2f47c0))(this);
        else return SetupRotatePopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2f4770))(this);
        else return SetupRotatePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f45d0))(this, p0);
        else return SetupRotatePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f4610))(this, p0);
        else return SetupRotatePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*, float)){&$SetupRotatePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x2f48b0))(this, p0, p1);
        else return SetupRotatePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x2f4970))(this, p0);
        else return SetupRotatePopup::textInputReturn(p0);
    }

    dupable $SetupRotatePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2f47c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupRotatePopup::*)()){&$SetupRotatePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2f4770, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x2f45d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x2f4610, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*, float)){&$SetupRotatePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x2f48b0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupRotatePopup::*)(CCTextInputNode*)){&$SetupRotatePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x2f4970, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SliderTouchLogic : public SliderTouchLogic, public $CacBase {
public:
    dupable ~$SliderTouchLogic() override {}

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d630))(this, p0, p1);
        else return SliderTouchLogic::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d760))(this, p0, p1);
        else return SliderTouchLogic::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18d730))(this, p0, p1);
        else return SliderTouchLogic::ccTouchEnded(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($SliderTouchLogic::*)()){&$SliderTouchLogic::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18da90))(this);
        else return SliderTouchLogic::registerWithTouchDispatcher();
    }

    dupable $SliderTouchLogic() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x18d630, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x18d760, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($SliderTouchLogic::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$SliderTouchLogic::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x18d730, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($SliderTouchLogic::*)()){&$SliderTouchLogic::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x18da90, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));
    }
};


template<class D>
class $SongOptionsLayer : public SongOptionsLayer, public $CacBase {
public:
    dupable ~$SongOptionsLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($SongOptionsLayer::*)()){&$SongOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf33c0))(this);
        else return SongOptionsLayer::keyBackClicked();
    }

    dupable $SongOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SongOptionsLayer::*)()){&$SongOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf33c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $WorldSelectLayer : public WorldSelectLayer, public $CacBase {
public:
    dupable ~$WorldSelectLayer() override {}

    dupable void onExit() override {
        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x201320))(this);
        else return WorldSelectLayer::onExit();
    }

    dupable void keyBackClicked() override {
        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x201250))(this);
        else return WorldSelectLayer::keyBackClicked();
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x201140))(this, p0, p1);
        else return WorldSelectLayer::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x201030))(this, p0, p1);
        else return WorldSelectLayer::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) override {
        if ((void($WorldSelectLayer::*)(cocos2d::CCPoint)){&$WorldSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x201370))(this, p0);
        else return WorldSelectLayer::scrollLayerMoved(p0);
    }

    dupable $WorldSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x201320, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($WorldSelectLayer::*)()){&$WorldSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x201250, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x201140, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));

        if ((void($WorldSelectLayer::*)(BoomScrollLayer*, int)){&$WorldSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x201030, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($WorldSelectLayer::*)(cocos2d::CCPoint)){&$WorldSelectLayer::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x201370, extract_virtual(V, (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));
    }
};


template<class D>
class $AccountLoginLayer : public AccountLoginLayer, public $CacBase {
public:
    dupable ~$AccountLoginLayer() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25d7e0))(this);
        else return AccountLoginLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25d6a0))(this);
        else return AccountLoginLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($AccountLoginLayer::*)(FLAlertLayer*, bool)){&$AccountLoginLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x25d4d0))(this, p0, p1);
        else return AccountLoginLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d9c0))(this, p0);
        else return AccountLoginLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d820))(this, p0);
        else return AccountLoginLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25d9e0))(this, p0);
        else return AccountLoginLayer::textChanged(p0);
    }

    dupable void loginAccountFinished(int p0, int p1) override {
        if ((void($AccountLoginLayer::*)(int, int)){&$AccountLoginLayer::loginAccountFinished} != (void(D::*)(int, int)){&D::loginAccountFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x25ce20))(this, p0, p1);
        else return AccountLoginLayer::loginAccountFinished(p0, p1);
    }

    dupable void loginAccountFailed(AccountError p0) override {
        if ((void($AccountLoginLayer::*)(AccountError)){&$AccountLoginLayer::loginAccountFailed} != (void(D::*)(AccountError)){&D::loginAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), AccountError)>(m->getOriginal(base+0x25d190))(this, p0);
        else return AccountLoginLayer::loginAccountFailed(p0);
    }

    dupable $AccountLoginLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25d7e0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($AccountLoginLayer::*)()){&$AccountLoginLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25d6a0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($AccountLoginLayer::*)(FLAlertLayer*, bool)){&$AccountLoginLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x25d4d0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x25d9c0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x25d820, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($AccountLoginLayer::*)(CCTextInputNode*)){&$AccountLoginLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x25d9e0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($AccountLoginLayer::*)(int, int)){&$AccountLoginLayer::loginAccountFinished} != (void(D::*)(int, int)){&D::loginAccountFinished})
            m->registerHook(base+0x25ce20, extract_virtual(V, (void(D::*)(int, int)){&D::loginAccountFinished}));

        if ((void($AccountLoginLayer::*)(AccountError)){&$AccountLoginLayer::loginAccountFailed} != (void(D::*)(AccountError)){&D::loginAccountFailed})
            m->registerHook(base+0x25d190, extract_virtual(V, (void(D::*)(AccountError)){&D::loginAccountFailed}));
    }
};


template<class D>
class $AchievementsLayer : public AchievementsLayer, public $CacBase {
public:
    dupable ~$AchievementsLayer() override {}

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($AchievementsLayer::*)(cocos2d::enumKeyCodes)){&$AchievementsLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x1be380))(this, p0);
        else return AchievementsLayer::keyDown(p0);
    }

    dupable void customSetup() override {
        if ((void($AchievementsLayer::*)()){&$AchievementsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1bdea0))(this);
        else return AchievementsLayer::customSetup();
    }

    dupable void loadPage(int p0) {
        if ((void($AchievementsLayer::*)(int)){&$AchievementsLayer::loadPage} != (void(D::*)(int)){&D::loadPage})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1be190))(this, p0);
        else return AchievementsLayer::loadPage(p0);
    }

    dupable $AchievementsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AchievementsLayer::*)(cocos2d::enumKeyCodes)){&$AchievementsLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x1be380, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($AchievementsLayer::*)()){&$AchievementsLayer::customSetup} != (void(D::*)()){&D::customSetup})
            m->registerHook(base+0x1bdea0, extract_virtual(V, (void(D::*)()){&D::customSetup}));

        if ((void($AchievementsLayer::*)(int)){&$AchievementsLayer::loadPage} != (void(D::*)(int)){&D::loadPage})
            m->registerHook(base+0x1be190, extract((void(D::*)(int)){&D::loadPage}));
    }
};


template<class D>
class $AudioEffectsLayer : public AudioEffectsLayer, public $CacBase {
public:
    dupable ~$AudioEffectsLayer() override {}

    dupable void draw() override {
        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2722a0))(this);
        else return AudioEffectsLayer::draw();
    }

    dupable void updateTweenAction(float p0, char const* p1) override {
        if ((void($AudioEffectsLayer::*)(float, char const*)){&$AudioEffectsLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x272170))(this, p0, p1);
        else return AudioEffectsLayer::updateTweenAction(p0, p1);
    }

    dupable $AudioEffectsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AudioEffectsLayer::*)()){&$AudioEffectsLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2722a0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($AudioEffectsLayer::*)(float, char const*)){&$AudioEffectsLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x272170, extract_virtual(V, (void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $CCMenuItemToggler : public CCMenuItemToggler, public $CacBase {
public:
    dupable ~$CCMenuItemToggler() override {}

    dupable void activate() override {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38bc0))(this);
        else return CCMenuItemToggler::activate();
    }

    dupable void selected() override {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::selected} != (void(D::*)()){&D::selected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38b80))(this);
        else return CCMenuItemToggler::selected();
    }

    dupable void unselected() override {
        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::unselected} != (void(D::*)()){&D::unselected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38c00))(this);
        else return CCMenuItemToggler::unselected();
    }

    dupable void setEnabled(bool p0) override {
        if ((void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::setEnabled} != (void(D::*)(bool)){&D::setEnabled})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x38c40))(this, p0);
        else return CCMenuItemToggler::setEnabled(p0);
    }

    dupable static CCMenuItemToggler* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            return reinterpret_cast<CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x38400))(p0, p1, p2, p3);
        else return CCMenuItemToggler::create(p0, p1, p2, p3);
    }

    dupable void setSizeMult(float p0) {
        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x38a40))(this, p0);
        else return CCMenuItemToggler::setSizeMult(p0);
    }

    dupable $CCMenuItemToggler() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x38bc0, extract_virtual(V, (void(D::*)()){&D::activate}));

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::selected} != (void(D::*)()){&D::selected})
            m->registerHook(base+0x38b80, extract_virtual(V, (void(D::*)()){&D::selected}));

        if ((void($CCMenuItemToggler::*)()){&$CCMenuItemToggler::unselected} != (void(D::*)()){&D::unselected})
            m->registerHook(base+0x38c00, extract_virtual(V, (void(D::*)()){&D::unselected}));

        if ((void($CCMenuItemToggler::*)(bool)){&$CCMenuItemToggler::setEnabled} != (void(D::*)(bool)){&D::setEnabled})
            m->registerHook(base+0x38c40, extract_virtual(V, (void(D::*)(bool)){&D::setEnabled}));

        if ((CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemToggler::create} != (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            m->registerHook(base+0x38400, (CCMenuItemToggler*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create});

        if ((void($CCMenuItemToggler::*)(float)){&$CCMenuItemToggler::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(base+0x38a40, extract((void(D::*)(float)){&D::setSizeMult}));
    }
};


template<class D>
class $ColorActionSprite : public ColorActionSprite, public $CacBase {
public:
    dupable ~$ColorActionSprite() override {}

    dupable bool init() override {
        if ((bool($ColorActionSprite::*)()){&$ColorActionSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x175370))(this);
        else return ColorActionSprite::init();
    }

    dupable $ColorActionSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ColorActionSprite::*)()){&$ColorActionSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x175370, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $DungeonBarsSprite : public DungeonBarsSprite, public $CacBase {
public:
    dupable ~$DungeonBarsSprite() override {}

    dupable bool init() override {
        if ((bool($DungeonBarsSprite::*)()){&$DungeonBarsSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x26c2b0))(this);
        else return DungeonBarsSprite::init();
    }

    dupable void visit() override {
        if ((void($DungeonBarsSprite::*)()){&$DungeonBarsSprite::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26c330))(this);
        else return DungeonBarsSprite::visit();
    }

    dupable $DungeonBarsSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($DungeonBarsSprite::*)()){&$DungeonBarsSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x26c2b0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($DungeonBarsSprite::*)()){&$DungeonBarsSprite::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x26c330, extract_virtual(V, (void(D::*)()){&D::visit}));
    }
};


template<class D>
class $EditTriggersPopup : public EditTriggersPopup, public $CacBase {
public:
    dupable ~$EditTriggersPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1458a0))(this);
        else return EditTriggersPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x145850))(this);
        else return EditTriggersPopup::show();
    }

    dupable $EditTriggersPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1458a0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($EditTriggersPopup::*)()){&$EditTriggersPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x145850, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $GJColorSetupLayer : public GJColorSetupLayer, public $CacBase {
public:
    dupable ~$GJColorSetupLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf0210))(this);
        else return GJColorSetupLayer::keyBackClicked();
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) override {
        if ((void($GJColorSetupLayer::*)(cocos2d::CCNode*)){&$GJColorSetupLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xf01e0))(this, p0);
        else return GJColorSetupLayer::colorSelectClosed(p0);
    }

    dupable $GJColorSetupLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJColorSetupLayer::*)()){&$GJColorSetupLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf0210, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJColorSetupLayer::*)(cocos2d::CCNode*)){&$GJColorSetupLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xf01e0, extract_virtual(V, (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));
    }
};


template<class D>
class $GJRotationControl : public GJRotationControl, public $CacBase {
public:
    dupable ~$GJRotationControl() override {}

    dupable bool init() override {
        if ((bool($GJRotationControl::*)()){&$GJRotationControl::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x31510))(this);
        else return GJRotationControl::init();
    }

    dupable void draw() override {
        if ((void($GJRotationControl::*)()){&$GJRotationControl::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x31ac0))(this);
        else return GJRotationControl::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31790))(this, p0, p1);
        else return GJRotationControl::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x318b0))(this, p0, p1);
        else return GJRotationControl::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31990))(this, p0, p1);
        else return GJRotationControl::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x31a80))(this, p0, p1);
        else return GJRotationControl::ccTouchCancelled(p0, p1);
    }

    dupable $GJRotationControl() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJRotationControl::*)()){&$GJRotationControl::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x31510, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GJRotationControl::*)()){&$GJRotationControl::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x31ac0, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x31790, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x318b0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x31990, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($GJRotationControl::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$GJRotationControl::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x31a80, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));
    }
};


template<class D>
class $GooglePlayManager : public GooglePlayManager, public $CacBase {
public:
    dupable ~$GooglePlayManager() override {}

    dupable bool init() override {
        if ((bool($GooglePlayManager::*)()){&$GooglePlayManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x246130))(this);
        else return GooglePlayManager::init();
    }

    dupable $GooglePlayManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GooglePlayManager::*)()){&$GooglePlayManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x246130, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $LeaderboardsLayer : public LeaderboardsLayer, public $CacBase {
public:
    dupable ~$LeaderboardsLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a11c0))(this);
        else return LeaderboardsLayer::keyBackClicked();
    }

    dupable void updateUserScoreFinished() override {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a07c0))(this);
        else return LeaderboardsLayer::updateUserScoreFinished();
    }

    dupable void updateUserScoreFailed() override {
        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2a0820))(this);
        else return LeaderboardsLayer::updateUserScoreFailed();
    }

    dupable void loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($LeaderboardsLayer::*)(cocos2d::CCArray*, char const*)){&$LeaderboardsLayer::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x2a08c0))(this, p0, p1);
        else return LeaderboardsLayer::loadLeaderboardFinished(p0, p1);
    }

    dupable void loadLeaderboardFailed(char const* p0) override {
        if ((void($LeaderboardsLayer::*)(char const*)){&$LeaderboardsLayer::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2a0fa0))(this, p0);
        else return LeaderboardsLayer::loadLeaderboardFailed(p0);
    }

    dupable $LeaderboardsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2a11c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x2a07c0, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($LeaderboardsLayer::*)()){&$LeaderboardsLayer::updateUserScoreFailed} != (void(D::*)()){&D::updateUserScoreFailed})
            m->registerHook(base+0x2a0820, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFailed}));

        if ((void($LeaderboardsLayer::*)(cocos2d::CCArray*, char const*)){&$LeaderboardsLayer::loadLeaderboardFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished})
            m->registerHook(base+0x2a08c0, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLeaderboardFinished}));

        if ((void($LeaderboardsLayer::*)(char const*)){&$LeaderboardsLayer::loadLeaderboardFailed} != (void(D::*)(char const*)){&D::loadLeaderboardFailed})
            m->registerHook(base+0x2a0fa0, extract_virtual(V, (void(D::*)(char const*)){&D::loadLeaderboardFailed}));
    }
};


template<class D>
class $LevelBrowserLayer : public LevelBrowserLayer, public $CacBase {
public:
    dupable ~$LevelBrowserLayer() override {}

    dupable void onEnter() override {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255b70))(this);
        else return LevelBrowserLayer::onEnter();
    }

    dupable void onEnterTransitionDidFinish() override {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255be0))(this);
        else return LevelBrowserLayer::onEnterTransitionDidFinish();
    }

    dupable void keyBackClicked() override {
        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x255630))(this);
        else return LevelBrowserLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($LevelBrowserLayer::*)(cocos2d::enumKeyCodes)){&$LevelBrowserLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x255680))(this, p0);
        else return LevelBrowserLayer::keyDown(p0);
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($LevelBrowserLayer::*)(cocos2d::CCArray*, char const*)){&$LevelBrowserLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x254e10))(this, p0, p1);
        else return LevelBrowserLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) override {
        if ((void($LevelBrowserLayer::*)(char const*)){&$LevelBrowserLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x254f60))(this, p0);
        else return LevelBrowserLayer::loadLevelsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($LevelBrowserLayer::*)(std::string, char const*)){&$LevelBrowserLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x255050))(this, p0, p1);
        else return LevelBrowserLayer::setupPageInfo(p0, p1);
    }

    dupable void setTextPopupClosed(SetTextPopup* p0, std::string p1) override {
        if ((void($LevelBrowserLayer::*)(SetTextPopup*, std::string)){&$LevelBrowserLayer::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetTextPopup*, std::string)>(m->getOriginal(base+0x255760))(this, p0, p1);
        else return LevelBrowserLayer::setTextPopupClosed(p0, p1);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($LevelBrowserLayer::*)(FLAlertLayer*, bool)){&$LevelBrowserLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x255840))(this, p0, p1);
        else return LevelBrowserLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void setIDPopupClosed(SetIDPopup* p0, int p1) override {
        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), SetIDPopup*, int)>(m->getOriginal(base+0x2554f0))(this, p0, p1);
        else return LevelBrowserLayer::setIDPopupClosed(p0, p1);
    }

    dupable $LevelBrowserLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x255b70, extract_virtual(V, (void(D::*)()){&D::onEnter}));

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(base+0x255be0, extract_virtual(V, (void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($LevelBrowserLayer::*)()){&$LevelBrowserLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x255630, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelBrowserLayer::*)(cocos2d::enumKeyCodes)){&$LevelBrowserLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x255680, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($LevelBrowserLayer::*)(cocos2d::CCArray*, char const*)){&$LevelBrowserLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x254e10, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($LevelBrowserLayer::*)(char const*)){&$LevelBrowserLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x254f60, extract_virtual(V, (void(D::*)(char const*)){&D::loadLevelsFailed}));

        if ((void($LevelBrowserLayer::*)(std::string, char const*)){&$LevelBrowserLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x255050, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($LevelBrowserLayer::*)(SetTextPopup*, std::string)){&$LevelBrowserLayer::setTextPopupClosed} != (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed})
            m->registerHook(base+0x255760, extract_virtual(V, (void(D::*)(SetTextPopup*, std::string)){&D::setTextPopupClosed}));

        if ((void($LevelBrowserLayer::*)(FLAlertLayer*, bool)){&$LevelBrowserLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x255840, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelBrowserLayer::*)(SetIDPopup*, int)){&$LevelBrowserLayer::setIDPopupClosed} != (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed})
            m->registerHook(base+0x2554f0, extract_virtual(V, (void(D::*)(SetIDPopup*, int)){&D::setIDPopupClosed}));
    }
};


template<class D>
class $LevelFeatureLayer : public LevelFeatureLayer, public $CacBase {
public:
    dupable ~$LevelFeatureLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($LevelFeatureLayer::*)()){&$LevelFeatureLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x297a00))(this);
        else return LevelFeatureLayer::keyBackClicked();
    }

    dupable $LevelFeatureLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelFeatureLayer::*)()){&$LevelFeatureLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x297a00, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $LocalLevelManager : public LocalLevelManager, public $CacBase {
public:
    dupable ~$LocalLevelManager() override {}

    dupable bool init() override {
        if ((bool($LocalLevelManager::*)()){&$LocalLevelManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x35dfc0))(this);
        else return LocalLevelManager::init();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) override {
        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x35ed60))(this, p0);
        else return LocalLevelManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) override {
        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x35eda0))(this, p0);
        else return LocalLevelManager::dataLoaded(p0);
    }

    dupable void firstLoad() override {
        if ((void($LocalLevelManager::*)()){&$LocalLevelManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x35ed10))(this);
        else return LocalLevelManager::firstLoad();
    }

    dupable $LocalLevelManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LocalLevelManager::*)()){&$LocalLevelManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x35dfc0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x35ed60, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($LocalLevelManager::*)(DS_Dictionary*)){&$LocalLevelManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x35eda0, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($LocalLevelManager::*)()){&$LocalLevelManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x35ed10, extract_virtual(V, (void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $PromoInterstitial : public PromoInterstitial, public $CacBase {
public:
    dupable ~$PromoInterstitial() override {}

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x169e80))(this, p0, p1);
        else return PromoInterstitial::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x16a0c0))(this, p0, p1);
        else return PromoInterstitial::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x169fa0))(this, p0, p1);
        else return PromoInterstitial::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x16a040))(this, p0, p1);
        else return PromoInterstitial::ccTouchCancelled(p0, p1);
    }

    dupable void keyBackClicked() override {
        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169cf0))(this);
        else return PromoInterstitial::keyBackClicked();
    }

    dupable void show() override {
        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x169cc0))(this);
        else return PromoInterstitial::show();
    }

    dupable $PromoInterstitial() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x169e80, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x16a0c0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x169fa0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($PromoInterstitial::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$PromoInterstitial::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x16a040, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x169cf0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($PromoInterstitial::*)()){&$PromoInterstitial::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x169cc0, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $PurchaseItemPopup : public PurchaseItemPopup, public $CacBase {
public:
    dupable ~$PurchaseItemPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($PurchaseItemPopup::*)()){&$PurchaseItemPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1a2fc0))(this);
        else return PurchaseItemPopup::keyBackClicked();
    }

    dupable $PurchaseItemPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PurchaseItemPopup::*)()){&$PurchaseItemPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1a2fc0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $RewardUnlockLayer : public RewardUnlockLayer, public $CacBase {
public:
    dupable ~$RewardUnlockLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($RewardUnlockLayer::*)()){&$RewardUnlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xf81b0))(this);
        else return RewardUnlockLayer::keyBackClicked();
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) override {
        if ((void($RewardUnlockLayer::*)(CurrencyRewardLayer*)){&$RewardUnlockLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0xf8170))(this, p0);
        else return RewardUnlockLayer::currencyWillExit(p0);
    }

    dupable $RewardUnlockLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($RewardUnlockLayer::*)()){&$RewardUnlockLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xf81b0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($RewardUnlockLayer::*)(CurrencyRewardLayer*)){&$RewardUnlockLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0xf8170, extract_virtual(V, (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));
    }
};


template<class D>
class $SecretNumberLayer : public SecretNumberLayer, public $CacBase {
public:
    dupable ~$SecretNumberLayer() override {}

    dupable bool init() override {
        if ((bool($SecretNumberLayer::*)()){&$SecretNumberLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x266c30))(this);
        else return SecretNumberLayer::init();
    }

    dupable $SecretNumberLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SecretNumberLayer::*)()){&$SecretNumberLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x266c30, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $SetupOpacityPopup : public SetupOpacityPopup, public $CacBase {
public:
    dupable ~$SetupOpacityPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34bf0))(this);
        else return SetupOpacityPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x34ba0))(this);
        else return SetupOpacityPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34a20))(this, p0);
        else return SetupOpacityPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34a60))(this, p0);
        else return SetupOpacityPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*, float)){&$SetupOpacityPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x34e50))(this, p0, p1);
        else return SetupOpacityPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x34f10))(this, p0);
        else return SetupOpacityPopup::textInputReturn(p0);
    }

    dupable $SetupOpacityPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x34bf0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupOpacityPopup::*)()){&$SetupOpacityPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x34ba0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x34a20, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x34a60, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*, float)){&$SetupOpacityPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x34e50, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupOpacityPopup::*)(CCTextInputNode*)){&$SetupOpacityPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x34f10, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareCommentLayer : public ShareCommentLayer, public $CacBase {
public:
    dupable ~$ShareCommentLayer() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x350590))(this);
        else return ShareCommentLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3504e0))(this);
        else return ShareCommentLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x350690))(this, p0);
        else return ShareCommentLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3505d0))(this, p0);
        else return ShareCommentLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x3507b0))(this, p0);
        else return ShareCommentLayer::textChanged(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3509f0))(this, p0, p1);
        else return ShareCommentLayer::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x350ad0))(this, p0, p1);
        else return ShareCommentLayer::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($ShareCommentLayer::*)(UploadActionPopup*)){&$ShareCommentLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x350ba0))(this, p0);
        else return ShareCommentLayer::onClosePopup(p0);
    }

    dupable $ShareCommentLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x350590, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($ShareCommentLayer::*)()){&$ShareCommentLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3504e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x350690, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x3505d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ShareCommentLayer::*)(CCTextInputNode*)){&$ShareCommentLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x3507b0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x3509f0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($ShareCommentLayer::*)(int, int)){&$ShareCommentLayer::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x350ad0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($ShareCommentLayer::*)(UploadActionPopup*)){&$ShareCommentLayer::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x350ba0, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));
    }
};


template<class D>
class $SpriteDescription : public SpriteDescription, public $CacBase {
public:
    dupable ~$SpriteDescription() override {}

    dupable $SpriteDescription() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TextInputDelegate : public TextInputDelegate, public $CacBase {
public:
    dupable ~$TextInputDelegate() override {}

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1573f0))(this, p0);
        else return TextInputDelegate::textChanged(p0);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x6200))(this, p0);
        else return TextInputDelegate::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x157400))(this, p0);
        else return TextInputDelegate::textInputClosed(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*, float)){&$TextInputDelegate::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0xe1810))(this, p0, p1);
        else return TextInputDelegate::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1820))(this, p0);
        else return TextInputDelegate::textInputReturn(p0);
    }

    dupable void allowTextInput(CCTextInputNode* p0) override {
        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x6210))(this, p0);
        else return TextInputDelegate::allowTextInput(p0);
    }

    dupable $TextInputDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1573f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x6200, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x157400, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*, float)){&$TextInputDelegate::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0xe1810, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0xe1820, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($TextInputDelegate::*)(CCTextInputNode*)){&$TextInputDelegate::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            m->registerHook(base+0x6210, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::allowTextInput}));
    }
};


template<class D>
class $UploadActionPopup : public UploadActionPopup, public $CacBase {
public:
    dupable ~$UploadActionPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($UploadActionPopup::*)()){&$UploadActionPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14ca10))(this);
        else return UploadActionPopup::keyBackClicked();
    }

    dupable $UploadActionPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadActionPopup::*)()){&$UploadActionPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14ca10, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $VideoOptionsLayer : public VideoOptionsLayer, public $CacBase {
public:
    dupable ~$VideoOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($VideoOptionsLayer::*)()){&$VideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x442460))(this);
        else return VideoOptionsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($VideoOptionsLayer::*)()){&$VideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x443f50))(this);
        else return VideoOptionsLayer::keyBackClicked();
    }

    dupable $VideoOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($VideoOptionsLayer::*)()){&$VideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x442460, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($VideoOptionsLayer::*)()){&$VideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x443f50, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $AchievementManager : public AchievementManager, public $CacBase {
public:
    dupable ~$AchievementManager() override {}

    dupable bool init() override {
        if ((bool($AchievementManager::*)()){&$AchievementManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x4244c0))(this);
        else return AchievementManager::init();
    }

    dupable void getAllAchievements() {
        if ((void($AchievementManager::*)()){&$AchievementManager::getAllAchievements} != (void(D::*)()){&D::getAllAchievements})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x434d60))(this);
        else return AchievementManager::getAllAchievements();
    }

    dupable void sharedState() {
        if ((void($AchievementManager::*)()){&$AchievementManager::sharedState} != (void(D::*)()){&D::sharedState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x424420))(this);
        else return AchievementManager::sharedState();
    }

    dupable $AchievementManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementManager::*)()){&$AchievementManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x4244c0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($AchievementManager::*)()){&$AchievementManager::getAllAchievements} != (void(D::*)()){&D::getAllAchievements})
            m->registerHook(base+0x434d60, extract((void(D::*)()){&D::getAllAchievements}));

        if ((void($AchievementManager::*)()){&$AchievementManager::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(base+0x424420, extract((void(D::*)()){&D::sharedState}));
    }
};


template<class D>
class $AnimatedGameObject : public AnimatedGameObject, public $CacBase {
public:
    dupable ~$AnimatedGameObject() override {}

    dupable void setOpacity(unsigned char p0) override {
        if ((void($AnimatedGameObject::*)(unsigned char)){&$AnimatedGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0xc8640))(this, p0);
        else return AnimatedGameObject::setOpacity(p0);
    }

    dupable void resetObject() override {
        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::resetObject} != (void(D::*)()){&D::resetObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc9720))(this);
        else return AnimatedGameObject::resetObject();
    }

    dupable void activateObject() override {
        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::activateObject} != (void(D::*)()){&D::activateObject})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xc84d0))(this);
        else return AnimatedGameObject::activateObject();
    }

    dupable void deactivateObject(bool p0) override {
        if ((void($AnimatedGameObject::*)(bool)){&$AnimatedGameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0xc85e0))(this, p0);
        else return AnimatedGameObject::deactivateObject(p0);
    }

    dupable void setObjectColor(cocos2d::_ccColor3B const& p0) override {
        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B const&)){&$AnimatedGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B const&)>(m->getOriginal(base+0xc8720))(this, p0);
        else return AnimatedGameObject::setObjectColor(p0);
    }

    dupable void animationFinished(char const* p0) override {
        if ((void($AnimatedGameObject::*)(char const*)){&$AnimatedGameObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0xc8750))(this, p0);
        else return AnimatedGameObject::animationFinished(p0);
    }

    dupable void displayFrameChanged(cocos2d::CCObject* p0, std::string p1) override {
        if ((void($AnimatedGameObject::*)(cocos2d::CCObject*, std::string)){&$AnimatedGameObject::displayFrameChanged} != (void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*, std::string)>(m->getOriginal(base+0xc9160))(this, p0, p1);
        else return AnimatedGameObject::displayFrameChanged(p0, p1);
    }

    dupable void playAnimation(int p0) {
        if ((void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation} != (void(D::*)(int)){&D::playAnimation})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xc93d0))(this, p0);
        else return AnimatedGameObject::playAnimation(p0);
    }

    dupable void updateChildSpriteColor(cocos2d::_ccColor3B p0) {
        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B)>(m->getOriginal(base+0xc8450))(this, p0);
        else return AnimatedGameObject::updateChildSpriteColor(p0);
    }

    dupable $AnimatedGameObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AnimatedGameObject::*)(unsigned char)){&$AnimatedGameObject::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0xc8640, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));

        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::resetObject} != (void(D::*)()){&D::resetObject})
            m->registerHook(base+0xc9720, extract_virtual(V, (void(D::*)()){&D::resetObject}));

        if ((void($AnimatedGameObject::*)()){&$AnimatedGameObject::activateObject} != (void(D::*)()){&D::activateObject})
            m->registerHook(base+0xc84d0, extract_virtual(V, (void(D::*)()){&D::activateObject}));

        if ((void($AnimatedGameObject::*)(bool)){&$AnimatedGameObject::deactivateObject} != (void(D::*)(bool)){&D::deactivateObject})
            m->registerHook(base+0xc85e0, extract_virtual(V, (void(D::*)(bool)){&D::deactivateObject}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B const&)){&$AnimatedGameObject::setObjectColor} != (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor})
            m->registerHook(base+0xc8720, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B const&)){&D::setObjectColor}));

        if ((void($AnimatedGameObject::*)(char const*)){&$AnimatedGameObject::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0xc8750, extract_virtual(V, (void(D::*)(char const*)){&D::animationFinished}));

        if ((void($AnimatedGameObject::*)(cocos2d::CCObject*, std::string)){&$AnimatedGameObject::displayFrameChanged} != (void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged})
            m->registerHook(base+0xc9160, extract_virtual(V, (void(D::*)(cocos2d::CCObject*, std::string)){&D::displayFrameChanged}));

        if ((void($AnimatedGameObject::*)(int)){&$AnimatedGameObject::playAnimation} != (void(D::*)(int)){&D::playAnimation})
            m->registerHook(base+0xc93d0, extract((void(D::*)(int)){&D::playAnimation}));

        if ((void($AnimatedGameObject::*)(cocos2d::_ccColor3B)){&$AnimatedGameObject::updateChildSpriteColor} != (void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor})
            m->registerHook(base+0xc8450, extract((void(D::*)(cocos2d::_ccColor3B)){&D::updateChildSpriteColor}));
    }
};


template<class D>
class $AnimatedShopKeeper : public AnimatedShopKeeper, public $CacBase {
public:
    dupable ~$AnimatedShopKeeper() override {}

    dupable void animationFinished(char const* p0) override {
        if ((void($AnimatedShopKeeper::*)(char const*)){&$AnimatedShopKeeper::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x1a3130))(this, p0);
        else return AnimatedShopKeeper::animationFinished(p0);
    }

    dupable $AnimatedShopKeeper() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($AnimatedShopKeeper::*)(char const*)){&$AnimatedShopKeeper::animationFinished} != (void(D::*)(char const*)){&D::animationFinished})
            m->registerHook(base+0x1a3130, extract_virtual(V, (void(D::*)(char const*)){&D::animationFinished}));
    }
};


template<class D>
class $ColorChannelSprite : public ColorChannelSprite, public $CacBase {
public:
    dupable ~$ColorChannelSprite() override {}

    dupable bool init() override {
        if ((bool($ColorChannelSprite::*)()){&$ColorChannelSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x16deb0))(this);
        else return ColorChannelSprite::init();
    }

    dupable $ColorChannelSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ColorChannelSprite::*)()){&$ColorChannelSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x16deb0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ConfigureHSVWidget : public ConfigureHSVWidget, public $CacBase {
public:
    dupable ~$ConfigureHSVWidget() override {}

    dupable $ConfigureHSVWidget() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $EditorOptionsLayer : public EditorOptionsLayer, public $CacBase {
public:
    dupable ~$EditorOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($EditorOptionsLayer::*)()){&$EditorOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x147420))(this);
        else return EditorOptionsLayer::init();
    }

    dupable void setupOptions() override {
        if ((void($EditorOptionsLayer::*)()){&$EditorOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x147440))(this);
        else return EditorOptionsLayer::setupOptions();
    }

    dupable void onClose(cocos2d::CCObject* p0) override {
        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x147c30))(this, p0);
        else return EditorOptionsLayer::onClose(p0);
    }

    dupable $EditorOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($EditorOptionsLayer::*)()){&$EditorOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x147420, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($EditorOptionsLayer::*)()){&$EditorOptionsLayer::setupOptions} != (void(D::*)()){&D::setupOptions})
            m->registerHook(base+0x147440, extract_virtual(V, (void(D::*)()){&D::setupOptions}));

        if ((void($EditorOptionsLayer::*)(cocos2d::CCObject*)){&$EditorOptionsLayer::onClose} != (void(D::*)(cocos2d::CCObject*)){&D::onClose})
            m->registerHook(base+0x147c30, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::onClose}));
    }
};


template<class D>
class $FriendRequestPopup : public FriendRequestPopup, public $CacBase {
public:
    dupable ~$FriendRequestPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($FriendRequestPopup::*)()){&$FriendRequestPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14e2a0))(this);
        else return FriendRequestPopup::keyBackClicked();
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x14e390))(this, p0, p1);
        else return FriendRequestPopup::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x14e560))(this, p0, p1);
        else return FriendRequestPopup::uploadActionFailed(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($FriendRequestPopup::*)(UploadActionPopup*)){&$FriendRequestPopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x14e640))(this, p0);
        else return FriendRequestPopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($FriendRequestPopup::*)(FLAlertLayer*, bool)){&$FriendRequestPopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x14e7c0))(this, p0, p1);
        else return FriendRequestPopup::FLAlert_Clicked(p0, p1);
    }

    dupable $FriendRequestPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FriendRequestPopup::*)()){&$FriendRequestPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14e2a0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x14e390, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($FriendRequestPopup::*)(int, int)){&$FriendRequestPopup::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x14e560, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($FriendRequestPopup::*)(UploadActionPopup*)){&$FriendRequestPopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x14e640, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($FriendRequestPopup::*)(FLAlertLayer*, bool)){&$FriendRequestPopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x14e7c0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $FriendsProfilePage : public FriendsProfilePage, public $CacBase {
public:
    dupable ~$FriendsProfilePage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa6e0))(this);
        else return FriendsProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3aa5e0))(this);
        else return FriendsProfilePage::keyBackClicked();
    }

    dupable void getUserListFinished(cocos2d::CCArray* p0, UserListType p1) override {
        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::getUserListFinished} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, UserListType)>(m->getOriginal(base+0x3aa240))(this, p0, p1);
        else return FriendsProfilePage::getUserListFinished(p0, p1);
    }

    dupable void getUserListFailed(UserListType p0, GJErrorCode p1) override {
        if ((void($FriendsProfilePage::*)(UserListType, GJErrorCode)){&$FriendsProfilePage::getUserListFailed} != (void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed})
            return reinterpret_cast<void(*)(decltype(this), UserListType, GJErrorCode)>(m->getOriginal(base+0x3aa390))(this, p0, p1);
        else return FriendsProfilePage::getUserListFailed(p0, p1);
    }

    dupable void userListChanged(cocos2d::CCArray* p0, UserListType p1) override {
        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::userListChanged} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, UserListType)>(m->getOriginal(base+0x3aa4a0))(this, p0, p1);
        else return FriendsProfilePage::userListChanged(p0, p1);
    }

    dupable void forceReloadList(UserListType p0) override {
        if ((void($FriendsProfilePage::*)(UserListType)){&$FriendsProfilePage::forceReloadList} != (void(D::*)(UserListType)){&D::forceReloadList})
            return reinterpret_cast<void(*)(decltype(this), UserListType)>(m->getOriginal(base+0x3aa4e0))(this, p0);
        else return FriendsProfilePage::forceReloadList(p0);
    }

    dupable $FriendsProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x3aa6e0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FriendsProfilePage::*)()){&$FriendsProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x3aa5e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::getUserListFinished} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished})
            m->registerHook(base+0x3aa240, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, UserListType)){&D::getUserListFinished}));

        if ((void($FriendsProfilePage::*)(UserListType, GJErrorCode)){&$FriendsProfilePage::getUserListFailed} != (void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed})
            m->registerHook(base+0x3aa390, extract_virtual(V, (void(D::*)(UserListType, GJErrorCode)){&D::getUserListFailed}));

        if ((void($FriendsProfilePage::*)(cocos2d::CCArray*, UserListType)){&$FriendsProfilePage::userListChanged} != (void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged})
            m->registerHook(base+0x3aa4a0, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, UserListType)){&D::userListChanged}));

        if ((void($FriendsProfilePage::*)(UserListType)){&$FriendsProfilePage::forceReloadList} != (void(D::*)(UserListType)){&D::forceReloadList})
            m->registerHook(base+0x3aa4e0, extract_virtual(V, (void(D::*)(UserListType)){&D::forceReloadList}));
    }
};


template<class D>
class $GJCommentListLayer : public GJCommentListLayer, public $CacBase {
public:
    dupable ~$GJCommentListLayer() override {}

    dupable $GJCommentListLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GJMoveCommandLayer : public GJMoveCommandLayer, public $CacBase {
public:
    dupable ~$GJMoveCommandLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x374970))(this);
        else return GJMoveCommandLayer::keyBackClicked();
    }

    dupable void valuePopupClosed(ConfigureValuePopup* p0, float p1) override {
        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(base+0x373c20))(this, p0, p1);
        else return GJMoveCommandLayer::valuePopupClosed(p0, p1);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374430))(this, p0);
        else return GJMoveCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374470))(this, p0);
        else return GJMoveCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x374b50))(this, p0, p1);
        else return GJMoveCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x374c10))(this, p0);
        else return GJMoveCommandLayer::textInputReturn(p0);
    }

    dupable $GJMoveCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJMoveCommandLayer::*)()){&$GJMoveCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x374970, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJMoveCommandLayer::*)(ConfigureValuePopup*, float)){&$GJMoveCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(base+0x373c20, extract_virtual(V, (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x374430, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x374470, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*, float)){&$GJMoveCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x374b50, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJMoveCommandLayer::*)(CCTextInputNode*)){&$GJMoveCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x374c10, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GameEffectsManager : public GameEffectsManager, public $CacBase {
public:
    dupable ~$GameEffectsManager() override {}

    dupable $GameEffectsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $GroupCommandObject : public GroupCommandObject, public $CacBase {
public:
    dupable ~$GroupCommandObject() override {}

    dupable bool init() override {
        if ((bool($GroupCommandObject::*)()){&$GroupCommandObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x16e590))(this);
        else return GroupCommandObject::init();
    }

    dupable void updateTweenAction(float p0, char const* p1) override {
        if ((void($GroupCommandObject::*)(float, char const*)){&$GroupCommandObject::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x16ead0))(this, p0, p1);
        else return GroupCommandObject::updateTweenAction(p0, p1);
    }

    dupable $GroupCommandObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GroupCommandObject::*)()){&$GroupCommandObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x16e590, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GroupCommandObject::*)(float, char const*)){&$GroupCommandObject::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x16ead0, extract_virtual(V, (void(D::*)(float, char const*)){&D::updateTweenAction}));
    }
};


template<class D>
class $KeybindingsManager : public KeybindingsManager, public $CacBase {
public:
    dupable ~$KeybindingsManager() override {}

    dupable bool init() override {
        if ((bool($KeybindingsManager::*)()){&$KeybindingsManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x289a00))(this);
        else return KeybindingsManager::init();
    }

    dupable $KeybindingsManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeybindingsManager::*)()){&$KeybindingsManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x289a00, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $LevelSettingsLayer : public LevelSettingsLayer, public $CacBase {
public:
    dupable ~$LevelSettingsLayer() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac070))(this);
        else return LevelSettingsLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac7b0))(this);
        else return LevelSettingsLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($LevelSettingsLayer::*)(FLAlertLayer*, bool)){&$LevelSettingsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0xac260))(this, p0, p1);
        else return LevelSettingsLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) override {
        if ((void($LevelSettingsLayer::*)(cocos2d::CCNode*)){&$LevelSettingsLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xac100))(this, p0);
        else return LevelSettingsLayer::colorSelectClosed(p0);
    }

    dupable void customSongLayerClosed() override {
        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::customSongLayerClosed} != (void(D::*)()){&D::customSongLayerClosed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xac340))(this);
        else return LevelSettingsLayer::customSongLayerClosed();
    }

    dupable void selectArtClosed(SelectArtLayer* p0) override {
        if ((void($LevelSettingsLayer::*)(SelectArtLayer*)){&$LevelSettingsLayer::selectArtClosed} != (void(D::*)(SelectArtLayer*)){&D::selectArtClosed})
            return reinterpret_cast<void(*)(decltype(this), SelectArtLayer*)>(m->getOriginal(base+0xac5e0))(this, p0);
        else return LevelSettingsLayer::selectArtClosed(p0);
    }

    dupable $LevelSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0xac070, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xac7b0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($LevelSettingsLayer::*)(FLAlertLayer*, bool)){&$LevelSettingsLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0xac260, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($LevelSettingsLayer::*)(cocos2d::CCNode*)){&$LevelSettingsLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xac100, extract_virtual(V, (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($LevelSettingsLayer::*)()){&$LevelSettingsLayer::customSongLayerClosed} != (void(D::*)()){&D::customSongLayerClosed})
            m->registerHook(base+0xac340, extract_virtual(V, (void(D::*)()){&D::customSongLayerClosed}));

        if ((void($LevelSettingsLayer::*)(SelectArtLayer*)){&$LevelSettingsLayer::selectArtClosed} != (void(D::*)(SelectArtLayer*)){&D::selectArtClosed})
            m->registerHook(base+0xac5e0, extract_virtual(V, (void(D::*)(SelectArtLayer*)){&D::selectArtClosed}));
    }
};


template<class D>
class $AchievementNotifier : public AchievementNotifier, public $CacBase {
public:
    dupable ~$AchievementNotifier() override {}

    dupable bool init() override {
        if ((bool($AchievementNotifier::*)()){&$AchievementNotifier::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x464e90))(this);
        else return AchievementNotifier::init();
    }

    dupable void sharedState() {
        if ((void($AchievementNotifier::*)()){&$AchievementNotifier::sharedState} != (void(D::*)()){&D::sharedState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x464e00))(this);
        else return AchievementNotifier::sharedState();
    }

    dupable void willSwitchToScene(cocos2d::CCScene* p0) {
        if ((void($AchievementNotifier::*)(cocos2d::CCScene*)){&$AchievementNotifier::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCScene*)>(m->getOriginal(base+0x4650b0))(this, p0);
        else return AchievementNotifier::willSwitchToScene(p0);
    }

    dupable $AchievementNotifier() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AchievementNotifier::*)()){&$AchievementNotifier::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x464e90, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($AchievementNotifier::*)()){&$AchievementNotifier::sharedState} != (void(D::*)()){&D::sharedState})
            m->registerHook(base+0x464e00, extract((void(D::*)()){&D::sharedState}));

        if ((void($AchievementNotifier::*)(cocos2d::CCScene*)){&$AchievementNotifier::willSwitchToScene} != (void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene})
            m->registerHook(base+0x4650b0, extract((void(D::*)(cocos2d::CCScene*)){&D::willSwitchToScene}));
    }
};


template<class D>
class $CCAnimateFrameCache : public CCAnimateFrameCache, public $CacBase {
public:
    dupable ~$CCAnimateFrameCache() override {}

    dupable $CCAnimateFrameCache() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $CollisionBlockPopup : public CollisionBlockPopup, public $CacBase {
public:
    dupable ~$CollisionBlockPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1317e0))(this);
        else return CollisionBlockPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x131790))(this);
        else return CollisionBlockPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x131630))(this, p0);
        else return CollisionBlockPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x131670))(this, p0);
        else return CollisionBlockPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*, float)){&$CollisionBlockPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1318f0))(this, p0, p1);
        else return CollisionBlockPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1319b0))(this, p0);
        else return CollisionBlockPopup::textInputReturn(p0);
    }

    dupable $CollisionBlockPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1317e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CollisionBlockPopup::*)()){&$CollisionBlockPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x131790, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x131630, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x131670, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*, float)){&$CollisionBlockPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1318f0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($CollisionBlockPopup::*)(CCTextInputNode*)){&$CollisionBlockPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1319b0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $CommunityCreditNode : public CommunityCreditNode, public $CacBase {
public:
    dupable ~$CommunityCreditNode() override {}

    dupable $CommunityCreditNode() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $ConfigureValuePopup : public ConfigureValuePopup, public $CacBase {
public:
    dupable ~$ConfigureValuePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($ConfigureValuePopup::*)()){&$ConfigureValuePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x382c00))(this);
        else return ConfigureValuePopup::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x382a90))(this, p0);
        else return ConfigureValuePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x382ad0))(this, p0);
        else return ConfigureValuePopup::textChanged(p0);
    }

    dupable $ConfigureValuePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ConfigureValuePopup::*)()){&$ConfigureValuePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x382c00, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x382a90, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($ConfigureValuePopup::*)(CCTextInputNode*)){&$ConfigureValuePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x382ad0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));
    }
};


template<class D>
class $CurrencyRewardLayer : public CurrencyRewardLayer, public $CacBase {
public:
    dupable ~$CurrencyRewardLayer() override {}

    dupable void update(float p0) override {
        if ((void($CurrencyRewardLayer::*)(float)){&$CurrencyRewardLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x44a5c0))(this, p0);
        else return CurrencyRewardLayer::update(p0);
    }

    dupable $CurrencyRewardLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CurrencyRewardLayer::*)(float)){&$CurrencyRewardLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x44a5c0, extract_virtual(V, (void(D::*)(float)){&D::update}));
    }
};


template<class D>
class $EditGameObjectPopup : public EditGameObjectPopup, public $CacBase {
public:
    dupable ~$EditGameObjectPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x154070))(this);
        else return EditGameObjectPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x154020))(this);
        else return EditGameObjectPopup::show();
    }

    dupable $EditGameObjectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x154070, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($EditGameObjectPopup::*)()){&$EditGameObjectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x154020, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $FRequestProfilePage : public FRequestProfilePage, public $CacBase {
public:
    dupable ~$FRequestProfilePage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x437300))(this);
        else return FRequestProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4372d0))(this);
        else return FRequestProfilePage::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($FRequestProfilePage::*)(FLAlertLayer*, bool)){&$FRequestProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x437200))(this, p0, p1);
        else return FRequestProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($FRequestProfilePage::*)(UploadActionPopup*)){&$FRequestProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x437340))(this, p0);
        else return FRequestProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x4373a0))(this, p0, p1);
        else return FRequestProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x437500))(this, p0, p1);
        else return FRequestProfilePage::uploadActionFailed(p0, p1);
    }

    dupable void loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($FRequestProfilePage::*)(cocos2d::CCArray*, char const*)){&$FRequestProfilePage::loadFRequestsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x437840))(this, p0, p1);
        else return FRequestProfilePage::loadFRequestsFinished(p0, p1);
    }

    dupable void loadFRequestsFailed(char const* p0, GJErrorCode p1) override {
        if ((void($FRequestProfilePage::*)(char const*, GJErrorCode)){&$FRequestProfilePage::loadFRequestsFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*, GJErrorCode)>(m->getOriginal(base+0x437930))(this, p0, p1);
        else return FRequestProfilePage::loadFRequestsFailed(p0, p1);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($FRequestProfilePage::*)(std::string, char const*)){&$FRequestProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x437ab0))(this, p0, p1);
        else return FRequestProfilePage::setupPageInfo(p0, p1);
    }

    dupable void forceReloadRequests(bool p0) override {
        if ((void($FRequestProfilePage::*)(bool)){&$FRequestProfilePage::forceReloadRequests} != (void(D::*)(bool)){&D::forceReloadRequests})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x437a60))(this, p0);
        else return FRequestProfilePage::forceReloadRequests(p0);
    }

    dupable $FRequestProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x437300, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($FRequestProfilePage::*)()){&$FRequestProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4372d0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($FRequestProfilePage::*)(FLAlertLayer*, bool)){&$FRequestProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x437200, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($FRequestProfilePage::*)(UploadActionPopup*)){&$FRequestProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x437340, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x4373a0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($FRequestProfilePage::*)(int, int)){&$FRequestProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x437500, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($FRequestProfilePage::*)(cocos2d::CCArray*, char const*)){&$FRequestProfilePage::loadFRequestsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished})
            m->registerHook(base+0x437840, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadFRequestsFinished}));

        if ((void($FRequestProfilePage::*)(char const*, GJErrorCode)){&$FRequestProfilePage::loadFRequestsFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed})
            m->registerHook(base+0x437930, extract_virtual(V, (void(D::*)(char const*, GJErrorCode)){&D::loadFRequestsFailed}));

        if ((void($FRequestProfilePage::*)(std::string, char const*)){&$FRequestProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x437ab0, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($FRequestProfilePage::*)(bool)){&$FRequestProfilePage::forceReloadRequests} != (void(D::*)(bool)){&D::forceReloadRequests})
            m->registerHook(base+0x437a60, extract_virtual(V, (void(D::*)(bool)){&D::forceReloadRequests}));
    }
};


template<class D>
class $GJWriteMessagePopup : public GJWriteMessagePopup, public $CacBase {
public:
    dupable ~$GJWriteMessagePopup() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1527b0))(this);
        else return GJWriteMessagePopup::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x152780))(this);
        else return GJWriteMessagePopup::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x152830))(this, p0);
        else return GJWriteMessagePopup::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1527f0))(this, p0);
        else return GJWriteMessagePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x152990))(this, p0);
        else return GJWriteMessagePopup::textChanged(p0);
    }

    dupable void uploadMessageFinished(int p0) override {
        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFinished} != (void(D::*)(int)){&D::uploadMessageFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x152fc0))(this, p0);
        else return GJWriteMessagePopup::uploadMessageFinished(p0);
    }

    dupable void uploadMessageFailed(int p0) override {
        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFailed} != (void(D::*)(int)){&D::uploadMessageFailed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x1530a0))(this, p0);
        else return GJWriteMessagePopup::uploadMessageFailed(p0);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($GJWriteMessagePopup::*)(UploadActionPopup*)){&$GJWriteMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x153170))(this, p0);
        else return GJWriteMessagePopup::onClosePopup(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($GJWriteMessagePopup::*)(FLAlertLayer*, bool)){&$GJWriteMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1532b0))(this, p0, p1);
        else return GJWriteMessagePopup::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*, float)){&$GJWriteMessagePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x153390))(this, p0, p1);
        else return GJWriteMessagePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x153450))(this, p0);
        else return GJWriteMessagePopup::textInputReturn(p0);
    }

    dupable $GJWriteMessagePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x1527b0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($GJWriteMessagePopup::*)()){&$GJWriteMessagePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x152780, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x152830, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1527f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x152990, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFinished} != (void(D::*)(int)){&D::uploadMessageFinished})
            m->registerHook(base+0x152fc0, extract_virtual(V, (void(D::*)(int)){&D::uploadMessageFinished}));

        if ((void($GJWriteMessagePopup::*)(int)){&$GJWriteMessagePopup::uploadMessageFailed} != (void(D::*)(int)){&D::uploadMessageFailed})
            m->registerHook(base+0x1530a0, extract_virtual(V, (void(D::*)(int)){&D::uploadMessageFailed}));

        if ((void($GJWriteMessagePopup::*)(UploadActionPopup*)){&$GJWriteMessagePopup::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x153170, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($GJWriteMessagePopup::*)(FLAlertLayer*, bool)){&$GJWriteMessagePopup::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1532b0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*, float)){&$GJWriteMessagePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x153390, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJWriteMessagePopup::*)(CCTextInputNode*)){&$GJWriteMessagePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x153450, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GauntletSelectLayer : public GauntletSelectLayer, public $CacBase {
public:
    dupable ~$GauntletSelectLayer() override {}

    dupable void onExit() override {
        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2eb490))(this);
        else return GauntletSelectLayer::onExit();
    }

    dupable void keyBackClicked() override {
        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2eb370))(this);
        else return GauntletSelectLayer::keyBackClicked();
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x2eb260))(this, p0, p1);
        else return GauntletSelectLayer::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x2eb150))(this, p0, p1);
        else return GauntletSelectLayer::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($GauntletSelectLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletSelectLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x2ea630))(this, p0, p1);
        else return GauntletSelectLayer::loadLevelsFinished(p0, p1);
    }

    dupable void loadLevelsFailed(char const* p0) override {
        if ((void($GauntletSelectLayer::*)(char const*)){&$GauntletSelectLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2ea820))(this, p0);
        else return GauntletSelectLayer::loadLevelsFailed(p0);
    }

    dupable $GauntletSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x2eb490, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($GauntletSelectLayer::*)()){&$GauntletSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2eb370, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x2eb260, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));

        if ((void($GauntletSelectLayer::*)(BoomScrollLayer*, int)){&$GauntletSelectLayer::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x2eb150, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($GauntletSelectLayer::*)(cocos2d::CCArray*, char const*)){&$GauntletSelectLayer::loadLevelsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished})
            m->registerHook(base+0x2ea630, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadLevelsFinished}));

        if ((void($GauntletSelectLayer::*)(char const*)){&$GauntletSelectLayer::loadLevelsFailed} != (void(D::*)(char const*)){&D::loadLevelsFailed})
            m->registerHook(base+0x2ea820, extract_virtual(V, (void(D::*)(char const*)){&D::loadLevelsFailed}));
    }
};


template<class D>
class $GravityEffectSprite : public GravityEffectSprite, public $CacBase {
public:
    dupable ~$GravityEffectSprite() override {}

    dupable bool init() override {
        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x80b20))(this);
        else return GravityEffectSprite::init();
    }

    dupable void draw() override {
        if ((void($GravityEffectSprite::*)()){&$GravityEffectSprite::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80d80))(this);
        else return GravityEffectSprite::draw();
    }

    dupable $GravityEffectSprite() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GravityEffectSprite::*)()){&$GravityEffectSprite::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x80b20, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GravityEffectSprite::*)()){&$GravityEffectSprite::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x80d80, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $LevelSettingsObject : public LevelSettingsObject, public $CacBase {
public:
    dupable ~$LevelSettingsObject() override {}

    dupable bool init() override {
        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0xa5690))(this);
        else return LevelSettingsObject::init();
    }

    dupable $LevelSettingsObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelSettingsObject::*)()){&$LevelSettingsObject::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0xa5690, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $MessagesProfilePage : public MessagesProfilePage, public $CacBase {
public:
    dupable ~$MessagesProfilePage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x107eb0))(this);
        else return MessagesProfilePage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x107e80))(this);
        else return MessagesProfilePage::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($MessagesProfilePage::*)(FLAlertLayer*, bool)){&$MessagesProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x107b20))(this, p0, p1);
        else return MessagesProfilePage::FLAlert_Clicked(p0, p1);
    }

    dupable void onClosePopup(UploadActionPopup* p0) override {
        if ((void($MessagesProfilePage::*)(UploadActionPopup*)){&$MessagesProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            return reinterpret_cast<void(*)(decltype(this), UploadActionPopup*)>(m->getOriginal(base+0x107b90))(this, p0);
        else return MessagesProfilePage::onClosePopup(p0);
    }

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x107bf0))(this, p0, p1);
        else return MessagesProfilePage::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x107d50))(this, p0, p1);
        else return MessagesProfilePage::uploadActionFailed(p0, p1);
    }

    dupable void loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($MessagesProfilePage::*)(cocos2d::CCArray*, char const*)){&$MessagesProfilePage::loadMessagesFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x108150))(this, p0, p1);
        else return MessagesProfilePage::loadMessagesFinished(p0, p1);
    }

    dupable void loadMessagesFailed(char const* p0, GJErrorCode p1) override {
        if ((void($MessagesProfilePage::*)(char const*, GJErrorCode)){&$MessagesProfilePage::loadMessagesFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*, GJErrorCode)>(m->getOriginal(base+0x108280))(this, p0, p1);
        else return MessagesProfilePage::loadMessagesFailed(p0, p1);
    }

    dupable void forceReloadMessages(bool p0) override {
        if ((void($MessagesProfilePage::*)(bool)){&$MessagesProfilePage::forceReloadMessages} != (void(D::*)(bool)){&D::forceReloadMessages})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1083b0))(this, p0);
        else return MessagesProfilePage::forceReloadMessages(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($MessagesProfilePage::*)(std::string, char const*)){&$MessagesProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x108400))(this, p0, p1);
        else return MessagesProfilePage::setupPageInfo(p0, p1);
    }

    dupable $MessagesProfilePage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x107eb0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($MessagesProfilePage::*)()){&$MessagesProfilePage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x107e80, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MessagesProfilePage::*)(FLAlertLayer*, bool)){&$MessagesProfilePage::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x107b20, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($MessagesProfilePage::*)(UploadActionPopup*)){&$MessagesProfilePage::onClosePopup} != (void(D::*)(UploadActionPopup*)){&D::onClosePopup})
            m->registerHook(base+0x107b90, extract_virtual(V, (void(D::*)(UploadActionPopup*)){&D::onClosePopup}));

        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x107bf0, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($MessagesProfilePage::*)(int, int)){&$MessagesProfilePage::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x107d50, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));

        if ((void($MessagesProfilePage::*)(cocos2d::CCArray*, char const*)){&$MessagesProfilePage::loadMessagesFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished})
            m->registerHook(base+0x108150, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadMessagesFinished}));

        if ((void($MessagesProfilePage::*)(char const*, GJErrorCode)){&$MessagesProfilePage::loadMessagesFailed} != (void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed})
            m->registerHook(base+0x108280, extract_virtual(V, (void(D::*)(char const*, GJErrorCode)){&D::loadMessagesFailed}));

        if ((void($MessagesProfilePage::*)(bool)){&$MessagesProfilePage::forceReloadMessages} != (void(D::*)(bool)){&D::forceReloadMessages})
            m->registerHook(base+0x1083b0, extract_virtual(V, (void(D::*)(bool)){&D::forceReloadMessages}));

        if ((void($MessagesProfilePage::*)(std::string, char const*)){&$MessagesProfilePage::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x108400, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));
    }
};


template<class D>
class $SetupAnimationPopup : public SetupAnimationPopup, public $CacBase {
public:
    dupable ~$SetupAnimationPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ade0))(this);
        else return SetupAnimationPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x20ad90))(this);
        else return SetupAnimationPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20aaf0))(this, p0);
        else return SetupAnimationPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20ab30))(this, p0);
        else return SetupAnimationPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*, float)){&$SetupAnimationPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x20af30))(this, p0, p1);
        else return SetupAnimationPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x20aff0))(this, p0);
        else return SetupAnimationPopup::textInputReturn(p0);
    }

    dupable $SetupAnimationPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x20ade0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupAnimationPopup::*)()){&$SetupAnimationPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x20ad90, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x20aaf0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x20ab30, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*, float)){&$SetupAnimationPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x20af30, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupAnimationPopup::*)(CCTextInputNode*)){&$SetupAnimationPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x20aff0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $AccountRegisterLayer : public AccountRegisterLayer, public $CacBase {
public:
    dupable ~$AccountRegisterLayer() override {}

    dupable bool init() override {
        if ((bool($AccountRegisterLayer::*)()){&$AccountRegisterLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2575d0))(this);
        else return AccountRegisterLayer::init();
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25a910))(this);
        else return AccountRegisterLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25a730))(this);
        else return AccountRegisterLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($AccountRegisterLayer::*)(FLAlertLayer*, bool)){&$AccountRegisterLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x25a380))(this, p0, p1);
        else return AccountRegisterLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b420))(this, p0);
        else return AccountRegisterLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25a950))(this, p0);
        else return AccountRegisterLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b440))(this, p0);
        else return AccountRegisterLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*, float)){&$AccountRegisterLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x25b460))(this, p0, p1);
        else return AccountRegisterLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b520))(this, p0);
        else return AccountRegisterLayer::textInputReturn(p0);
    }

    dupable void allowTextInput(CCTextInputNode* p0) override {
        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x25b5d0))(this, p0);
        else return AccountRegisterLayer::allowTextInput(p0);
    }

    dupable void registerAccountFinished() override {
        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerAccountFinished} != (void(D::*)()){&D::registerAccountFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x259bf0))(this);
        else return AccountRegisterLayer::registerAccountFinished();
    }

    dupable void registerAccountFailed(AccountError p0) override {
        if ((void($AccountRegisterLayer::*)(AccountError)){&$AccountRegisterLayer::registerAccountFailed} != (void(D::*)(AccountError)){&D::registerAccountFailed})
            return reinterpret_cast<void(*)(decltype(this), AccountError)>(m->getOriginal(base+0x259d70))(this, p0);
        else return AccountRegisterLayer::registerAccountFailed(p0);
    }

    dupable $AccountRegisterLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($AccountRegisterLayer::*)()){&$AccountRegisterLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2575d0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x25a910, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x25a730, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($AccountRegisterLayer::*)(FLAlertLayer*, bool)){&$AccountRegisterLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x25a380, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0x25b420, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x25a950, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x25b440, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*, float)){&$AccountRegisterLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x25b460, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x25b520, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));

        if ((void($AccountRegisterLayer::*)(CCTextInputNode*)){&$AccountRegisterLayer::allowTextInput} != (void(D::*)(CCTextInputNode*)){&D::allowTextInput})
            m->registerHook(base+0x25b5d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::allowTextInput}));

        if ((void($AccountRegisterLayer::*)()){&$AccountRegisterLayer::registerAccountFinished} != (void(D::*)()){&D::registerAccountFinished})
            m->registerHook(base+0x259bf0, extract_virtual(V, (void(D::*)()){&D::registerAccountFinished}));

        if ((void($AccountRegisterLayer::*)(AccountError)){&$AccountRegisterLayer::registerAccountFailed} != (void(D::*)(AccountError)){&D::registerAccountFailed})
            m->registerHook(base+0x259d70, extract_virtual(V, (void(D::*)(AccountError)){&D::registerAccountFailed}));
    }
};


template<class D>
class $CommunityCreditsPage : public CommunityCreditsPage, public $CacBase {
public:
    dupable ~$CommunityCreditsPage() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e9f0))(this);
        else return CommunityCreditsPage::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e980))(this);
        else return CommunityCreditsPage::keyBackClicked();
    }

    dupable void show() override {
        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19e7e0))(this);
        else return CommunityCreditsPage::show();
    }

    dupable $CommunityCreditsPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x19e9f0, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x19e980, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CommunityCreditsPage::*)()){&$CommunityCreditsPage::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x19e7e0, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $CustomizeObjectLayer : public CustomizeObjectLayer, public $CacBase {
public:
    dupable ~$CustomizeObjectLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($CustomizeObjectLayer::*)()){&$CustomizeObjectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xe16c0))(this);
        else return CustomizeObjectLayer::keyBackClicked();
    }

    dupable void textInputOpened(CCTextInputNode* p0) override {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1280))(this, p0);
        else return CustomizeObjectLayer::textInputOpened(p0);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1430))(this, p0);
        else return CustomizeObjectLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0xe1470))(this, p0);
        else return CustomizeObjectLayer::textChanged(p0);
    }

    dupable void hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) override {
        if ((void($CustomizeObjectLayer::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&$CustomizeObjectLayer::hsvPopupClosed} != (void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed})
            return reinterpret_cast<void(*)(decltype(this), HSVWidgetPopup*, cocos2d::_ccHSVValue)>(m->getOriginal(base+0xe1050))(this, p0, p1);
        else return CustomizeObjectLayer::hsvPopupClosed(p0, p1);
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) override {
        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0xe0c60))(this, p0);
        else return CustomizeObjectLayer::colorSelectClosed(p0);
    }

    dupable void colorSetupClosed(int p0) override {
        if ((void($CustomizeObjectLayer::*)(int)){&$CustomizeObjectLayer::colorSetupClosed} != (void(D::*)(int)){&D::colorSetupClosed})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xe0850))(this, p0);
        else return CustomizeObjectLayer::colorSetupClosed(p0);
    }

    dupable $CustomizeObjectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CustomizeObjectLayer::*)()){&$CustomizeObjectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0xe16c0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputOpened} != (void(D::*)(CCTextInputNode*)){&D::textInputOpened})
            m->registerHook(base+0xe1280, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputOpened}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0xe1430, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($CustomizeObjectLayer::*)(CCTextInputNode*)){&$CustomizeObjectLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0xe1470, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($CustomizeObjectLayer::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&$CustomizeObjectLayer::hsvPopupClosed} != (void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed})
            m->registerHook(base+0xe1050, extract_virtual(V, (void(D::*)(HSVWidgetPopup*, cocos2d::_ccHSVValue)){&D::hsvPopupClosed}));

        if ((void($CustomizeObjectLayer::*)(cocos2d::CCNode*)){&$CustomizeObjectLayer::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0xe0c60, extract_virtual(V, (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($CustomizeObjectLayer::*)(int)){&$CustomizeObjectLayer::colorSetupClosed} != (void(D::*)(int)){&D::colorSetupClosed})
            m->registerHook(base+0xe0850, extract_virtual(V, (void(D::*)(int)){&D::colorSetupClosed}));
    }
};


template<class D>
class $GJFollowCommandLayer : public GJFollowCommandLayer, public $CacBase {
public:
    dupable ~$GJFollowCommandLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x16da20))(this);
        else return GJFollowCommandLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16d440))(this, p0);
        else return GJFollowCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16d480))(this, p0);
        else return GJFollowCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x16dc00))(this, p0, p1);
        else return GJFollowCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x16dcc0))(this, p0);
        else return GJFollowCommandLayer::textInputReturn(p0);
    }

    dupable $GJFollowCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJFollowCommandLayer::*)()){&$GJFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x16da20, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x16d440, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x16d480, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x16dc00, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJFollowCommandLayer::*)(CCTextInputNode*)){&$GJFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x16dcc0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GJRotateCommandLayer : public GJRotateCommandLayer, public $CacBase {
public:
    dupable ~$GJRotateCommandLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x5e30))(this);
        else return GJRotateCommandLayer::keyBackClicked();
    }

    dupable void valuePopupClosed(ConfigureValuePopup* p0, float p1) override {
        if ((void($GJRotateCommandLayer::*)(ConfigureValuePopup*, float)){&$GJRotateCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            return reinterpret_cast<void(*)(decltype(this), ConfigureValuePopup*, float)>(m->getOriginal(base+0x5160))(this, p0, p1);
        else return GJRotateCommandLayer::valuePopupClosed(p0, p1);
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x5890))(this, p0);
        else return GJRotateCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x58d0))(this, p0);
        else return GJRotateCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*, float)){&$GJRotateCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x6010))(this, p0, p1);
        else return GJRotateCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x60d0))(this, p0);
        else return GJRotateCommandLayer::textInputReturn(p0);
    }

    dupable $GJRotateCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJRotateCommandLayer::*)()){&$GJRotateCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x5e30, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJRotateCommandLayer::*)(ConfigureValuePopup*, float)){&$GJRotateCommandLayer::valuePopupClosed} != (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed})
            m->registerHook(base+0x5160, extract_virtual(V, (void(D::*)(ConfigureValuePopup*, float)){&D::valuePopupClosed}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x5890, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x58d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*, float)){&$GJRotateCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x6010, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJRotateCommandLayer::*)(CCTextInputNode*)){&$GJRotateCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x60d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $GJSpecialColorSelect : public GJSpecialColorSelect, public $CacBase {
public:
    dupable ~$GJSpecialColorSelect() override {}

    dupable void keyBackClicked() override {
        if ((void($GJSpecialColorSelect::*)()){&$GJSpecialColorSelect::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x383ca0))(this);
        else return GJSpecialColorSelect::keyBackClicked();
    }

    dupable $GJSpecialColorSelect() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJSpecialColorSelect::*)()){&$GJSpecialColorSelect::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x383ca0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $MusicDelegateHandler : public MusicDelegateHandler, public $CacBase {
public:
    dupable ~$MusicDelegateHandler() override {}

    dupable $MusicDelegateHandler() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $MusicDownloadManager : public MusicDownloadManager, public $CacBase {
public:
    dupable ~$MusicDownloadManager() override {}

    dupable bool init() override {
        if ((bool($MusicDownloadManager::*)()){&$MusicDownloadManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2ef100))(this);
        else return MusicDownloadManager::init();
    }

    dupable $MusicDownloadManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MusicDownloadManager::*)()){&$MusicDownloadManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2ef100, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $ParentalOptionsLayer : public ParentalOptionsLayer, public $CacBase {
public:
    dupable ~$ParentalOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x445da0))(this);
        else return ParentalOptionsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x4472d0))(this);
        else return ParentalOptionsLayer::keyBackClicked();
    }

    dupable $ParentalOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x445da0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ParentalOptionsLayer::*)()){&$ParentalOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x4472d0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $TeleportPortalObject : public TeleportPortalObject, public $CacBase {
public:
    dupable ~$TeleportPortalObject() override {}

    dupable void setPosition(cocos2d::CCPoint const& p0) override {
        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint const&)){&$TeleportPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint const&)>(m->getOriginal(base+0xdad00))(this, p0);
        else return TeleportPortalObject::setPosition(p0);
    }

    dupable void setRotation(float p0) override {
        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xdadb0))(this, p0);
        else return TeleportPortalObject::setRotation(p0);
    }

    dupable void setStartPos(cocos2d::CCPoint p0) override {
        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint)){&$TeleportPortalObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0xdab50))(this, p0);
        else return TeleportPortalObject::setStartPos(p0);
    }

    dupable void getSaveString() override {
        if ((void($TeleportPortalObject::*)()){&$TeleportPortalObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xdaf00))(this);
        else return TeleportPortalObject::getSaveString();
    }

    dupable void addToGroup(int p0) override {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae40))(this, p0);
        else return TeleportPortalObject::addToGroup(p0);
    }

    dupable void removeFromGroup(int p0) override {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdaea0))(this, p0);
        else return TeleportPortalObject::removeFromGroup(p0);
    }

    dupable void setRotation2(float p0) override {
        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation2} != (void(D::*)(float)){&D::setRotation2})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0xdae10))(this, p0);
        else return TeleportPortalObject::setRotation2(p0);
    }

    dupable void addToGroup2(int p0) override {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup2} != (void(D::*)(int)){&D::addToGroup2})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae20))(this, p0);
        else return TeleportPortalObject::addToGroup2(p0);
    }

    dupable void removeFromGroup2(int p0) override {
        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup2} != (void(D::*)(int)){&D::removeFromGroup2})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0xdae30))(this, p0);
        else return TeleportPortalObject::removeFromGroup2(p0);
    }

    dupable $TeleportPortalObject() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint const&)){&$TeleportPortalObject::setPosition} != (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition})
            m->registerHook(base+0xdad00, extract_virtual(V, (void(D::*)(cocos2d::CCPoint const&)){&D::setPosition}));

        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation} != (void(D::*)(float)){&D::setRotation})
            m->registerHook(base+0xdadb0, extract_virtual(V, (void(D::*)(float)){&D::setRotation}));

        if ((void($TeleportPortalObject::*)(cocos2d::CCPoint)){&$TeleportPortalObject::setStartPos} != (void(D::*)(cocos2d::CCPoint)){&D::setStartPos})
            m->registerHook(base+0xdab50, extract_virtual(V, (void(D::*)(cocos2d::CCPoint)){&D::setStartPos}));

        if ((void($TeleportPortalObject::*)()){&$TeleportPortalObject::getSaveString} != (void(D::*)()){&D::getSaveString})
            m->registerHook(base+0xdaf00, extract_virtual(V, (void(D::*)()){&D::getSaveString}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup} != (void(D::*)(int)){&D::addToGroup})
            m->registerHook(base+0xdae40, extract_virtual(V, (void(D::*)(int)){&D::addToGroup}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup} != (void(D::*)(int)){&D::removeFromGroup})
            m->registerHook(base+0xdaea0, extract_virtual(V, (void(D::*)(int)){&D::removeFromGroup}));

        if ((void($TeleportPortalObject::*)(float)){&$TeleportPortalObject::setRotation2} != (void(D::*)(float)){&D::setRotation2})
            m->registerHook(base+0xdae10, extract_virtual(V, (void(D::*)(float)){&D::setRotation2}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::addToGroup2} != (void(D::*)(int)){&D::addToGroup2})
            m->registerHook(base+0xdae20, extract_virtual(V, (void(D::*)(int)){&D::addToGroup2}));

        if ((void($TeleportPortalObject::*)(int)){&$TeleportPortalObject::removeFromGroup2} != (void(D::*)(int)){&D::removeFromGroup2})
            m->registerHook(base+0xdae30, extract_virtual(V, (void(D::*)(int)){&D::removeFromGroup2}));
    }
};


template<class D>
class $UploadActionDelegate : public UploadActionDelegate, public $CacBase {
public:
    dupable ~$UploadActionDelegate() override {}

    dupable void uploadActionFinished(int p0, int p1) override {
        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3aa720))(this, p0, p1);
        else return UploadActionDelegate::uploadActionFinished(p0, p1);
    }

    dupable void uploadActionFailed(int p0, int p1) override {
        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x3aa730))(this, p0, p1);
        else return UploadActionDelegate::uploadActionFailed(p0, p1);
    }

    dupable $UploadActionDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFinished} != (void(D::*)(int, int)){&D::uploadActionFinished})
            m->registerHook(base+0x3aa720, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFinished}));

        if ((void($UploadActionDelegate::*)(int, int)){&$UploadActionDelegate::uploadActionFailed} != (void(D::*)(int, int)){&D::uploadActionFailed})
            m->registerHook(base+0x3aa730, extract_virtual(V, (void(D::*)(int, int)){&D::uploadActionFailed}));
    }
};


template<class D>
class $CCMenuItemSpriteExtra : public CCMenuItemSpriteExtra, public $CacBase {
public:
    dupable ~$CCMenuItemSpriteExtra() override {}

    dupable void activate() override {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::activate} != (void(D::*)()){&D::activate})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125730))(this);
        else return CCMenuItemSpriteExtra::activate();
    }

    dupable void selected() override {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::selected} != (void(D::*)()){&D::selected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125840))(this);
        else return CCMenuItemSpriteExtra::selected();
    }

    dupable void unselected() override {
        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::unselected} != (void(D::*)()){&D::unselected})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x125a70))(this);
        else return CCMenuItemSpriteExtra::unselected();
    }

    dupable static CCMenuItemSpriteExtra* create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x1253c0))(p0, p1, p2, p3);
        else return CCMenuItemSpriteExtra::create(p0, p1, p2, p3);
    }

    dupable void setSizeMult(float p0) {
        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x1255e0))(this, p0);
        else return CCMenuItemSpriteExtra::setSizeMult(p0);
    }

    dupable bool init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) {
        if ((bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::init} != (bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)>(m->getOriginal(base+0x125450))(this, p0, p1, p2, p3);
        else return CCMenuItemSpriteExtra::init(p0, p1, p2, p3);
    }

    dupable $CCMenuItemSpriteExtra() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::activate} != (void(D::*)()){&D::activate})
            m->registerHook(base+0x125730, extract_virtual(V, (void(D::*)()){&D::activate}));

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::selected} != (void(D::*)()){&D::selected})
            m->registerHook(base+0x125840, extract_virtual(V, (void(D::*)()){&D::selected}));

        if ((void($CCMenuItemSpriteExtra::*)()){&$CCMenuItemSpriteExtra::unselected} != (void(D::*)()){&D::unselected})
            m->registerHook(base+0x125a70, extract_virtual(V, (void(D::*)()){&D::unselected}));

        if ((CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::create} != (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create})
            m->registerHook(base+0x1253c0, (CCMenuItemSpriteExtra*(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::create});

        if ((void($CCMenuItemSpriteExtra::*)(float)){&$CCMenuItemSpriteExtra::setSizeMult} != (void(D::*)(float)){&D::setSizeMult})
            m->registerHook(base+0x1255e0, extract((void(D::*)(float)){&D::setSizeMult}));

        if ((bool($CCMenuItemSpriteExtra::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&$CCMenuItemSpriteExtra::init} != (bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init})
            m->registerHook(base+0x125450, extract((bool(D::*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler)){&D::init}));
    }
};


template<class D>
class $CreateGuidelinesLayer : public CreateGuidelinesLayer, public $CacBase {
public:
    dupable ~$CreateGuidelinesLayer() override {}

    dupable void update(float p0) override {
        if ((void($CreateGuidelinesLayer::*)(float)){&$CreateGuidelinesLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x299c50))(this, p0);
        else return CreateGuidelinesLayer::update(p0);
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299dd0))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299f50))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x299f70))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x29a030))(this, p0, p1);
        else return CreateGuidelinesLayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29a070))(this);
        else return CreateGuidelinesLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x299ce0))(this);
        else return CreateGuidelinesLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x29a0b0))(this, p0);
        else return CreateGuidelinesLayer::keyDown(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($CreateGuidelinesLayer::*)(FLAlertLayer*, bool)){&$CreateGuidelinesLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x299c70))(this, p0, p1);
        else return CreateGuidelinesLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) override {
        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x29a180))(this, p0);
        else return CreateGuidelinesLayer::keyUp(p0);
    }

    dupable $CreateGuidelinesLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($CreateGuidelinesLayer::*)(float)){&$CreateGuidelinesLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x299c50, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((bool($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x299dd0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x299f50, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x299f70, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$CreateGuidelinesLayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x29a030, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x29a070, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($CreateGuidelinesLayer::*)()){&$CreateGuidelinesLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x299ce0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x29a0b0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($CreateGuidelinesLayer::*)(FLAlertLayer*, bool)){&$CreateGuidelinesLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x299c70, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($CreateGuidelinesLayer::*)(cocos2d::enumKeyCodes)){&$CreateGuidelinesLayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x29a180, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $GJPFollowCommandLayer : public GJPFollowCommandLayer, public $CacBase {
public:
    dupable ~$GJPFollowCommandLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1b2590))(this);
        else return GJPFollowCommandLayer::keyBackClicked();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b1d80))(this, p0);
        else return GJPFollowCommandLayer::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b1dc0))(this, p0);
        else return GJPFollowCommandLayer::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJPFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1b27a0))(this, p0, p1);
        else return GJPFollowCommandLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1b2860))(this, p0);
        else return GJPFollowCommandLayer::textInputReturn(p0);
    }

    dupable $GJPFollowCommandLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJPFollowCommandLayer::*)()){&$GJPFollowCommandLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1b2590, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1b1d80, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1b1dc0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*, float)){&$GJPFollowCommandLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1b27a0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJPFollowCommandLayer::*)(CCTextInputNode*)){&$GJPFollowCommandLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1b2860, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $MoreVideoOptionsLayer : public MoreVideoOptionsLayer, public $CacBase {
public:
    dupable ~$MoreVideoOptionsLayer() override {}

    dupable bool init() override {
        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x444150))(this);
        else return MoreVideoOptionsLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x445ba0))(this);
        else return MoreVideoOptionsLayer::keyBackClicked();
    }

    dupable $MoreVideoOptionsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x444150, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MoreVideoOptionsLayer::*)()){&$MoreVideoOptionsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x445ba0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $MusicDownloadDelegate : public MusicDownloadDelegate, public $CacBase {
public:
    dupable ~$MusicDownloadDelegate() override {}

    dupable void loadSongInfoFinished(SongInfoObject* p0) override {
        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x320a0))(this, p0);
        else return MusicDownloadDelegate::loadSongInfoFinished(p0);
    }

    dupable void loadSongInfoFailed(int p0, GJSongError p1) override {
        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x320b0))(this, p0, p1);
        else return MusicDownloadDelegate::loadSongInfoFailed(p0, p1);
    }

    dupable void downloadSongFinished(SongInfoObject* p0) override {
        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            return reinterpret_cast<void(*)(decltype(this), SongInfoObject*)>(m->getOriginal(base+0x320c0))(this, p0);
        else return MusicDownloadDelegate::downloadSongFinished(p0);
    }

    dupable void downloadSongFailed(int p0, GJSongError p1) override {
        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            return reinterpret_cast<void(*)(decltype(this), int, GJSongError)>(m->getOriginal(base+0x320d0))(this, p0, p1);
        else return MusicDownloadDelegate::downloadSongFailed(p0, p1);
    }

    dupable $MusicDownloadDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::loadSongInfoFinished} != (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished})
            m->registerHook(base+0x320a0, extract_virtual(V, (void(D::*)(SongInfoObject*)){&D::loadSongInfoFinished}));

        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::loadSongInfoFailed} != (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed})
            m->registerHook(base+0x320b0, extract_virtual(V, (void(D::*)(int, GJSongError)){&D::loadSongInfoFailed}));

        if ((void($MusicDownloadDelegate::*)(SongInfoObject*)){&$MusicDownloadDelegate::downloadSongFinished} != (void(D::*)(SongInfoObject*)){&D::downloadSongFinished})
            m->registerHook(base+0x320c0, extract_virtual(V, (void(D::*)(SongInfoObject*)){&D::downloadSongFinished}));

        if ((void($MusicDownloadDelegate::*)(int, GJSongError)){&$MusicDownloadDelegate::downloadSongFailed} != (void(D::*)(int, GJSongError)){&D::downloadSongFailed})
            m->registerHook(base+0x320d0, extract_virtual(V, (void(D::*)(int, GJSongError)){&D::downloadSongFailed}));
    }
};


template<class D>
class $SetupTouchTogglePopup : public SetupTouchTogglePopup, public $CacBase {
public:
    dupable ~$SetupTouchTogglePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x159850))(this);
        else return SetupTouchTogglePopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x159800))(this);
        else return SetupTouchTogglePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x159660))(this, p0);
        else return SetupTouchTogglePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1596a0))(this, p0);
        else return SetupTouchTogglePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*, float)){&$SetupTouchTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x159960))(this, p0, p1);
        else return SetupTouchTogglePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x159a20))(this, p0);
        else return SetupTouchTogglePopup::textInputReturn(p0);
    }

    dupable $SetupTouchTogglePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x159850, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupTouchTogglePopup::*)()){&$SetupTouchTogglePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x159800, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x159660, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1596a0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*, float)){&$SetupTouchTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x159960, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupTouchTogglePopup::*)(CCTextInputNode*)){&$SetupTouchTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x159a20, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ColorSelectLiveOverlay : public ColorSelectLiveOverlay, public $CacBase {
public:
    dupable ~$ColorSelectLiveOverlay() override {}

    dupable void keyBackClicked() override {
        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e4550))(this);
        else return ColorSelectLiveOverlay::keyBackClicked();
    }

    dupable void show() override {
        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e4620))(this);
        else return ColorSelectLiveOverlay::show();
    }

    dupable $ColorSelectLiveOverlay() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2e4550, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ColorSelectLiveOverlay::*)()){&$ColorSelectLiveOverlay::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x2e4620, extract_virtual(V, (void(D::*)()){&D::show}));
    }
};


template<class D>
class $DemonFilterSelectLayer : public DemonFilterSelectLayer, public $CacBase {
public:
    dupable ~$DemonFilterSelectLayer() override {}

    dupable bool init() override {
        if ((bool($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x38b9d0))(this);
        else return DemonFilterSelectLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x38c060))(this);
        else return DemonFilterSelectLayer::keyBackClicked();
    }

    dupable $DemonFilterSelectLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x38b9d0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($DemonFilterSelectLayer::*)()){&$DemonFilterSelectLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x38c060, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));
    }
};


template<class D>
class $GJAccountSettingsLayer : public GJAccountSettingsLayer, public $CacBase {
public:
    dupable ~$GJAccountSettingsLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($GJAccountSettingsLayer::*)()){&$GJAccountSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14b200))(this);
        else return GJAccountSettingsLayer::keyBackClicked();
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*, float)){&$GJAccountSettingsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x14abe0))(this, p0, p1);
        else return GJAccountSettingsLayer::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*)){&$GJAccountSettingsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x14aca0))(this, p0);
        else return GJAccountSettingsLayer::textInputReturn(p0);
    }

    dupable $GJAccountSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($GJAccountSettingsLayer::*)()){&$GJAccountSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14b200, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*, float)){&$GJAccountSettingsLayer::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x14abe0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($GJAccountSettingsLayer::*)(CCTextInputNode*)){&$GJAccountSettingsLayer::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x14aca0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupAnimSettingsPopup : public SetupAnimSettingsPopup, public $CacBase {
public:
    dupable ~$SetupAnimSettingsPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x599f0))(this);
        else return SetupAnimSettingsPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x599a0))(this);
        else return SetupAnimSettingsPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x597b0))(this, p0);
        else return SetupAnimSettingsPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x597f0))(this, p0);
        else return SetupAnimSettingsPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*, float)){&$SetupAnimSettingsPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x59ae0))(this, p0, p1);
        else return SetupAnimSettingsPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x59ba0))(this, p0);
        else return SetupAnimSettingsPopup::textInputReturn(p0);
    }

    dupable $SetupAnimSettingsPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x599f0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupAnimSettingsPopup::*)()){&$SetupAnimSettingsPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x599a0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x597b0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x597f0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*, float)){&$SetupAnimSettingsPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x59ae0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupAnimSettingsPopup::*)(CCTextInputNode*)){&$SetupAnimSettingsPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x59ba0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupCountTriggerPopup : public SetupCountTriggerPopup, public $CacBase {
public:
    dupable ~$SetupCountTriggerPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15ec70))(this);
        else return SetupCountTriggerPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x15ec20))(this);
        else return SetupCountTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15e960))(this, p0);
        else return SetupCountTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15e9a0))(this, p0);
        else return SetupCountTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCountTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x15ede0))(this, p0, p1);
        else return SetupCountTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x15eea0))(this, p0);
        else return SetupCountTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupCountTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x15ec70, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupCountTriggerPopup::*)()){&$SetupCountTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x15ec20, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x15e960, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x15e9a0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCountTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x15ede0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupCountTriggerPopup::*)(CCTextInputNode*)){&$SetupCountTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x15eea0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupInstantCountPopup : public SetupInstantCountPopup, public $CacBase {
public:
    dupable ~$SetupInstantCountPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x355600))(this);
        else return SetupInstantCountPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x3555b0))(this);
        else return SetupInstantCountPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355230))(this, p0);
        else return SetupInstantCountPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355270))(this, p0);
        else return SetupInstantCountPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*, float)){&$SetupInstantCountPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x355770))(this, p0, p1);
        else return SetupInstantCountPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x355830))(this, p0);
        else return SetupInstantCountPopup::textInputReturn(p0);
    }

    dupable $SetupInstantCountPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x355600, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupInstantCountPopup::*)()){&$SetupInstantCountPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x3555b0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x355230, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x355270, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*, float)){&$SetupInstantCountPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x355770, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupInstantCountPopup::*)(CCTextInputNode*)){&$SetupInstantCountPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x355830, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupObjectTogglePopup : public SetupObjectTogglePopup, public $CacBase {
public:
    dupable ~$SetupObjectTogglePopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1c27f0))(this);
        else return SetupObjectTogglePopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1c27a0))(this);
        else return SetupObjectTogglePopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c2620))(this, p0);
        else return SetupObjectTogglePopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c2660))(this, p0);
        else return SetupObjectTogglePopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*, float)){&$SetupObjectTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1c2900))(this, p0, p1);
        else return SetupObjectTogglePopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1c29c0))(this, p0);
        else return SetupObjectTogglePopup::textInputReturn(p0);
    }

    dupable $SetupObjectTogglePopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1c27f0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupObjectTogglePopup::*)()){&$SetupObjectTogglePopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1c27a0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1c2620, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1c2660, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*, float)){&$SetupObjectTogglePopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1c2900, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupObjectTogglePopup::*)(CCTextInputNode*)){&$SetupObjectTogglePopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1c29c0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SpriteAnimationManager : public SpriteAnimationManager, public $CacBase {
public:
    dupable ~$SpriteAnimationManager() override {}

    dupable $SpriteAnimationManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $BoomScrollLayerDelegate : public BoomScrollLayerDelegate, public $CacBase {
public:
    dupable ~$BoomScrollLayerDelegate() override {}

    dupable void scrollLayerScrollingStarted(BoomScrollLayer* p0) override {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*)){&$BoomScrollLayerDelegate::scrollLayerScrollingStarted} != (void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*)>(m->getOriginal(base+0x204370))(this, p0);
        else return BoomScrollLayerDelegate::scrollLayerScrollingStarted(p0);
    }

    dupable void scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x23cf70))(this, p0, p1);
        else return BoomScrollLayerDelegate::scrollLayerScrolledToPage(p0, p1);
    }

    dupable void scrollLayerMoved(cocos2d::CCPoint p0) override {
        if ((void($BoomScrollLayerDelegate::*)(cocos2d::CCPoint)){&$BoomScrollLayerDelegate::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x2eca30))(this, p0);
        else return BoomScrollLayerDelegate::scrollLayerMoved(p0);
    }

    dupable void scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) override {
        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            return reinterpret_cast<void(*)(decltype(this), BoomScrollLayer*, int)>(m->getOriginal(base+0x23cf80))(this, p0, p1);
        else return BoomScrollLayerDelegate::scrollLayerWillScrollToPage(p0, p1);
    }

    dupable $BoomScrollLayerDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*)){&$BoomScrollLayerDelegate::scrollLayerScrollingStarted} != (void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted})
            m->registerHook(base+0x204370, extract_virtual(V, (void(D::*)(BoomScrollLayer*)){&D::scrollLayerScrollingStarted}));

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerScrolledToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage})
            m->registerHook(base+0x23cf70, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerScrolledToPage}));

        if ((void($BoomScrollLayerDelegate::*)(cocos2d::CCPoint)){&$BoomScrollLayerDelegate::scrollLayerMoved} != (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved})
            m->registerHook(base+0x2eca30, extract_virtual(V, (void(D::*)(cocos2d::CCPoint)){&D::scrollLayerMoved}));

        if ((void($BoomScrollLayerDelegate::*)(BoomScrollLayer*, int)){&$BoomScrollLayerDelegate::scrollLayerWillScrollToPage} != (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage})
            m->registerHook(base+0x23cf80, extract_virtual(V, (void(D::*)(BoomScrollLayer*, int)){&D::scrollLayerWillScrollToPage}));
    }
};


template<class D>
class $SetupPickupTriggerPopup : public SetupPickupTriggerPopup, public $CacBase {
public:
    dupable ~$SetupPickupTriggerPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37f00))(this);
        else return SetupPickupTriggerPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37eb0))(this);
        else return SetupPickupTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x37c60))(this, p0);
        else return SetupPickupTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x37ca0))(this, p0);
        else return SetupPickupTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*, float)){&$SetupPickupTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x38050))(this, p0, p1);
        else return SetupPickupTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x38110))(this, p0);
        else return SetupPickupTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupPickupTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x37f00, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupPickupTriggerPopup::*)()){&$SetupPickupTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x37eb0, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x37c60, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x37ca0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*, float)){&$SetupPickupTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x38050, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupPickupTriggerPopup::*)(CCTextInputNode*)){&$SetupPickupTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x38110, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $ShareLevelSettingsLayer : public ShareLevelSettingsLayer, public $CacBase {
public:
    dupable ~$ShareLevelSettingsLayer() override {}

    dupable void keyBackClicked() override {
        if ((void($ShareLevelSettingsLayer::*)()){&$ShareLevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x12db50))(this);
        else return ShareLevelSettingsLayer::keyBackClicked();
    }

    dupable void numberInputClosed(NumberInputLayer* p0) override {
        if ((void($ShareLevelSettingsLayer::*)(NumberInputLayer*)){&$ShareLevelSettingsLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            return reinterpret_cast<void(*)(decltype(this), NumberInputLayer*)>(m->getOriginal(base+0x12da50))(this, p0);
        else return ShareLevelSettingsLayer::numberInputClosed(p0);
    }

    dupable $ShareLevelSettingsLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($ShareLevelSettingsLayer::*)()){&$ShareLevelSettingsLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x12db50, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($ShareLevelSettingsLayer::*)(NumberInputLayer*)){&$ShareLevelSettingsLayer::numberInputClosed} != (void(D::*)(NumberInputLayer*)){&D::numberInputClosed})
            m->registerHook(base+0x12da50, extract_virtual(V, (void(D::*)(NumberInputLayer*)){&D::numberInputClosed}));
    }
};


template<class D>
class $PlatformDownloadDelegate : public PlatformDownloadDelegate, public $CacBase {
public:
    dupable ~$PlatformDownloadDelegate() override {}

    dupable void downloadFinished(char const* p0) override {
        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFinished} != (void(D::*)(char const*)){&D::downloadFinished})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2f2db0))(this, p0);
        else return PlatformDownloadDelegate::downloadFinished(p0);
    }

    dupable void downloadFailed(char const* p0) override {
        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFailed} != (void(D::*)(char const*)){&D::downloadFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x2f2dc0))(this, p0);
        else return PlatformDownloadDelegate::downloadFailed(p0);
    }

    dupable $PlatformDownloadDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFinished} != (void(D::*)(char const*)){&D::downloadFinished})
            m->registerHook(base+0x2f2db0, extract_virtual(V, (void(D::*)(char const*)){&D::downloadFinished}));

        if ((void($PlatformDownloadDelegate::*)(char const*)){&$PlatformDownloadDelegate::downloadFailed} != (void(D::*)(char const*)){&D::downloadFailed})
            m->registerHook(base+0x2f2dc0, extract_virtual(V, (void(D::*)(char const*)){&D::downloadFailed}));
    }
};


template<class D>
class $SetupInteractObjectPopup : public SetupInteractObjectPopup, public $CacBase {
public:
    dupable ~$SetupInteractObjectPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29c550))(this);
        else return SetupInteractObjectPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x29c500))(this);
        else return SetupInteractObjectPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c270))(this, p0);
        else return SetupInteractObjectPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c2b0))(this, p0);
        else return SetupInteractObjectPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*, float)){&$SetupInteractObjectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x29c6a0))(this, p0, p1);
        else return SetupInteractObjectPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x29c760))(this, p0);
        else return SetupInteractObjectPopup::textInputReturn(p0);
    }

    dupable $SetupInteractObjectPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x29c550, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupInteractObjectPopup::*)()){&$SetupInteractObjectPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x29c500, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x29c270, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x29c2b0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*, float)){&$SetupInteractObjectPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x29c6a0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupInteractObjectPopup::*)(CCTextInputNode*)){&$SetupInteractObjectPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x29c760, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $SetupCollisionTriggerPopup : public SetupCollisionTriggerPopup, public $CacBase {
public:
    dupable ~$SetupCollisionTriggerPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d8880))(this);
        else return SetupCollisionTriggerPopup::keyBackClicked();
    }

    dupable void show() override {
        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d8830))(this);
        else return SetupCollisionTriggerPopup::show();
    }

    dupable void textInputClosed(CCTextInputNode* p0) override {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d8490))(this, p0);
        else return SetupCollisionTriggerPopup::textInputClosed(p0);
    }

    dupable void textChanged(CCTextInputNode* p0) override {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d84d0))(this, p0);
        else return SetupCollisionTriggerPopup::textChanged(p0);
    }

    dupable void textInputShouldOffset(CCTextInputNode* p0, float p1) override {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCollisionTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*, float)>(m->getOriginal(base+0x1d89f0))(this, p0, p1);
        else return SetupCollisionTriggerPopup::textInputShouldOffset(p0, p1);
    }

    dupable void textInputReturn(CCTextInputNode* p0) override {
        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            return reinterpret_cast<void(*)(decltype(this), CCTextInputNode*)>(m->getOriginal(base+0x1d8ab0))(this, p0);
        else return SetupCollisionTriggerPopup::textInputReturn(p0);
    }

    dupable $SetupCollisionTriggerPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d8880, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($SetupCollisionTriggerPopup::*)()){&$SetupCollisionTriggerPopup::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x1d8830, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputClosed} != (void(D::*)(CCTextInputNode*)){&D::textInputClosed})
            m->registerHook(base+0x1d8490, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputClosed}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textChanged} != (void(D::*)(CCTextInputNode*)){&D::textChanged})
            m->registerHook(base+0x1d84d0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textChanged}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*, float)){&$SetupCollisionTriggerPopup::textInputShouldOffset} != (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset})
            m->registerHook(base+0x1d89f0, extract_virtual(V, (void(D::*)(CCTextInputNode*, float)){&D::textInputShouldOffset}));

        if ((void($SetupCollisionTriggerPopup::*)(CCTextInputNode*)){&$SetupCollisionTriggerPopup::textInputReturn} != (void(D::*)(CCTextInputNode*)){&D::textInputReturn})
            m->registerHook(base+0x1d8ab0, extract_virtual(V, (void(D::*)(CCTextInputNode*)){&D::textInputReturn}));
    }
};


template<class D>
class $UpdateAccountSettingsPopup : public UpdateAccountSettingsPopup, public $CacBase {
public:
    dupable ~$UpdateAccountSettingsPopup() override {}

    dupable void keyBackClicked() override {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14bcb0))(this);
        else return UpdateAccountSettingsPopup::keyBackClicked();
    }

    dupable void updateSettingsFinished() override {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFinished} != (void(D::*)()){&D::updateSettingsFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14ba40))(this);
        else return UpdateAccountSettingsPopup::updateSettingsFinished();
    }

    dupable void updateSettingsFailed() override {
        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFailed} != (void(D::*)()){&D::updateSettingsFailed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x14bb80))(this);
        else return UpdateAccountSettingsPopup::updateSettingsFailed();
    }

    dupable $UpdateAccountSettingsPopup() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x14bcb0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFinished} != (void(D::*)()){&D::updateSettingsFinished})
            m->registerHook(base+0x14ba40, extract_virtual(V, (void(D::*)()){&D::updateSettingsFinished}));

        if ((void($UpdateAccountSettingsPopup::*)()){&$UpdateAccountSettingsPopup::updateSettingsFailed} != (void(D::*)()){&D::updateSettingsFailed})
            m->registerHook(base+0x14bb80, extract_virtual(V, (void(D::*)()){&D::updateSettingsFailed}));
    }
};


template<class D>
class $Slider : public Slider, public $CacBase {
public:
    dupable ~$Slider() override {}

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e2e0))(this, p0, p1);
        else return Slider::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e360))(this, p0, p1);
        else return Slider::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x18e320))(this, p0, p1);
        else return Slider::ccTouchEnded(p0, p1);
    }

    dupable $Slider() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x18e2e0, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x18e360, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($Slider::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$Slider::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x18e320, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));
    }
};


template<class D>
class $UILayer : public UILayer, public $CacBase {
public:
    dupable ~$UILayer() override {}

    dupable bool init() override {
        if ((bool($UILayer::*)()){&$UILayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x27fe40))(this);
        else return UILayer::init();
    }

    dupable void draw() override {
        if ((void($UILayer::*)()){&$UILayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x280980))(this);
        else return UILayer::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280990))(this, p0, p1);
        else return UILayer::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280ad0))(this, p0, p1);
        else return UILayer::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280af0))(this, p0, p1);
        else return UILayer::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x280bd0))(this, p0, p1);
        else return UILayer::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($UILayer::*)()){&$UILayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x280c10))(this);
        else return UILayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($UILayer::*)()){&$UILayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2808e0))(this);
        else return UILayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x280470))(this, p0);
        else return UILayer::keyDown(p0);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) override {
        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x280600))(this, p0);
        else return UILayer::keyUp(p0);
    }

    dupable $UILayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($UILayer::*)()){&$UILayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x27fe40, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($UILayer::*)()){&$UILayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x280980, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x280990, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x280ad0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x280af0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($UILayer::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$UILayer::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x280bd0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($UILayer::*)()){&$UILayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x280c10, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($UILayer::*)()){&$UILayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x2808e0, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x280470, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($UILayer::*)(cocos2d::enumKeyCodes)){&$UILayer::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x280600, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));
    }
};


template<class D>
class $EditorUI : public EditorUI, public $CacBase {
public:
    dupable ~$EditorUI() override {}

    dupable void draw() override {
        if ((void($EditorUI::*)()){&$EditorUI::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e170))(this);
        else return EditorUI::draw();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2ed60))(this, p0, p1);
        else return EditorUI::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2f3d0))(this, p0, p1);
        else return EditorUI::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2fb00))(this, p0, p1);
        else return EditorUI::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x30710))(this, p0, p1);
        else return EditorUI::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($EditorUI::*)()){&$EditorUI::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x30750))(this);
        else return EditorUI::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($EditorUI::*)()){&$EditorUI::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x24c50))(this);
        else return EditorUI::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x30790))(this, p0);
        else return EditorUI::keyDown(p0);
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($EditorUI::*)(FLAlertLayer*, bool)){&$EditorUI::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1f590))(this, p0, p1);
        else return EditorUI::FLAlert_Clicked(p0, p1);
    }

    dupable void songStateChanged() override {
        if ((void($EditorUI::*)()){&$EditorUI::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x24760))(this);
        else return EditorUI::songStateChanged();
    }

    dupable void colorSelectClosed(cocos2d::CCNode* p0) override {
        if ((void($EditorUI::*)(cocos2d::CCNode*)){&$EditorUI::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCNode*)>(m->getOriginal(base+0x29940))(this, p0);
        else return EditorUI::colorSelectClosed(p0);
    }

    dupable void keyUp(cocos2d::enumKeyCodes p0) override {
        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x312b0))(this, p0);
        else return EditorUI::keyUp(p0);
    }

    dupable void scrollWheel(float p0, float p1) override {
        if ((void($EditorUI::*)(float, float)){&$EditorUI::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x31370))(this, p0, p1);
        else return EditorUI::scrollWheel(p0, p1);
    }

    dupable void angleChangeBegin() override {
        if ((void($EditorUI::*)()){&$EditorUI::angleChangeBegin} != (void(D::*)()){&D::angleChangeBegin})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e260))(this);
        else return EditorUI::angleChangeBegin();
    }

    dupable void angleChangeEnded() override {
        if ((void($EditorUI::*)()){&$EditorUI::angleChangeEnded} != (void(D::*)()){&D::angleChangeEnded})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x2e320))(this);
        else return EditorUI::angleChangeEnded();
    }

    dupable void angleChanged(float p0) override {
        if ((void($EditorUI::*)(float)){&$EditorUI::angleChanged} != (void(D::*)(float)){&D::angleChanged})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x2e3a0))(this, p0);
        else return EditorUI::angleChanged(p0);
    }

    dupable void scaleChangeBegin() override {
        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeBegin} != (void(D::*)()){&D::scaleChangeBegin})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x25120))(this);
        else return EditorUI::scaleChangeBegin();
    }

    dupable void scaleChangeEnded() override {
        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeEnded} != (void(D::*)()){&D::scaleChangeEnded})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x251e0))(this);
        else return EditorUI::scaleChangeEnded();
    }

    dupable void scaleChanged(float p0) override {
        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x25260))(this, p0);
        else return EditorUI::scaleChanged(p0);
    }

    dupable void constrainGameLayerPosition() {
        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1c6d0))(this);
        else return EditorUI::constrainGameLayerPosition();
    }

    dupable void create(LevelEditorLayer* p0) {
        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer*)){&D::create})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(base+0x8a80))(this, p0);
        else return EditorUI::create(p0);
    }

    dupable void deselectAll() {
        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1f300))(this);
        else return EditorUI::deselectAll();
    }

    dupable void onDeselectAll(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDeselectAll} != (void(D::*)(cocos2d::CCObject*)){&D::onDeselectAll})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x19cd0))(this, p0);
        else return EditorUI::onDeselectAll(p0);
    }

    dupable void disableButton(CreateMenuItem* p0) {
        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem*)){&D::disableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(base+0x1c0f0))(this, p0);
        else return EditorUI::disableButton(p0);
    }

    dupable void editButtonUsable() {
        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x28f30))(this);
        else return EditorUI::editButtonUsable();
    }

    dupable void editObject(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject*)){&D::editObject})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x195a0))(this, p0);
        else return EditorUI::editObject(p0);
    }

    dupable void enableButton(CreateMenuItem* p0) {
        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem*)){&D::enableButton})
            return reinterpret_cast<void(*)(decltype(this), CreateMenuItem*)>(m->getOriginal(base+0x1bff0))(this, p0);
        else return EditorUI::enableButton(p0);
    }

    dupable CCMenuItemSpriteExtra* getCreateBtn(int p0, int p1) {
        if ((CCMenuItemSpriteExtra*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn})
            return reinterpret_cast<CCMenuItemSpriteExtra*(*)(decltype(this), int, int)>(m->getOriginal(base+0x1f6c0))(this, p0, p1);
        else return EditorUI::getCreateBtn(p0, p1);
    }

    dupable void getGroupCenter(cocos2d::CCArray* p0, bool p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(base+0x23470))(this, p0, p1);
        else return EditorUI::getGroupCenter(p0, p1);
    }

    dupable cocos2d::CCArray* getSelectedObjects() {
        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            return reinterpret_cast<cocos2d::CCArray*(*)(decltype(this))>(m->getOriginal(base+0x23f30))(this);
        else return EditorUI::getSelectedObjects();
    }

    dupable void init(LevelEditorLayer* p0) {
        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer*)){&D::init})
            return reinterpret_cast<void(*)(decltype(this), LevelEditorLayer*)>(m->getOriginal(base+0x8ae0))(this, p0);
        else return EditorUI::init(p0);
    }

    dupable void moveObject(GameObject* p0, cocos2d::CCPoint p1) {
        if ((void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, cocos2d::CCPoint)>(m->getOriginal(base+0x24b10))(this, p0, p1);
        else return EditorUI::moveObject(p0, p1);
    }

    dupable void onDuplicate(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject*)){&D::onDuplicate})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x18ba0))(this, p0);
        else return EditorUI::onDuplicate(p0);
    }

    dupable void pasteObjects(std::string p0) {
        if ((void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects} != (void(D::*)(std::string)){&D::pasteObjects})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x232d0))(this, p0);
        else return EditorUI::pasteObjects(p0);
    }

    dupable void playerTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {
        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::playerTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::playerTouchBegan})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x2ebf0))(this, p0, p1);
        else return EditorUI::playerTouchBegan(p0, p1);
    }

    dupable void playtestStopped() {
        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x24790))(this);
        else return EditorUI::playtestStopped();
    }

    dupable void redoLastAction(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::redoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0xb8e0))(this, p0);
        else return EditorUI::redoLastAction(p0);
    }

    dupable void replaceGroupID(GameObject* p0, int p1, int p2) {
        if ((void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject*, int, int)){&D::replaceGroupID})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, int, int)>(m->getOriginal(base+0x27470))(this, p0, p1, p2);
        else return EditorUI::replaceGroupID(p0, p1, p2);
    }

    dupable void scaleObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, float, cocos2d::CCPoint)>(m->getOriginal(base+0x252e0))(this, p0, p1, p2);
        else return EditorUI::scaleObjects(p0, p1, p2);
    }

    dupable void selectObjects(cocos2d::CCArray* p0, bool p1) {
        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, bool)>(m->getOriginal(base+0x23940))(this, p0, p1);
        else return EditorUI::selectObjects(p0, p1);
    }

    dupable void setupCreateMenu() {
        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0xcb50))(this);
        else return EditorUI::setupCreateMenu();
    }

    dupable void undoLastAction(cocos2d::CCObject* p0) {
        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::undoLastAction})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0xb830))(this, p0);
        else return EditorUI::undoLastAction(p0);
    }

    dupable void updateButtons() {
        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1a300))(this);
        else return EditorUI::updateButtons();
    }

    dupable void updateObjectInfoLabel() {
        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1cb10))(this);
        else return EditorUI::updateObjectInfoLabel();
    }

    dupable void updateSlider() {
        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18a90))(this);
        else return EditorUI::updateSlider();
    }

    dupable void updateZoom(float p0) {
        if ((void($EditorUI::*)(float)){&$EditorUI::updateZoom} != (void(D::*)(float)){&D::updateZoom})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x248c0))(this, p0);
        else return EditorUI::updateZoom(p0);
    }

    dupable $EditorUI() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($EditorUI::*)()){&$EditorUI::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x2e170, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((bool($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x2ed60, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x2f3d0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x2fb00, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x30710, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($EditorUI::*)()){&$EditorUI::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x30750, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($EditorUI::*)()){&$EditorUI::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x24c50, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x30790, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($EditorUI::*)(FLAlertLayer*, bool)){&$EditorUI::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1f590, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($EditorUI::*)()){&$EditorUI::songStateChanged} != (void(D::*)()){&D::songStateChanged})
            m->registerHook(base+0x24760, extract_virtual(V, (void(D::*)()){&D::songStateChanged}));

        if ((void($EditorUI::*)(cocos2d::CCNode*)){&$EditorUI::colorSelectClosed} != (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed})
            m->registerHook(base+0x29940, extract_virtual(V, (void(D::*)(cocos2d::CCNode*)){&D::colorSelectClosed}));

        if ((void($EditorUI::*)(cocos2d::enumKeyCodes)){&$EditorUI::keyUp} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp})
            m->registerHook(base+0x312b0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyUp}));

        if ((void($EditorUI::*)(float, float)){&$EditorUI::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            m->registerHook(base+0x31370, extract_virtual(V, (void(D::*)(float, float)){&D::scrollWheel}));

        if ((void($EditorUI::*)()){&$EditorUI::angleChangeBegin} != (void(D::*)()){&D::angleChangeBegin})
            m->registerHook(base+0x2e260, extract_virtual(V, (void(D::*)()){&D::angleChangeBegin}));

        if ((void($EditorUI::*)()){&$EditorUI::angleChangeEnded} != (void(D::*)()){&D::angleChangeEnded})
            m->registerHook(base+0x2e320, extract_virtual(V, (void(D::*)()){&D::angleChangeEnded}));

        if ((void($EditorUI::*)(float)){&$EditorUI::angleChanged} != (void(D::*)(float)){&D::angleChanged})
            m->registerHook(base+0x2e3a0, extract_virtual(V, (void(D::*)(float)){&D::angleChanged}));

        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeBegin} != (void(D::*)()){&D::scaleChangeBegin})
            m->registerHook(base+0x25120, extract_virtual(V, (void(D::*)()){&D::scaleChangeBegin}));

        if ((void($EditorUI::*)()){&$EditorUI::scaleChangeEnded} != (void(D::*)()){&D::scaleChangeEnded})
            m->registerHook(base+0x251e0, extract_virtual(V, (void(D::*)()){&D::scaleChangeEnded}));

        if ((void($EditorUI::*)(float)){&$EditorUI::scaleChanged} != (void(D::*)(float)){&D::scaleChanged})
            m->registerHook(base+0x25260, extract_virtual(V, (void(D::*)(float)){&D::scaleChanged}));

        if ((void($EditorUI::*)()){&$EditorUI::constrainGameLayerPosition} != (void(D::*)()){&D::constrainGameLayerPosition})
            m->registerHook(base+0x1c6d0, extract((void(D::*)()){&D::constrainGameLayerPosition}));

        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::create} != (void(D::*)(LevelEditorLayer*)){&D::create})
            m->registerHook(base+0x8a80, extract((void(D::*)(LevelEditorLayer*)){&D::create}));

        if ((void($EditorUI::*)()){&$EditorUI::deselectAll} != (void(D::*)()){&D::deselectAll})
            m->registerHook(base+0x1f300, extract((void(D::*)()){&D::deselectAll}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDeselectAll} != (void(D::*)(cocos2d::CCObject*)){&D::onDeselectAll})
            m->registerHook(base+0x19cd0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDeselectAll}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::disableButton} != (void(D::*)(CreateMenuItem*)){&D::disableButton})
            m->registerHook(base+0x1c0f0, extract((void(D::*)(CreateMenuItem*)){&D::disableButton}));

        if ((void($EditorUI::*)()){&$EditorUI::editButtonUsable} != (void(D::*)()){&D::editButtonUsable})
            m->registerHook(base+0x28f30, extract((void(D::*)()){&D::editButtonUsable}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::editObject} != (void(D::*)(cocos2d::CCObject*)){&D::editObject})
            m->registerHook(base+0x195a0, extract((void(D::*)(cocos2d::CCObject*)){&D::editObject}));

        if ((void($EditorUI::*)(CreateMenuItem*)){&$EditorUI::enableButton} != (void(D::*)(CreateMenuItem*)){&D::enableButton})
            m->registerHook(base+0x1bff0, extract((void(D::*)(CreateMenuItem*)){&D::enableButton}));

        if ((CCMenuItemSpriteExtra*($EditorUI::*)(int, int)){&$EditorUI::getCreateBtn} != (CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn})
            m->registerHook(base+0x1f6c0, extract((CCMenuItemSpriteExtra*(D::*)(int, int)){&D::getCreateBtn}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::getGroupCenter} != (void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter})
            m->registerHook(base+0x23470, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::getGroupCenter}));

        if ((cocos2d::CCArray*($EditorUI::*)()){&$EditorUI::getSelectedObjects} != (cocos2d::CCArray*(D::*)()){&D::getSelectedObjects})
            m->registerHook(base+0x23f30, extract((cocos2d::CCArray*(D::*)()){&D::getSelectedObjects}));

        if ((void($EditorUI::*)(LevelEditorLayer*)){&$EditorUI::init} != (void(D::*)(LevelEditorLayer*)){&D::init})
            m->registerHook(base+0x8ae0, extract((void(D::*)(LevelEditorLayer*)){&D::init}));

        if ((void($EditorUI::*)(GameObject*, cocos2d::CCPoint)){&$EditorUI::moveObject} != (void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject})
            m->registerHook(base+0x24b10, extract((void(D::*)(GameObject*, cocos2d::CCPoint)){&D::moveObject}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::onDuplicate} != (void(D::*)(cocos2d::CCObject*)){&D::onDuplicate})
            m->registerHook(base+0x18ba0, extract((void(D::*)(cocos2d::CCObject*)){&D::onDuplicate}));

        if ((void($EditorUI::*)(std::string)){&$EditorUI::pasteObjects} != (void(D::*)(std::string)){&D::pasteObjects})
            m->registerHook(base+0x232d0, extract((void(D::*)(std::string)){&D::pasteObjects}));

        if ((void($EditorUI::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$EditorUI::playerTouchBegan} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::playerTouchBegan})
            m->registerHook(base+0x2ebf0, extract((void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::playerTouchBegan}));

        if ((void($EditorUI::*)()){&$EditorUI::playtestStopped} != (void(D::*)()){&D::playtestStopped})
            m->registerHook(base+0x24790, extract((void(D::*)()){&D::playtestStopped}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::redoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::redoLastAction})
            m->registerHook(base+0xb8e0, extract((void(D::*)(cocos2d::CCObject*)){&D::redoLastAction}));

        if ((void($EditorUI::*)(GameObject*, int, int)){&$EditorUI::replaceGroupID} != (void(D::*)(GameObject*, int, int)){&D::replaceGroupID})
            m->registerHook(base+0x27470, extract((void(D::*)(GameObject*, int, int)){&D::replaceGroupID}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&$EditorUI::scaleObjects} != (void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects})
            m->registerHook(base+0x252e0, extract((void(D::*)(cocos2d::CCArray*, float, cocos2d::CCPoint)){&D::scaleObjects}));

        if ((void($EditorUI::*)(cocos2d::CCArray*, bool)){&$EditorUI::selectObjects} != (void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects})
            m->registerHook(base+0x23940, extract((void(D::*)(cocos2d::CCArray*, bool)){&D::selectObjects}));

        if ((void($EditorUI::*)()){&$EditorUI::setupCreateMenu} != (void(D::*)()){&D::setupCreateMenu})
            m->registerHook(base+0xcb50, extract((void(D::*)()){&D::setupCreateMenu}));

        if ((void($EditorUI::*)(cocos2d::CCObject*)){&$EditorUI::undoLastAction} != (void(D::*)(cocos2d::CCObject*)){&D::undoLastAction})
            m->registerHook(base+0xb830, extract((void(D::*)(cocos2d::CCObject*)){&D::undoLastAction}));

        if ((void($EditorUI::*)()){&$EditorUI::updateButtons} != (void(D::*)()){&D::updateButtons})
            m->registerHook(base+0x1a300, extract((void(D::*)()){&D::updateButtons}));

        if ((void($EditorUI::*)()){&$EditorUI::updateObjectInfoLabel} != (void(D::*)()){&D::updateObjectInfoLabel})
            m->registerHook(base+0x1cb10, extract((void(D::*)()){&D::updateObjectInfoLabel}));

        if ((void($EditorUI::*)()){&$EditorUI::updateSlider} != (void(D::*)()){&D::updateSlider})
            m->registerHook(base+0x18a90, extract((void(D::*)()){&D::updateSlider}));

        if ((void($EditorUI::*)(float)){&$EditorUI::updateZoom} != (void(D::*)(float)){&D::updateZoom})
            m->registerHook(base+0x248c0, extract((void(D::*)(float)){&D::updateZoom}));
    }
};


template<class D>
class $GManager : public GManager, public $CacBase {
public:
    dupable ~$GManager() override {}

    dupable bool init() override {
        if ((bool($GManager::*)()){&$GManager::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x26ee00))(this);
        else return GManager::init();
    }

    dupable void setup() override {
        if ((void($GManager::*)()){&$GManager::setup} != (void(D::*)()){&D::setup})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26ee20))(this);
        else return GManager::setup();
    }

    dupable void encodeDataTo(DS_Dictionary* p0) override {
        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x26f5b0))(this, p0);
        else return GManager::encodeDataTo(p0);
    }

    dupable void dataLoaded(DS_Dictionary* p0) override {
        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            return reinterpret_cast<void(*)(decltype(this), DS_Dictionary*)>(m->getOriginal(base+0x26fb70))(this, p0);
        else return GManager::dataLoaded(p0);
    }

    dupable void firstLoad() override {
        if ((void($GManager::*)()){&$GManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x26fb80))(this);
        else return GManager::firstLoad();
    }

    dupable $GManager() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GManager::*)()){&$GManager::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x26ee00, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GManager::*)()){&$GManager::setup} != (void(D::*)()){&D::setup})
            m->registerHook(base+0x26ee20, extract_virtual(V, (void(D::*)()){&D::setup}));

        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::encodeDataTo} != (void(D::*)(DS_Dictionary*)){&D::encodeDataTo})
            m->registerHook(base+0x26f5b0, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::encodeDataTo}));

        if ((void($GManager::*)(DS_Dictionary*)){&$GManager::dataLoaded} != (void(D::*)(DS_Dictionary*)){&D::dataLoaded})
            m->registerHook(base+0x26fb70, extract_virtual(V, (void(D::*)(DS_Dictionary*)){&D::dataLoaded}));

        if ((void($GManager::*)()){&$GManager::firstLoad} != (void(D::*)()){&D::firstLoad})
            m->registerHook(base+0x26fb80, extract_virtual(V, (void(D::*)()){&D::firstLoad}));
    }
};


template<class D>
class $GameCell : public GameCell, public $CacBase {
public:
    dupable ~$GameCell() override {}

    dupable bool init() override {
        if ((bool($GameCell::*)()){&$GameCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18f980))(this);
        else return GameCell::init();
    }

    dupable void draw() override {
        if ((void($GameCell::*)()){&$GameCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18fa40))(this);
        else return GameCell::draw();
    }

    dupable $GameCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GameCell::*)()){&$GameCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18f980, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($GameCell::*)()){&$GameCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18fa40, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $ListCell : public ListCell, public $CacBase {
public:
    dupable ~$ListCell() override {}

    dupable bool init() override {
        if ((bool($ListCell::*)()){&$ListCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x18f7a0))(this);
        else return ListCell::init();
    }

    dupable void draw() override {
        if ((void($ListCell::*)()){&$ListCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x18f840))(this);
        else return ListCell::draw();
    }

    dupable $ListCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($ListCell::*)()){&$ListCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x18f7a0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($ListCell::*)()){&$ListCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x18f840, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $SongCell : public SongCell, public $CacBase {
public:
    dupable ~$SongCell() override {}

    dupable bool init() override {
        if ((bool($SongCell::*)()){&$SongCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11c200))(this);
        else return SongCell::init();
    }

    dupable void draw() override {
        if ((void($SongCell::*)()){&$SongCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11c240))(this);
        else return SongCell::draw();
    }

    dupable $SongCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($SongCell::*)()){&$SongCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11c200, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($SongCell::*)()){&$SongCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11c240, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $TextArea : public TextArea, public $CacBase {
public:
    dupable ~$TextArea() override {}

    dupable void draw() override {
        if ((void($TextArea::*)()){&$TextArea::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x19f890))(this);
        else return TextArea::draw();
    }

    dupable void setOpacity(unsigned char p0) override {
        if ((void($TextArea::*)(unsigned char)){&$TextArea::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            return reinterpret_cast<void(*)(decltype(this), unsigned char)>(m->getOriginal(base+0x19f760))(this, p0);
        else return TextArea::setOpacity(p0);
    }

    dupable $TextArea() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TextArea::*)()){&$TextArea::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x19f890, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($TextArea::*)(unsigned char)){&$TextArea::setOpacity} != (void(D::*)(unsigned char)){&D::setOpacity})
            m->registerHook(base+0x19f760, extract_virtual(V, (void(D::*)(unsigned char)){&D::setOpacity}));
    }
};


template<class D>
class $GJComment : public GJComment, public $CacBase {
public:
    dupable ~$GJComment() override {}

    dupable bool init() override {
        if ((bool($GJComment::*)()){&$GJComment::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2dfec0))(this);
        else return GJComment::init();
    }

    dupable $GJComment() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJComment::*)()){&$GJComment::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2dfec0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $GJMapPack : public GJMapPack, public $CacBase {
public:
    dupable ~$GJMapPack() override {}

    dupable bool init() override {
        if ((bool($GJMapPack::*)()){&$GJMapPack::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x2de0e0))(this);
        else return GJMapPack::init();
    }

    dupable $GJMapPack() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($GJMapPack::*)()){&$GJMapPack::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x2de0e0, extract_virtual(V, (bool(D::*)()){&D::init}));
    }
};


template<class D>
class $InfoLayer : public InfoLayer, public $CacBase {
public:
    dupable ~$InfoLayer() override {}

    dupable void registerWithTouchDispatcher() override {
        if ((void($InfoLayer::*)()){&$InfoLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a070))(this);
        else return InfoLayer::registerWithTouchDispatcher();
    }

    dupable void keyBackClicked() override {
        if ((void($InfoLayer::*)()){&$InfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a000))(this);
        else return InfoLayer::keyBackClicked();
    }

    dupable void show() override {
        if ((void($InfoLayer::*)()){&$InfoLayer::show} != (void(D::*)()){&D::show})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45ab80))(this);
        else return InfoLayer::show();
    }

    dupable void loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) override {
        if ((void($InfoLayer::*)(cocos2d::CCArray*, char const*)){&$InfoLayer::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCArray*, char const*)>(m->getOriginal(base+0x45a1b0))(this, p0, p1);
        else return InfoLayer::loadCommentsFinished(p0, p1);
    }

    dupable void loadCommentsFailed(char const* p0) override {
        if ((void($InfoLayer::*)(char const*)){&$InfoLayer::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            return reinterpret_cast<void(*)(decltype(this), char const*)>(m->getOriginal(base+0x45a270))(this, p0);
        else return InfoLayer::loadCommentsFailed(p0);
    }

    dupable void setupPageInfo(std::string p0, char const* p1) override {
        if ((void($InfoLayer::*)(std::string, char const*)){&$InfoLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            return reinterpret_cast<void(*)(decltype(this), std::string, char const*)>(m->getOriginal(base+0x45a320))(this, p0, p1);
        else return InfoLayer::setupPageInfo(p0, p1);
    }

    dupable void commentUploadFinished(int p0) override {
        if ((void($InfoLayer::*)(int)){&$InfoLayer::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x45a890))(this, p0);
        else return InfoLayer::commentUploadFinished(p0);
    }

    dupable void commentUploadFailed(int p0, CommentError p1) override {
        if ((void($InfoLayer::*)(int, CommentError)){&$InfoLayer::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            return reinterpret_cast<void(*)(decltype(this), int, CommentError)>(m->getOriginal(base+0x45a960))(this, p0, p1);
        else return InfoLayer::commentUploadFailed(p0, p1);
    }

    dupable void updateUserScoreFinished() override {
        if ((void($InfoLayer::*)()){&$InfoLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x45a720))(this);
        else return InfoLayer::updateUserScoreFinished();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($InfoLayer::*)(FLAlertLayer*, bool)){&$InfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x459d50))(this, p0, p1);
        else return InfoLayer::FLAlert_Clicked(p0, p1);
    }

    dupable $InfoLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($InfoLayer::*)()){&$InfoLayer::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x45a070, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($InfoLayer::*)()){&$InfoLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x45a000, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($InfoLayer::*)()){&$InfoLayer::show} != (void(D::*)()){&D::show})
            m->registerHook(base+0x45ab80, extract_virtual(V, (void(D::*)()){&D::show}));

        if ((void($InfoLayer::*)(cocos2d::CCArray*, char const*)){&$InfoLayer::loadCommentsFinished} != (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished})
            m->registerHook(base+0x45a1b0, extract_virtual(V, (void(D::*)(cocos2d::CCArray*, char const*)){&D::loadCommentsFinished}));

        if ((void($InfoLayer::*)(char const*)){&$InfoLayer::loadCommentsFailed} != (void(D::*)(char const*)){&D::loadCommentsFailed})
            m->registerHook(base+0x45a270, extract_virtual(V, (void(D::*)(char const*)){&D::loadCommentsFailed}));

        if ((void($InfoLayer::*)(std::string, char const*)){&$InfoLayer::setupPageInfo} != (void(D::*)(std::string, char const*)){&D::setupPageInfo})
            m->registerHook(base+0x45a320, extract_virtual(V, (void(D::*)(std::string, char const*)){&D::setupPageInfo}));

        if ((void($InfoLayer::*)(int)){&$InfoLayer::commentUploadFinished} != (void(D::*)(int)){&D::commentUploadFinished})
            m->registerHook(base+0x45a890, extract_virtual(V, (void(D::*)(int)){&D::commentUploadFinished}));

        if ((void($InfoLayer::*)(int, CommentError)){&$InfoLayer::commentUploadFailed} != (void(D::*)(int, CommentError)){&D::commentUploadFailed})
            m->registerHook(base+0x45a960, extract_virtual(V, (void(D::*)(int, CommentError)){&D::commentUploadFailed}));

        if ((void($InfoLayer::*)()){&$InfoLayer::updateUserScoreFinished} != (void(D::*)()){&D::updateUserScoreFinished})
            m->registerHook(base+0x45a720, extract_virtual(V, (void(D::*)()){&D::updateUserScoreFinished}));

        if ((void($InfoLayer::*)(FLAlertLayer*, bool)){&$InfoLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x459d50, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));
    }
};


template<class D>
class $KeysLayer : public KeysLayer, public $CacBase {
public:
    dupable ~$KeysLayer() override {}

    dupable bool init() override {
        if ((bool($KeysLayer::*)()){&$KeysLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x44d340))(this);
        else return KeysLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($KeysLayer::*)()){&$KeysLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x453210))(this);
        else return KeysLayer::keyBackClicked();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($KeysLayer::*)(FLAlertLayer*, bool)){&$KeysLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x4532e0))(this, p0, p1);
        else return KeysLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($KeysLayer::*)(DialogLayer*)){&$KeysLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x453090))(this, p0);
        else return KeysLayer::dialogClosed(p0);
    }

    dupable $KeysLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($KeysLayer::*)()){&$KeysLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x44d340, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($KeysLayer::*)()){&$KeysLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x453210, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($KeysLayer::*)(FLAlertLayer*, bool)){&$KeysLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x4532e0, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($KeysLayer::*)(DialogLayer*)){&$KeysLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x453090, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $LevelCell : public LevelCell, public $CacBase {
public:
    dupable ~$LevelCell() override {}

    dupable bool init() override {
        if ((bool($LevelCell::*)()){&$LevelCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x117a40))(this);
        else return LevelCell::init();
    }

    dupable void draw() override {
        if ((void($LevelCell::*)()){&$LevelCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11a4d0))(this);
        else return LevelCell::draw();
    }

    dupable $LevelCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelCell::*)()){&$LevelCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x117a40, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($LevelCell::*)()){&$LevelCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11a4d0, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $LevelPage : public LevelPage, public $CacBase {
public:
    dupable ~$LevelPage() override {}

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23cd90))(this, p0, p1);
        else return LevelPage::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23ceb0))(this, p0, p1);
        else return LevelPage::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23ced0))(this, p0, p1);
        else return LevelPage::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x23cef0))(this, p0, p1);
        else return LevelPage::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($LevelPage::*)()){&$LevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x23cf30))(this);
        else return LevelPage::registerWithTouchDispatcher();
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($LevelPage::*)(DialogLayer*)){&$LevelPage::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x23cad0))(this, p0);
        else return LevelPage::dialogClosed(p0);
    }

    dupable $LevelPage() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x23cd90, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x23ceb0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x23ced0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($LevelPage::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$LevelPage::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x23cef0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($LevelPage::*)()){&$LevelPage::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x23cf30, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($LevelPage::*)(DialogLayer*)){&$LevelPage::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x23cad0, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));
    }
};


template<class D>
class $MenuLayer : public MenuLayer, public $CacBase {
public:
    dupable ~$MenuLayer() override {}

    dupable bool init() override {
        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x1d14b0))(this);
        else return MenuLayer::init();
    }

    dupable void keyBackClicked() override {
        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d3160))(this);
        else return MenuLayer::keyBackClicked();
    }

    dupable void keyDown(cocos2d::enumKeyCodes p0) override {
        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::enumKeyCodes)>(m->getOriginal(base+0x1d33d0))(this, p0);
        else return MenuLayer::keyDown(p0);
    }

    dupable void googlePlaySignedIn() override {
        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x1d2f30))(this);
        else return MenuLayer::googlePlaySignedIn();
    }

    dupable void FLAlert_Clicked(FLAlertLayer* p0, bool p1) override {
        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            return reinterpret_cast<void(*)(decltype(this), FLAlertLayer*, bool)>(m->getOriginal(base+0x1d3190))(this, p0, p1);
        else return MenuLayer::FLAlert_Clicked(p0, p1);
    }

    dupable void onMoreGames(cocos2d::CCObject* p0) override {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1d2ad0))(this, p0);
        else return MenuLayer::onMoreGames(p0);
    }

    dupable void onQuit(cocos2d::CCObject* p0) override {
        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCObject*)>(m->getOriginal(base+0x1d2b40))(this, p0);
        else return MenuLayer::onQuit(p0);
    }

    dupable void scene(bool p0) override {
        if ((void($MenuLayer::*)(bool)){&$MenuLayer::scene} != (void(D::*)(bool)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x1d12d0))(this, p0);
        else return MenuLayer::scene(p0);
    }

    dupable $MenuLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($MenuLayer::*)()){&$MenuLayer::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x1d14b0, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($MenuLayer::*)()){&$MenuLayer::keyBackClicked} != (void(D::*)()){&D::keyBackClicked})
            m->registerHook(base+0x1d3160, extract_virtual(V, (void(D::*)()){&D::keyBackClicked}));

        if ((void($MenuLayer::*)(cocos2d::enumKeyCodes)){&$MenuLayer::keyDown} != (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown})
            m->registerHook(base+0x1d33d0, extract_virtual(V, (void(D::*)(cocos2d::enumKeyCodes)){&D::keyDown}));

        if ((void($MenuLayer::*)()){&$MenuLayer::googlePlaySignedIn} != (void(D::*)()){&D::googlePlaySignedIn})
            m->registerHook(base+0x1d2f30, extract_virtual(V, (void(D::*)()){&D::googlePlaySignedIn}));

        if ((void($MenuLayer::*)(FLAlertLayer*, bool)){&$MenuLayer::FLAlert_Clicked} != (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked})
            m->registerHook(base+0x1d3190, extract_virtual(V, (void(D::*)(FLAlertLayer*, bool)){&D::FLAlert_Clicked}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onMoreGames} != (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames})
            m->registerHook(base+0x1d2ad0, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::onMoreGames}));

        if ((void($MenuLayer::*)(cocos2d::CCObject*)){&$MenuLayer::onQuit} != (void(D::*)(cocos2d::CCObject*)){&D::onQuit})
            m->registerHook(base+0x1d2b40, extract_virtual(V, (void(D::*)(cocos2d::CCObject*)){&D::onQuit}));

        if ((void($MenuLayer::*)(bool)){&$MenuLayer::scene} != (void(D::*)(bool)){&D::scene})
            m->registerHook(base+0x1d12d0, extract_virtual(V, (void(D::*)(bool)){&D::scene}));
    }
};


template<class D>
class $PlayLayer : public PlayLayer, public $CacBase {
public:
    dupable ~$PlayLayer() override {}

    dupable void update(float p0) override {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x77900))(this, p0);
        else return PlayLayer::update(p0);
    }

    dupable void onEnterTransitionDidFinish() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x806e0))(this);
        else return PlayLayer::onEnterTransitionDidFinish();
    }

    dupable void onExit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80710))(this);
        else return PlayLayer::onExit();
    }

    dupable void draw() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7d160))(this);
        else return PlayLayer::draw();
    }

    dupable void visit() override {
        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x75ef0))(this);
        else return PlayLayer::visit();
    }

    dupable void updateTweenAction(float p0, char const* p1) override {
        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            return reinterpret_cast<void(*)(decltype(this), float, char const*)>(m->getOriginal(base+0x7ffb0))(this, p0, p1);
        else return PlayLayer::updateTweenAction(p0, p1);
    }

    dupable void updateColor(cocos2d::_ccColor3B p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue p5, int p6, bool p7, int p8, EffectGameObject* p9) override {
        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)>(m->getOriginal(base+0x7c7f0))(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        else return PlayLayer::updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    dupable void flipGravity(PlayerObject* p0, bool p1, bool p2) override {
        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, bool, bool)>(m->getOriginal(base+0x7cd10))(this, p0, p1, p2);
        else return PlayLayer::flipGravity(p0, p1, p2);
    }

    dupable void calculateColorValues(EffectGameObject* p0, EffectGameObject* p1, int p2, float p3, ColorActionSprite* p4, GJEffectManager* p5) override {
        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            return reinterpret_cast<void(*)(decltype(this), EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)>(m->getOriginal(base+0x7aa10))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::calculateColorValues(p0, p1, p2, p3, p4, p5);
    }

    dupable void timeForXPos(float p0) override {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x7d120))(this, p0);
        else return PlayLayer::timeForXPos(p0);
    }

    dupable void xPosForTime(float p0) override {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x7d140))(this, p0);
        else return PlayLayer::xPosForTime(p0);
    }

    dupable void currencyWillExit(CurrencyRewardLayer* p0) override {
        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            return reinterpret_cast<void(*)(decltype(this), CurrencyRewardLayer*)>(m->getOriginal(base+0x7e070))(this, p0);
        else return PlayLayer::currencyWillExit(p0);
    }

    dupable void circleWaveWillBeRemoved(CCCircleWave* p0) override {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(base+0x7e110))(this, p0);
        else return PlayLayer::circleWaveWillBeRemoved(p0);
    }

    dupable void dialogClosed(DialogLayer* p0) override {
        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            return reinterpret_cast<void(*)(decltype(this), DialogLayer*)>(m->getOriginal(base+0x7e0b0))(this, p0);
        else return PlayLayer::dialogClosed(p0);
    }

    dupable void addCircle(CCCircleWave* p0) {
        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave*)){&D::addCircle})
            return reinterpret_cast<void(*)(decltype(this), CCCircleWave*)>(m->getOriginal(base+0x7e0f0))(this, p0);
        else return PlayLayer::addCircle(p0);
    }

    dupable void addObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject} != (void(D::*)(GameObject*)){&D::addObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x70e50))(this, p0);
        else return PlayLayer::addObject(p0);
    }

    dupable void addToGroupOld(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject*)){&D::addToGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x77680))(this, p0);
        else return PlayLayer::addToGroupOld(p0);
    }

    dupable void addToSpeedObjects(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x7cfc0))(this, p0);
        else return PlayLayer::addToSpeedObjects(p0);
    }

    dupable void animateInDualGround(GameObject* p0, float p1, bool p2) {
        if ((void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, float, bool)>(m->getOriginal(base+0x7d710))(this, p0, p1, p2);
        else return PlayLayer::animateInDualGround(p0, p1, p2);
    }

    dupable void animateInGround(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround} != (void(D::*)(bool)){&D::animateInGround})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x7d9d0))(this, p0);
        else return PlayLayer::animateInGround(p0);
    }

    dupable void animateOutGround(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround} != (void(D::*)(bool)){&D::animateOutGround})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x6f350))(this, p0);
        else return PlayLayer::animateOutGround(p0);
    }

    dupable void animateOutGroundFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7de80))(this);
        else return PlayLayer::animateOutGroundFinished();
    }

    dupable void applyEnterEffect(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject*)){&D::applyEnterEffect})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x7c310))(this, p0);
        else return PlayLayer::applyEnterEffect(p0);
    }

    dupable void cameraMoveX(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX} != (void(D::*)(float, float, float)){&D::cameraMoveX})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(base+0x7cbe0))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveX(p0, p1, p2);
    }

    dupable void cameraMoveY(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY} != (void(D::*)(float, float, float)){&D::cameraMoveY})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(base+0x7cc60))(this, p0, p1, p2);
        else return PlayLayer::cameraMoveY(p0, p1, p2);
    }

    dupable void checkCollisions(PlayerObject* p0, float p1) {
        if ((void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, float)>(m->getOriginal(base+0x78c90))(this, p0, p1);
        else return PlayLayer::checkCollisions(p0, p1);
    }

    dupable void claimParticle(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle} != (void(D::*)(std::string)){&D::claimParticle})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x76ba0))(this, p0);
        else return PlayLayer::claimParticle(p0);
    }

    dupable void clearPickedUpItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7cfa0))(this);
        else return PlayLayer::clearPickedUpItems();
    }

    dupable void colorObject(int p0, cocos2d::_ccColor3B p1) {
        if ((void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject} != (void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject})
            return reinterpret_cast<void(*)(decltype(this), int, cocos2d::_ccColor3B)>(m->getOriginal(base+0x77810))(this, p0, p1);
        else return PlayLayer::colorObject(p0, p1);
    }

    dupable void commitJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x737e0))(this);
        else return PlayLayer::commitJumps();
    }

    dupable static PlayLayer* create(GJGameLevel* p0) {
        if ((PlayLayer*(*)(GJGameLevel*)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel*)){&D::create})
            return reinterpret_cast<PlayLayer*(*)(GJGameLevel*)>(m->getOriginal(base+0x6b590))(p0);
        else return PlayLayer::create(p0);
    }

    dupable void createCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7e470))(this);
        else return PlayLayer::createCheckpoint();
    }

    dupable void createObjectsFromSetup(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x6d130))(this, p0);
        else return PlayLayer::createObjectsFromSetup(p0);
    }

    dupable void createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle})
            return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(base+0x76800))(this, p0, p1, p2, p3);
        else return PlayLayer::createParticle(p0, p1, p2, p3);
    }

    dupable void delayedResetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7e050))(this);
        else return PlayLayer::delayedResetLevel();
    }

    dupable void destroyPlayer(PlayerObject* p0, GameObject* p1) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(base+0x7ab80))(this, p0, p1);
        else return PlayLayer::destroyPlayer(p0, p1);
    }

    dupable void enterDualMode(GameObject* p0, bool p1) {
        if ((void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject*, bool)){&D::enterDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool)>(m->getOriginal(base+0x7d6a0))(this, p0, p1);
        else return PlayLayer::enterDualMode(p0, p1);
    }

    dupable void exitAirMode() {
        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7dd40))(this);
        else return PlayLayer::exitAirMode();
    }

    dupable void exitBirdMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject*)){&D::exitBirdMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7dd80))(this, p0);
        else return PlayLayer::exitBirdMode(p0);
    }

    dupable void exitDartMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject*)){&D::exitDartMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7ddd0))(this, p0);
        else return PlayLayer::exitDartMode(p0);
    }

    dupable void exitFlyMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject*)){&D::exitFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7dcf0))(this, p0);
        else return PlayLayer::exitFlyMode(p0);
    }

    dupable void exitRobotMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject*)){&D::exitRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7de20))(this, p0);
        else return PlayLayer::exitRobotMode(p0);
    }

    dupable void exitRollMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject*)){&D::exitRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7de60))(this, p0);
        else return PlayLayer::exitRollMode(p0);
    }

    dupable void exitSpiderMode(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject*)){&D::exitSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7de40))(this, p0);
        else return PlayLayer::exitSpiderMode(p0);
    }

    dupable void flipFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7e150))(this);
        else return PlayLayer::flipFinished();
    }

    dupable void flipObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x76130))(this);
        else return PlayLayer::flipObjects();
    }

    dupable void fullReset() {
        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7f8e0))(this);
        else return PlayLayer::fullReset();
    }

    dupable void getLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7f840))(this);
        else return PlayLayer::getLastCheckpoint();
    }

    dupable void getMaxPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7b4e0))(this);
        else return PlayLayer::getMaxPortalY();
    }

    dupable void getMinPortalY() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7b550))(this);
        else return PlayLayer::getMinPortalY();
    }

    dupable void getObjectsState() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7e9d0))(this);
        else return PlayLayer::getObjectsState();
    }

    dupable void getOtherPlayer(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject*)){&D::getOtherPlayer})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7dcc0))(this, p0);
        else return PlayLayer::getOtherPlayer(p0);
    }

    dupable void getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) {
        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey})
            return reinterpret_cast<void(*)(decltype(this), int, char const*, int, cocos2d::tCCPositionType)>(m->getOriginal(base+0x764d0))(this, p0, p1, p2, p3);
        else return PlayLayer::getParticleKey(p0, p1, p2, p3);
    }

    dupable void getParticleKey2(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::string)){&D::getParticleKey2})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x767b0))(this, p0);
        else return PlayLayer::getParticleKey2(p0);
    }

    dupable void getRelativeMod(cocos2d::CCPoint p0, float p1, float p2, float p3) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, float, float, float)>(m->getOriginal(base+0x7c2a0))(this, p0, p1, p2, p3);
        else return PlayLayer::getRelativeMod(p0, p1, p2, p3);
    }

    dupable void getTempMilliTime() {
        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x778e0))(this);
        else return PlayLayer::getTempMilliTime();
    }

    dupable void gravityEffectFinished() {
        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7cec0))(this);
        else return PlayLayer::gravityEffectFinished();
    }

    dupable void hasItem(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::hasItem} != (void(D::*)(int)){&D::hasItem})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x7cee0))(this, p0);
        else return PlayLayer::hasItem(p0);
    }

    dupable void hasUniqueCoin(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject*)){&D::hasUniqueCoin})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x77510))(this, p0);
        else return PlayLayer::hasUniqueCoin(p0);
    }

    dupable void incrementJumps() {
        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7ff40))(this);
        else return PlayLayer::incrementJumps();
    }

    dupable bool init(GJGameLevel* p0) {
        if ((bool($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            return reinterpret_cast<bool(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x6b5f0))(this, p0);
        else return PlayLayer::init(p0);
    }

    dupable void isFlipping() {
        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x76100))(this);
        else return PlayLayer::isFlipping();
    }

    dupable void levelComplete() {
        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x72b80))(this);
        else return PlayLayer::levelComplete();
    }

    dupable void lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)>(m->getOriginal(base+0x75cc0))(this, p0, p1, p2, p3, p4, p5, p6, p7);
        else return PlayLayer::lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    dupable void lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint, cocos2d::_ccColor3B)>(m->getOriginal(base+0x75bf0))(this, p0, p1);
        else return PlayLayer::lightningFlash(p0, p1);
    }

    dupable void loadDefaultColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6ef30))(this);
        else return PlayLayer::loadDefaultColors();
    }

    dupable void loadFromCheckpoint(CheckpointObject* p0) {
        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(base+0x7f000))(this, p0);
        else return PlayLayer::loadFromCheckpoint(p0);
    }

    dupable void loadLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7efc0))(this);
        else return PlayLayer::loadLastCheckpoint();
    }

    dupable void loadSavedObjectsState(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::string)){&D::loadSavedObjectsState})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x7f3d0))(this, p0);
        else return PlayLayer::loadSavedObjectsState(p0);
    }

    dupable void markCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7ef60))(this);
        else return PlayLayer::markCheckpoint();
    }

    dupable void moveCameraToPos(cocos2d::CCPoint p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x7c980))(this, p0);
        else return PlayLayer::moveCameraToPos(p0);
    }

    dupable void onQuit() {
        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x72710))(this);
        else return PlayLayer::onQuit();
    }

    dupable void optimizeColorGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6dad0))(this);
        else return PlayLayer::optimizeColorGroups();
    }

    dupable void optimizeOpacityGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6dc20))(this);
        else return PlayLayer::optimizeOpacityGroups();
    }

    dupable void optimizeSaveRequiredGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6dd70))(this);
        else return PlayLayer::optimizeSaveRequiredGroups();
    }

    dupable void pauseGame(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame} != (void(D::*)(bool)){&D::pauseGame})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x802d0))(this, p0);
        else return PlayLayer::pauseGame(p0);
    }

    dupable void pickupItem(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject*)){&D::pickupItem})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x7c1d0))(this, p0);
        else return PlayLayer::pickupItem(p0);
    }

    dupable void playAnimationCommand(int p0, int p1) {
        if ((void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand} != (void(D::*)(int, int)){&D::playAnimationCommand})
            return reinterpret_cast<void(*)(decltype(this), int, int)>(m->getOriginal(base+0x75930))(this, p0, p1);
        else return PlayLayer::playAnimationCommand(p0, p1);
    }

    dupable void playEndAnimationToPos(cocos2d::CCPoint p0) {
        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCPoint)>(m->getOriginal(base+0x759a0))(this, p0);
        else return PlayLayer::playEndAnimationToPos(p0);
    }

    dupable void playExitDualEffect(PlayerObject* p0) {
        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject*)){&D::playExitDualEffect})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*)>(m->getOriginal(base+0x7d1d0))(this, p0);
        else return PlayLayer::playExitDualEffect(p0);
    }

    dupable void playFlashEffect(float p0, int p1, float p2) {
        if ((void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect} != (void(D::*)(float, int, float)){&D::playFlashEffect})
            return reinterpret_cast<void(*)(decltype(this), float, int, float)>(m->getOriginal(base+0x75e50))(this, p0, p1, p2);
        else return PlayLayer::playFlashEffect(p0, p1, p2);
    }

    dupable void playGravityEffect(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect} != (void(D::*)(bool)){&D::playGravityEffect})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x7b5a0))(this, p0);
        else return PlayLayer::playGravityEffect(p0);
    }

    dupable void playSpeedParticle(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle} != (void(D::*)(float)){&D::playSpeedParticle})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x77030))(this, p0);
        else return PlayLayer::playSpeedParticle(p0);
    }

    dupable void playerWillSwitchMode(PlayerObject* p0, GameObject* p1) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*)>(m->getOriginal(base+0x7b820))(this, p0, p1);
        else return PlayLayer::playerWillSwitchMode(p0, p1);
    }

    dupable void prepareSpawnObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fc00))(this);
        else return PlayLayer::prepareSpawnObjects();
    }

    dupable void processItems() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x735c0))(this);
        else return PlayLayer::processItems();
    }

    dupable void processLoadedMoveActions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7a7c0))(this);
        else return PlayLayer::processLoadedMoveActions();
    }

    dupable void recordAction(bool p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction} != (void(D::*)(bool, PlayerObject*)){&D::recordAction})
            return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(base+0x7e190))(this, p0, p1);
        else return PlayLayer::recordAction(p0, p1);
    }

    dupable void registerActiveObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject*)){&D::registerActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x77620))(this, p0);
        else return PlayLayer::registerActiveObject(p0);
    }

    dupable void registerStateObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject*)){&D::registerStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x777b0))(this, p0);
        else return PlayLayer::registerStateObject(p0);
    }

    dupable void removeAllObjects() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x727b0))(this);
        else return PlayLayer::removeAllObjects();
    }

    dupable void removeFromGroupOld(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject*)){&D::removeFromGroupOld})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x77750))(this, p0);
        else return PlayLayer::removeFromGroupOld(p0);
    }

    dupable void removeLastCheckpoint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7f870))(this);
        else return PlayLayer::removeLastCheckpoint();
    }

    dupable void removePlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7d630))(this);
        else return PlayLayer::removePlayer2();
    }

    dupable void resetLevel() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x71c50))(this);
        else return PlayLayer::resetLevel();
    }

    dupable void resume() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80480))(this);
        else return PlayLayer::resume();
    }

    dupable void resumeAndRestart() {
        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x80400))(this);
        else return PlayLayer::resumeAndRestart();
    }

    dupable void saveRecordAction(bool p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction} != (void(D::*)(bool, PlayerObject*)){&D::saveRecordAction})
            return reinterpret_cast<void(*)(decltype(this), bool, PlayerObject*)>(m->getOriginal(base+0x78750))(this, p0, p1);
        else return PlayLayer::saveRecordAction(p0, p1);
    }

    dupable void scene(GJGameLevel* p0) {
        if ((void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            return reinterpret_cast<void(*)(decltype(this), GJGameLevel*)>(m->getOriginal(base+0x6b500))(this, p0);
        else return PlayLayer::scene(p0);
    }

    dupable void setupLevelStart(LevelSettingsObject* p0) {
        if ((void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            return reinterpret_cast<void(*)(decltype(this), LevelSettingsObject*)>(m->getOriginal(base+0x6f560))(this, p0);
        else return PlayLayer::setupLevelStart(p0);
    }

    dupable void setupReplay(std::string p0) {
        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay} != (void(D::*)(std::string)){&D::setupReplay})
            return reinterpret_cast<void(*)(decltype(this), std::string)>(m->getOriginal(base+0x7e1e0))(this, p0);
        else return PlayLayer::setupReplay(p0);
    }

    dupable void shakeCamera(float p0, float p1, float p2) {
        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera} != (void(D::*)(float, float, float)){&D::shakeCamera})
            return reinterpret_cast<void(*)(decltype(this), float, float, float)>(m->getOriginal(base+0x744a0))(this, p0, p1, p2);
        else return PlayLayer::shakeCamera(p0, p1, p2);
    }

    dupable void shouldBlend(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x771b0))(this, p0);
        else return PlayLayer::shouldBlend(p0);
    }

    dupable void showCompleteEffect() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x738e0))(this);
        else return PlayLayer::showCompleteEffect();
    }

    dupable void showCompleteText() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x73be0))(this);
        else return PlayLayer::showCompleteText();
    }

    dupable void showEndLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x74450))(this);
        else return PlayLayer::showEndLayer();
    }

    dupable void showHint() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7deb0))(this);
        else return PlayLayer::showHint();
    }

    dupable void showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) {
        if ((void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest} != (void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest})
            return reinterpret_cast<void(*)(decltype(this), bool, int, int, bool, bool, bool)>(m->getOriginal(base+0x74580))(this, p0, p1, p2, p3, p4, p5);
        else return PlayLayer::showNewBest(p0, p1, p2, p3, p4, p5);
    }

    dupable void showRetryLayer() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x75ba0))(this);
        else return PlayLayer::showRetryLayer();
    }

    dupable void showTwoPlayerGuide() {
        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6df00))(this);
        else return PlayLayer::showTwoPlayerGuide();
    }

    dupable void sortGroups() {
        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6d9e0))(this);
        else return PlayLayer::sortGroups();
    }

    dupable void spawnCircle() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x73820))(this);
        else return PlayLayer::spawnCircle();
    }

    dupable void spawnFirework() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x74200))(this);
        else return PlayLayer::spawnFirework();
    }

    dupable void spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) {
        if ((void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle} != (void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle})
            return reinterpret_cast<void(*)(decltype(this), char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)>(m->getOriginal(base+0x76330))(this, p0, p1, p2, p3);
        else return PlayLayer::spawnParticle(p0, p1, p2, p3);
    }

    dupable void spawnPlayer2() {
        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7d170))(this);
        else return PlayLayer::spawnPlayer2();
    }

    dupable void startGame() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x726b0))(this);
        else return PlayLayer::startGame();
    }

    dupable void startMusic() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x72910))(this);
        else return PlayLayer::startMusic();
    }

    dupable void startRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fec0))(this);
        else return PlayLayer::startRecording();
    }

    dupable void startRecordingDelayed() {
        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fed0))(this);
        else return PlayLayer::startRecordingDelayed();
    }

    dupable void stopCameraShake() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x75900))(this);
        else return PlayLayer::stopCameraShake();
    }

    dupable void stopRecording() {
        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6d090))(this);
        else return PlayLayer::stopRecording();
    }

    dupable void storeCheckpoint(CheckpointObject* p0) {
        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject*)){&D::storeCheckpoint})
            return reinterpret_cast<void(*)(decltype(this), CheckpointObject*)>(m->getOriginal(base+0x7ef10))(this, p0);
        else return PlayLayer::storeCheckpoint(p0);
    }

    dupable void switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool, int)>(m->getOriginal(base+0x7baf0))(this, p0, p1, p2, p3);
        else return PlayLayer::switchToFlyMode(p0, p1, p2, p3);
    }

    dupable void switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(base+0x7bc80))(this, p0, p1, p2);
        else return PlayLayer::switchToRobotMode(p0, p1, p2);
    }

    dupable void switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(base+0x7bbe0))(this, p0, p1, p2);
        else return PlayLayer::switchToRollMode(p0, p1, p2);
    }

    dupable void switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, GameObject*, bool)>(m->getOriginal(base+0x7bd20))(this, p0, p1, p2);
        else return PlayLayer::switchToSpiderMode(p0, p1, p2);
    }

    dupable void timeForXPos2(float p0, bool p1) {
        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2} != (void(D::*)(float, bool)){&D::timeForXPos2})
            return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(base+0x293eb0))(this, p0, p1);
        else return PlayLayer::timeForXPos2(p0, p1);
    }

    dupable void toggleBGEffectVisibility(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(bool)){&D::toggleBGEffectVisibility})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x7fe80))(this, p0);
        else return PlayLayer::toggleBGEffectVisibility(p0);
    }

    dupable void toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) {
        if ((void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            return reinterpret_cast<void(*)(decltype(this), GameObject*, bool, PlayerObject*, bool)>(m->getOriginal(base+0x7bf90))(this, p0, p1, p2, p3);
        else return PlayLayer::toggleDualMode(p0, p1, p2, p3);
    }

    dupable void toggleFlipped(bool p0, bool p1) {
        if ((void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped} != (void(D::*)(bool, bool)){&D::toggleFlipped})
            return reinterpret_cast<void(*)(decltype(this), bool, bool)>(m->getOriginal(base+0x7bdc0))(this, p0, p1);
        else return PlayLayer::toggleFlipped(p0, p1);
    }

    dupable void toggleGhostEffect(int p0) {
        if ((void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(int)){&D::toggleGhostEffect})
            return reinterpret_cast<void(*)(decltype(this), int)>(m->getOriginal(base+0x7fe40))(this, p0);
        else return PlayLayer::toggleGhostEffect(p0);
    }

    dupable void toggleGlitter(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter} != (void(D::*)(bool)){&D::toggleGlitter})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x70e00))(this, p0);
        else return PlayLayer::toggleGlitter(p0);
    }

    dupable void togglePracticeMode(bool p0) {
        if ((void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode} != (void(D::*)(bool)){&D::togglePracticeMode})
            return reinterpret_cast<void(*)(decltype(this), bool)>(m->getOriginal(base+0x7f9e0))(this, p0);
        else return PlayLayer::togglePracticeMode(p0);
    }

    dupable void toggleProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6eeb0))(this);
        else return PlayLayer::toggleProgressbar();
    }

    dupable void tryStartRecord() {
        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fe00))(this);
        else return PlayLayer::tryStartRecord();
    }

    dupable void unclaimParticle(char const* p0, cocos2d::CCParticleSystemQuad* p1) {
        if ((void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle})
            return reinterpret_cast<void(*)(decltype(this), char const*, cocos2d::CCParticleSystemQuad*)>(m->getOriginal(base+0x76e00))(this, p0, p1);
        else return PlayLayer::unclaimParticle(p0, p1);
    }

    dupable void unregisterActiveObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject*)){&D::unregisterActiveObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x77660))(this, p0);
        else return PlayLayer::unregisterActiveObject(p0);
    }

    dupable void unregisterStateObject(GameObject* p0) {
        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject*)){&D::unregisterStateObject})
            return reinterpret_cast<void(*)(decltype(this), GameObject*)>(m->getOriginal(base+0x777f0))(this, p0);
        else return PlayLayer::unregisterStateObject(p0);
    }

    dupable void updateAttempts() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fcd0))(this);
        else return PlayLayer::updateAttempts();
    }

    dupable void updateCamera(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateCamera} != (void(D::*)(float)){&D::updateCamera})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x6e2b0))(this, p0);
        else return PlayLayer::updateCamera(p0);
    }

    dupable void updateDualGround(PlayerObject* p0, int p1, bool p2) {
        if ((void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            return reinterpret_cast<void(*)(decltype(this), PlayerObject*, int, bool)>(m->getOriginal(base+0x7caa0))(this, p0, p1, p2);
        else return PlayLayer::updateDualGround(p0, p1, p2);
    }

    dupable void updateEffectPositions() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7a6d0))(this);
        else return PlayLayer::updateEffectPositions();
    }

    dupable void updateLevelColors() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6f1e0))(this);
        else return PlayLayer::updateLevelColors();
    }

    dupable void updateMoveObjectsLastPosition() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7a720))(this);
        else return PlayLayer::updateMoveObjectsLastPosition();
    }

    dupable void updateProgressbar() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6ed70))(this);
        else return PlayLayer::updateProgressbar();
    }

    dupable void updateReplay(float p0) {
        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateReplay} != (void(D::*)(float)){&D::updateReplay})
            return reinterpret_cast<void(*)(decltype(this), float)>(m->getOriginal(base+0x78b60))(this, p0);
        else return PlayLayer::updateReplay(p0);
    }

    dupable void updateTimeMod(float p0, bool p1) {
        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod} != (void(D::*)(float, bool)){&D::updateTimeMod})
            return reinterpret_cast<void(*)(decltype(this), float, bool)>(m->getOriginal(base+0x786f0))(this, p0, p1);
        else return PlayLayer::updateTimeMod(p0, p1);
    }

    dupable void updateVisibility() {
        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x6fb90))(this);
        else return PlayLayer::updateVisibility();
    }

    dupable void vfDChk() {
        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x7fcb0))(this);
        else return PlayLayer::vfDChk();
    }

    dupable void visitWithColorFlash() {
        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x761f0))(this);
        else return PlayLayer::visitWithColorFlash();
    }

    dupable void willSwitchToMode(int p0, PlayerObject* p1) {
        if ((void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode} != (void(D::*)(int, PlayerObject*)){&D::willSwitchToMode})
            return reinterpret_cast<void(*)(decltype(this), int, PlayerObject*)>(m->getOriginal(base+0x7b9e0))(this, p0, p1);
        else return PlayLayer::willSwitchToMode(p0, p1);
    }

    dupable $PlayLayer() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($PlayLayer::*)(float)){&$PlayLayer::update} != (void(D::*)(float)){&D::update})
            m->registerHook(base+0x77900, extract_virtual(V, (void(D::*)(float)){&D::update}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onEnterTransitionDidFinish} != (void(D::*)()){&D::onEnterTransitionDidFinish})
            m->registerHook(base+0x806e0, extract_virtual(V, (void(D::*)()){&D::onEnterTransitionDidFinish}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x80710, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x7d160, extract_virtual(V, (void(D::*)()){&D::draw}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visit} != (void(D::*)()){&D::visit})
            m->registerHook(base+0x75ef0, extract_virtual(V, (void(D::*)()){&D::visit}));

        if ((void($PlayLayer::*)(float, char const*)){&$PlayLayer::updateTweenAction} != (void(D::*)(float, char const*)){&D::updateTweenAction})
            m->registerHook(base+0x7ffb0, extract_virtual(V, (void(D::*)(float, char const*)){&D::updateTweenAction}));

        if ((void($PlayLayer::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&$PlayLayer::updateColor} != (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor})
            m->registerHook(base+0x7c7f0, extract_virtual(V, (void(D::*)(cocos2d::_ccColor3B, float, int, bool, float, cocos2d::_ccHSVValue, int, bool, int, EffectGameObject*)){&D::updateColor}));

        if ((void($PlayLayer::*)(PlayerObject*, bool, bool)){&$PlayLayer::flipGravity} != (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity})
            m->registerHook(base+0x7cd10, extract_virtual(V, (void(D::*)(PlayerObject*, bool, bool)){&D::flipGravity}));

        if ((void($PlayLayer::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&$PlayLayer::calculateColorValues} != (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues})
            m->registerHook(base+0x7aa10, extract_virtual(V, (void(D::*)(EffectGameObject*, EffectGameObject*, int, float, ColorActionSprite*, GJEffectManager*)){&D::calculateColorValues}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::timeForXPos} != (void(D::*)(float)){&D::timeForXPos})
            m->registerHook(base+0x7d120, extract_virtual(V, (void(D::*)(float)){&D::timeForXPos}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::xPosForTime} != (void(D::*)(float)){&D::xPosForTime})
            m->registerHook(base+0x7d140, extract_virtual(V, (void(D::*)(float)){&D::xPosForTime}));

        if ((void($PlayLayer::*)(CurrencyRewardLayer*)){&$PlayLayer::currencyWillExit} != (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit})
            m->registerHook(base+0x7e070, extract_virtual(V, (void(D::*)(CurrencyRewardLayer*)){&D::currencyWillExit}));

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::circleWaveWillBeRemoved} != (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved})
            m->registerHook(base+0x7e110, extract_virtual(V, (void(D::*)(CCCircleWave*)){&D::circleWaveWillBeRemoved}));

        if ((void($PlayLayer::*)(DialogLayer*)){&$PlayLayer::dialogClosed} != (void(D::*)(DialogLayer*)){&D::dialogClosed})
            m->registerHook(base+0x7e0b0, extract_virtual(V, (void(D::*)(DialogLayer*)){&D::dialogClosed}));

        if ((void($PlayLayer::*)(CCCircleWave*)){&$PlayLayer::addCircle} != (void(D::*)(CCCircleWave*)){&D::addCircle})
            m->registerHook(base+0x7e0f0, extract((void(D::*)(CCCircleWave*)){&D::addCircle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addObject} != (void(D::*)(GameObject*)){&D::addObject})
            m->registerHook(base+0x70e50, extract((void(D::*)(GameObject*)){&D::addObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToGroupOld} != (void(D::*)(GameObject*)){&D::addToGroupOld})
            m->registerHook(base+0x77680, extract((void(D::*)(GameObject*)){&D::addToGroupOld}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::addToSpeedObjects} != (void(D::*)(GameObject*)){&D::addToSpeedObjects})
            m->registerHook(base+0x7cfc0, extract((void(D::*)(GameObject*)){&D::addToSpeedObjects}));

        if ((void($PlayLayer::*)(GameObject*, float, bool)){&$PlayLayer::animateInDualGround} != (void(D::*)(GameObject*, float, bool)){&D::animateInDualGround})
            m->registerHook(base+0x7d710, extract((void(D::*)(GameObject*, float, bool)){&D::animateInDualGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateInGround} != (void(D::*)(bool)){&D::animateInGround})
            m->registerHook(base+0x7d9d0, extract((void(D::*)(bool)){&D::animateInGround}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::animateOutGround} != (void(D::*)(bool)){&D::animateOutGround})
            m->registerHook(base+0x6f350, extract((void(D::*)(bool)){&D::animateOutGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::animateOutGroundFinished} != (void(D::*)()){&D::animateOutGroundFinished})
            m->registerHook(base+0x7de80, extract((void(D::*)()){&D::animateOutGroundFinished}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::applyEnterEffect} != (void(D::*)(GameObject*)){&D::applyEnterEffect})
            m->registerHook(base+0x7c310, extract((void(D::*)(GameObject*)){&D::applyEnterEffect}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveX} != (void(D::*)(float, float, float)){&D::cameraMoveX})
            m->registerHook(base+0x7cbe0, extract((void(D::*)(float, float, float)){&D::cameraMoveX}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::cameraMoveY} != (void(D::*)(float, float, float)){&D::cameraMoveY})
            m->registerHook(base+0x7cc60, extract((void(D::*)(float, float, float)){&D::cameraMoveY}));

        if ((void($PlayLayer::*)(PlayerObject*, float)){&$PlayLayer::checkCollisions} != (void(D::*)(PlayerObject*, float)){&D::checkCollisions})
            m->registerHook(base+0x78c90, extract((void(D::*)(PlayerObject*, float)){&D::checkCollisions}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::claimParticle} != (void(D::*)(std::string)){&D::claimParticle})
            m->registerHook(base+0x76ba0, extract((void(D::*)(std::string)){&D::claimParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::clearPickedUpItems} != (void(D::*)()){&D::clearPickedUpItems})
            m->registerHook(base+0x7cfa0, extract((void(D::*)()){&D::clearPickedUpItems}));

        if ((void($PlayLayer::*)(int, cocos2d::_ccColor3B)){&$PlayLayer::colorObject} != (void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject})
            m->registerHook(base+0x77810, extract((void(D::*)(int, cocos2d::_ccColor3B)){&D::colorObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::commitJumps} != (void(D::*)()){&D::commitJumps})
            m->registerHook(base+0x737e0, extract((void(D::*)()){&D::commitJumps}));

        if ((PlayLayer*(*)(GJGameLevel*)){&$PlayLayer::create} != (PlayLayer*(*)(GJGameLevel*)){&D::create})
            m->registerHook(base+0x6b590, (PlayLayer*(*)(GJGameLevel*)){&D::create});

        if ((void($PlayLayer::*)()){&$PlayLayer::createCheckpoint} != (void(D::*)()){&D::createCheckpoint})
            m->registerHook(base+0x7e470, extract((void(D::*)()){&D::createCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::createObjectsFromSetup} != (void(D::*)(std::string)){&D::createObjectsFromSetup})
            m->registerHook(base+0x6d130, extract((void(D::*)(std::string)){&D::createObjectsFromSetup}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::createParticle} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle})
            m->registerHook(base+0x76800, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::createParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::delayedResetLevel} != (void(D::*)()){&D::delayedResetLevel})
            m->registerHook(base+0x7e050, extract((void(D::*)()){&D::delayedResetLevel}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::destroyPlayer} != (void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer})
            m->registerHook(base+0x7ab80, extract((void(D::*)(PlayerObject*, GameObject*)){&D::destroyPlayer}));

        if ((void($PlayLayer::*)(GameObject*, bool)){&$PlayLayer::enterDualMode} != (void(D::*)(GameObject*, bool)){&D::enterDualMode})
            m->registerHook(base+0x7d6a0, extract((void(D::*)(GameObject*, bool)){&D::enterDualMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::exitAirMode} != (void(D::*)()){&D::exitAirMode})
            m->registerHook(base+0x7dd40, extract((void(D::*)()){&D::exitAirMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitBirdMode} != (void(D::*)(PlayerObject*)){&D::exitBirdMode})
            m->registerHook(base+0x7dd80, extract((void(D::*)(PlayerObject*)){&D::exitBirdMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitDartMode} != (void(D::*)(PlayerObject*)){&D::exitDartMode})
            m->registerHook(base+0x7ddd0, extract((void(D::*)(PlayerObject*)){&D::exitDartMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitFlyMode} != (void(D::*)(PlayerObject*)){&D::exitFlyMode})
            m->registerHook(base+0x7dcf0, extract((void(D::*)(PlayerObject*)){&D::exitFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRobotMode} != (void(D::*)(PlayerObject*)){&D::exitRobotMode})
            m->registerHook(base+0x7de20, extract((void(D::*)(PlayerObject*)){&D::exitRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitRollMode} != (void(D::*)(PlayerObject*)){&D::exitRollMode})
            m->registerHook(base+0x7de60, extract((void(D::*)(PlayerObject*)){&D::exitRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::exitSpiderMode} != (void(D::*)(PlayerObject*)){&D::exitSpiderMode})
            m->registerHook(base+0x7de40, extract((void(D::*)(PlayerObject*)){&D::exitSpiderMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipFinished} != (void(D::*)()){&D::flipFinished})
            m->registerHook(base+0x7e150, extract((void(D::*)()){&D::flipFinished}));

        if ((void($PlayLayer::*)()){&$PlayLayer::flipObjects} != (void(D::*)()){&D::flipObjects})
            m->registerHook(base+0x76130, extract((void(D::*)()){&D::flipObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::fullReset} != (void(D::*)()){&D::fullReset})
            m->registerHook(base+0x7f8e0, extract((void(D::*)()){&D::fullReset}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getLastCheckpoint} != (void(D::*)()){&D::getLastCheckpoint})
            m->registerHook(base+0x7f840, extract((void(D::*)()){&D::getLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMaxPortalY} != (void(D::*)()){&D::getMaxPortalY})
            m->registerHook(base+0x7b4e0, extract((void(D::*)()){&D::getMaxPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getMinPortalY} != (void(D::*)()){&D::getMinPortalY})
            m->registerHook(base+0x7b550, extract((void(D::*)()){&D::getMinPortalY}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getObjectsState} != (void(D::*)()){&D::getObjectsState})
            m->registerHook(base+0x7e9d0, extract((void(D::*)()){&D::getObjectsState}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::getOtherPlayer} != (void(D::*)(PlayerObject*)){&D::getOtherPlayer})
            m->registerHook(base+0x7dcc0, extract((void(D::*)(PlayerObject*)){&D::getOtherPlayer}));

        if ((void($PlayLayer::*)(int, char const*, int, cocos2d::tCCPositionType)){&$PlayLayer::getParticleKey} != (void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey})
            m->registerHook(base+0x764d0, extract((void(D::*)(int, char const*, int, cocos2d::tCCPositionType)){&D::getParticleKey}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::getParticleKey2} != (void(D::*)(std::string)){&D::getParticleKey2})
            m->registerHook(base+0x767b0, extract((void(D::*)(std::string)){&D::getParticleKey2}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, float, float, float)){&$PlayLayer::getRelativeMod} != (void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod})
            m->registerHook(base+0x7c2a0, extract((void(D::*)(cocos2d::CCPoint, float, float, float)){&D::getRelativeMod}));

        if ((void($PlayLayer::*)()){&$PlayLayer::getTempMilliTime} != (void(D::*)()){&D::getTempMilliTime})
            m->registerHook(base+0x778e0, extract((void(D::*)()){&D::getTempMilliTime}));

        if ((void($PlayLayer::*)()){&$PlayLayer::gravityEffectFinished} != (void(D::*)()){&D::gravityEffectFinished})
            m->registerHook(base+0x7cec0, extract((void(D::*)()){&D::gravityEffectFinished}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::hasItem} != (void(D::*)(int)){&D::hasItem})
            m->registerHook(base+0x7cee0, extract((void(D::*)(int)){&D::hasItem}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::hasUniqueCoin} != (void(D::*)(GameObject*)){&D::hasUniqueCoin})
            m->registerHook(base+0x77510, extract((void(D::*)(GameObject*)){&D::hasUniqueCoin}));

        if ((void($PlayLayer::*)()){&$PlayLayer::incrementJumps} != (void(D::*)()){&D::incrementJumps})
            m->registerHook(base+0x7ff40, extract((void(D::*)()){&D::incrementJumps}));

        if ((bool($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::init} != (bool(D::*)(GJGameLevel*)){&D::init})
            m->registerHook(base+0x6b5f0, extract((bool(D::*)(GJGameLevel*)){&D::init}));

        if ((void($PlayLayer::*)()){&$PlayLayer::isFlipping} != (void(D::*)()){&D::isFlipping})
            m->registerHook(base+0x76100, extract((void(D::*)()){&D::isFlipping}));

        if ((void($PlayLayer::*)()){&$PlayLayer::levelComplete} != (void(D::*)()){&D::levelComplete})
            m->registerHook(base+0x72b80, extract((void(D::*)()){&D::levelComplete}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash})
            m->registerHook(base+0x75cc0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float)){&D::lightningFlash}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&$PlayLayer::lightningFlash} != (void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash})
            m->registerHook(base+0x75bf0, extract((void(D::*)(cocos2d::CCPoint, cocos2d::_ccColor3B)){&D::lightningFlash}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadDefaultColors} != (void(D::*)()){&D::loadDefaultColors})
            m->registerHook(base+0x6ef30, extract((void(D::*)()){&D::loadDefaultColors}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::loadFromCheckpoint} != (void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint})
            m->registerHook(base+0x7f000, extract((void(D::*)(CheckpointObject*)){&D::loadFromCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::loadLastCheckpoint} != (void(D::*)()){&D::loadLastCheckpoint})
            m->registerHook(base+0x7efc0, extract((void(D::*)()){&D::loadLastCheckpoint}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::loadSavedObjectsState} != (void(D::*)(std::string)){&D::loadSavedObjectsState})
            m->registerHook(base+0x7f3d0, extract((void(D::*)(std::string)){&D::loadSavedObjectsState}));

        if ((void($PlayLayer::*)()){&$PlayLayer::markCheckpoint} != (void(D::*)()){&D::markCheckpoint})
            m->registerHook(base+0x7ef60, extract((void(D::*)()){&D::markCheckpoint}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::moveCameraToPos} != (void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos})
            m->registerHook(base+0x7c980, extract((void(D::*)(cocos2d::CCPoint)){&D::moveCameraToPos}));

        if ((void($PlayLayer::*)()){&$PlayLayer::onQuit} != (void(D::*)()){&D::onQuit})
            m->registerHook(base+0x72710, extract((void(D::*)()){&D::onQuit}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeColorGroups} != (void(D::*)()){&D::optimizeColorGroups})
            m->registerHook(base+0x6dad0, extract((void(D::*)()){&D::optimizeColorGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeOpacityGroups} != (void(D::*)()){&D::optimizeOpacityGroups})
            m->registerHook(base+0x6dc20, extract((void(D::*)()){&D::optimizeOpacityGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::optimizeSaveRequiredGroups} != (void(D::*)()){&D::optimizeSaveRequiredGroups})
            m->registerHook(base+0x6dd70, extract((void(D::*)()){&D::optimizeSaveRequiredGroups}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::pauseGame} != (void(D::*)(bool)){&D::pauseGame})
            m->registerHook(base+0x802d0, extract((void(D::*)(bool)){&D::pauseGame}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::pickupItem} != (void(D::*)(GameObject*)){&D::pickupItem})
            m->registerHook(base+0x7c1d0, extract((void(D::*)(GameObject*)){&D::pickupItem}));

        if ((void($PlayLayer::*)(int, int)){&$PlayLayer::playAnimationCommand} != (void(D::*)(int, int)){&D::playAnimationCommand})
            m->registerHook(base+0x75930, extract((void(D::*)(int, int)){&D::playAnimationCommand}));

        if ((void($PlayLayer::*)(cocos2d::CCPoint)){&$PlayLayer::playEndAnimationToPos} != (void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos})
            m->registerHook(base+0x759a0, extract((void(D::*)(cocos2d::CCPoint)){&D::playEndAnimationToPos}));

        if ((void($PlayLayer::*)(PlayerObject*)){&$PlayLayer::playExitDualEffect} != (void(D::*)(PlayerObject*)){&D::playExitDualEffect})
            m->registerHook(base+0x7d1d0, extract((void(D::*)(PlayerObject*)){&D::playExitDualEffect}));

        if ((void($PlayLayer::*)(float, int, float)){&$PlayLayer::playFlashEffect} != (void(D::*)(float, int, float)){&D::playFlashEffect})
            m->registerHook(base+0x75e50, extract((void(D::*)(float, int, float)){&D::playFlashEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::playGravityEffect} != (void(D::*)(bool)){&D::playGravityEffect})
            m->registerHook(base+0x7b5a0, extract((void(D::*)(bool)){&D::playGravityEffect}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::playSpeedParticle} != (void(D::*)(float)){&D::playSpeedParticle})
            m->registerHook(base+0x77030, extract((void(D::*)(float)){&D::playSpeedParticle}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*)){&$PlayLayer::playerWillSwitchMode} != (void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode})
            m->registerHook(base+0x7b820, extract((void(D::*)(PlayerObject*, GameObject*)){&D::playerWillSwitchMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::prepareSpawnObjects} != (void(D::*)()){&D::prepareSpawnObjects})
            m->registerHook(base+0x7fc00, extract((void(D::*)()){&D::prepareSpawnObjects}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processItems} != (void(D::*)()){&D::processItems})
            m->registerHook(base+0x735c0, extract((void(D::*)()){&D::processItems}));

        if ((void($PlayLayer::*)()){&$PlayLayer::processLoadedMoveActions} != (void(D::*)()){&D::processLoadedMoveActions})
            m->registerHook(base+0x7a7c0, extract((void(D::*)()){&D::processLoadedMoveActions}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::recordAction} != (void(D::*)(bool, PlayerObject*)){&D::recordAction})
            m->registerHook(base+0x7e190, extract((void(D::*)(bool, PlayerObject*)){&D::recordAction}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerActiveObject} != (void(D::*)(GameObject*)){&D::registerActiveObject})
            m->registerHook(base+0x77620, extract((void(D::*)(GameObject*)){&D::registerActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::registerStateObject} != (void(D::*)(GameObject*)){&D::registerStateObject})
            m->registerHook(base+0x777b0, extract((void(D::*)(GameObject*)){&D::registerStateObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeAllObjects} != (void(D::*)()){&D::removeAllObjects})
            m->registerHook(base+0x727b0, extract((void(D::*)()){&D::removeAllObjects}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::removeFromGroupOld} != (void(D::*)(GameObject*)){&D::removeFromGroupOld})
            m->registerHook(base+0x77750, extract((void(D::*)(GameObject*)){&D::removeFromGroupOld}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removeLastCheckpoint} != (void(D::*)()){&D::removeLastCheckpoint})
            m->registerHook(base+0x7f870, extract((void(D::*)()){&D::removeLastCheckpoint}));

        if ((void($PlayLayer::*)()){&$PlayLayer::removePlayer2} != (void(D::*)()){&D::removePlayer2})
            m->registerHook(base+0x7d630, extract((void(D::*)()){&D::removePlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resetLevel} != (void(D::*)()){&D::resetLevel})
            m->registerHook(base+0x71c50, extract((void(D::*)()){&D::resetLevel}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resume} != (void(D::*)()){&D::resume})
            m->registerHook(base+0x80480, extract((void(D::*)()){&D::resume}));

        if ((void($PlayLayer::*)()){&$PlayLayer::resumeAndRestart} != (void(D::*)()){&D::resumeAndRestart})
            m->registerHook(base+0x80400, extract((void(D::*)()){&D::resumeAndRestart}));

        if ((void($PlayLayer::*)(bool, PlayerObject*)){&$PlayLayer::saveRecordAction} != (void(D::*)(bool, PlayerObject*)){&D::saveRecordAction})
            m->registerHook(base+0x78750, extract((void(D::*)(bool, PlayerObject*)){&D::saveRecordAction}));

        if ((void($PlayLayer::*)(GJGameLevel*)){&$PlayLayer::scene} != (void(D::*)(GJGameLevel*)){&D::scene})
            m->registerHook(base+0x6b500, extract((void(D::*)(GJGameLevel*)){&D::scene}));

        if ((void($PlayLayer::*)(LevelSettingsObject*)){&$PlayLayer::setupLevelStart} != (void(D::*)(LevelSettingsObject*)){&D::setupLevelStart})
            m->registerHook(base+0x6f560, extract((void(D::*)(LevelSettingsObject*)){&D::setupLevelStart}));

        if ((void($PlayLayer::*)(std::string)){&$PlayLayer::setupReplay} != (void(D::*)(std::string)){&D::setupReplay})
            m->registerHook(base+0x7e1e0, extract((void(D::*)(std::string)){&D::setupReplay}));

        if ((void($PlayLayer::*)(float, float, float)){&$PlayLayer::shakeCamera} != (void(D::*)(float, float, float)){&D::shakeCamera})
            m->registerHook(base+0x744a0, extract((void(D::*)(float, float, float)){&D::shakeCamera}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::shouldBlend} != (void(D::*)(int)){&D::shouldBlend})
            m->registerHook(base+0x771b0, extract((void(D::*)(int)){&D::shouldBlend}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteEffect} != (void(D::*)()){&D::showCompleteEffect})
            m->registerHook(base+0x738e0, extract((void(D::*)()){&D::showCompleteEffect}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showCompleteText} != (void(D::*)()){&D::showCompleteText})
            m->registerHook(base+0x73be0, extract((void(D::*)()){&D::showCompleteText}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showEndLayer} != (void(D::*)()){&D::showEndLayer})
            m->registerHook(base+0x74450, extract((void(D::*)()){&D::showEndLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showHint} != (void(D::*)()){&D::showHint})
            m->registerHook(base+0x7deb0, extract((void(D::*)()){&D::showHint}));

        if ((void($PlayLayer::*)(bool, int, int, bool, bool, bool)){&$PlayLayer::showNewBest} != (void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest})
            m->registerHook(base+0x74580, extract((void(D::*)(bool, int, int, bool, bool, bool)){&D::showNewBest}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showRetryLayer} != (void(D::*)()){&D::showRetryLayer})
            m->registerHook(base+0x75ba0, extract((void(D::*)()){&D::showRetryLayer}));

        if ((void($PlayLayer::*)()){&$PlayLayer::showTwoPlayerGuide} != (void(D::*)()){&D::showTwoPlayerGuide})
            m->registerHook(base+0x6df00, extract((void(D::*)()){&D::showTwoPlayerGuide}));

        if ((void($PlayLayer::*)()){&$PlayLayer::sortGroups} != (void(D::*)()){&D::sortGroups})
            m->registerHook(base+0x6d9e0, extract((void(D::*)()){&D::sortGroups}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnCircle} != (void(D::*)()){&D::spawnCircle})
            m->registerHook(base+0x73820, extract((void(D::*)()){&D::spawnCircle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnFirework} != (void(D::*)()){&D::spawnFirework})
            m->registerHook(base+0x74200, extract((void(D::*)()){&D::spawnFirework}));

        if ((void($PlayLayer::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&$PlayLayer::spawnParticle} != (void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle})
            m->registerHook(base+0x76330, extract((void(D::*)(char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint)){&D::spawnParticle}));

        if ((void($PlayLayer::*)()){&$PlayLayer::spawnPlayer2} != (void(D::*)()){&D::spawnPlayer2})
            m->registerHook(base+0x7d170, extract((void(D::*)()){&D::spawnPlayer2}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startGame} != (void(D::*)()){&D::startGame})
            m->registerHook(base+0x726b0, extract((void(D::*)()){&D::startGame}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startMusic} != (void(D::*)()){&D::startMusic})
            m->registerHook(base+0x72910, extract((void(D::*)()){&D::startMusic}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecording} != (void(D::*)()){&D::startRecording})
            m->registerHook(base+0x7fec0, extract((void(D::*)()){&D::startRecording}));

        if ((void($PlayLayer::*)()){&$PlayLayer::startRecordingDelayed} != (void(D::*)()){&D::startRecordingDelayed})
            m->registerHook(base+0x7fed0, extract((void(D::*)()){&D::startRecordingDelayed}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopCameraShake} != (void(D::*)()){&D::stopCameraShake})
            m->registerHook(base+0x75900, extract((void(D::*)()){&D::stopCameraShake}));

        if ((void($PlayLayer::*)()){&$PlayLayer::stopRecording} != (void(D::*)()){&D::stopRecording})
            m->registerHook(base+0x6d090, extract((void(D::*)()){&D::stopRecording}));

        if ((void($PlayLayer::*)(CheckpointObject*)){&$PlayLayer::storeCheckpoint} != (void(D::*)(CheckpointObject*)){&D::storeCheckpoint})
            m->registerHook(base+0x7ef10, extract((void(D::*)(CheckpointObject*)){&D::storeCheckpoint}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool, int)){&$PlayLayer::switchToFlyMode} != (void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode})
            m->registerHook(base+0x7baf0, extract((void(D::*)(PlayerObject*, GameObject*, bool, int)){&D::switchToFlyMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRobotMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode})
            m->registerHook(base+0x7bc80, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRobotMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToRollMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode})
            m->registerHook(base+0x7bbe0, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToRollMode}));

        if ((void($PlayLayer::*)(PlayerObject*, GameObject*, bool)){&$PlayLayer::switchToSpiderMode} != (void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode})
            m->registerHook(base+0x7bd20, extract((void(D::*)(PlayerObject*, GameObject*, bool)){&D::switchToSpiderMode}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::timeForXPos2} != (void(D::*)(float, bool)){&D::timeForXPos2})
            m->registerHook(base+0x293eb0, extract((void(D::*)(float, bool)){&D::timeForXPos2}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleBGEffectVisibility} != (void(D::*)(bool)){&D::toggleBGEffectVisibility})
            m->registerHook(base+0x7fe80, extract((void(D::*)(bool)){&D::toggleBGEffectVisibility}));

        if ((void($PlayLayer::*)(GameObject*, bool, PlayerObject*, bool)){&$PlayLayer::toggleDualMode} != (void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode})
            m->registerHook(base+0x7bf90, extract((void(D::*)(GameObject*, bool, PlayerObject*, bool)){&D::toggleDualMode}));

        if ((void($PlayLayer::*)(bool, bool)){&$PlayLayer::toggleFlipped} != (void(D::*)(bool, bool)){&D::toggleFlipped})
            m->registerHook(base+0x7bdc0, extract((void(D::*)(bool, bool)){&D::toggleFlipped}));

        if ((void($PlayLayer::*)(int)){&$PlayLayer::toggleGhostEffect} != (void(D::*)(int)){&D::toggleGhostEffect})
            m->registerHook(base+0x7fe40, extract((void(D::*)(int)){&D::toggleGhostEffect}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::toggleGlitter} != (void(D::*)(bool)){&D::toggleGlitter})
            m->registerHook(base+0x70e00, extract((void(D::*)(bool)){&D::toggleGlitter}));

        if ((void($PlayLayer::*)(bool)){&$PlayLayer::togglePracticeMode} != (void(D::*)(bool)){&D::togglePracticeMode})
            m->registerHook(base+0x7f9e0, extract((void(D::*)(bool)){&D::togglePracticeMode}));

        if ((void($PlayLayer::*)()){&$PlayLayer::toggleProgressbar} != (void(D::*)()){&D::toggleProgressbar})
            m->registerHook(base+0x6eeb0, extract((void(D::*)()){&D::toggleProgressbar}));

        if ((void($PlayLayer::*)()){&$PlayLayer::tryStartRecord} != (void(D::*)()){&D::tryStartRecord})
            m->registerHook(base+0x7fe00, extract((void(D::*)()){&D::tryStartRecord}));

        if ((void($PlayLayer::*)(char const*, cocos2d::CCParticleSystemQuad*)){&$PlayLayer::unclaimParticle} != (void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle})
            m->registerHook(base+0x76e00, extract((void(D::*)(char const*, cocos2d::CCParticleSystemQuad*)){&D::unclaimParticle}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterActiveObject} != (void(D::*)(GameObject*)){&D::unregisterActiveObject})
            m->registerHook(base+0x77660, extract((void(D::*)(GameObject*)){&D::unregisterActiveObject}));

        if ((void($PlayLayer::*)(GameObject*)){&$PlayLayer::unregisterStateObject} != (void(D::*)(GameObject*)){&D::unregisterStateObject})
            m->registerHook(base+0x777f0, extract((void(D::*)(GameObject*)){&D::unregisterStateObject}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateAttempts} != (void(D::*)()){&D::updateAttempts})
            m->registerHook(base+0x7fcd0, extract((void(D::*)()){&D::updateAttempts}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateCamera} != (void(D::*)(float)){&D::updateCamera})
            m->registerHook(base+0x6e2b0, extract((void(D::*)(float)){&D::updateCamera}));

        if ((void($PlayLayer::*)(PlayerObject*, int, bool)){&$PlayLayer::updateDualGround} != (void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround})
            m->registerHook(base+0x7caa0, extract((void(D::*)(PlayerObject*, int, bool)){&D::updateDualGround}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateEffectPositions} != (void(D::*)()){&D::updateEffectPositions})
            m->registerHook(base+0x7a6d0, extract((void(D::*)()){&D::updateEffectPositions}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateLevelColors} != (void(D::*)()){&D::updateLevelColors})
            m->registerHook(base+0x6f1e0, extract((void(D::*)()){&D::updateLevelColors}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateMoveObjectsLastPosition} != (void(D::*)()){&D::updateMoveObjectsLastPosition})
            m->registerHook(base+0x7a720, extract((void(D::*)()){&D::updateMoveObjectsLastPosition}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateProgressbar} != (void(D::*)()){&D::updateProgressbar})
            m->registerHook(base+0x6ed70, extract((void(D::*)()){&D::updateProgressbar}));

        if ((void($PlayLayer::*)(float)){&$PlayLayer::updateReplay} != (void(D::*)(float)){&D::updateReplay})
            m->registerHook(base+0x78b60, extract((void(D::*)(float)){&D::updateReplay}));

        if ((void($PlayLayer::*)(float, bool)){&$PlayLayer::updateTimeMod} != (void(D::*)(float, bool)){&D::updateTimeMod})
            m->registerHook(base+0x786f0, extract((void(D::*)(float, bool)){&D::updateTimeMod}));

        if ((void($PlayLayer::*)()){&$PlayLayer::updateVisibility} != (void(D::*)()){&D::updateVisibility})
            m->registerHook(base+0x6fb90, extract((void(D::*)()){&D::updateVisibility}));

        if ((void($PlayLayer::*)()){&$PlayLayer::vfDChk} != (void(D::*)()){&D::vfDChk})
            m->registerHook(base+0x7fcb0, extract((void(D::*)()){&D::vfDChk}));

        if ((void($PlayLayer::*)()){&$PlayLayer::visitWithColorFlash} != (void(D::*)()){&D::visitWithColorFlash})
            m->registerHook(base+0x761f0, extract((void(D::*)()){&D::visitWithColorFlash}));

        if ((void($PlayLayer::*)(int, PlayerObject*)){&$PlayLayer::willSwitchToMode} != (void(D::*)(int, PlayerObject*)){&D::willSwitchToMode})
            m->registerHook(base+0x7b9e0, extract((void(D::*)(int, PlayerObject*)){&D::willSwitchToMode}));
    }
};


template<class D>
class $StatsCell : public StatsCell, public $CacBase {
public:
    dupable ~$StatsCell() override {}

    dupable bool init() override {
        if ((bool($StatsCell::*)()){&$StatsCell::init} != (bool(D::*)()){&D::init})
            return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(base+0x11b100))(this);
        else return StatsCell::init();
    }

    dupable void draw() override {
        if ((void($StatsCell::*)()){&$StatsCell::draw} != (void(D::*)()){&D::draw})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x11bf80))(this);
        else return StatsCell::draw();
    }

    dupable $StatsCell() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((bool($StatsCell::*)()){&$StatsCell::init} != (bool(D::*)()){&D::init})
            m->registerHook(base+0x11b100, extract_virtual(V, (bool(D::*)()){&D::init}));

        if ((void($StatsCell::*)()){&$StatsCell::draw} != (void(D::*)()){&D::draw})
            m->registerHook(base+0x11bf80, extract_virtual(V, (void(D::*)()){&D::draw}));
    }
};


template<class D>
class $CCScrollLayerExtDelegate : public CCScrollLayerExtDelegate, public $CacBase {
public:
    dupable ~$CCScrollLayerExtDelegate() override {}

    dupable $CCScrollLayerExtDelegate() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});
    }
};


template<class D>
class $TableView : public TableView, public $CacBase {
public:
    dupable ~$TableView() override {}

    dupable void onEnter() override {
        if ((void($TableView::*)()){&$TableView::onEnter} != (void(D::*)()){&D::onEnter})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff30))(this);
        else return TableView::onEnter();
    }

    dupable void onExit() override {
        if ((void($TableView::*)()){&$TableView::onExit} != (void(D::*)()){&D::onExit})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff40))(this);
        else return TableView::onExit();
    }

    dupable bool ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((bool($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            return reinterpret_cast<bool(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380120))(this, p0, p1);
        else return TableView::ccTouchBegan(p0, p1);
    }

    dupable void ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380be0))(this, p0, p1);
        else return TableView::ccTouchMoved(p0, p1);
    }

    dupable void ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x3809a0))(this, p0, p1);
        else return TableView::ccTouchEnded(p0, p1);
    }

    dupable void ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) override {
        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            return reinterpret_cast<void(*)(decltype(this), cocos2d::CCTouch*, cocos2d::CCEvent*)>(m->getOriginal(base+0x380b20))(this, p0, p1);
        else return TableView::ccTouchCancelled(p0, p1);
    }

    dupable void registerWithTouchDispatcher() override {
        if ((void($TableView::*)()){&$TableView::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37ff50))(this);
        else return TableView::registerWithTouchDispatcher();
    }

    dupable void scrollWheel(float p0, float p1) override {
        if ((void($TableView::*)(float, float)){&$TableView::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            return reinterpret_cast<void(*)(decltype(this), float, float)>(m->getOriginal(base+0x380cd0))(this, p0, p1);
        else return TableView::scrollWheel(p0, p1);
    }

    dupable void scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) override {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrllViewWillBeginDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818a0))(this, p0);
        else return TableView::scrllViewWillBeginDecelerating(p0);
    }

    dupable void scrollViewDidEndDecelerating(CCScrollLayerExt* p0) override {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818c0))(this, p0);
        else return TableView::scrollViewDidEndDecelerating(p0);
    }

    dupable void scrollViewTouchMoving(CCScrollLayerExt* p0) override {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewTouchMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x3818e0))(this, p0);
        else return TableView::scrollViewTouchMoving(p0);
    }

    dupable void scrollViewDidEndMoving(CCScrollLayerExt* p0) override {
        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving})
            return reinterpret_cast<void(*)(decltype(this), CCScrollLayerExt*)>(m->getOriginal(base+0x381900))(this, p0);
        else return TableView::scrollViewDidEndMoving(p0);
    }

    dupable static TableView* create(TableViewDelegate* p0, TableViewDataSource* p1, cocos2d::CCRect p2) {
        if ((TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&$TableView::create} != (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create})
            return reinterpret_cast<TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)>(m->getOriginal(base+0x37eb30))(p0, p1, p2);
        else return TableView::create(p0, p1, p2);
    }

    dupable void reloadData() {
        if ((void($TableView::*)()){&$TableView::reloadData} != (void(D::*)()){&D::reloadData})
            return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(base+0x37f970))(this);
        else return TableView::reloadData();
    }

    dupable $TableView() {
        if ($lock) return;
        $lock = true;
        auto V = *reinterpret_cast<uintptr_t*>(new D());
        $lock = false;
        m->registerHook(extract_destructor(V), +[](){});

        if ((void($TableView::*)()){&$TableView::onEnter} != (void(D::*)()){&D::onEnter})
            m->registerHook(base+0x37ff30, extract_virtual(V, (void(D::*)()){&D::onEnter}));

        if ((void($TableView::*)()){&$TableView::onExit} != (void(D::*)()){&D::onExit})
            m->registerHook(base+0x37ff40, extract_virtual(V, (void(D::*)()){&D::onExit}));

        if ((bool($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchBegan} != (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan})
            m->registerHook(base+0x380120, extract_virtual(V, (bool(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchBegan}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchMoved} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved})
            m->registerHook(base+0x380be0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchMoved}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchEnded} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded})
            m->registerHook(base+0x3809a0, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchEnded}));

        if ((void($TableView::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&$TableView::ccTouchCancelled} != (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled})
            m->registerHook(base+0x380b20, extract_virtual(V, (void(D::*)(cocos2d::CCTouch*, cocos2d::CCEvent*)){&D::ccTouchCancelled}));

        if ((void($TableView::*)()){&$TableView::registerWithTouchDispatcher} != (void(D::*)()){&D::registerWithTouchDispatcher})
            m->registerHook(base+0x37ff50, extract_virtual(V, (void(D::*)()){&D::registerWithTouchDispatcher}));

        if ((void($TableView::*)(float, float)){&$TableView::scrollWheel} != (void(D::*)(float, float)){&D::scrollWheel})
            m->registerHook(base+0x380cd0, extract_virtual(V, (void(D::*)(float, float)){&D::scrollWheel}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrllViewWillBeginDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating})
            m->registerHook(base+0x3818a0, extract_virtual(V, (void(D::*)(CCScrollLayerExt*)){&D::scrllViewWillBeginDecelerating}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndDecelerating} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating})
            m->registerHook(base+0x3818c0, extract_virtual(V, (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndDecelerating}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewTouchMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving})
            m->registerHook(base+0x3818e0, extract_virtual(V, (void(D::*)(CCScrollLayerExt*)){&D::scrollViewTouchMoving}));

        if ((void($TableView::*)(CCScrollLayerExt*)){&$TableView::scrollViewDidEndMoving} != (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving})
            m->registerHook(base+0x381900, extract_virtual(V, (void(D::*)(CCScrollLayerExt*)){&D::scrollViewDidEndMoving}));

        if ((TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&$TableView::create} != (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create})
            m->registerHook(base+0x37eb30, (TableView*(*)(TableViewDelegate*, TableViewDataSource*, cocos2d::CCRect)){&D::create});

        if ((void($TableView::*)()){&$TableView::reloadData} != (void(D::*)()){&D::reloadData})
            m->registerHook(base+0x37f970, extract((void(D::*)()){&D::reloadData}));
    }
};
