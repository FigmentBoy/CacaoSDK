//Copyright camden314 2021. Autogenerated using a python script
#include <Cacao.hpp>
using namespace cocos2d;
ModContainer* m;

#ifndef CAC_PROJ_NAME
#define CAC_PROJ_NAME "Default Cacao Project"
#endif

typedef char const* c_string;

template <class F>
struct GetReturnType;

template <class K>
struct RemoveRef;

template <class R, class... A, class G>
struct GetReturnType<R (G::*)(A...)>
{
  typedef R type;
};

template <class M>
struct RemoveRef <M&>
{
    typedef M type;
};

#define cac_this (reinterpret_cast<RemoveRef<decltype(*this)>::type::__thistype>(this))

template <typename F, class T>
inline typename GetReturnType<F>::type (*extract_virtual(T instance, F func))(T) {
    return reinterpret_cast<typename GetReturnType<F>::type(*)(T)>(*reinterpret_cast<long*>(*reinterpret_cast<long*>(instance)+*reinterpret_cast<long*>(&func)-1));
};
 
class $GameObject {
 public:
    $GameObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef GameObject* __thistype;

    virtual int getGroupID(int  p0) {
        return reinterpret_cast<int(*)(decltype(this),int )>(m->getOriginal(getBase()+0x33ae10))(this,p0);
    }

    virtual void setPosition(CCPoint  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCPoint )>(m->getOriginal(getBase()+0x335850))(this,p0);
    }

    virtual void setStartPos(CCPoint  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCPoint )>(m->getOriginal(getBase()+0x2fa520))(this,p0);
    }

    virtual void selectObject(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x341f90))(this,p0);
    }

    virtual void setupCoinArt() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x337dd0))(this);
    }

    virtual void destroyObject() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336a00))(this);
    }

    virtual void playShineEffect() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2fa9d0))(this);
    }

    virtual void calculateSpawnXPos() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x336970))(this);
    }

    virtual bool init(char const*  p0) {
        return reinterpret_cast<bool(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x2f5520))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x33ae10, extract_virtual(this, &$GameObject::getGroupID));

        m->registerHook(getBase()+0x335850, extract_virtual(this, &$GameObject::setPosition));

        m->registerHook(getBase()+0x2fa520, extract_virtual(this, &$GameObject::setStartPos));

        m->registerHook(getBase()+0x341f90, extract_virtual(this, &$GameObject::selectObject));

        m->registerHook(getBase()+0x337dd0, extract_virtual(this, &$GameObject::setupCoinArt));

        m->registerHook(getBase()+0x336a00, extract_virtual(this, &$GameObject::destroyObject));

        m->registerHook(getBase()+0x2fa9d0, extract_virtual(this, &$GameObject::playShineEffect));

        m->registerHook(getBase()+0x336970, extract_virtual(this, &$GameObject::calculateSpawnXPos));

        m->registerHook(getBase()+0x2f5520, extract_virtual(this, &$GameObject::init));
    }
};

class $GameManager {
 public:
    $GameManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef GameManager* __thistype;

    virtual _ccColor3B colorForIdx(int  p0) {
        return reinterpret_cast<_ccColor3B(*)(decltype(this),int )>(m->getOriginal(getBase()+0x1cbc80))(this,p0);
    }

    virtual void doQuickSave() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0200))(this);
    }

    virtual void fadeInMusic(char const*  p0) {
        return reinterpret_cast<void(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x1c2ff0))(this,p0);
    }

    virtual void reloadAllStep5() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d0b00))(this);
    }

    virtual int getGameVariable(char const*  p0) {
        return reinterpret_cast<int(*)(decltype(this),char const* )>(m->getOriginal(getBase()+0x1cccd0))(this,p0);
    }

    virtual int setGameVariable(char const*  p0,bool  p1) {
        return reinterpret_cast<int(*)(decltype(this),char const* ,bool )>(m->getOriginal(getBase()+0x1cca80))(this,p0,p1);
    }

    virtual bool accountStatusChanged() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x1cdad0))(this);
    }

    virtual void load() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x26ee20))(this);
    }

    virtual void loadFont(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x1cc550))(this,p0);
    }

    virtual void reloadAll(bool  p0,bool  p1,bool  p2) {
        return reinterpret_cast<void(*)(decltype(this),bool ,bool ,bool )>(m->getOriginal(getBase()+0x1d08a0))(this,p0,p1,p2);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x1cbc80, extract_virtual(this, &$GameManager::colorForIdx));

        m->registerHook(getBase()+0x1d0200, extract_virtual(this, &$GameManager::doQuickSave));

        m->registerHook(getBase()+0x1c2ff0, extract_virtual(this, &$GameManager::fadeInMusic));

        m->registerHook(getBase()+0x1d0b00, extract_virtual(this, &$GameManager::reloadAllStep5));

        m->registerHook(getBase()+0x1cccd0, extract_virtual(this, &$GameManager::getGameVariable));

        m->registerHook(getBase()+0x1cca80, extract_virtual(this, &$GameManager::setGameVariable));

        m->registerHook(getBase()+0x1cdad0, extract_virtual(this, &$GameManager::accountStatusChanged));

        m->registerHook(getBase()+0x26ee20, extract_virtual(this, &$GameManager::load));

        m->registerHook(getBase()+0x1cc550, extract_virtual(this, &$GameManager::loadFont));

        m->registerHook(getBase()+0x1d08a0, extract_virtual(this, &$GameManager::reloadAll));
    }
};

class $PlayerObject {
 public:
    $PlayerObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef PlayerObject* __thistype;

    virtual void pushButton(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x22aa00))(this,p0);
    }

    virtual void flipGravity(bool  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),bool ,bool )>(m->getOriginal(getBase()+0x21c090))(this,p0,p1);
    }

    virtual void setSecondColor(_ccColor3B const&  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B const& )>(m->getOriginal(getBase()+0x219610))(this,p0);
    }

    virtual void addAllParticles() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x2189b0))(this);
    }

    virtual void setColor(_ccColor3B const&  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B const& )>(m->getOriginal(getBase()+0x22cdf0))(this,p0);
    }

    virtual void update(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x218bf0))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x22aa00, extract_virtual(this, &$PlayerObject::pushButton));

        m->registerHook(getBase()+0x21c090, extract_virtual(this, &$PlayerObject::flipGravity));

        m->registerHook(getBase()+0x219610, extract_virtual(this, &$PlayerObject::setSecondColor));

        m->registerHook(getBase()+0x2189b0, extract_virtual(this, &$PlayerObject::addAllParticles));

        m->registerHook(getBase()+0x22cdf0, extract_virtual(this, &$PlayerObject::setColor));

        m->registerHook(getBase()+0x218bf0, extract_virtual(this, &$PlayerObject::update));
    }
};

class $ObjectToolbox {
 public:
    $ObjectToolbox() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef ObjectToolbox* __thistype;

    virtual c_string intKeyToFrame(int  p0) {
        return reinterpret_cast<c_string(*)(decltype(this),int )>(m->getOriginal(getBase()+0x4173b0))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x4173b0, extract_virtual(this, &$ObjectToolbox::intKeyToFrame));
    }
};

class $CCTextInputNode {
 public:
    $CCTextInputNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCTextInputNode* __thistype;

    virtual void setAllowedChars(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x5d360))(this,p0);
    }

    virtual void setMaxLabelScale(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x5da30))(this,p0);
    }

    virtual void setMaxLabelWidth(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x5da50))(this,p0);
    }

    virtual void setLabelPlaceholderColor(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x5da90))(this,p0);
    }

    virtual std::string getString() {
        return reinterpret_cast<std::string(*)(decltype(this))>(m->getOriginal(getBase()+0x5d6f0))(this);
    }

    virtual void setString(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x5d3e0))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x5d360, extract_virtual(this, &$CCTextInputNode::setAllowedChars));

        m->registerHook(getBase()+0x5da30, extract_virtual(this, &$CCTextInputNode::setMaxLabelScale));

        m->registerHook(getBase()+0x5da50, extract_virtual(this, &$CCTextInputNode::setMaxLabelWidth));

        m->registerHook(getBase()+0x5da90, extract_virtual(this, &$CCTextInputNode::setLabelPlaceholderColor));

        m->registerHook(getBase()+0x5d6f0, extract_virtual(this, &$CCTextInputNode::getString));

        m->registerHook(getBase()+0x5d3e0, extract_virtual(this, &$CCTextInputNode::setString));
    }
};

class $EndPortalObject {
 public:
    $EndPortalObject() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef EndPortalObject* __thistype;

    virtual void updateColors(_ccColor3B  p0) {
        return reinterpret_cast<void(*)(decltype(this),_ccColor3B )>(m->getOriginal(getBase()+0x1dacb0))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x1dacb0, extract_virtual(this, &$EndPortalObject::updateColors));
    }
};

class $GJBaseGameLayer {
 public:
    $GJBaseGameLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef GJBaseGameLayer* __thistype;

    virtual void spawnGroup(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0xb7050))(this,p0);
    }

    virtual void addToSection(GameObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* )>(m->getOriginal(getBase()+0xb7b70))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0xb7050, extract_virtual(this, &$GJBaseGameLayer::spawnGroup));

        m->registerHook(getBase()+0xb7b70, extract_virtual(this, &$GJBaseGameLayer::addToSection));
    }
};

class $EditorPauseLayer {
 public:
    $EditorPauseLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef EditorPauseLayer* __thistype;

    virtual void saveLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x13ebd0))(this);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x13ebd0, extract_virtual(this, &$EditorPauseLayer::saveLevel));
    }
};

class $GameSoundManager {
 public:
    $GameSoundManager() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef GameSoundManager* __thistype;

    virtual void stopBackgroundMusic() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x362130))(this);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x362130, extract_virtual(this, &$GameSoundManager::stopBackgroundMusic));
    }
};

class $LevelEditorLayer {
 public:
    $LevelEditorLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef LevelEditorLayer* __thistype;

    virtual void createObject(int  p0,CCPoint  p1,bool  p2) {
        return reinterpret_cast<void(*)(decltype(this),int ,CCPoint ,bool )>(m->getOriginal(getBase()+0x957c0))(this,p0,p1,p2);
    }

    virtual void handleAction(bool  p0,CCArray*  p1) {
        return reinterpret_cast<void(*)(decltype(this),bool ,CCArray* )>(m->getOriginal(getBase()+0x97020))(this,p0,p1);
    }

    virtual void removeObject(GameObject*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* ,bool )>(m->getOriginal(getBase()+0x96890))(this,p0,p1);
    }

    virtual void redoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97750))(this);
    }

    virtual void undoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x97770))(this);
    }

    virtual void removeAllObjects() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x93d80))(this);
    }

    virtual int getNextFreeGroupID(CCArray*  p0) {
        return reinterpret_cast<int(*)(decltype(this),CCArray* )>(m->getOriginal(getBase()+0x9a1b0))(this,p0);
    }

    virtual GameObject* addObjectFromString(std::string  p0) {
        return reinterpret_cast<GameObject*(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x94640))(this,p0);
    }

    virtual void createObjectsFromString(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x94730))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x957c0, extract_virtual(this, &$LevelEditorLayer::createObject));

        m->registerHook(getBase()+0x97020, extract_virtual(this, &$LevelEditorLayer::handleAction));

        m->registerHook(getBase()+0x96890, extract_virtual(this, &$LevelEditorLayer::removeObject));

        m->registerHook(getBase()+0x97750, extract_virtual(this, &$LevelEditorLayer::redoLastAction));

        m->registerHook(getBase()+0x97770, extract_virtual(this, &$LevelEditorLayer::undoLastAction));

        m->registerHook(getBase()+0x93d80, extract_virtual(this, &$LevelEditorLayer::removeAllObjects));

        m->registerHook(getBase()+0x9a1b0, extract_virtual(this, &$LevelEditorLayer::getNextFreeGroupID));

        m->registerHook(getBase()+0x94640, extract_virtual(this, &$LevelEditorLayer::addObjectFromString));

        m->registerHook(getBase()+0x94730, extract_virtual(this, &$LevelEditorLayer::createObjectsFromString));
    }
};

class $CCMenuItemToggler {
 public:
    $CCMenuItemToggler() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCMenuItemToggler* __thistype;

    virtual void setSizeMult(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x38a40))(this,p0);
    }

    virtual void toggle(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x38950))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x38a40, extract_virtual(this, &$CCMenuItemToggler::setSizeMult));

        m->registerHook(getBase()+0x38950, extract_virtual(this, &$CCMenuItemToggler::toggle));
    }
};

class $CCMenuItemSpriteExtra {
 public:
    $CCMenuItemSpriteExtra() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCMenuItemSpriteExtra* __thistype;

    virtual void setSizeMult(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x1255e0))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x1255e0, extract_virtual(this, &$CCMenuItemSpriteExtra::setSizeMult));
    }
};

class $MoreVideoOptionsLayer {
 public:
    $MoreVideoOptionsLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef MoreVideoOptionsLayer* __thistype;

    virtual bool init() {
        return reinterpret_cast<bool(*)(decltype(this))>(m->getOriginal(getBase()+0x444150))(this);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x444150, extract_virtual(this, &$MoreVideoOptionsLayer::init));
    }
};

class $Slider {
 public:
    $Slider() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef Slider* __thistype;

    virtual void setBarVisibility(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x18e280))(this,p0);
    }

    virtual float getValue() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x18e0c0))(this);
    }

    virtual void setValue(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x18e170))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x18e280, extract_virtual(this, &$Slider::setBarVisibility));

        m->registerHook(getBase()+0x18e0c0, extract_virtual(this, &$Slider::getValue));

        m->registerHook(getBase()+0x18e170, extract_virtual(this, &$Slider::setValue));
    }
};

class $CCLabelBMFont {
 public:
    $CCLabelBMFont() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCLabelBMFont* __thistype;

    virtual void limitLabelWidth(float  p0,float  p1,float  p2) {
        return reinterpret_cast<void(*)(decltype(this),float ,float ,float )>(m->getOriginal(getBase()+0x34a6e0))(this,p0,p1,p2);
    }

    virtual void setScale(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x34a5d0))(this,p0);
    }

    virtual void setString(char const*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),char const* ,bool )>(m->getOriginal(getBase()+0x3489e0))(this,p0,p1);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x34a6e0, extract_virtual(this, &$CCLabelBMFont::limitLabelWidth));

        m->registerHook(getBase()+0x34a5d0, extract_virtual(this, &$CCLabelBMFont::setScale));

        m->registerHook(getBase()+0x3489e0, extract_virtual(this, &$CCLabelBMFont::setString));
    }
};

class $CCMouseDelegate {
 public:
    $CCMouseDelegate() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCMouseDelegate* __thistype;

    virtual void rightKeyUp() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61c0))(this);
    }

    virtual void scrollWheel(float  p0,float  p1) {
        return reinterpret_cast<void(*)(decltype(this),float ,float )>(m->getOriginal(getBase()+0x61d0))(this,p0,p1);
    }

    virtual void rightKeyDown() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x61b0))(this);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x61c0, extract_virtual(this, &$CCMouseDelegate::rightKeyUp));

        m->registerHook(getBase()+0x61d0, extract_virtual(this, &$CCMouseDelegate::scrollWheel));

        m->registerHook(getBase()+0x61b0, extract_virtual(this, &$CCMouseDelegate::rightKeyDown));
    }
};

class $CCNode {
 public:
    $CCNode() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef CCNode* __thistype;

    virtual void _setZOrder(int  p0) {
        return reinterpret_cast<void(*)(decltype(this),int )>(m->getOriginal(getBase()+0x122990))(this,p0);
    }

    virtual float getVertexZ() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x1229e0))(this);
    }

    virtual void setVertexZ(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x1229f0))(this,p0);
    }

    virtual void setVisible(bool  p0) {
        return reinterpret_cast<void(*)(decltype(this),bool )>(m->getOriginal(getBase()+0x122d60))(this,p0);
    }

    virtual void unschedule(Cacao::CC_SEL  p0) {
        return reinterpret_cast<void(*)(decltype(this),Cacao::CC_SEL )>(m->getOriginal(getBase()+0x124180))(this,p0);
    }

    virtual CCArray* getChildren() {
        return reinterpret_cast<CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x122c80))(this);
    }

    virtual CCPoint getPosition() {
        return reinterpret_cast<CCPoint(*)(decltype(this))>(m->getOriginal(getBase()+0x122b60))(this);
    }

    virtual float getRotation() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a00))(this);
    }

    virtual void* getUserData() {
        return reinterpret_cast<void*(*)(decltype(this))>(m->getOriginal(getBase()+0x122f30))(this);
    }

    virtual void setPosition(float  p0,float  p1) {
        return reinterpret_cast<void(*)(decltype(this),float ,float )>(m->getOriginal(getBase()+0x122ba0))(this,p0,p1);
    }

    virtual void setRotation(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a10))(this,p0);
    }

    virtual void setUserData(void*  p0) {
        return reinterpret_cast<void(*)(decltype(this),void* )>(m->getOriginal(getBase()+0x122f40))(this,p0);
    }

    virtual float getPositionX() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122be0))(this);
    }

    virtual float getPositionY() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122bf0))(this);
    }

    virtual float getRotationX() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a50))(this);
    }

    virtual float getRotationY() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x122a80))(this);
    }

    virtual float getScheduler() {
        return reinterpret_cast<float(*)(decltype(this))>(m->getOriginal(getBase()+0x123f70))(this);
    }

    virtual void setPositionX(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122c00))(this,p0);
    }

    virtual void setPositionY(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122c40))(this,p0);
    }

    virtual void setRotationX(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a60))(this,p0);
    }

    virtual void setRotationY(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x122a90))(this,p0);
    }

    virtual CCNode* getChildByTag(int  p0) {
        return reinterpret_cast<CCNode*(*)(decltype(this),int )>(m->getOriginal(getBase()+0x123220))(this,p0);
    }

    virtual CCObject* getUserObject() {
        return reinterpret_cast<CCObject*(*)(decltype(this))>(m->getOriginal(getBase()+0x122f80))(this);
    }

    virtual void setUserObject(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x122fb0))(this,p0);
    }

    virtual void setContentSize(CCSize  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCSize )>(m->getOriginal(getBase()+0x122e50))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x122990, extract_virtual(this, &$CCNode::_setZOrder));

        m->registerHook(getBase()+0x1229e0, extract_virtual(this, &$CCNode::getVertexZ));

        m->registerHook(getBase()+0x1229f0, extract_virtual(this, &$CCNode::setVertexZ));

        m->registerHook(getBase()+0x122d60, extract_virtual(this, &$CCNode::setVisible));

        m->registerHook(getBase()+0x124180, extract_virtual(this, &$CCNode::unschedule));

        m->registerHook(getBase()+0x122c80, extract_virtual(this, &$CCNode::getChildren));

        m->registerHook(getBase()+0x122b60, extract_virtual(this, &$CCNode::getPosition));

        m->registerHook(getBase()+0x122a00, extract_virtual(this, &$CCNode::getRotation));

        m->registerHook(getBase()+0x122f30, extract_virtual(this, &$CCNode::getUserData));

        m->registerHook(getBase()+0x122ba0, extract_virtual(this, &$CCNode::setPosition));

        m->registerHook(getBase()+0x122a10, extract_virtual(this, &$CCNode::setRotation));

        m->registerHook(getBase()+0x122f40, extract_virtual(this, &$CCNode::setUserData));

        m->registerHook(getBase()+0x122be0, extract_virtual(this, &$CCNode::getPositionX));

        m->registerHook(getBase()+0x122bf0, extract_virtual(this, &$CCNode::getPositionY));

        m->registerHook(getBase()+0x122a50, extract_virtual(this, &$CCNode::getRotationX));

        m->registerHook(getBase()+0x122a80, extract_virtual(this, &$CCNode::getRotationY));

        m->registerHook(getBase()+0x123f70, extract_virtual(this, &$CCNode::getScheduler));

        m->registerHook(getBase()+0x122c00, extract_virtual(this, &$CCNode::setPositionX));

        m->registerHook(getBase()+0x122c40, extract_virtual(this, &$CCNode::setPositionY));

        m->registerHook(getBase()+0x122a60, extract_virtual(this, &$CCNode::setRotationX));

        m->registerHook(getBase()+0x122a90, extract_virtual(this, &$CCNode::setRotationY));

        m->registerHook(getBase()+0x123220, extract_virtual(this, &$CCNode::getChildByTag));

        m->registerHook(getBase()+0x122f80, extract_virtual(this, &$CCNode::getUserObject));

        m->registerHook(getBase()+0x122fb0, extract_virtual(this, &$CCNode::setUserObject));

        m->registerHook(getBase()+0x122e50, extract_virtual(this, &$CCNode::setContentSize));
    }
};

class $EditorUI {
 public:
    $EditorUI() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef EditorUI* __thistype;

    virtual void deselectAll() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1f300))(this);
    }

    virtual void onDuplicate(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x18ba0))(this,p0);
    }

    virtual void enableButton(CreateMenuItem*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CreateMenuItem* )>(m->getOriginal(getBase()+0x1bff0))(this,p0);
    }

    virtual CreateMenuItem* getCreateBtn(int  p0,int  p1) {
        return reinterpret_cast<CreateMenuItem*(*)(decltype(this),int ,int )>(m->getOriginal(getBase()+0x1f6c0))(this,p0,p1);
    }

    virtual void pasteObjects(std::string  p0) {
        return reinterpret_cast<void(*)(decltype(this),std::string )>(m->getOriginal(getBase()+0x232d0))(this,p0);
    }

    virtual void disableButton(CreateMenuItem*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CreateMenuItem* )>(m->getOriginal(getBase()+0x1c0f0))(this,p0);
    }

    virtual void selectObjects(CCArray*  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),CCArray* ,bool )>(m->getOriginal(getBase()+0x23940))(this,p0,p1);
    }

    virtual void updateButtons() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1a300))(this);
    }

    virtual void redoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb8e0))(this);
    }

    virtual void undoLastAction() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0xb830))(this);
    }

    virtual CCArray* getSelectedObjects() {
        return reinterpret_cast<CCArray*(*)(decltype(this))>(m->getOriginal(getBase()+0x23f30))(this);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x1f300, extract_virtual(this, &$EditorUI::deselectAll));

        m->registerHook(getBase()+0x18ba0, extract_virtual(this, &$EditorUI::onDuplicate));

        m->registerHook(getBase()+0x1bff0, extract_virtual(this, &$EditorUI::enableButton));

        m->registerHook(getBase()+0x1f6c0, extract_virtual(this, &$EditorUI::getCreateBtn));

        m->registerHook(getBase()+0x232d0, extract_virtual(this, &$EditorUI::pasteObjects));

        m->registerHook(getBase()+0x1c0f0, extract_virtual(this, &$EditorUI::disableButton));

        m->registerHook(getBase()+0x23940, extract_virtual(this, &$EditorUI::selectObjects));

        m->registerHook(getBase()+0x1a300, extract_virtual(this, &$EditorUI::updateButtons));

        m->registerHook(getBase()+0xb8e0, extract_virtual(this, &$EditorUI::redoLastAction));

        m->registerHook(getBase()+0xb830, extract_virtual(this, &$EditorUI::undoLastAction));

        m->registerHook(getBase()+0x23f30, extract_virtual(this, &$EditorUI::getSelectedObjects));
    }
};

class $InfoLayer {
 public:
    $InfoLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef InfoLayer* __thistype;

    virtual void onRefreshComments(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x459b60))(this,p0);
    }

    virtual void loadPage(int  p0,bool  p1) {
        return reinterpret_cast<void(*)(decltype(this),int ,bool )>(m->getOriginal(getBase()+0x458fb0))(this,p0,p1);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x459b60, extract_virtual(this, &$InfoLayer::onRefreshComments));

        m->registerHook(getBase()+0x458fb0, extract_virtual(this, &$InfoLayer::loadPage));
    }
};

class $MenuLayer {
 public:
    $MenuLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef MenuLayer* __thistype;

    virtual void keyBackClicked() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x1d3170))(this);
    }

    virtual void onQuit(CCObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),CCObject* )>(m->getOriginal(getBase()+0x1d2b40))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x1d3170, extract_virtual(this, &$MenuLayer::keyBackClicked));

        m->registerHook(getBase()+0x1d2b40, extract_virtual(this, &$MenuLayer::onQuit));
    }
};

class $PlayLayer {
 public:
    $PlayLayer() {
        if (!m)
            m = new ModContainer(CAC_PROJ_NAME);
        apply_hooks();
        m->enable();
    }
    typedef PlayLayer* __thistype;

    virtual void resetLevel() {
        return reinterpret_cast<void(*)(decltype(this))>(m->getOriginal(getBase()+0x71c50))(this);
    }

    virtual void switchToScene(GJGameLevel*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GJGameLevel* )>(m->getOriginal(getBase()+0xe5d50))(this,p0);
    }

    virtual void update(float  p0) {
        return reinterpret_cast<void(*)(decltype(this),float )>(m->getOriginal(getBase()+0x77900))(this,p0);
    }

    virtual void addObject(GameObject*  p0) {
        return reinterpret_cast<void(*)(decltype(this),GameObject* )>(m->getOriginal(getBase()+0x70e50))(this,p0);
    }

    void apply_hooks() {
        m->registerHook(getBase()+0x71c50, extract_virtual(this, &$PlayLayer::resetLevel));

        m->registerHook(getBase()+0xe5d50, extract_virtual(this, &$PlayLayer::switchToScene));

        m->registerHook(getBase()+0x77900, extract_virtual(this, &$PlayLayer::update));

        m->registerHook(getBase()+0x70e50, extract_virtual(this, &$PlayLayer::addObject));
    }
};

